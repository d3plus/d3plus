// WARNING: do not edit this file directly, it is generated dynamically from
// the source JSDOC comments using the npm run docs script.

import React from "react";
import {argTypes as vizArgTypes} from "./Viz.args.jsx";
import {assign} from "@d3plus/dom";

import {Sankey as D3plusSankey} from "@d3plus/react";
export const Sankey = ({ config }) => <D3plusSankey config={config} />;

export const argTypes = assign(

  /**
   * Filters out unused argTypes from the Viz primitive and
   * overrides any defaults that have been changed in Sankey
   */
  Object.keys(vizArgTypes)
    .filter(k => !k.match(/^(zoom.*)$/))
    .reduce((obj, k) => (obj[k] = vizArgTypes[k], obj), {}),

  /**
   * Sankey-specific methods
   */
  
  {
    hover: {
      control: {},
      description: "If *value* is specified, sets the hover method to the specified function and returns the current class instance.",
      table: {
        defaultValue: {
          summary: "undefined"
        }
      },
      type: {
        required: false,
        summary: "function"
      }
    },
    links: {
      control: {
        type: "object"
      },
      defaultValue: "d => d[\"links\"]",
      description: "A predefined *Array* of edges that connect each object passed to the [node](#Sankey.node) method. The `source` and `target` keys in each link need to map to the nodes in one of one way:\n1. A *String* value matching the `id` of the node.\n\nThe value passed should be an *Array* of data. An optional formatting function can be passed as a second argument to this method. This custom function will be passed the data that has been loaded, as long as there are no errors. This function should return the final links *Array*.",
      table: {
        defaultValue: {
          detail: "d => d[\"links\"]",
          summary: "function"
        }
      },
      type: {
        required: true,
        summary: "array"
      }
    },
    linksSource: {
      control: {
        type: "text"
      },
      defaultValue: "source",
      description: "The key inside of each link Object that references the source node.",
      table: {
        defaultValue: {
          summary: "source"
        }
      },
      type: {
        required: false,
        summary: "string"
      }
    },
    linksTarget: {
      control: {
        type: "text"
      },
      defaultValue: "target",
      description: "The key inside of each link Object that references the target node.",
      table: {
        defaultValue: {
          summary: "target"
        }
      },
      type: {
        required: false,
        summary: "string"
      }
    },
    noDataMessage: {
      control: {
        type: "boolean"
      },
      defaultValue: false,
      description: "Toggles the visibility of the status message that is displayed when no data is supplied to the visualization.",
      table: {
        defaultValue: {
          summary: false
        }
      },
      type: {
        required: false,
        summary: "boolean"
      }
    },
    nodeAlign: {
      control: {
        type: "text"
      },
      defaultValue: "sankeyAligns.justify",
      description: "Sets the nodeAlign property of the sankey layout, which can either be \"left\", \"right\", \"center\", or \"justify\".",
      table: {
        defaultValue: {
          summary: "sankeyAligns.justify"
        }
      },
      type: {
        required: false,
        summary: "function | string"
      }
    },
    nodeId: {
      control: {
        type: "text"
      },
      defaultValue: "d => d[\"id\"]",
      description: "If *value* is specified, sets the node id accessor(s) to the specified array of values and returns the current class instance. If *value* is not specified, returns the current node group accessor.",
      table: {
        defaultValue: {
          detail: "d => d[\"id\"]",
          summary: "function"
        }
      },
      type: {
        required: false,
        summary: "string"
      }
    },
    nodePadding: {
      control: {
        type: "number"
      },
      defaultValue: 8,
      description: "If *value* is specified, sets the padding of the node and returns the current class instance. If *value* is not specified, returns the current nodePadding. By default, the nodePadding size is 8.",
      table: {
        defaultValue: {
          summary: 8
        }
      },
      type: {
        required: false,
        summary: "number"
      }
    },
    nodeWidth: {
      control: {
        type: "number"
      },
      defaultValue: 30,
      description: "If *value* is specified, sets the width of the node and returns the current class instance. If *value* is not specified, returns the current nodeWidth. By default, the nodeWidth size is 30.",
      table: {
        defaultValue: {
          summary: 30
        }
      },
      type: {
        required: false,
        summary: "number"
      }
    },
    nodes: {
      control: {
        type: "object"
      },
      defaultValue: "d => d[\"nodes\"]",
      description: "The list of nodes to be used for drawing the network. The value passed must be an *Array* of data.\n\nAdditionally, a custom formatting function can be passed as a second argument to this method. This custom function will be passed the data that has been loaded, as long as there are no errors. This function should return the final node *Array*.",
      table: {
        defaultValue: {
          detail: "d => d[\"nodes\"]",
          summary: "function"
        }
      },
      type: {
        required: true,
        summary: "array"
      }
    },
    on: {
      control: {
        type: "text"
      },
      defaultValue: {
        mouseenter: "() => {\n  }",
        "mouseleave.shape": "() => {\n  this.hover(false);\n}",
        "mousemove.shape": "(d, i, x, event) => {\n  defaultMouseMove(d, i, x, event);\n  if (this._focus && this._focus === d.id) {\n      this.hover(false);\n      this._on.mouseenter.bind(this)(d, i, x, event);\n      this._focus = undefined;\n  } else {\n      const id = this._nodeId(d, i), node = this._nodeLookup[id], nodeLookup = Object.keys(this._nodeLookup).reduce((all, item)=>{\n          all[this._nodeLookup[item]] = !isNaN(item) ? parseInt(item, 10) : item;\n          return all;\n      }, {});\n      const links = this._linkLookup[node];\n      const filterIds = [\n          id\n      ];\n      links.forEach((l)=>{\n          filterIds.push(nodeLookup[l]);\n      });\n      this.hover((h, x)=>{\n          if (h.source && h.target) {\n              return h.source.id === id || h.target.id === id;\n          } else {\n              return filterIds.includes(this._nodeId(h, x));\n          }\n      });\n  }\n}"
      },
      description: "Adds or removes a *listener* to each object for the specified event *typenames*. If a *listener* is not specified, returns the currently assigned listener for the specified event *typename*. Mirrors the core [d3-selection](https://github.com/d3/d3-selection#selection_on) behavior.",
      table: {
        defaultValue: {
          summary: {
            mouseenter: "() => {\n  }",
            "mouseleave.shape": "() => {\n  this.hover(false);\n}",
            "mousemove.shape": "(d, i, x, event) => {\n  defaultMouseMove(d, i, x, event);\n  if (this._focus && this._focus === d.id) {\n      this.hover(false);\n      this._on.mouseenter.bind(this)(d, i, x, event);\n      this._focus = undefined;\n  } else {\n      const id = this._nodeId(d, i), node = this._nodeLookup[id], nodeLookup = Object.keys(this._nodeLookup).reduce((all, item)=>{\n          all[this._nodeLookup[item]] = !isNaN(item) ? parseInt(item, 10) : item;\n          return all;\n      }, {});\n      const links = this._linkLookup[node];\n      const filterIds = [\n          id\n      ];\n      links.forEach((l)=>{\n          filterIds.push(nodeLookup[l]);\n      });\n      this.hover((h, x)=>{\n          if (h.source && h.target) {\n              return h.source.id === id || h.target.id === id;\n          } else {\n              return filterIds.includes(this._nodeId(h, x));\n          }\n      });\n  }\n}"
          }
        }
      },
      type: {
        required: false,
        summary: "string"
      }
    },
    shape: {
      control: {
        type: "text"
      },
      defaultValue: "Rect",
      description: "Changes the primary shape used to represent each data point in a visualization. Not all visualizations support changing shapes, this method can be provided the String name of a D3plus shape class (for example, \"Rect\" or \"Circle\"), or an accessor Function that returns the String class name to be used for each individual data point.",
      table: {
        defaultValue: {
          summary: "Rect"
        }
      },
      type: {
        required: false,
        summary: "string | function"
      }
    },
    shapeConfig: {
      control: {
        type: "object"
      },
      defaultValue: "assign(this._shapeConfig, {Path: {fill: none, hoverStyle: {stroke-width: (d) => Math.max(1, Math.abs(d.source.y1 - d.source.y0) * (d.value / d.source.value) - 2)}, label: false, stroke: #DBDBDB, strokeOpacity: 0.5, strokeWidth: (d) => Math.max(1, Math.abs(d.source.y1 - d.source.y0) * (d.value / d.source.value) - 2)}, Rect: {}})",
      description: "If *value* is specified, sets the config method for each shape and returns the current class instance.",
      table: {
        defaultValue: {
          detail: "assign(this._shapeConfig, {Path: {fill: none, hoverStyle: {stroke-width: (d) => Math.max(1, Math.abs(d.source.y1 - d.source.y0) * (d.value / d.source.value) - 2)}, label: false, stroke: #DBDBDB, strokeOpacity: 0.5, strokeWidth: (d) => Math.max(1, Math.abs(d.source.y1 - d.source.y0) * (d.value / d.source.value) - 2)}, Rect: {}})",
          summary: "function"
        }
      },
      type: {
        required: false,
        summary: "object"
      }
    },
    value: {
      control: {
        type: "number"
      },
      defaultValue: 1,
      description: "If *value* is specified, sets the width of the links and returns the current class instance. If *value* is not specified, returns the current value accessor.",
      table: {
        defaultValue: {
          summary: 1
        }
      },
      type: {
        required: true,
        summary: "function | number"
      }
    }
  }
);
