(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var fetchValue = require("../core/fetch/value.js"),
    fetchColor = require("../core/fetch/color.js"),
    fetchText  = require("../core/fetch/text.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Sorts an array of objects
//------------------------------------------------------------------------------
d3plus.array.sort = function( arr , keys , sort , colors , vars ) {

  if ( !arr || arr.length <= 1 || !keys ) {
    return arr || []
  }

  if ( !sort ) {
    var sort = "asc"
  }

  if ( !(keys instanceof Array) ) {
    keys = [ keys ]
  }

  if ( !colors ) {
    var colors = [ "color" ]
  }
  else if ( !(colors instanceof Array) ) {
    colors = [ colors ]
  }

  function comparator( a , b ) {

    var retVal = 0

    for ( var i = 0 ; i < keys.length ; i++ ) {

      var k = keys[i]

      if ( vars ) {

        var depthKey = a.d3plus ? vars.id.nesting[a.d3plus.depth] : undefined
          , depthInt = a.d3plus ? a.d3plus.depth : undefined

        a = k === vars.color.value
          ? fetchColor( vars , a , depthKey )
          : k === vars.text.value
          ? fetchText( vars , a , depthInt )
          : fetchValue( vars , a , k , depthKey )

        var depthKey = b.d3plus ? vars.id.nesting[b.d3plus.depth] : undefined
          , depthInt = b.d3plus ? b.d3plus.depth : undefined
        b = k === vars.color.value
          ? fetchColor( vars , b , depthKey )
          : k === vars.text.value
          ? fetchText( vars , b , depthInt )
          : fetchValue( vars , b , k , depthKey )

      }
      else {
        a = a[k]
        b = b[k]
      }

      a = a instanceof Array ? a = a[0]
        : typeof a === "string" ? a = a.toLowerCase() : a
      b = b instanceof Array ? b = b[0]
        : typeof b === "string" ? b = b.toLowerCase() : b

      retVal = colors.indexOf(k) >= 0 ? d3plus.color.sort( a , b )
             : a < b ? -1 : 1

      if ( retVal !== 0 || i === keys.length-1 ) {
        break
      }

    }

    return sort === "asc" ? retVal : -retVal

  }

  if ( arr.length === 2 ) {
    return comparator(arr[0],arr[1])
  }

  return arr.sort(comparator)


}

},{"../core/fetch/color.js":undefined,"../core/fetch/text.js":undefined,"../core/fetch/value.js":undefined}],2:[function(require,module,exports){

/**
 * Updates an array, either overwriting it with a new array, removing an entry
 * if it is present, or adding it if it is not.
 */
d3plus.array.update = function(arr, x) {
  if (!(arr instanceof Array)) {
    arr = [];
  }
  if (x instanceof Array) {
    arr = x;
  } else if (arr.indexOf(x) >= 0) {
    arr.splice(arr.indexOf(x), 1);
  } else {
    arr.push(x);
  }
  return arr;
};


},{}],3:[function(require,module,exports){

/**
 * Darkens a color if it's too light to appear on white
 */
d3plus.color.legible = function(color) {
  var hsl;
  hsl = d3.hsl(color);
  if (hsl.l > .45) {
    if (hsl.s > .8) {
      hsl.s = 0.8;
    }
    hsl.l = 0.45;
  }
  return hsl.toString();
};


},{}],4:[function(require,module,exports){

/**
 * Lightens a color
 */
d3plus.color.lighter = function(color, increment) {
  var c;
  if (increment === undefined) {
    increment = 0.5;
  }
  c = d3.hsl(color);
  c.l += (1 - c.l) * increment;
  return c.toString();
};


},{}],5:[function(require,module,exports){

/**
 * Mixes 2 colors with optional opacities
 */
d3plus.color.mix = function(c1, c2, o1, o2) {
  var b, g, r;
  if (!o1) {
    o1 = 1;
  }
  if (!o2) {
    o2 = 1;
  }
  c1 = d3.rgb(c1);
  c2 = d3.rgb(c2);
  r = (o1 * c1.r + o2 * c2.r - o1 * o2 * c2.r) / (o1 + o2 - o1 * o2);
  g = (o1 * c1.g + o2 * c2.g - o1 * o2 * c2.g) / (o1 + o2 - o1 * o2);
  b = (o1 * c1.b + o2 * c2.b - o1 * o2 * c2.b) / (o1 + o2 - o1 * o2);
  return d3.rgb(r, g, b).toString();
};


},{}],6:[function(require,module,exports){

/**
 * Returns a random color
 */
d3plus.color.random = function(x, scale) {
  var rand_int;
  rand_int = x || Math.floor(Math.random() * 20);
  scale = scale || d3plus.color.scale;
  return scale(rand_int);
};


},{}],7:[function(require,module,exports){

/**
 * Default D3plus color scale
 */
d3plus.color.scale = d3.scale.ordinal().range(["#b22200", "#EACE3F", "#282F6B", "#B35C1E", "#224F20", "#5F487C", "#759143", "#419391", "#993F88", "#e89c89", "#ffee8d", "#afd5e8", "#f7ba77", "#a5c697", "#c5b5e5", "#d1d392", "#bbefd0", "#e099cf"]);


},{}],8:[function(require,module,exports){

/**
 * Sorts 2 colors based on hue.
 */
d3plus.color.sort = function(a, b) {
  var aHSL, bHSL;
  aHSL = d3.hsl(a);
  bHSL = d3.hsl(b);
  a = aHSL.s === 0 ? 361 : aHSL.h;
  b = bHSL.s === 0 ? 361 : bHSL.h;
  if (a === b) {
    return aHSL.l - bHSL.l;
  } else {
    return a - b;
  }
};


},{}],9:[function(require,module,exports){

/**
 * Returns appropriate text color based off of a given color
 */
d3plus.color.text = function(color) {
  var b, g, r, rgbColor, yiq;
  rgbColor = d3.rgb(color);
  r = rgbColor.r;
  g = rgbColor.g;
  b = rgbColor.b;
  yiq = (r * 299 + g * 587 + b * 114) / 1000;
  if (yiq >= 128) {
    return "#444444";
  } else {
    return "#f7f7f7";
  }
};


},{}],10:[function(require,module,exports){

/**
 * Tests if a string is a valid color
 */
d3plus.color.validate = function(color) {
  var blackColors, testColor, userBlack;
  color = color + "";
  color = color.replace(RegExp(" ", "g"), "");
  if (color.indexOf("rgb") === 0) {
    color = color.split("(")[1].split(")")[0].split(",").slice(0, 3).join(",");
  }
  if (color.indexOf("hsl") === 0) {
    color = color.split(",")[2].split(")")[0];
  }
  testColor = d3.rgb(color).toString();
  blackColors = ["black", "#000", "#000000", "0%", "0,0,0"];
  userBlack = blackColors.indexOf(color) >= 0;
  return testColor !== "#000000" || userBlack;
};


},{}],11:[function(require,module,exports){
var fetchValue = require("../fetch/value.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Sets color range of data, if applicable
//-------------------------------------------------------------------
module.exports = function(vars) {

  if ( vars.dev.value ) d3plus.console.time("getting color data range")

  var data_range = []
  vars.data.pool.forEach(function(d){
    var val = parseFloat(fetchValue(vars,d,vars.color.value))
    if (typeof val == "number" && !isNaN(val) && data_range.indexOf(val) < 0) data_range.push(val)
  })

  if ( vars.dev.value ) d3plus.console.timeEnd("getting color data range")

  if (data_range.length > 1) {

    var data_domain = null

    if ( vars.dev.value ) d3plus.console.time("calculating color scale")

    data_range = d3.extent(data_range)

    if (data_range[0] < 0 && data_range[1] > 0) {
      var color_range = vars.color.range
      if (color_range.length == 3) {
        data_range.push(data_range[1])
        data_range[1] = 0
      }
    }
    else if (data_range[1] > 0 && data_range[0] >= 0) {
      var color_range = vars.color.heatmap
      data_range = d3plus.util.buckets(data_range,color_range.length)
    }
    else {
      var color_range = vars.color.range.slice(0)
      if (data_range[0] < 0) {
        color_range.pop()
      }
      else {
        color_range.shift()
      }
    }

    vars.color.valueScale = d3.scale.sqrt()
      .domain(data_range)
      .range(color_range)
      .interpolate(d3.interpolateRgb)

    if ( vars.dev.value ) d3plus.console.timeEnd("calculating color scale")

  }
  else {
    vars.color.valueScale = null
  }

}

},{"../fetch/value.js":undefined}],12:[function(require,module,exports){
var fetchValue = require("../fetch/value.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Restricts data based on Solo/Mute filters
//------------------------------------------------------------------------------
module.exports = function( vars , data ) {

  if ( vars.dev.value ) d3plus.console.time("filtering data")

  var availableKeys = d3.keys(vars.data.keys || {})

  if ( "attrs" in vars ) {
    availableKeys = availableKeys.concat(d3.keys(vars.attrs.keys || {}))
  }

  data = data.filter(function(d){
    return vars.id.value in d
  })

  vars.data.filters.forEach( function( key ) {

    if ( availableKeys.indexOf(vars[key].value) >= 0 ) {

      data = data.filter( function( d ) {

        var val = fetchValue(vars,d,vars[key].value)
        if ( key === "size" ) {
          return typeof val === "number"
        }
        else {
          return val !== null
        }

      })

    }

  })

  // if "solo", only check against "solo" (disregard "mute")
  var key = vars.data.solo.length ? "solo" : "mute"

  vars.data[key].forEach( function( v ) {

    function test_value( val ) {

      var arr = vars[v][key].value

      var match = false
      arr.forEach(function(f){
        if (typeof f === "function") {
          match = f(val)
        }
        else if ( f === val ) {
          match = true
        }

      })

      return match
    }

    function nest_check( d ) {

      // if the variable has nesting, check all levels
      var match = false
      if (vars[v].nesting) {
        var nesting = vars[v].nesting
        if (d3plus.object.validate(nesting)) {
          nesting = d3.keys(nesting)
        }
        nesting.forEach(function(n){
          if (!match) {
            match = test_value(fetchValue(vars,d,n))
          }
        })
      }
      else {
        match = test_value(fetchValue(vars,d,vars[v].value))
      }

      return key === "solo" ? match : !match

    }

    data = data.filter(nest_check)

    if ( v === "id" ) {

      if ("nodes" in vars && vars.nodes.value) {
        if ( vars.dev.value ) d3plus.console.log("Filtering Nodes")
        vars.nodes.restricted = vars.nodes.value.filter(nest_check)
      }

      if ("edges" in vars && vars.edges.value) {
        if ( vars.dev.value ) d3plus.console.log("Filtering Connections")
        vars.edges.restricted = vars.edges.value.filter(function(d){
          var first_match = nest_check(d[vars.edges.source]),
              second_match = nest_check(d[vars.edges.target])
          return first_match && second_match
        })
      }

    }

  })

  if ( vars.dev.value ) d3plus.console.timeEnd("filtering data")

  return data

}

},{"../fetch/value.js":undefined}],13:[function(require,module,exports){
var dataNest   = require("./nest.js"),
    fetchValue = require("../fetch/value.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Formats raw data by time and nesting
//------------------------------------------------------------------------------
module.exports = function( vars ) {

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Gets all unique time values
  //----------------------------------------------------------------------------
  vars.data.time = {"values": []}
  if ( vars.time && vars.time.value ) {

    if ( vars.dev.value ) {
      var timerString = "analyzing time periods"
      d3plus.console.time( timerString )
    }

    var uniqueTimes = d3plus.util.uniques( vars.data.value , vars.time.value )
    for ( var i = 0; i < uniqueTimes.length ; i++ ) {
      var d = new Date(uniqueTimes[i].toString())
      if (d !== "Invalid Date") {
        d.setTime( d.getTime() + d.getTimezoneOffset() * 60 * 1000 )
        vars.data.time.values.push(d)
      }
    }
    vars.data.time.values.sort(function(a,b){return a-b})

    var step = []
    vars.data.time.values.forEach(function(y,i){
      if (i != 0) {
        var prev = vars.data.time.values[i-1]
        step.push(y-prev)
        if (i === vars.data.time.values.length - 1) {
          vars.data.time.total = y - vars.data.time.values[0]
        }
      }
    })

    vars.data.time.step = d3.min(step)

    var periods = ["Milliseconds","Seconds","Minutes","Hours","Date","Month","FullYear"]
      , conversions = [1000,60,60,24,30,12,1]

    var getDiff = function(start,end,i) {

      if (!vars.data.time.stepDivider) {
        vars.data.time.stepDivider = conversions.slice(0,i).reduce(function(a,b){return a*b})
      }

      return Math.round(Math.floor(end-start)/vars.data.time.stepDivider)

    }

    var step = vars.data.time.step, total = vars.data.time.total
    periods.forEach(function(p,i){

      if (!vars.data.time.stepType && (i === periods.length-1 || Math.round(step) < conversions[i])) {
        vars.data.time.stepType = p
        var start = vars.data.time.values[0]
          , end = vars.data.time.values[vars.data.time.values.length-1]
        vars.data.time.stepIntervals = getDiff(start,end,i)
      }

      if (!vars.data.time.totalType && (i === periods.length-1 || Math.round(total) < conversions[i])) {
        vars.data.time.totalType = p
      }

      step = step/conversions[i]
      total = total/conversions[i]
    })

    vars.data.time.values.forEach(function(y,i){
      if (i != 0) {
        var prev = vars.data.time.values[0]
        // console.log(periods.indexOf(vars.data.time.stepType))
        vars.data.time.dataSteps.push(getDiff(prev,y,periods.indexOf(vars.data.time.stepType)))
      }
      else {
        vars.data.time.dataSteps = [0]
      }
    })

    var stepType = vars.data.time.stepType
      , totalType = vars.data.time.totalType
      , locale = vars.format.locale.value

    var getFormat = function(s,t,small) {

      if (s === t) {
        return small && locale.timeFormat[s+"Small"] ? locale.timeFormat[s+"Small"] : locale.timeFormat[s]
      }
      else {
        if (periods.indexOf(s) >= 4 || periods.indexOf(t) <= 3) {
          return locale.timeFormat[t+"-"+s]
        }
        else {

          if (t === "Date") {
            var format = locale.timeFormat[t]
          }
          else {
            var format = locale.timeFormat[t+"-Date"]
          }

          if (s === "Hours") {
            return format +" "+ locale.timeFormat[s]
          }
          else {
            return format +" "+ locale.timeFormat["Hours-"+s]
          }

        }
      }

    }

    var multi = []
      , functions = [
        , function(d) { return d.getMilliseconds(); }
        , function(d) { return d.getSeconds(); }
        , function(d) { return d.getMinutes(); }
        , function(d) { return d.getHours(); }
        , function(d) { return d.getDate() != 1; }
        , function(d) { return d.getMonth(); }
        , function() { return true; }
      ]

    for (var i = periods.indexOf(stepType); i <= periods.indexOf(totalType); i++) {
      var prev = i-1 < periods.indexOf(stepType) ? periods[i] : periods[i-1]
      var small = periods[i] === prev && stepType !== totalType
      var format = getFormat(prev,periods[i],small)
      multi.push([format,functions[i+1]])
    }

    vars.data.time.format = d3.locale(locale.format).timeFormat(getFormat(stepType,totalType))
    vars.data.time.multiFormat = d3.locale(locale.format).timeFormat.multi(multi)

    vars.data.time.ticks = []
    var min = d3.min(vars.data.time.values)
    for (var i = 0; i <= vars.data.time.stepIntervals; i++) {
      var d = new Date(min)
      d["set"+vars.data.time.stepType](d["get"+vars.data.time.stepType]() + i)
      vars.data.time.ticks.push(d)
    }

    if ( vars.dev.value ) d3plus.console.timeEnd( timerString )

  }

  if ( vars.dev.value ) {
    var timerString = "nesting data by time and depths"
    d3plus.console.time( timerString )
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Gets all unique time values
  //----------------------------------------------------------------------------
  vars.data.nested = {}
  if (vars.data.time.values.length === 0) {

    vars.data.nested.all = {}
    vars.id.nesting.forEach( function( depth , i ) {

      var nestingDepth = vars.id.nesting.slice( 0 , i + 1 )

      vars.data.nested.all[ depth ] = dataNest( vars
                                                      , vars.data.value
                                                      , nestingDepth )

    })

  }
  else {

    vars.data.time.values.forEach( function( t ) {

      var ms = t.getTime()

      vars.data.nested[ ms ] = { }

      var timeData = vars.data.value.filter( function(d) {
        var d = new Date(fetchValue( vars , d , vars.time.value ).toString())
        d.setTime( d.getTime() + d.getTimezoneOffset() * 60 * 1000 )
        return d.getTime() === ms
      })

      vars.id.nesting.forEach( function( depth , i ) {

        var nestingDepth = vars.id.nesting.slice( 0 , i + 1 )

        vars.data.nested[ ms ][ depth ] = dataNest( vars
                                                         , timeData
                                                         , nestingDepth )

      })

    })

  }

  if ( vars.dev.value ) d3plus.console.timeEnd( timerString )

}

},{"../fetch/value.js":undefined,"./nest.js":undefined}],14:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Get Key Types from Data
//------------------------------------------------------------------------------
module.exports = function( vars , type ) {

  if ( vars.dev.value ) {
    var timerString = type + " key analysis"
    console.time( timerString )
  }

  vars[type].keys = {}

  function get_keys( arr ) {
    if (arr instanceof Array) {
      arr.forEach(function(d) {
        get_keys( d )
      })
    }
    else if ( d3plus.object.validate(arr) ) {
      for (var d in arr) {
        if ( d3plus.object.validate(arr[d]) ) {
          get_keys( arr[d] )
        }
        else if (!(d in vars[type].keys) && d in arr) {
          vars[type].keys[d] = typeof arr[d]
        }
      }
    }
  }

  if ( d3plus.object.validate(vars[type].value) ) {
    for ( var a in vars[type].value ) {
      get_keys(vars[type].value[a])
    }
  }
  else {
    get_keys(vars[type].value)
  }

  if ( vars.dev.value ) console.time( timerString )

}

},{}],15:[function(require,module,exports){

/**
 * Load Data using JSON
 */
module.exports = function(vars, key, next) {
  var fileType, parser, url;
  if (vars.dev.value) {
    d3plus.console.time("loading " + key);
  }
  url = vars[key].url;
  if (!vars[key].filetype.value) {
    fileType = url.slice(url.length - 5).split(".");
    if (fileType.length > 1) {
      fileType = fileType[1];
    } else {
      fileType = false;
    }
    if (fileType) {
      if (fileType === "txt") {
        fileType = "text";
      }
      if (vars[key].filetype.accepted.indexOf(fileType) < 0) {
        fileType = "json";
      }
    } else {
      fileType = "json";
    }
  } else {
    fileType = vars[key].filetype.value;
  }
  if (fileType === "dsv") {
    parser = d3.dsv(vars[key].delimiter.value, "text/plain");
  } else {
    parser = d3[fileType];
  }
  return parser(url, function(error, data) {
    var k, ret;
    if (!error && data) {
      if (typeof vars[key].callback === "function") {
        ret = vars[key].callback(data);
        if (ret) {
          if (d3plus.object.validate(ret) && key in ret) {
            for (k in ret) {
              if (k in vars) {
                vars[k].value = ret[k];
              }
            }
          } else {
            vars[key].value = ret;
          }
        }
      } else {
        vars[key].value = data;
      }
      if (["json"].indexOf(fileType) < 0) {
        vars[key].value.forEach(function(d) {
          var _results;
          _results = [];
          for (k in d) {
            if (!isNaN(d[k])) {
              _results.push(d[k] = parseFloat(d[k]));
            } else if (d[k].toLowerCase() === "false") {
              _results.push(d[k] = false);
            } else if (d[k].toLowerCase() === "true") {
              _results.push(d[k] = true);
            } else if (d[k].toLowerCase() === "null") {
              _results.push(d[k] = null);
            } else {
              if (d[k].toLowerCase() === "undefined") {
                _results.push(d[k] = undefined);
              } else {
                _results.push(void 0);
              }
            }
          }
          return _results;
        });
      }
      vars[key].changed = true;
      vars[key].loaded = true;
    } else {
      vars.internal_error = "Could not load data from: \"" + url + "\"";
    }
    if (vars.dev.value) {
      d3plus.console.time("loading " + key);
    }
    return next();
  });
};


},{}],16:[function(require,module,exports){
var fetchValue = require("../fetch/value.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Nests and groups the data.
//------------------------------------------------------------------------------
var dataNest = function( vars , flatData , nestingLevels , requirements ) {

  var nestedData   = d3.nest()
    , groupedData  = []
    , segments     = vars.shell === "viz"
                    ? [ "active" , "temp" , "total" ] : []
    , requirements = requirements || vars.types[vars.type.value].requirements || []
    , exceptions   = vars.shell === "viz"
                   ? [ vars.time.value , vars.icon.value ] : []
    , checkAxes    = function() {

      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      // If the visualization has method requirements, check to see if we need
      // to key the data by a continuous scale variable.
      //------------------------------------------------------------------------
      if ( requirements && requirements.length ) {

        vars.axes.values.forEach(function(axis){

          var axisKey = vars[axis].value

          if ( requirements.indexOf(axis) >= 0 && axisKey
               && vars[axis].scale.value === "continuous") {

            exceptions.push(axisKey)

            nestedData.key(function(d){
              return fetchValue( vars , d , axisKey )
            })

          }

        })

      }

    }

  if (!(requirements instanceof Array)) requirements = [requirements]

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Loop through each nesting level.
  //----------------------------------------------------------------------------
  nestingLevels.forEach(function( level , i ){

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Create a nest key for the current level.
    //--------------------------------------------------------------------------
    nestedData
      .key(function(d){

        if ( typeof level === "function" ) {
          return level(d)
        }

        return fetchValue( vars , d , level )
      })

    checkAxes()

  })

  if ( !nestingLevels.length ) {

    nestedData
      .key(function(d){
        return true
      })

    checkAxes()
  }

  var i = nestingLevels.length ? nestingLevels.length - 1 : 0

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // If we're at the deepest level, create the rollup function.
  //----------------------------------------------------------------------------
  nestedData.rollup(function( leaves ) {

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // If there's only 1 leaf, and it's been processed, return it as-is.
    //--------------------------------------------------------------------------
    if ( leaves.length === 1 && ("d3plus" in leaves[0]) ) {
      // var returnObj = leaves[0]
      // returnObj.d3plus.depth = i
      groupedData.push(leaves[0])
      return leaves[0]
    }

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Create the "d3plus" object for the return variable, starting with
    // just the current depth.
    //--------------------------------------------------------------------------
    var returnObj = {
      "d3plus": {
        "depth": i
      }
    }

    if ("d3plus" in leaves[0]) {

      leaves.forEach(function(l){
        if ("d3plus" in l) {
          if (l.d3plus.merged instanceof Array) {
            if (!returnObj.d3plus.merged) returnObj.d3plus.merged = []
            returnObj.d3plus.merged = returnObj.d3plus.merged.concat(l.d3plus.merged)
          }
          if (l.d3plus.text) returnObj.d3plus.text = l.d3plus.text
        }
      })
    }

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Create a reference sum for the 3 different "segment" variables.
    //--------------------------------------------------------------------------
    segments.forEach(function(c){

      var key = vars[c].value || c

      returnObj.d3plus[key] = d3.sum(leaves, function( d ) {

        if ( vars[c].value ) {

          var a = fetchValue(vars,d,vars[c].value)

          if ( typeof a !== "number" ) {
            a = a ? 1 : 0
          }

        }
        else if ( c === "total" ) {
          var a = 1
        }
        else {
          var a = 0
        }

        return a

      })

    })

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Aggregate all values detected in the data.
    //--------------------------------------------------------------------------
    for ( var key in vars.data.keys ) {

      var agg     = vars.aggs.value[key] || "sum"
        , aggType = typeof agg
        , keyType = vars.data.keys[key]
        , idKey   = vars.id.nesting.indexOf(key) >= 0
        , timeKey = "time" in vars && key === vars.time.value

      if ( key in returnObj.d3plus ) {

        returnObj[key] = returnObj.d3plus[key]

      }
      else if ( aggType === "function" ) {

        returnObj[key] = vars.aggs.value[key](leaves)

      }
      else if ( timeKey ) {
        var uniques = d3plus.util.uniques(leaves,key), dates = []

        function parseDates(arr) {

          for ( var i = 0; i < arr.length ; i++ ) {
            var d = arr[i]
            if (d !== undefined) {
              if (d.constructor === Date) dates.push(d)
              else if (d.constructor === Array) {
                parseDates(d)
              }
              else {
                d = new Date(d.toString())
                if (d !== "Invalid Date") {
                  d.setTime( d.getTime() + d.getTimezoneOffset() * 60 * 1000 )
                  dates.push(d)
                }
              }
            }
          }

        }

        parseDates(uniques)

        if (dates.length === 1) returnObj[key] = dates[0]
        else if (uniques.length) returnObj[key] = dates
        else returnObj[key] = null
      }
      else if ( keyType === "number" && aggType === "string" && !idKey ) {
        var uniques = d3plus.util.uniques(leaves,key)
        if (uniques.length) returnObj[key] = d3[agg](uniques)
        else returnObj[key] = null
      }
      else {

        var testVals = []
        function checkVal(obj) {
          if (obj instanceof Array) {
            obj.forEach(checkVal)
          }
          else if (d3plus.object.validate(obj) && key in obj) {
            if (obj[key] instanceof Array) {
              obj[key].forEach(checkVal)
            }
            else {
              testVals.push(obj)
            }
          }
        }
        checkVal(leaves)

        var keyValues = testVals.length === 1 ? testVals[0][key]
                      : d3plus.util.uniques( testVals , key )

        if ( keyValues !== undefined && keyValues !== null ) {

          if ( !(keyValues instanceof Array) ) {
            keyValues = [ keyValues ]
          }

          if ( keyValues.length ) {

            if ( idKey && vars.id.nesting.indexOf(key) > i && testVals.length > 1 ) {
              if (key == "id" && nestingLevels.length == 1 && testVals.length > leaves.length) {
                var newNesting = nestingLevels.concat(key)
                testVals = dataNest(vars,testVals,newNesting)
              }
              returnObj[key] = testVals.length === 1 ? testVals[0] : testVals

            }
            else {

              returnObj[key] = keyValues.length === 1 ? keyValues[0] : keyValues

            }

          }

        }
        else if (idKey) {
          var endPoint = vars.id.nesting.indexOf(key) - 1
          if (endPoint >= i && (!("endPoint" in returnObj.d3plus) || returnObj.d3plus.endPoint > i)) {
            returnObj.d3plus.endPoint = i
          }
        }

      }

    }

    groupedData.push(returnObj)

    return returnObj

  })

  var rename_key_value = function(obj) {
    if (obj.values && obj.values.length) {
      obj.children = obj.values.map(function(obj) {
        return rename_key_value(obj);
      })
      delete obj.values
      return obj
    }
    else if(obj.values) {
      return obj.values
    }
    else {
      return obj;
    }
  }

  var find_keys = function(obj,depth,keys) {
    if (obj.children) {
      if (vars.data.keys[nestingLevels[depth]] == "number") {
        obj.key = parseFloat(obj.key)
      }
      keys[nestingLevels[depth]] = obj.key
      delete obj.key
      for ( var k in keys ) {
        obj[k] = keys[k]
      }
      depth++
      obj.children.forEach(function(c){
        find_keys(c,depth,keys)
      })
    }
  }

  nestedData = nestedData
    .entries(flatData)
    .map(rename_key_value)
    .map(function(obj){
      find_keys(obj,0,{})
      return obj
    })

  return groupedData

}

module.exports = dataNest

},{"../fetch/value.js":undefined}],17:[function(require,module,exports){
var dataNest   = require("./nest.js"),
    fetchValue = require("../fetch/value.js"),
    fetchColor = require("../fetch/color.js"),
    fetchText  = require("../fetch/text.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Merges data underneath the size threshold
//-------------------------------------------------------------------
module.exports = function( vars , rawData , split ) {

  if ( vars.size.threshold === false ) {
    var threshold = 0
  }
  else if (typeof vars.size.threshold === "number") {
    var threshold = vars.size.threshold
  }
  else if (typeof vars.types[vars.type.value].threshold === "number") {
    var threshold = vars.types[vars.type.value].threshold
  }
  else if (typeof vars.types[vars.type.value].threshold === "function") {
    var threshold = vars.types[vars.type.value].threshold(vars)
  }
  else {
    var threshold = 0.02
  }

  if (typeof threshold == "number" && threshold > 0) {

    var allowed = [],
        cutoff = vars.depth.value == 0 ? 0 : {},
        removed = [],
        largest = {}

    var nest = d3.nest()

    if (split) {
      nest
        .key(function(d){
          return fetchValue(vars,d,split)
        })
    }

    nest
      .rollup(function(leaves){
        var total = leaves.length
        if (vars.aggs[vars.size.value]) {
          if (typeof vars.aggs[vars.size.value] == "function") {
            total = vars.aggs[vars.size.value](leaves)
          }
          else if (typeof vars.aggs[vars.size.value] == "string") {
            total = d3[vars.aggs[vars.size.value]](leaves,function(l){
              return fetchValue(vars,l,vars.size.value)
            })
          }
        }
        else {
          total = d3.sum(leaves,function(l){
            return fetchValue(vars,l,vars.size.value)
          })
        }
        var x = split ? fetchValue(vars,leaves[0],split) : "all"
        largest[x] = total
        return total
      })
      .entries(rawData)

    var filteredData = rawData.filter(function(d){

      var id = fetchValue(vars,d,vars.id.value),
          val = fetchValue(vars,d,vars.size.value),
          x = split ? fetchValue(vars,d,split) : "all"

      if (allowed.indexOf(id) < 0) {
        if (val/largest[x] >= threshold) {
          allowed.push(id)
        }

      }

      if (allowed.indexOf(id) < 0) {
        if (vars.depth.value == 0) {
          if (val > cutoff) cutoff = val
        }
        else {
          var parent = d[vars.id.nesting[vars.depth.value-1]]
          if (!(parent in cutoff)) cutoff[parent] = 0
          if (val > cutoff[parent]) cutoff[parent] = val
        }
        removed.push(d)
        return false
      }
      else {
        return true
      }

    })

    if ( removed.length > 1 ) {

      removed = d3plus.array.sort( removed , vars.size.value , "desc" , [] , vars )

      var levels = vars.id.nesting.slice(0,vars.depth.value)
      var merged = dataNest(vars,removed,levels)

      merged.forEach(function(m){

        var parent = vars.id.nesting[vars.depth.value-1]

        vars.id.nesting.forEach(function(d,i){

          if (vars.depth.value == i) {
            var prev = m[vars.id.nesting[i-1]]
            if ( typeof prev === "string" ) {
              m[d] = "d3plus_other_"+prev
            }
            else {
              m[d] = "d3plus_other"
            }
          }
          else if (i > vars.depth.value) {
            delete m[d]
          }
        })

        if (vars.color.value && vars.color.type === "string") {
          if (vars.depth.value == 0) {
            m[vars.color.value] = vars.color.missing
          }
          else {
            m[vars.color.value] = fetchValue(vars,m[parent],vars.color.value,parent)
          }
        }

        if (vars.icon.value) {
          m[vars.icon.value] = fetchValue(vars,m[parent],vars.icon.value,parent)
        }

        if (m[parent]) {
          m.d3plus.depth = vars.depth.value
        }

        if (vars.depth.value == 0) {
          var textLabel = vars.format.value(vars.format.locale.value.ui.values)
          textLabel += " < "+vars.format.value(cutoff)
        }
        else {
          var textLabel = fetchText(vars,m,vars.depth.value-1)
          textLabel = textLabel.length ? textLabel[0].split(" < ")[0] : vars.format.value(vars.format.locale.value.ui.values)
          textLabel += " < "+vars.format.value(cutoff[m[parent]],vars.size.value)
        }
        textLabel += " ("+vars.format.value(threshold*100)+"%)"

        m.d3plus.threshold = cutoff
        if (parent) {
          m.d3plus.merged = []
          removed.forEach(function(r){
            if (m[parent] == r[parent]) {
              m.d3plus.merged.push(r)
            }
          })
        }
        else {
          m.d3plus.merged = removed
        }

        if (vars.text.value) {
          m[vars.text.value] = textLabel
        }
        else {
          m.d3plus.text = textLabel
        }

      })

    }
    else {
      merged = removed
    }

    return filteredData.concat(merged)

  }

  return rawData

}

},{"../fetch/color.js":undefined,"../fetch/text.js":undefined,"../fetch/value.js":undefined,"./nest.js":undefined}],18:[function(require,module,exports){
var fetchValue = require("./value.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Finds an object's color and returns random if it cannot be found
//------------------------------------------------------------------------------
module.exports = function( vars , id , level ) {

  if ( !level ) {
    var level = vars.id.value
  }

  function getRandom( c ) {

    if ( d3plus.object.validate( c ) ) {
      c = c[ level ]
    }

    if (c instanceof Array) {
      c = c[0]
    }

    return d3plus.color.random( c, vars.color.scale.value )

  }

  if ( !vars.color.value ) {

    return getRandom( id )

  }
  else {

    for ( var i = vars.id.nesting.indexOf(level) ; i >= 0 ; i-- ) {
      var colorLevel = vars.id.nesting[i]
        , o = d3plus.object.validate(id) && !(vars.color.value in id) && id[level] instanceof Array ? id[level][0] : fetchValue(vars, id, colorLevel)
        , color = fetchValue( vars , o , vars.color.value , colorLevel )
      if ( color ) break
    }

    if ( !color ) {

      if ( vars.color.value || typeof vars.color.valueScale === "function" ) {
        return vars.color.missing
      }
      return getRandom( id )

    }
    else if ( !vars.color.valueScale ) {
      return d3plus.color.validate( color ) ? color : getRandom( color )
    }
    else {
      return vars.color.valueScale( color )
    }

  }

}

},{"./value.js":undefined}],19:[function(require,module,exports){
var dataFilter = require("../data/filter.js"),
    dataNest = require("../data/nest.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Fetches specific years of data
//-------------------------------------------------------------------
module.exports = function( vars , years ) {

  if (!vars.data.value) return []

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // If "years" have not been requested, determine the years using .time()
  // solo and mute
  //----------------------------------------------------------------------------
  if ( !years && "time" in vars ) {

    var key   = vars.time.solo.value.length ? "solo" : "mute"
      , years = []

    if ( vars.time[key].value.length ) {

      var years = []
      vars.time[key].value.forEach(function( y ){
        if ( typeof y === "function" ) {
          vars.data.time.values.forEach(function( t ){
            if ( y(t.getTime()) ) years.push( t.getTime() )
          })
        }
        else if ( y.constructor === Date ) {
          years.push(new Date(y).getTime())
        }
        else {
          var d = new Date(y.toString())
          if (d !== "Invalid Date") {
            d.setTime( d.getTime() + d.getTimezoneOffset() * 60 * 1000 )
            years.push(d.getTime())
          }
        }

      })

      if ( key === "mute" ) {
        years = vars.data.time.values.filter(function( t ){
          return years.indexOf( t.getTime() ) < 0
        })
      }

    }
    else years.push("all")

  }
  else {
    years = [ "all" ]
  }

  if (years.indexOf("all") >= 0 && vars.data.time.values.length) {
    years = vars.data.time.values.slice(0)
    for (var i = 0; i < years.length; i++) {
      years[i] = years[i].getTime()
    }
  }

  var cacheID = [ vars.type.value , vars.id.value , vars.depth.value ]
                  .concat( vars.data.filters )
                  .concat( years )
    , filter  = vars.data.solo.length ? "solo" : "mute"
    , cacheKeys = d3.keys(vars.data.cache)
    , vizFilter = vars.shell === "viz"
                 ? vars.types[vars.type.value].filter : null

  if ( vars.data[filter].length ) {
    vars.data[filter].forEach(function(f){
      var vals = vars[f][filter].value.slice(0)
      vals.unshift(f)
      cacheID = cacheID.concat(vals)
    })
  }

  cacheID = cacheID.join("_")

  var match = false

  for ( var i = 0 ; i < cacheKeys.length ; i++ ) {

    var matchKey = cacheKeys[i].split("_").slice(1).join("_")

    if ( matchKey === cacheID ) {
      cacheID = new Date().getTime() + "_" + cacheID
      vars.data.cache[cacheID] = vars.data.cache[cacheKeys[i]]
      delete vars.data.cache[cacheKeys[i]]
      break
    }

  }

  if ( vars.data.cache[cacheID] ) {

    if ( vars.dev.value ) d3plus.console.comment("data already cached")

    var returnData = vars.data.cache[cacheID]

    if ( typeof vizFilter === "function" ) {
      returnData = vizFilter( vars ,  returnData )
    }

    return returnData

  }
  else {

    var missing = []
      , returnData = []

    if ( vars.data.value && vars.data.value.length ) {

      years.forEach(function(y){
        if ( vars.data.nested[y] ) {
          returnData = returnData.concat( vars.data.nested[y][vars.id.value] )
        }
        else missing.push( y )
      })

    }

    if ( returnData.length === 0 && missing.length && !vars.internal_error ) {

      var format = vars.time.format.value || vars.data.time.format

      if (missing.length > 1) {
        missing = d3.extent(missing)
      }

      missing = missing.map(function(m){
        return format(new Date(m))
      })
      missing = missing.join(" - ")

      var str = vars.format.locale.value.error.dataYear
        , and = vars.format.locale.value.ui.and
      missing = d3plus.string.list(missing,and)
      vars.internal_error = d3plus.string.format(str,missing)
      vars.time.missing = true

    }
    else {

      if (vars.time) vars.time.missing = false

      if ( years.length > 1 ) {

        var separated = false
        vars.axes.values.forEach(function(a){
          if ( vars[a].value === vars.time.value
          && vars[a].scale.value === "continuous" ) {
            separated = true
          }
        })

        if (!separated) {
          var nested = vars.id.nesting.slice(0,vars.depth.value+1)
          returnData = dataNest( vars , returnData , nested )
        }

      }

      if ( !returnData ) {
        returnData = []
      }
      else {

        returnData = dataFilter( vars , returnData )

      }

      var cacheKeys = d3.keys(vars.data.cache)
      if ( cacheKeys.length === 20 ) {
        cacheKeys.sort()
        delete vars.data.cache(cacheKeys[0])
      }

      cacheID = new Date().getTime() + "_" + cacheID
      vars.data.cache[cacheID] = returnData

      if ( typeof vizFilter === "function" ) {
        returnData = vizFilter( vars , returnData )
      }

      if ( vars.dev.value ) d3plus.console.comment("storing data in cache")

    }

    return returnData

  }

}

},{"../data/filter.js":undefined,"../data/nest.js":undefined}],20:[function(require,module,exports){
var fetchValue = require("./value.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Get array of available text values
//------------------------------------------------------------------------------
module.exports = function(vars,obj,depth) {

  if ( typeof depth !== "number" ) var depth = vars.depth.value

  var key = vars.id.nesting[depth]

  if ( vars.text.nesting && d3plus.object.validate(vars.text.nesting) ) {
    if ( vars.text.nesting[key] ) {
      var textKeys = vars.text.nesting[key]
    }
    else {
      var textKeys = vars.text.value
    }
  }
  else {
    var textKeys = []
    if (vars.text.value && depth === vars.depth.value) textKeys.push(vars.text.value)
    textKeys.push(key)
  }

  if ( !(textKeys instanceof Array) ) {
    textKeys = [ textKeys ]
  }

  var names = []

  if (d3plus.object.validate(obj) && "d3plus" in obj && obj.d3plus.text) {
    names.push(obj.d3plus.text.toString())
  }
  else {

    var ids = d3plus.object.validate(obj) && key in obj ? obj[key] : fetchValue(vars, obj, key)
    if (!(ids instanceof Array)) ids = [ids]
    else if (d3plus.object.validate(ids[0])) {
      ids = d3plus.util.uniques(ids,key)
    }

    textKeys.forEach(function( t ){

      var name = []
      ids.forEach(function(i){
        var n = fetchValue(vars,i,t,key)
        if (n) {
          if (n instanceof Array && d3plus.object.validate(n[0])) {
            n = d3plus.util.uniques(n,t)
          }
          name = name.concat(n)
        }
      })

      if ( name.length ) {
        name = name.map(function(n){
          if (n instanceof Array) {
            return n.map(function(nn){
              return vars.format.value(nn.toString(),t)
            })
          }
          else if (n) {
            return vars.format.value(n.toString(),t)
          }
        })
        if (name.length === 1) name = name[0]
        names.push(name)
      }

    })

  }

  return names

}

},{"./value.js":undefined}],21:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Finds a given variable by searching through the data and attrs
//------------------------------------------------------------------------------
module.exports = function( vars , id , variable , id_var , agg ) {

  if ( variable && typeof variable === "function" ) {
    return variable( id )
  }
  else if ( !variable ) {
    return null
  }

  if (!id_var) {
    if ( d3plus.object.validate(variable) ) {
      if (variable[vars.id.value]) {
        var id_var = vars.id.value
      }
      else {
        var id_var = d3.keys(variable)[0]
      }
      variable = variable[id_var]
    }
    else {
      var id_var = vars.id.value
    }
  }

  if ( variable === id_var ) {
    if ( d3plus.object.validate(id) && variable in id ) {
      return id[variable]
    }
    else if ( !(id instanceof Array) ) {
      return id
    }
  }

  function filterArray( arr ) {

    if ( id instanceof Array ) {
      var uniques = d3plus.util.uniques( id , id_var )
      return arr.filter(function(d){
        return uniques.indexOf(d[id_var]) >= 0
      })
    }
    else {
      return arr.filter(function(d){
        return d[id_var] === id
      })
    }

  }

  if ( d3plus.object.validate(id) && variable in id ) {
    return id[variable]
  }
  else {

    function checkData( data ) {
      var vals = d3plus.util.uniques( data , variable )
      if ( vals.length === 1 ) return vals[0]
    }

    if ( d3plus.object.validate(id) && id_var in id ) {
      var val = checkData( id )
      if ( val ) return val
      id = id[id_var]
    }

    if ( id instanceof Array ) {
      var val = checkData( id )
      if ( val ) return val
    }

    if ( vars.data.app instanceof Array ) {
      var val = checkData( filterArray( vars.data.app ) )
      if ( val ) return val
    }

  }

  if ( "attrs" in vars && vars.attrs.value ) {

    if ( vars.attrs.value instanceof Array ) {
      var attr = filterArray(vars.attrs.value)
    }
    else if ( id_var in vars.attrs.value ) {
      if ( vars.attrs.value[id_var] instanceof Array ) {
        var attr = filterArray(vars.attrs.value[id_var])
      }
      else {
        var attr = vars.attrs.value[id_var]
      }
    }
    else {
      var attr = vars.attrs.value
    }

  }

  if ( d3plus.object.validate(attr) ) {

    var newAttr = []

    if ( id instanceof Array ) {
      if (d3plus.object.validate(id[0])) id = d3plus.util.uniques(id,id_var)
      id.forEach(function(d){
        newAttr.push(attr[d])
      })
    }
    else newAttr.push(attr[id])

    attr = newAttr

  }

  if ( attr && attr.length ) {
    var vals = d3plus.util.uniques( attr , variable )
    if ( vals.length === 1 ) return vals[0]
    else if (vals.length) return vals

  }

  return null

}

},{}],22:[function(require,module,exports){

/**
 * Creates an invisible test element to populate
 */
module.exports = function(type) {
  var styles, tester;
  if (["div", "svg"].indexOf(type) < 0) {
    type = "div";
  }
  styles = {
    position: "absolute",
    left: "-9999px",
    top: "-9999px",
    visibility: "hidden",
    display: "block"
  };
  tester = d3.select("body").selectAll(type + ".d3plus_tester").data(["d3plus_tester"]);
  tester.enter().append(type).attr("class", "d3plus_tester").style(styles);
  return tester;
};


},{}],23:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Resets certain keys in global variables.
//-------------------------------------------------------------------
var reset = function( obj , method ) {

  if ( obj.changed ) {
    obj.changed = false
  }

  if ( method === "draw" ) {
    obj.frozen = false
    obj.update = true
    obj.first = false
  }

  for ( var o in obj ) {

    if ( d3plus.object.validate( obj[o] ) ) {

      reset( obj[o] , o )

    }

  }

}

module.exports = reset

},{}],24:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Cleans edges list and populates nodes list if needed
//-------------------------------------------------------------------
module.exports = function( vars ) {

  if ( vars.dev.value ) {
    var timerString = "analyzing edges list"
    d3plus.console.time( timerString )
  }

  var appReqs     = vars.types[vars.type.value].requirements
  if (!(appReqs instanceof Array)) appReqs = [appReqs]
  var createNodes = appReqs.indexOf("nodes") >= 0 && !vars.nodes.value

  if ( createNodes ) {
    vars.nodes.value = []
    var placed = []
    vars.nodes.changed = true
  }

  vars.edges.value.forEach(function(e){

    if (typeof e[vars.edges.source] !== "object") {
      var obj = {}
      obj[vars.id.value] = e[vars.edges.source]
      e[vars.edges.source] = obj
    }
    if (typeof e[vars.edges.target] !== "object") {
      var obj = {}
      obj[vars.id.value] = e[vars.edges.target]
      e[vars.edges.target] = obj
    }

    if (!("keys" in vars.data)) {
      vars.data.keys = {}
    }

    if (!(vars.id.value in vars.data.keys)) {
      vars.data.keys[vars.id.value] = typeof e[vars.edges.source][vars.id.value]
    }

    if ( createNodes ) {
      if (placed.indexOf(e[vars.edges.source][vars.id.value]) < 0) {
        placed.push(e[vars.edges.source][vars.id.value])
        vars.nodes.value.push(e[vars.edges.source])
      }
      if (placed.indexOf(e[vars.edges.target][vars.id.value]) < 0) {
        placed.push(e[vars.edges.target][vars.id.value])
        vars.nodes.value.push(e[vars.edges.target])
      }
    }

  })

  vars.edges.value = vars.edges.value.filter(function(e){

    var source = e[vars.edges.source][vars.id.value]
      , target = e[vars.edges.target][vars.id.value]

    if ( source === target ) {
      var str = vars.format.locale.value.dev.sameEdge
      d3plus.console.warning(d3plus.string.format(str,"\""+source+"\"") , "edges" )
      return false
    }
    else {
      return true
    }

  })

  vars.edges.linked = true

  if ( vars.dev.value ) d3plus.console.timeEnd( timerString )

}

},{}],25:[function(require,module,exports){
// Parses an HTML element for data
module.exports = function( vars ) {

  var attributes = [ vars.color.value
                   , vars.icon.value
                   , vars.keywords.value
                   , vars.alt.value
                   , "style" ]

  if (!vars.text.value) {
    vars.self.text("text")
  }

  attributes = attributes.concat(vars.id.nesting)

  function get_attributes( obj , elem ) {
    [].forEach.call(elem.attributes, function(attr) {
        if (/^data-/.test(attr.name)) {
            var camelCaseName = attr.name.substr(5).replace(/-(.)/g, function ($0, $1) {
                return $1.toUpperCase();
            });
            obj[camelCaseName] = attr.value;
        }
    })

    attributes.forEach(function(a){

      if ( elem.getAttribute(a) !== null ) {
        obj[a] = elem.getAttribute(a)
      }

    })

  }

  vars.self.data({"element": vars.data.value})

  var elementTag  = vars.data.element.value.node().tagName.toLowerCase()
    , elementType = vars.data.element.value.attr("type")
    , elementData = []

  if ( elementTag === "select" ) {

    var elementID = vars.data.element.value.node().id
    if ( elementID ) {
      vars.self.container({"id": elementID})
    }

    vars.data.element.value.selectAll("option")
      .each(function( o , i ){

        var data_obj = {}

        data_obj.text = this.innerHTML

        get_attributes(data_obj,this)

        elementData.push(data_obj)

        if (this.selected) {
          for (var i = vars.id.nesting.length-1; i >= 0; i--) {
            var level = vars.id.nesting[i]
            if (level in data_obj) {
              vars.self.focus(data_obj[level])
              break
            }
          }
        }

      })

  }
  else if ( elementTag === "input" && elementType === "radio" ) {

    var elementName = vars.data.element.value.node().getAttribute("name")
    if ( elementName ) {
      vars.self.container({"id": elementName})
    }

    vars.data.element.value
      .each(function( o , i ){

        var data_obj = {}

        get_attributes(data_obj,this)

        var id = data_obj[vars.id.value] || this.id || false

        if ( id && isNaN(parseFloat(id)) ) {

          var label = d3.select("label[for="+id+"]")

          if ( !label.empty() ) {
            data_obj.text = label.html()
            label.call(hideElement)
          }

        }

        elementData.push(data_obj)

        if (this.checked) {
          vars.focus.value[0] = data_obj[vars.id.value]
        }

      })

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Get focus from data, if it hasn't been found or set.
  //----------------------------------------------------------------------------
  if ( !vars.focus.value.length && elementData.length ) {

    vars.data.element.value.node().selectedIndex = 0
    vars.self.focus(elementData[0][vars.id.value])

  }

  function hideElement( elem ) {

    elem
      .style("position","absolute","important")
      .style("clip","rect(1px 1px 1px 1px)","important")
      .style("clip","rect(1px, 1px, 1px, 1px)","important")
      .style("width","1px","important")
      .style("height","1px","important")
      .style("margin","-1px","important")
      .style("padding","0","important")
      .style("border","0","important")
      .style("overflow","hidden","important")

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // If a <legend> element exists, use it as the title.
  //----------------------------------------------------------------------------
  var elementLegend = d3.select("legend[for="+vars.container.id+"]")
  if ( !elementLegend.empty() ) {

    vars.self.title(elementLegend.html())
    elementLegend.call(hideElement)

  }

  var containerTag = vars.container.value
                   ? vars.container.value.node().tagName.toLowerCase() : false

  if ( vars.container.value === false || containerTag === "body" ) {
    vars.container.value = d3.select(vars.data.element.value.node().parentNode)
  }

  return elementData

}

},{}],26:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Calculates node positions, if needed for network
//-------------------------------------------------------------------
module.exports = function(vars) {

  if ( vars.dev.value ) {
    var timerString = "analyzing node positions"
    d3plus.console.time( timerString )
  }

  var set = vars.nodes.value.filter(function(n){
    return typeof n.x == "number" && typeof n.y == "number"
  }).length

  if (set == vars.nodes.value.length) {
    vars.nodes.positions = true
  }
  else {

    var force = d3.layout.force()
      .size([vars.width.viz,vars.height.viz])
      .nodes(vars.nodes.value)
      .links(vars.edges.value)

    var iterations = 50,
        threshold = 0.01;

    force.start(); // Defaults to alpha = 0.1
    for (var i = iterations; i > 0; --i) {
      force.tick();
      if(force.alpha() < threshold) {
        break;
      }
    }
    force.stop();

    vars.nodes.positions = true

  }

  if ( vars.dev.value ) d3plus.console.timeEnd( timerString )

}

},{}],27:[function(require,module,exports){
var numeric;

numeric = require('numeric');

d3plus.data.bestRegress = function(data, options) {
  var N, X, Xfulltr, Xtr, bestResult, beta_hat, bic, degree, degrees, i, j, k, loglike, point, prevBIC, q, residual, sigma2, sse, y, y_hat, _i, _j, _ref, _ref1;
  if (options == null) {
    options = {};
  }
  if (options.maxDegree == null) {
    options.maxDegree = 5;
  }
  N = data.length;
  prevBIC = Number.MAX_VALUE;
  bestResult = null;
  Xfulltr = (function() {
    var _i, _ref, _results;
    _results = [];
    for (degree = _i = 1, _ref = options.maxDegree + 1; 1 <= _ref ? _i < _ref : _i > _ref; degree = 1 <= _ref ? ++_i : --_i) {
      _results.push((function() {
        var _j, _len, _results1;
        _results1 = [];
        for (_j = 0, _len = data.length; _j < _len; _j++) {
          point = data[_j];
          _results1.push(Math.pow(point[0], degree));
        }
        return _results1;
      })());
    }
    return _results;
  })();
  y = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      point = data[_i];
      _results.push(point[1]);
    }
    return _results;
  })();
  for (i = _i = 0, _ref = 1 << options.maxDegree; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    Xtr = [
      (function() {
        var _j, _results;
        _results = [];
        for (q = _j = 0; 0 <= N ? _j < N : _j > N; q = 0 <= N ? ++_j : --_j) {
          _results.push(1);
        }
        return _results;
      })()
    ];
    degrees = [0];
    for (j = _j = 0, _ref1 = options.maxDegree; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
      if ((i & 1 << j) > 0) {
        Xtr.push(Xfulltr[j]);
        degrees.push(j + 1);
      }
    }
    X = numeric.transpose(Xtr);
    k = degrees.length;
    beta_hat = numeric.dot(numeric.dot(numeric.inv(numeric.dot(Xtr, X)), Xtr), y);
    y_hat = numeric.dot(X, beta_hat);
    residual = numeric.sub(y, y_hat);
    sse = numeric.dot(residual, residual);
    sigma2 = sse / (N - k);
    loglike = -0.5 * N * Math.log(2 * Math.PI) - 0.5 * N * Math.log(sigma2) - sse / (2 * sigma2);
    bic = -2 * loglike + k * (Math.log(N) - Math.log(2 * Math.PI));
    if (bic < prevBIC) {
      prevBIC = bic;
      bestResult = [degrees, beta_hat, y_hat];
    }
  }
  return bestResult;
};


},{"numeric":241}],28:[function(require,module,exports){
var kdtree;

kdtree = require('static-kdtree');

d3plus.data.lof = function(points, K) {
  var avg_lrd, i, j, kdists, ldr, ldrs, neighbors, p, reachDist, result, sqDist, tree;
  if (K == null) {
    K = 10;
  }
  tree = kdtree(points);
  neighbors = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = points.length; _i < _len; _i++) {
      p = points[_i];
      _results.push(tree.knn(p, K + 1).slice(1));
    }
    return _results;
  })();
  sqDist = function(i, j) {
    var A, B, delta, dist, _i, _ref;
    A = points[i];
    B = points[j];
    dist = 0;
    for (i = _i = 0, _ref = A.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      delta = A[i] - B[i];
      dist += delta * delta;
    }
    return dist;
  };
  kdists = (function() {
    var _i, _ref, _results;
    _results = [];
    for (i = _i = 0, _ref = points.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      _results.push(sqDist(i, neighbors[i][K - 1]));
    }
    return _results;
  })();
  reachDist = function(i, j) {
    return Math.max(sqDist(i, j), kdists[j]);
  };
  ldr = function(i) {
    var j, rDist, _i, _len, _ref;
    rDist = 0;
    _ref = neighbors[i];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      j = _ref[_i];
      rDist += reachDist(i, j);
    }
    return K / rDist;
  };
  ldrs = (function() {
    var _i, _ref, _results;
    _results = [];
    for (i = _i = 0, _ref = points.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      _results.push(ldr(i));
    }
    return _results;
  })();
  result = (function() {
    var _i, _j, _len, _ref, _ref1, _results;
    _results = [];
    for (i = _i = 0, _ref = points.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      avg_lrd = 0;
      _ref1 = neighbors[i];
      for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
        j = _ref1[_j];
        avg_lrd += ldrs[j];
      }
      avg_lrd /= K;
      _results.push([i, avg_lrd / ldrs[i]]);
    }
    return _results;
  })();
  result.sort(function(a, b) {
    return b[1] - a[1];
  });
  return result;
};


},{"static-kdtree":243}],29:[function(require,module,exports){
d3plus.data.mad = function(points) {
  var mad, median, result;
  median = d3.median(points);
  mad = d3.median(points.map(function(p) {
    return Math.abs(p - median);
  }));
  result = points.map(function(p, i) {
    return [i, Math.abs(p - median) / mad];
  });
  result.sort(function(a, b) {
    return b[1] - a[1];
  });
  return result;
};


},{}],30:[function(require,module,exports){

/**
 * Detects if the Font-Awesome library is loaded on the page.
 */
var stylesheet;

stylesheet = require("../style/sheet.coffee");

d3plus.font.awesome = stylesheet("font-awesome");


},{"../style/sheet.coffee":undefined}],31:[function(require,module,exports){
var fontTester;

fontTester = require("../core/font/tester.coffee");


/**
 * Creates test div to populate with test DIVs
 */

d3plus.font.sizes = function(words, style, parent) {
  var attr, sizes, tester, tspans;
  tester = parent || fontTester("svg").append("text");
  style = style || {};
  sizes = [];
  if (!(words instanceof Array)) {
    words = [words];
  }
  tspans = tester.selectAll("tspan.d3plus_testFontSize").data(words);
  attr = {
    x: 0,
    y: 0
  };
  tspans.enter().append("tspan").attr("class", "d3plus_testFontSize").text(String).style(style).attr(attr).each(function(d) {
    return sizes.push({
      height: this.offsetHeight || this.getBoundingClientRect().height,
      text: d,
      width: this.getComputedTextLength()
    });
  });
  tspans.remove();
  if (!tester) {
    tester.remove();
  }
  return sizes;
};


},{"../core/font/tester.coffee":undefined}],32:[function(require,module,exports){
var fontTester = require("../core/font/tester.coffee")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Given a single font or a list of font, determines which can be rendered
//------------------------------------------------------------------------------
d3plus.font.validate = function(test_fonts) {

  if (!(test_fonts instanceof Array)) {
    test_fonts = test_fonts.split(",")
  }

  var fontString = test_fonts.join(", ")
    , completed = d3plus.font.validate.complete

  if (fontString in completed) {
    return completed[fontString]
  }

  var tester = fontTester("div")

  function create_element(font) {

    return tester.append("span")
      .style("font-family",font)
      .style("font-size","32px")
      .style("padding","0px")
      .style("margin","0px")
      .text("abcdefghiABCDEFGHI_!@#$%^&*()_+1234567890")

  }

  function different(elem1,elem2) {

    var width1 = elem1.node().offsetWidth,
        width2 = elem2.node().offsetWidth

    return width1 !== width2

  }

  var monospace = create_element("monospace"),
      proportional = create_element("sans-serif")

  for ( var font in test_fonts ) {

    var family = test_fonts[font].trim()

    var test = create_element(family+",monospace")

    var valid = different(test,monospace)
    test.remove()

    if (!valid) {
      var test = create_element(family+",sans-serif")
      valid = different(test,proportional)
      test.remove()
    }

    if (valid) {
      valid = family
      break;
    }

  }

  if (!valid) {
    valid = "sans-serif"
  }

  monospace.remove()
  proportional.remove()

  completed[fontString] = valid

  return valid

}

d3plus.font.validate.complete = {}

},{"../core/font/tester.coffee":undefined}],33:[function(require,module,exports){
var dataFormat = require("../core/data/format.js"),
    dataKeys = require("../core/data/keys.js"),
    dataLoad = require("../core/data/load.coffee"),
    fetchData  = require("../core/fetch/data.js"),
    methodReset = require("../core/method/reset.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Form Element shell
//------------------------------------------------------------------------------
d3plus.form = function() {

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Initialize the global variable object.
  //----------------------------------------------------------------------------
  var vars = {
    "types": {
      "auto": require("./types/auto.js"),
      "button": require("./types/button/button.js"),
      "drop": require("./types/drop/drop.js"),
      "toggle": require("./types/toggle.js")
    },
    "shell": "form"
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Create the main drawing function.
  //----------------------------------------------------------------------------
  vars.self = function( selection ) {

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Set timing to 0 if it's the first time running this function or if the
    // data length is longer than the "large" limit
    //--------------------------------------------------------------------------
    var large = vars.data.value instanceof Array
                && vars.data.value.length > vars.data.large

    vars.draw.timing = vars.draw.first || large || d3plus.ie
                     ? 0 : vars.timing.ui

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Create/update the UI element
    //--------------------------------------------------------------------------
    if ( vars.data.value instanceof Array ) {

      if ( vars.dev.value ) d3plus.console.groupCollapsed("drawing \""+vars.type.value+"\"")

      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      // Analyze new data, if changed.
      //------------------------------------------------------------------------
      if ( vars.data.changed ) {
        vars.data.cache = {}
        dataKeys( vars , "data" )
        dataFormat( vars )
      }

      vars.data.app = fetchData( vars )

      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      // Sort the data, if needed.
      //------------------------------------------------------------------------
      if ( vars.data.changed || vars.order.changed || vars.order.sort.changed ) {

        d3plus.array.sort( vars.data.app , vars.order.value || vars.text.value
                         , vars.order.sort.value , vars.color.value , vars )

      }

      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      // Set first element in data as focus if there is no focus set.
      //------------------------------------------------------------------------
      if ( !vars.focus.value.length ) {

        var element = vars.data.element.value

        if ( element && element.node().tagName.toLowerCase() === "select" ) {
          var i = element.property("selectedIndex")
          i = i < 0 ? 0 : i
          var option = element.selectAll("option")[0][i]
            , val = option.getAttribute("data-"+vars.id.value) || option.getAttribute(vars.id.value)
          if (val) vars.focus.value[0] = val
        }

        if ( !vars.focus.value.length && vars.data.app.length ) {
          vars.focus.value[0] = vars.data.app[0][vars.id.value]
        }

        if ( vars.dev.value && vars.focus.value.length ) d3plus.console.log("\"value\" set to \""+vars.focus+"\"")

      }

      function getLevel(d,depth) {

        var depth = typeof depth !== "number" ? vars.id.nesting.length === 1
                  ? 0 : vars.id.nesting.length-1 : depth
          , level = vars.id.nesting[depth]

        if ( depth > 0 && (!(level in d) || d[level] instanceof Array) ) {
          return getLevel(d,depth-1)
        }
        else {
          return level
        }

      }

      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      // Run these things if the data has changed.
      //------------------------------------------------------------------------
      if ( vars.data.changed ) {

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Determine if search box is needed.
        //----------------------------------------------------------------------
        if ( vars.search.value === "auto" ) {

          if (vars.data.app.length > 10) {
            vars.search.enabled = true
            if ( vars.dev.value ) d3plus.console.log("Search enabled.")
          }
          else {
            vars.search.enabled = false
            if ( vars.dev.value ) d3plus.console.log("Search disabled.")
          }

        }
        else {

          vars.search.enabled = vars.search.value

        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Update OPTION elements with the new data.
        //----------------------------------------------------------------------
        var elementTag = vars.data.element.value
                       ? vars.data.element.value.node().tagName.toLowerCase() : ""
        if ( vars.data.element.value && elementTag === "select" ) {

          var optionData = []
          for (var level in vars.data.nested.all) {
            optionData = optionData.concat(vars.data.nested.all[level])
          }

          options = vars.data.element.value.selectAll("option")
            .data(optionData,function(d){
              var level = getLevel(d)
              return d && level in d ? d[level] : false
            })

          options.exit().remove()

          options.enter().append("option")

          options
            .each(function(d){

              var level   = getLevel(d)
                , textKey = level === vars.id.value ? vars.text.value || vars.id.value
                          : vars.text.nesting !== true && level in vars.text.nesting
                          ? vars.text.nesting[level] : level

              for ( var k in d ) {

                if ( typeof d[k] !== "object" ) {

                  if ( k === textKey ) {
                    d3.select(this).html(d[k])
                  }

                  if ( ["alt","value"].indexOf(k) >= 0 ) {
                    d3.select(this).attr(k,d[k])
                  }
                  else {
                    d3.select(this).attr("data-"+k,d[k])
                  }

                }

              }

              if (d[level] === vars.focus.value[0]) {
                this.selected = true
              }
              else {
                this.selected = false
              }

            })

        }

      }
      else if (vars.focus.changed && vars.data.element.value) {
        var elementTag = vars.data.element.value.node().tagName.toLowerCase()
        if (elementTag === "select") {
          vars.data.element.value.selectAll("option")
            .each(function(d){
              var level = getLevel(d)
              if (d[level] === vars.focus.value[0]) {
                this.selected = true
              }
              else {
                this.selected = false
              }
            })
        }
      }

      if ( vars.type.value !== "auto" ) {

        if ( !vars.container.ui ) {

          //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          // Select container DIV for UI element
          //----------------------------------------------------------------------
          vars.container.ui = vars.container.value
            .selectAll("div#d3plus_"+vars.type.value+"_"+vars.container.id)
            .data(["container"])

          //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          // Create container DIV for UI element
          //----------------------------------------------------------------------
          var before = vars.data.element.value ? vars.data.element.value[0][0] : null

          if ( before ) {

            if ( before.id ) {
              before = "#"+before.id
            }
            else {

              var id = before.getAttribute(vars.id.value)
                     ? vars.id.value : "data-"+vars.id.value

              if ( before.getAttribute(id) ) {
                before = "["+id+"="+before.getAttribute(id)+"]"
              }
              else {
                before = null
              }

            }

          }

          vars.container.ui.enter()
            .insert("div",before)
            .attr("id","d3plus_"+vars.type.value+"_"+vars.container.id)
            .style("position","relative")
            .style("overflow","visible")
            .style("vertical-align","top")

        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Update Container
        //------------------------------------------------------------------------
        vars.container.ui
          .style("display",vars.ui.display.value)

        vars.container.ui.transition().duration(vars.draw.timing)
          .style("margin",vars.ui.margin+"px")

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Create title, if available.
        //------------------------------------------------------------------------
        var title = vars.container.ui.selectAll("div.d3plus_title")
          .data(vars.title.value ? [vars.title.value] : [])

        title.enter().insert("div","#d3plus_"+vars.type.value+"_"+vars.container.id)
          .attr("class","d3plus_title")
          .style("display","inline-block")

        title
          .style("color",vars.font.color)
          .style("font-family",vars.font.family.value)
          .style("font-size",vars.font.size+"px")
          .style("font-weight",vars.font.weight)
          .style("padding",vars.ui.padding+"px")
          .style("border-color","transparent")
          .style("border-style","solid")
          .style("border-width",vars.ui.border+"px")
          .text(String)
          .each(function(d){
            vars.margin.left = this.offsetWidth
          })

      }

      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      // Call specific UI element type, if there is data.
      //------------------------------------------------------------------------
      if ( vars.data.value.length ) {

        var app = vars.format.locale.value.visualization[vars.type.value]
        if ( vars.dev.value ) d3plus.console.time("drawing "+ app)
        vars.types[vars.type.value]( vars )
        if ( vars.dev.value ) d3plus.console.timeEnd("drawing "+ app)

      }
      else if ( vars.data.url && (!vars.data.loaded || vars.data.stream) ) {

        dataLoad( vars , "data" , vars.self.draw )

      }

      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      // Initialization complete
      //------------------------------------------------------------------------
      methodReset( vars )
      vars.methodGroup = false

      if ( vars.dev.value ) d3plus.console.groupEnd()

    }

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Define methods and expose public variables.
  //----------------------------------------------------------------------------
  var methods = [ "active" , "aggs" , "alt" , "color" , "container" , "depth"
                , "dev" , "data" , "draw" , "focus" , "format" , "height"
                , "history" , "hover" , "icon" , "id" , "keywords" , "margin"
                , "open" , "order" , "remove" , "search" , "select"
                , "selectAll" , "text" , "title" , "type" , "width" ]
    , styles  = [ "data" , "font" , "icon" , "timing" , "title" , "ui" ]

  d3plus.method( vars , methods , styles )

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Finally, return the main UI function to the user
  //----------------------------------------------------------------------------
  return vars.self

}

},{"../core/data/format.js":undefined,"../core/data/keys.js":undefined,"../core/data/load.coffee":undefined,"../core/fetch/data.js":undefined,"../core/method/reset.js":undefined,"./types/auto.js":undefined,"./types/button/button.js":undefined,"./types/drop/drop.js":undefined,"./types/toggle.js":undefined}],34:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Determines form type based on data length.
//------------------------------------------------------------------------------
module.exports = function( vars ) {

  var dataLength = vars.data.value.length

  if ( dataLength === 1 ) {
    vars.self.type("button").draw()
  }
  else if ( dataLength < 5 ) {
    vars.self.type("toggle").draw()
  }
  else {
    vars.self.type("drop").draw()
  }

}

},{}],35:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates a Button
//------------------------------------------------------------------------------
module.exports = function( vars ) {

  var color = require("./functions/color.js")
    , icons = require("./functions/icons.js")
    , mouseevents = require("./functions/mouseevents.js")
    , style = require("./functions/style.js")

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Bind Data to Buttons
  //----------------------------------------------------------------------------
  var button = vars.container.ui.selectAll("div.d3plus_node")
    .data(vars.data.app,function(d){
      return d[vars.id.value]
    })

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Enter Buttons
  //----------------------------------------------------------------------------
  if ( vars.dev.value ) d3plus.console.time("enter")

  button.enter().append("div")
    .attr("class","d3plus_node")
    .call( color , vars )
    .call( style , vars )
    .call( icons , vars )
    .call( mouseevents , vars , color )

  if ( vars.dev.value ) d3plus.console.timeEnd("enter")

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Update Buttons
  //----------------------------------------------------------------------------
  if (vars.draw.update || vars.draw.timing) {

    if ( vars.dev.value ) d3plus.console.time("ordering")
    button.order()
    if ( vars.dev.value ) d3plus.console.timeEnd("ordering")

    var updatedButtons = button

  }
  else {

    var checks = [ vars.focus.previous
                 , vars.focus.value[0]
                 , vars.hover.previous
                 , vars.hover.value ].filter(function(c){ return c })

    var updatedButtons = button.filter(function(b){
      return checks.indexOf(b[vars.id.value]) >= 0
    })

  }

  if ( vars.dev.value ) d3plus.console.time("update")
  if (vars.draw.timing) {
    updatedButtons
      .transition().duration(vars.draw.timing)
      .call( color , vars )
      .call( style , vars )
  }
  else {
    updatedButtons
      .call( color , vars )
      .call( style , vars )
  }

  updatedButtons
    .call( icons , vars )
    .call( mouseevents , vars , color )
  if ( vars.dev.value ) d3plus.console.timeEnd("update")

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Exit Buttons
  //----------------------------------------------------------------------------
  button.exit().remove()

}

},{"./functions/color.js":undefined,"./functions/icons.js":undefined,"./functions/mouseevents.js":undefined,"./functions/style.js":undefined}],36:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Defines button color
//------------------------------------------------------------------------------
module.exports = function ( elem , vars ) {

  elem
    .style("background-color",function(d){

      if ( vars.focus.value[0] !== d[vars.id.value] ) {

        if ( vars.hover.value === d[vars.id.value] ) {
          return d3plus.color.lighter(vars.ui.color.secondary.value,.25)
        }
        else {
          return vars.ui.color.secondary.value
        }

      }
      else {

        if ( vars.hover.value === d[vars.id.value] ) {
          return d3.rgb(vars.ui.color.primary.value).darker(0.15).toString()
        }
        else {
          return vars.ui.color.primary.value
        }

      }

    })
    .style("color",function(d){

      var image = d[vars.icon.value] && vars.data.app.length < vars.data.large

      if ( vars.focus.value[0] === d[vars.id.value] ) {
        var opacity = 1
      }
      else {
        var opacity = 0.75
      }

      if ( vars.focus.value[0] === d[vars.id.value] && d[vars.color.value] && !image ) {
        var color = d3plus.color.legible(d[vars.color.value])
      }
      else if ( vars.focus.value[0] === d[vars.id.value] ) {
        var color = d3plus.color.text(vars.ui.color.primary.value)
      }
      else {
        var color = d3plus.color.text(vars.ui.color.secondary.value)
      }

      var color = d3.rgb(color)

      return "rgba("+color.r+","+color.g+","+color.b+","+opacity+")"

    })
    .style("border-color",vars.ui.color.secondary.value)

}

},{}],37:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//
//------------------------------------------------------------------------------
module.exports = function ( elem , vars ) {

  var reversed = (vars.font.align.value === "right" && !d3plus.rtl)
                 || (d3plus.rtl && vars.font.align.value === "right")

  elem
    .each(function(d,i){

      var children = ["label"]

      if ( d[vars.icon.value] && vars.data.app.length <= vars.data.large ) {
        children.push("icon")
      }

      var iconGraphic = vars.icon.button.value
      if ( d[vars.id.value] === vars.focus.value[0] && vars.icon.select.value ) {
        iconGraphic = vars.icon.select.value
        children.push("selected")
      }
      else if ( iconGraphic && d.d3plus.icon !== false ) {
        children.push("selected")
      }

      var buffer = 0

      var items = d3.select(this).selectAll("div.d3plus_button_element")
        .data(children,function(c){
          return c
        })

      items.enter().append("div")
        .style("display",function(c){
          return c === "label" ? "block" : "absolute"
        })

      items.order()
        .attr("class",function(c){
          var extra = ""
          if ( c === "selected" && iconGraphic.indexOf("fa-") === 0 ) {
            extra = " fa "+iconGraphic
          }
          return "d3plus_button_element d3plus_button_" + c + extra
        })
        .html(function(c){
          if ( c === "label" ) {
            var k = vars.text.value && vars.text.value in d && !(d[vars.text.value] instanceof Array)
                  ? vars.text.value : vars.id.value
            return vars.format.value(d[k])
          }
          return c === "selected" && iconGraphic.indexOf("fa-") < 0
                 ? iconGraphic : ""
        })
        .style("background-image",function(c){
          if (c === "icon") {
            return "url('"+d[vars.icon.value]+"')"
          }
          return "none"
        })
        .style("background-color",function(c){
          if (c === "icon" && d.style === "knockout") {
            return d[vars.color.value] || vars.ui.color.primary.value
          }
          return "transparent"
        })
        .style("background-size","100%")
        .style("text-align",function(c){
          return c === "label" ? vars.font.align.value : "center"
        })
        .style("position",function(c){
          return c == "label" ? "static" : "absolute"
        })
        .style("width",function(c){

          if ( c === "label" ) {
            return "auto"
          }

          if (vars.height.value) {
            buffer = (vars.height.value-(vars.ui.padding*2)-(vars.ui.border*2))
          }
          else {
            buffer = vars.font.size+vars.ui.padding+vars.ui.border
          }
          return buffer+"px"
        })
        .style("height",function(c){
          if ( c === "icon" ) {
            return buffer+"px"
          }
          return "auto"
        })
        .style("margin-top",function(c){
          if ( c === "label" ) {
            return "0px"
          }
          if (this.offsetHeight || this.getBoundingClientRect().height) {
            var h = this.offsetHeight || this.getBoundingClientRect().height
          }
          else if ( c === "selected" ) {
            var h = vars.font.size
          }
          else {
            var h = buffer
          }
          return -h/2+"px"
        })
        .style("top",function(c){
          return c === "label" ? "auto" : "50%"
        })
        .style("left",function(c){
          if ((c === "icon" && !reversed) || (c === "selected" && reversed)) {
            return vars.ui.padding+"px"
          }
          return "auto"
        })
        .style("right",function(c){
          if ((c === "icon" && reversed) || (c === "selected" && !reversed)) {
            return vars.ui.padding+"px"
          }
          return "auto"
        })
        .style(d3plus.prefix()+"transition",function(c){
          return c === "selected" ? (vars.draw.timing/1000)+"s" : "none"
        })
        .style(d3plus.prefix()+"transform",function(c){
          var degree = c === "selected" ? vars.icon.select.rotate : "none"
          return "rotate("+degree+"deg)"
        })
        .style("opacity",function(c){
          return c === "selected" ? vars.icon.select.opacity : 1
        })

      items.exit().remove()

      var text = d3.select(this).selectAll(".d3plus_button_label")

      if (buffer > 0) {

        buffer += vars.ui.padding*2

        var p = vars.ui.padding

        if (children.length === 3) {
          var padding = p+"px "+buffer+"px"
        }
        else if ((children.indexOf("icon") >= 0 && !d3plus.rtl) || (children.indexOf("selected") >= 0 && d3plus.rtl)) {
          var padding = p+"px "+p+"px "+p+"px "+buffer+"px"
        }
        else {
          var padding = p+"px "+buffer+"px "+p+"px "+p+"px"
        }

        text.style("padding",padding)

      }
      else {
        text.style("padding",vars.ui.padding+"px")
      }

      if (typeof vars.width.value === "number") {
        var width = vars.width.value
        width -= parseFloat(text.style("padding-left"),10)
        width -= parseFloat(text.style("padding-right"),10)
        width -= vars.ui.border*2
        width += "px"
      }
      else {
        var width = "auto"
      }

      text.style("width",width)

    })

}

},{}],38:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//
//------------------------------------------------------------------------------
module.exports = function ( elem , vars , color ) {

  elem
    .on(d3plus.evt.over,function(d,i){

      vars.self.hover(d[vars.id.value])

      if ( d3plus.ie || !vars.draw.timing ) {

        d3.select(this).style("cursor","pointer")
          .call( color , vars )

      }
      else {

        d3.select(this).style("cursor","pointer")
          .transition().duration(vars.timing.mouseevents)
          .call( color , vars )
      }

    })
    .on(d3plus.evt.out,function(d){

      vars.self.hover(false)

      if ( d3plus.ie || !vars.draw.timing ) {
        d3.select(this).style("cursor","auto")
          .call( color , vars )
      }
      else {
        d3.select(this).style("cursor","auto")
          .transition().duration(vars.timing.mouseevents)
          .call( color , vars )
      }

    })
    .on(d3plus.evt.click,function(d){

      if ( vars.id.value in d ) {

        vars.self.focus(d[vars.id.value]).draw()

      }

    })

}

},{}],39:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//
//------------------------------------------------------------------------------
module.exports = function ( elem , vars ) {

  elem
    .style("position","relative")
    .style("margin",vars.ui.margin+"px")
    .style("display",vars.ui.display.value)
    .style("border-style","solid")
    .style("border-width",vars.ui.border+"px")
    .style("font-family",vars.font.family.value)
    .style("font-size",vars.font.size+"px")
    .style("font-weight",vars.font.weight)
    .style("letter-spacing",vars.font.spacing+"px")

}

},{}],40:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates Dropdown Menu
//------------------------------------------------------------------------------
module.exports = function( vars ) {

  var element = require("./functions/element.js")
    , keyboard = require("./functions/keyboard.js")
    , windowevent = require("./functions/window.js")
    , width = require("./functions/width.js")
    , button = require("./functions/button.js")
    , selector = require("./functions/selector.js")
    , title = require("./functions/title.js")
    , search = require("./functions/search.js")
    , list = require("./functions/list.js")
    , data = require("./functions/data.js")
    , update = require("./functions/update.js")

  vars.margin.top = 0
  vars.margin.title = 0

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Hijack events of original element, if applicable.
  //----------------------------------------------------------------------------
  element( vars )

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Capture keyboard events
  //----------------------------------------------------------------------------
  keyboard( vars )

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Apply click function to all parent windows to close dropdown.
  //----------------------------------------------------------------------------
  windowevent( vars )

  // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Check to make sure we have both a button and list width.
  // ---------------------------------------------------------------------------
  width( vars )

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Create main button, if it does not already exist.
  //----------------------------------------------------------------------------
  button( vars )

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Create "selector" to hold the search box and search vars.container.list.
  //----------------------------------------------------------------------------
  selector( vars )

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Create and style the title box, if applicable.
  //----------------------------------------------------------------------------
  title( vars )

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Create and style the search box, if applicable.
  //----------------------------------------------------------------------------
  search( vars )

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Create and style the item list.
  //----------------------------------------------------------------------------
  list( vars )

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Filter data based off search term, if applicable.
  //----------------------------------------------------------------------------
  data( vars )

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Updates all divs
  //----------------------------------------------------------------------------
  update( vars )

}

},{"./functions/button.js":undefined,"./functions/data.js":undefined,"./functions/element.js":undefined,"./functions/keyboard.js":undefined,"./functions/list.js":undefined,"./functions/search.js":undefined,"./functions/selector.js":undefined,"./functions/title.js":undefined,"./functions/update.js":undefined,"./functions/width.js":undefined,"./functions/window.js":undefined}],41:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Checks to see if a given variable is allowed to be selected.
//------------------------------------------------------------------------------
module.exports = function ( vars , value , active ) {

  var ret = []
    , active = active || vars.active.value

  if ( active instanceof Array ) {

    for (var i = 0; i < active.length; i++) {
      ret.push(this(vars,value,active[i]))
    }

  }
  else {

    var t = typeof active

    if (t === "number") {
      ret.push(vars.depth.value === active)
    }
    else if (t === "function") {
      ret.push(active(value))
    }
    else {
      ret.push(value === active)
    }

  }

  return ret.indexOf(true) >= 0

}

},{}],42:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Toggles the state of the dropdown menu.
//------------------------------------------------------------------------------
module.exports = function ( vars ) {

  if ( vars.dev.value ) d3plus.console.time("rotating arrow")

  var offset = vars.icon.drop.value === "&#x276f;" ? 90 : 0

  if (vars.open.value != vars.open.flipped.value) {
    var rotate = 180 + offset
  }
  else {
    var rotate = offset
  }

  vars.container.button
    .icon({
      "select": {
        "opacity": vars.open.value ? 0.5 : 1,
        "rotate": rotate
      }
    })
    .draw()

  if ( vars.dev.value ) d3plus.console.timeEnd("rotating arrow")

}

},{}],43:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates and styles the main drop button.
//------------------------------------------------------------------------------
module.exports = function ( vars ) {

  if ( !("button" in vars.container) ) {

    if ( vars.dev.value ) d3plus.console.time("creating main button")

    vars.container.button = d3plus.form()
      .container(vars.container.ui)
      .type("button")
      .ui({
        "margin": 0
      })

    if ( vars.dev.value ) d3plus.console.timeEnd("creating main button")

  }

  if ( vars.focus.changed || vars.data.changed || vars.depth.changed ) {

    var depth = vars.depth.value

    var buttonData = d3plus.util.copy(vars.data.value.filter(function(d){
      var match = false
      for ( var i = 0 ; i < vars.id.nesting.length ; i++ ) {
        var level = vars.id.nesting[i]
        match = level in d && d[level] === vars.focus.value[0]
        if (match) {
          depth = i
          break
        }
      }
      return match
    })[0])

    if ( !buttonData ) {
      buttonData = vars.container.button.data()[0] || vars.data.app[0]
    }

    vars.container.button
      .data([buttonData])
      .id( vars.id.nesting )
      .depth(depth)

  }

  vars.container.button
    .draw({
      "update": vars.draw.update
    })
    .focus(vars.focus.value[0])
    .font( vars.font )
    .icon({
      "button": vars.icon.drop.value,
      "select": vars.icon.drop.value,
      "value": vars.icon.value
    })
    .text( vars.text.value )
    .timing({
      "ui": vars.draw.timing
    })
    .ui({
      "color": vars.ui.color,
      "padding": vars.ui.padding
    })
    .width(vars.width.value)
    .draw()

  var button = vars.container.button.container(Object).ui

  vars.margin.top += button.node().offsetHeight || button.node().getBoundingClientRect().height

  button.on(d3plus.evt.click,function(){
    vars.self.open(!vars.open.value).draw()
  })

}

},{}],44:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates and populates the dropdown list of items.
//------------------------------------------------------------------------------
module.exports = function ( vars ) {

  if ( vars.data.url && !vars.data.loaded ) {
    var loadingObject = {}
    loadingObject[vars.text.value || vars.id.value] = vars.format.value(vars.format.locale.value.ui.loading)
    vars.data.filtered = [loadingObject]
  }
  else if (vars.open.value) {

    var searchText  = vars.text.solo.value.length
                    ? vars.text.solo.value[0].toLowerCase() : ""
      , searchWords = d3plus.string.strip(searchText).split("_")
      , searchKeys  = [ vars.id.value
                      , vars.text.value
                      , vars.alt.value
                      , vars.keywords.value ]

    searchKeys = searchKeys.filter(function(t){ return t })
    searchWords = searchWords.filter(function(t){ return t != ""; })

    if (!vars.text.solo.value.length || vars.text.solo.value[0] === "") {
      vars.data.filtered = vars.data.app
      if (vars.id.nesting.length > 1 && vars.depth.value < vars.id.nesting.length-1) {
        vars.data.filtered = vars.data.filtered.filter(function(d){
          if ("endPoint" in d.d3plus && d.d3plus.endPoint === vars.depth.value) {
            d.d3plus.icon = false
          }
          return true
        })
      }
    }
    else {

      var startMatches = []
        , exactMatches = []
        , softMatches  = []
        , searchData   = []

      vars.id.nesting.forEach(function(n){
        searchData = searchData.concat(vars.data.nested.all[n])
      })

      searchData.forEach(function(d){

        var match = false

        searchKeys.forEach(function(key){

          if ( !match && key in d && typeof d[key] === "string" ) {

            var text = d[key].toLowerCase()

            if ( [vars.text.value,vars.id.value].indexOf(key) >= 0 && text.indexOf(searchText) == 0 ) {
              startMatches.push(d)
              match = true
            }
            else if ( text.indexOf(searchText) >= 0 ) {
              exactMatches.push(d)
              match = true
            }
            else {

              var texts = d3plus.string.strip(text).split("_")

              for (t in texts) {

                if ( !match ) {

                  for (s in searchWords) {
                    if (texts[t].indexOf(searchWords[s]) === 0) {
                      softMatches.push(d)
                      match = true
                      break
                    }
                  }

                }
                else {
                  break
                }

              }

            }
          }

        })

      })

      vars.data.filtered = d3.merge([ startMatches , exactMatches , softMatches ])

      vars.data.filtered.forEach(function(d,i){
        d.d3plus_order = i
      })

    }

    if ( vars.data.filtered.length === 0 ) {

      var noData = {}
        , str = vars.format.value(vars.format.locale.value.ui.noResults)
      noData[vars.text.value || vars.id.value] = d3plus.string.format(str,"\""+searchText+"\"")
      vars.data.filtered = [ noData ]

    }

  }
  else {
    vars.data.filtered = []
  }

}

},{}],45:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Overrides keyboard behavior of the original input element.
//------------------------------------------------------------------------------
module.exports = function ( vars ) {

  if (vars.data.element.value) {

    vars.data.element.value.on("focus."+vars.container.id,function(){
      vars.self.draw({"update":false}).draw()
    })

    vars.data.element.value.on("blur."+vars.container.id,function(){

      var search = vars.search.enabled
                 ? d3.event.relatedTarget != vars.container.value.select("input").node()
                 : true

      if (search) {
        vars.self.draw({"update":false}).draw()
      }

    })

    vars.data.element.value.on("change."+vars.container.id,function(){
      vars.self.focus(this.value).draw()
    })

    vars.data.element.value.on("keydown.cancel_"+vars.container.id,function(){
      var key = d3.event.keyCode
      if (key != 9) {
        d3.event.preventDefault()
      }
    })

  }

}

},{}],46:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Calculates the height and orientation of the dropdown list, based on
// available screen space.
//------------------------------------------------------------------------------
module.exports = function ( vars ) {

  var button = vars.container.button.container().node().getBoundingClientRect()

  vars.height.secondary = window.innerHeight - button.bottom - vars.ui.margin
                         - vars.ui.padding*2 - vars.ui.border*2

  if ( vars.height.secondary < button.height*3 ) {
    vars.height.secondary = button.top-10
    vars.self.open({"flipped": true})
  }
  else {
    vars.self.open({"flipped": false})
  }

  var scrolling = false
  if (vars.height.secondary > vars.height.max) {
    vars.height.secondary = vars.height.max
  }

}

},{}],47:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Populates item list based on filtered data.
//------------------------------------------------------------------------------
module.exports = function ( vars ) {

  var active = require("./active.js")

  if (vars.open.value) {

    if ( vars.dev.value ) d3plus.console.time("updating list items")

    if ( !("items" in vars.container) ) {

      vars.container.items = d3plus.form()
        .container(vars.container.list)
        .type("button")
        .ui({
          "border": 0,
          "display": "block",
          "margin": 0
        })
        .width(false)

    }

    var large = vars.draw.timing ? vars.data.large : 1
      , order = d3plus.util.copy(vars.order)
      , deepest = vars.depth.value === vars.id.nesting.length-1

    order.value = vars.text.solo.value.length && vars.text.solo.value[0] !== ""
                ? "d3plus_order" : vars.order.value

    if ( vars.focus.changed || !vars.container.items.focus().length ) {

      vars.container.items
        .focus( vars.focus.value[0] , function(value){

          value = value[0]

          var change = value !== vars.focus.value[0]
          if ( change && vars.active.value ) {

            change = active(vars,value)

          }

          if ( change ) {

            vars.self.focus( value )

          }

          var data = vars.data.filtered.filter(function(f){
            return f[vars.id.value] === value
          })[0]

          if ( vars.depth.value < vars.id.nesting.length - 1 && vars.id.nesting[vars.depth.value+1] in data ) {

            var depth = vars.depth.value
              , solo  = vars.id.solo.value

            vars.history.states.push(function(){

              vars.self
                .depth( depth )
                .id({ "solo" : solo })
                .draw()

            })

            vars.self
              .depth( vars.depth.value + 1 )
              .id({ "solo" : [value] })
              .draw()

          }
          else if ( !vars.depth.changed ) {

            vars.self.open(false).draw()

          }
          else if ( change ) {
            vars.self.draw()
          }

        })

    }

    vars.container.items
      .active( vars.active.value )
      .data({
        "large": large,
        "value": vars.data.filtered
      })
      .draw({
        "update": vars.draw.update
      })
      .font( vars.font.secondary )
      .id( vars.id.value )
      .icon({
        "button": deepest ? false : vars.icon.next,
        "select": deepest ? vars.icon.select : false
      })
      .order( order )
      .text( vars.text.secondary.value || vars.text.value )
      .timing({
        "ui": vars.draw.timing
      })
      .ui({
        "color": {
          "primary": vars.id.nesting.length === 1 ? vars.ui.color.primary.value : vars.ui.color.secondary.value,
          "secondary": vars.ui.color.secondary.value
        },
        "padding": vars.ui.padding
      })
      .draw()

    if ( vars.dev.value ) d3plus.console.timeEnd("updating list items")

  }

}

},{"./active.js":undefined}],48:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Assigns behavior to the user's keyboard for navigation.
//------------------------------------------------------------------------------
module.exports = function ( vars ) {

  d3.select(document).on("keydown."+vars.container.id,function(){

    if (vars.open.value || vars.hover === true) {

      var key = d3.event.keyCode,
          options = vars.container.list.select("div").selectAll("div.d3plus_node"),
          index = 0

      if (typeof vars.hover == "boolean") {
        options.each(function(d,i){
          if (d.value == vars.focus) {
            index = i
          }
        })
      }
      else {
        options.each(function(d,i){
          if (d.value == vars.hover) {
            index = i
          }
        })
      }

      // Tab
      if ([9].indexOf(key) >= 0 && (!vars.search.enabled || (vars.search.enabled && !d3.event.shiftKey))) {
        vars.self.draw({"update":false}).disable()
      }
      // Down Arrow
      else if ([40].indexOf(key) >= 0) {
        if (vars.open.value) {
          if (index >= options.size()-1) {
            index = 0
          }
          else {
            index += 1
          }
        }

        if (typeof vars.hover != "boolean") {
          var hover = options.data()[index].value
        }
        else {
          var hover = vars.focus
        }

        if (vars.open.value) {
          vars.self.draw({"update":false}).hover(hover).draw(60)
        }
        else {
          vars.self.draw({"update":false}).hover(hover).enable()
        }

      }
      // Up Arrow
      else if ([38].indexOf(key) >= 0) {
        if (vars.open.value) {
          if (index <= 0) {
            index = options.size()-1
          }
          else {
            index -= 1
          }
        }

        if (typeof vars.hover != "boolean") {
          var hover = options.data()[index].value
        }
        else {
          var hover = vars.focus
        }

        if (vars.open.value) {
          vars.self.draw({"update":false}).hover(hover).draw(60)
        }
        else {
          vars.self.draw({"update":false}).hover(hover).enable()
        }

      }
      // Enter/Return
      else if ([13].indexOf(key) >= 0) {
        if (typeof vars.hover != "boolean") {
          vars.self.value(vars.hover).draw()
        }
        else {
          vars.self.hover(vars.focus).toggle()
        }
      }
      // Esc
      else if ([27].indexOf(key) >= 0) {
        if (vars.open.value) {
          vars.self.disable()
        }
        else if (vars.hover === true) {
          vars.self.hover(false).draw()
        }
      }

    }

  })

}

},{}],49:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates and populates the dropdown list of items.
//------------------------------------------------------------------------------
module.exports = function ( vars ) {

  if ( vars.dev.value ) d3plus.console.time("populating list")

  vars.container.list = vars.container.selector.selectAll("div.d3plus_drop_list")
    .data(["list"])

  vars.container.list.enter().append("div")
    .attr("class","d3plus_drop_list")
    .attr("id","d3plus_drop_list_"+vars.container.id)
    .style("overflow-y","auto")
    .style("overflow-x","hidden")

  if ( vars.dev.value ) d3plus.console.timeEnd("populating list")

}

},{}],50:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Calculates scroll position of list.
//------------------------------------------------------------------------------
module.exports = function ( vars ) {

  if (vars.open.value) {

    if ( vars.dev.value ) d3plus.console.time("calculating height")

    var hidden = false
    if (vars.container.selector.style("display") == "none") {
      var hidden = true
    }

    if (hidden) vars.container.selector.style("display","block")

    var searchHeight = vars.search.enabled ? vars.container.search.node().offsetHeight || vars.container.search.node().getBoundingClientRect().height : 0

    var old_height = vars.container.selector.style("height"),
        old_scroll = vars.container.selector.property("scrollTop"),
        list_height = vars.container.list.style("max-height"),
        list_scroll = vars.container.list.property("scrollTop")

    vars.container.selector.style("height","auto")
    vars.container.list.style("max-height","200000px")

    vars.container.listHeight = parseFloat(vars.container.selector.style("height"),10)

    vars.container.list
      .style("max-height",list_height)
      .property("scrollTop",list_scroll)

    vars.container.selector
      .style("height",old_height)
      .property("scrollTop",old_scroll)

    var scrolling = false
    if (vars.container.listHeight > vars.height.secondary) {
      vars.container.listHeight = vars.height.secondary
      scrolling = true
    }

    if (hidden) vars.container.selector.style("display","none")

    if ( vars.dev.value ) d3plus.console.timeEnd("calculating height")

    if (scrolling) {

      if ( vars.dev.value ) d3plus.console.time("calculating scroll position")

      var options = vars.container.list.select("div").selectAll("div.d3plus_node")
      var option = options[0][0]
      options.each(function(d,i){
        if (d[vars.id.value] == vars.focus.value[0]) {
          option = this
        }
      })

      var hidden = false
      if (vars.container.selector.style("display") === "none") {
        hidden = true
        vars.container.selector.style("display","block")
      }

      var button_top = option.offsetTop,
          button_height = option.offsetHeight || option.getBoundingClientRect().height,
          list_top = vars.container.list.property("scrollTop")

      if (hidden) vars.container.selector.style("display","none")

      if ( hidden || vars.data.changed || vars.depth.changed ) {

        vars.container.listScroll = button_top

      }
      else {

        vars.container.listScroll = list_top

        if (button_top < list_top) {
          vars.container.listScroll = button_top
        }
        else if (button_top+button_height > list_top+vars.height.secondary-searchHeight) {
          vars.container.listScroll = button_top - (vars.height.secondary-button_height-searchHeight)
        }

      }

      if ( vars.dev.value ) d3plus.console.timeEnd("calculating scroll position")

    }
    else {
      vars.container.listScroll = 0
    }

  }
  else {
    vars.container.listScroll = vars.container.list.property("scrollTop")
    vars.container.listHeight = 0
  }

}

},{}],51:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates and styles the search box, if enabled.
//------------------------------------------------------------------------------
module.exports = function ( vars ) {

  if ( vars.dev.value ) d3plus.console.time("creating search")

  var data = require("./data.js")
    , items = require("./items.js")
    , update = require("./update.js")

  vars.container.search = vars.container.selector.selectAll("div.d3plus_drop_search")
    .data(vars.search.enabled ? ["search"] : [])

  function searchStyle(elem) {

    elem
      .style("padding",vars.ui.padding+"px")
      .style("display","block")
      .style("background-color",vars.ui.color.secondary.value)

  }

  function inputStyle(elem) {

    var width = vars.width.secondary - vars.ui.padding*4 - vars.ui.border*2

    elem
      .style("padding",vars.ui.padding+"px")
      .style("width",width+"px")
      .style("border-style","solid")
      .style("border-width","0px")
      .style("font-family",vars.font.secondary.family.value)
      .style("font-size",vars.font.secondary.size+"px")
      .style("font-weight",vars.font.secondary.weight)
      .style("text-align",vars.font.secondary.align)
      .style("outline","none")
      .style(d3plus.prefix()+"border-radius","0")
      .attr("placeholder",vars.format.value(vars.format.locale.value.method.search))

  }

  if (vars.draw.timing) {

    vars.container.search.transition().duration(vars.draw.timing)
      .call(searchStyle)

    vars.container.search.select("input").transition().duration(vars.draw.timing)
      .call(inputStyle)

  }
  else {

    vars.container.search
      .call(searchStyle)

    vars.container.search.select("input")
      .call(inputStyle)

  }

  vars.container.search.enter()
    .insert("div","#d3plus_drop_list_"+vars.container.id)
      .attr("class","d3plus_drop_search")
      .attr("id","d3plus_drop_search_"+vars.container.id)
      .call(searchStyle)
      .append("input")
        .attr("id","d3plus_drop_input_"+vars.container.id)
        .style("-webkit-appearance","none")
        .call(inputStyle)

  vars.container.search.select("input").on("keyup."+vars.container.id,function(d){
    if (vars.text.solo[0] !== this.value) {
      vars.self.text({"solo":[this.value]})
      data( vars )
      items( vars )
      update( vars )
    }
  })

  vars.container.search.exit().remove()

  if ( vars.search.enabled ) {
    vars.margin.title += vars.container.search.node().offsetHeight || vars.container.search.node().getBoundingClientRect().height
  }

  if ( vars.dev.value ) d3plus.console.timeEnd("creating search")

}

},{"./data.js":undefined,"./items.js":undefined,"./update.js":undefined}],52:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates and styles the div that holds the search box and item list.
//------------------------------------------------------------------------------
module.exports = function ( vars ) {

  vars.container.selector = vars.container.ui
    .selectAll("div.d3plus_drop_selector")
    .data(["selector"])

  vars.container.selector.enter().append("div")
    .attr("class","d3plus_drop_selector")
    .style("position","absolute")
    .style("top","0px")
    .style("z-index","-1")
    .style("overflow","hidden")

    vars.container.selector
      .style("padding",vars.ui.border+"px")

}

},{}],53:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates and styles the title and back button.
//------------------------------------------------------------------------------
module.exports = function ( vars ) {

  if ( vars.open.value ) {

    if ( vars.dev.value ) d3plus.console.time("creating title and back button")

    var self    = this
      , enabled = vars.id.solo.value.length === 1 && vars.depth.value > 0
      , title   = enabled
      , focus   = vars.container.button.data(Object).app[0]

    title = true
    for (var i = 0; i < vars.id.nesting.length; i++) {
      var level = vars.id.nesting[i]
      if ( level in focus && focus[level] === vars.focus.value[0] ) {
        title = false
        break;
      }
    }

    vars.container.title = vars.container.selector.selectAll("div.d3plus_drop_title")
      .data(enabled ? ["title"] : [])

    function boxStyle(elem) {

      elem
        .style("padding",vars.ui.padding+"px")
        .style("display","block")
        .style("background-color",vars.ui.color.secondary.value)
        .style("font-family",vars.font.secondary.family.value)
        .style("font-size",vars.font.secondary.size+"px")
        .style("font-weight",vars.font.secondary.weight)
        .style("text-align",vars.font.secondary.align)
        .style("color",d3plus.color.text(vars.ui.color.secondary.value))

    }

    function backStyle(elem) {

      if ( !elem.empty() ) {

        var className = vars.icon.back.value.indexOf("fa-") === 0 ? " fa "+vars.icon.back.value : ""
        className = "d3plus_drop_back" + className

        var text = vars.icon.back.value.indexOf("fa-") === 0 ? "" : vars.icon.back.value

        elem
          .style("position","absolute")
          .attr("class",className)
          .style("top",vars.ui.padding+(vars.font.secondary.size/2)/2.5+"px")
          .html(text)

      }

    }

    function titleStyle(elem) {

      var text = title ? vars.focus.value.length : vars.format.locale.value.ui.back

      elem
        .text(vars.format.value(text))
        .style("padding","0px "+vars.ui.padding*2+"px")

    }

    if (vars.draw.timing) {

      vars.container.title.transition().duration(vars.draw.timing)
        .call(boxStyle)

      vars.container.title.select("div.d3plus_drop_title_text")
        .transition().duration(vars.draw.timing)
        .call(titleStyle)

    }
    else {

      vars.container.title
        .call(boxStyle)

      vars.container.title.select("div.d3plus_drop_title_text")
        .call(titleStyle)

    }

    vars.container.title.select("span.d3plus_drop_back")
      .call(backStyle)

    var enter = vars.container.title.enter()
      .insert("div","#d3plus_drop_list_"+vars.container.id)
        .attr("class","d3plus_drop_title")
        .attr("id","d3plus_drop_title_"+vars.container.id)
        .call(boxStyle)

    enter.append("span")
      .attr("id","d3plus_drop_back_"+vars.container.id)
      .attr("class","d3plus_drop_back")
      .call(backStyle)

    enter.append("div")
      .attr("id","d3plus_drop_title_text_"+vars.container.id)
      .attr("class","d3plus_drop_title_text")
      .call(titleStyle)

    vars.container.title
      .on(d3plus.evt.over,function(d,i){

        var color = d3plus.color.lighter(vars.ui.color.secondary.value)

        d3.select(this).style("cursor","pointer")
          .transition().duration(vars.timing.mouseevents)
          .style("background-color",color)
          .style("color",d3plus.color.text(color))

      })
      .on(d3plus.evt.out,function(d){

        var color = vars.ui.color.secondary.value

        d3.select(this).style("cursor","auto")
          .transition().duration(vars.timing.mouseevents)
          .style("background-color",color)
          .style("color",d3plus.color.text(color))

      })
      .on(d3plus.evt.click,function(d){
        vars.history.back()
      })

    vars.container.title.exit().remove()

    if ( enabled ) {
      vars.margin.title += vars.container.title.node().offsetHeight || vars.container.title.node().getBoundingClientRect().height
    }

    if ( vars.dev.value ) d3plus.console.timeEnd("creating title and back button")

  }

}

},{}],54:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Redraws only the drop down list.
//------------------------------------------------------------------------------
module.exports = function ( vars ) {

  var items = require("./items.js")
    , height = require("./height.js")
    , scrolllist = require("./scroll.js")
    , arrow = require("./arrow.js")

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // If the menu is open, set the container element's z-index to '9999'.
  //----------------------------------------------------------------------------
  if ( vars.draw.timing ) {

    vars.container.ui.transition().duration(vars.draw.timing)
      .each("start",function(){
        if (vars.open.value) {
          d3.select(this).style("z-index",9999)
        }
      })
      .style("margin",vars.ui.margin+"px")
      .each("end",function(){
        if (!vars.open.value) {
          d3.select(this).style("z-index","auto")
        }
      })

  }
  else {

    vars.container.ui
      .style("margin",vars.ui.margin+"px")
      .style("z-index",function(){
        if (vars.open.value) {
          return 9999
        }
        else {
          return "auto"
        }
      })

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Update list items based on filtered data.
  //----------------------------------------------------------------------------
  items( vars )

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Calculate the height and orientation of the dropdown list.
  //----------------------------------------------------------------------------
  height( vars )

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Calculate scroll position of dropdown menu.
  //----------------------------------------------------------------------------
  scrolllist( vars )

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Rotate the dropdown button arrow appropriately.
  //----------------------------------------------------------------------------
  arrow( vars )

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Update List
  //----------------------------------------------------------------------------
  if ( vars.dev.value ) d3plus.console.time("drawing list")

  function update(elem) {

    elem
      .style("left",function(){
        if (vars.font.align.value === "left") {
          return vars.margin.left+"px"
        }
        else if (vars.font.align.value === "center") {
          return vars.margin.left-((vars.width.secondary-vars.width.value)/2)+"px"
        }
        else {
          return "auto"
        }
      })
      .style("right",function(){
        return vars.font.align.value === "right" ? "0px" : "auto"
      })
      .style("height",vars.container.listHeight+"px")
      .style("padding",vars.ui.border+"px")
      .style("background-color",vars.ui.color.secondary.value)
      .style("z-index",function(){
        return vars.open.value ? "9999" : "-1";
      })
      .style("width",(vars.width.secondary-(vars.ui.border*2))+"px")
      .style("top",function(){
        return vars.open.flipped.value ? "auto" : vars.margin.top+"px"
      })
      .style("bottom",function(){
        return vars.open.flipped.value ? vars.margin.top+"px" : "auto"
      })
      .style("opacity",vars.open.value ? 1 : 0)

  }

  function finish(elem) {

    elem
      .style("top",function(){
        return vars.open.flipped.value ? "auto" : vars.margin.top+"px"
      })
      .style("bottom",function(){
        return vars.open.flipped.value ? vars.margin.top+"px" : "auto"
      })
      .style("display",!vars.open.value ? "none" : null)

    if (vars.search.enabled && vars.open.value) {
      vars.container.selector.select("div.d3plus_drop_search input").node().focus()
    }

  }

  var max_height = vars.open.value ? vars.height.secondary-vars.margin.title : 0

  if (!vars.draw.timing) {

    vars.container.selector.call(update).call(finish)

    vars.container.list
      .style("width",vars.width.secondary-vars.ui.border*2+"px")
      .style("max-height",max_height+"px")
      .property("scrollTop",vars.container.listScroll)

  }
  else {
    vars.container.selector.transition().duration(vars.draw.timing)
      .each("start",function(){
        d3.select(this)
          .style("display",vars.open.value ? "block" : null)
      })
      .call(update)
      .each("end",function(){

        d3.select(this).transition().duration(vars.draw.timing)
          .call(finish)

      })

    function scrollTopTween(scrollTop) {
        return function() {
            var i = d3.interpolateNumber(this.scrollTop, scrollTop);
            return function(t) { this.scrollTop = i(t); };
        };
    }

    vars.container.list.transition().duration(vars.draw.timing)
      .style("width",vars.width.secondary-vars.ui.border*2+"px")
      .style("max-height",max_height+"px")
      .tween("scroll",scrollTopTween(vars.container.listScroll))
  }

  if ( vars.dev.value ) d3plus.console.timeEnd("drawing list")

}

},{"./arrow.js":undefined,"./height.js":undefined,"./items.js":undefined,"./scroll.js":undefined}],55:[function(require,module,exports){
var fontTester = require("../../../../core/font/tester.coffee")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// If no widths are defined, then this calculates the width needed to fit the
// longest entry in the list.
//------------------------------------------------------------------------------
module.exports = function ( vars ) {

  var data = [], buffer = 0
  for ( var level in vars.data.nested.all ) {
    var newData = vars.data.nested.all[level]
      , key     = d3plus.object.validate(vars.text.nesting) && level in vars.text.nesting
                ? vars.text.nesting[level][0] : level

    if ( [vars.id.value,vars.text.value].indexOf(key) < 0 ) {
      newData = d3plus.util.copy(newData)
      newData.forEach(function(d){
        d[vars.text.value || vars.id.value] = d[key]
      })
    }
    data = data.concat( newData )
  }

  function getWidth( type ) {

    var key  = type === "primary" ? "value" : type
      , icon = key === "value" ? vars.icon.drop.value
             : vars.icon.select.value || vars.icon.drop.value
      , text = key === "value" ? vars.text.value
             : vars.text.secondary.value || vars.text.value
      , font = key === "value" ? vars.font : vars.font.secondary

    if ( vars.dev.value ) d3plus.console.time("calculating "+type+" width")

    var button = d3plus.form()
      .container( fontTester() )
      .data({
        "large": 9999,
        "value": data
      })
      .draw({ "update": false })
      .font( font )
      .icon({ "button": icon, "value": vars.icon.value })
      .id(vars.id.value)
      .timing({
        "ui": 0
      })
      .text( text || vars.id.value )
      .type( "button" )
      .ui({
        "border": type === "primary" ? vars.ui.border : 0,
        "display": "inline-block",
        "margin": 0,
        "padding": vars.ui.padding
      })
      .width(false)
      .draw()

    var w = []
    button.selectAll("div.d3plus_node").each(function(o){
      w.push(this.offsetWidth)
    }).remove()

    var dropWidth = {}
    dropWidth[key] = d3.max(w)

    vars.self.width( dropWidth )

    if ( vars.dev.value ) d3plus.console.timeEnd("calculating "+type+" width")

  }

  if ( typeof vars.width.value !== "number" ) {

    getWidth( "primary" )

  }

  if ( typeof vars.width.secondary !== "number" ) {

    if ( !vars.text.secondary.value || vars.text.value === vars.text.secondary.value ) {
      vars.self.width({"secondary": vars.width.value})
    }
    else {
      getWidth( "secondary" )
    }

  }

}

},{"../../../../core/font/tester.coffee":undefined}],56:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Recursive function that applies a click event to all parent windows that
// will close the dropdown if it is open.
//------------------------------------------------------------------------------
var windowEvents = function ( vars , elem ) {

  if ( elem === undefined ) {
    var elem = window
  }

  d3.select(elem).on("click."+vars.container.id,function(){

    var element = d3.event.target || d3.event.toElement
      , parent  = element.parentNode

    if ( parent && ["d3plus_node","d3plus_drop_title"].indexOf(parent.className) >= 0 ) {
      element = parent.parentNode
    }

    if (element && parent && !d3plus.util.child(vars.container.ui, element) && vars.open.value) {
      vars.self.open(!vars.open.value).draw()
    }

  })

  try {
    var same_origin = window.parent.location.host === window.location.host;
  }
  catch (e) {
    var same_origin = false
  }

  if (same_origin) {
    if (elem.self !== window.top) {
      windowEvents( vars , elem.parent )
    }
  }

}

module.exports = windowEvents

},{}],57:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates a set of Toggle Buttons
//------------------------------------------------------------------------------
module.exports = function( vars ) {

  if ( !("buttons" in vars.container) ) {

    vars.container.buttons = d3plus.form()
      .container(vars.container.ui)
      .type("button")

  }

  var dataLength  = vars.data.app.length
    , buttonWidth = vars.width.value
                  ? vars.width.value/dataLength
                  : false

  var toggles = vars.container.ui.selectAll("div.d3plus_toggle")
    .data(vars.data.app,function(d){
      return d[vars.id.value]
    })

  toggles.enter().append("div")
    .attr("class","d3plus_toggle")
    .style("display","inline-block")
    .style("vertical-align","top")

  toggles.order()
    .each(function(d){

      if (!("form" in d.d3plus)) {
        d.d3plus.form = d3plus.form()
          .container(d3.select(this))
      }

      var id = vars.id.nesting.length > vars.depth.value ? vars.id.nesting[vars.depth.value+1] : vars.id.value

      if (d[id] instanceof Array) {
        d.d3plus.form
          .container({"id": vars.container.id+"_"+d[vars.id.value]})
          .data(d[id])
          .id(vars.id.nesting.slice(1))
          .type("drop")
      }
      else {
        d.d3plus.form
          .data([d])
          .id(vars.id.value)
          .type("button")
      }

      d.d3plus.form
        .color(vars.color)
        .focus(vars.focus.value[0],function(value){

          if (value[0] !== vars.focus.value[0]) {
            vars.self.focus(value[0]).draw()
          }

        })
        .icon({
          "select": false,
          "value": vars.icon.value
        })
        .font(vars.font)
        .format(vars.format)
        .order(vars.order)
        .text(vars.text.value)
        .ui({
          "border": vars.ui.border,
          "color": vars.ui.color,
          "display": "inline-block",
          "margin": 0,
          "padding": vars.ui.padding
        })
        .width(buttonWidth)
        .draw()

    })

}

},{}],58:[function(require,module,exports){
var wiki;

wiki = require("./wiki.coffee");

d3plus.console = function(type, message, style) {
  style = style || "";
  if (d3plus.ie || typeof InstallTrigger !== 'undefined') {
    console.log("[ D3plus ] " + message);
  } else if (type === "groupCollapsed") {
    if (window.chrome && navigator.onLine) {
      console[type]("%c%c " + message, "padding:3px 10px;line-height:25px;background-size:20px;background-position:top left;background-image:url('http://d3plus.org/assets/img/favicon.ico');", "font-weight:200;" + style);
    } else {
      console[type]("%cD3plus%c " + message, "line-height:25px;font-weight:800;color:#b35c1e;margin-left:0px;", "font-weight:200;" + style);
    }
  } else {
    console[type]("%c" + message, style + "font-weight:200;");
  }
};

d3plus.console.comment = function(message) {
  this("log", message, "color:#aaa;");
};

d3plus.console.error = function(message, url) {
  this("groupCollapsed", "ERROR: " + message, "font-weight:800;color:#D74B03;");
  this.stack();
  this.wiki(url);
  this.groupEnd();
};

d3plus.console.group = function(message) {
  this("group", message, "color:#888;");
};

d3plus.console.groupCollapsed = function(message) {
  this("groupCollapsed", message, "color:#888;");
};

d3plus.console.groupEnd = function() {
  if (!d3plus.ie) {
    console.groupEnd();
  }
};

d3plus.console.log = function(message) {
  this("log", message, "color:#444444;");
};

d3plus.console.stack = function() {
  var err, line, message, page, splitter, stack, url;
  if (!d3plus.ie) {
    err = new Error();
    if (err.stack) {
      stack = err.stack.split("\n");
      stack = stack.filter(function(e) {
        return e.indexOf("Error") !== 0 && e.indexOf("d3plus.js:") < 0 && e.indexOf("d3plus.min.js:") < 0;
      });
      if (stack.length) {
        splitter = (window.chrome ? "at " : "@");
        url = stack[0].split(splitter)[1];
        stack = url.split(":");
        if (stack.length === 3) {
          stack.pop();
        }
        line = stack.pop();
        page = stack.join(":").split("/");
        page = page[page.length - 1];
        message = "line " + line + " of " + page + ": " + url;
        this("log", message, "color:#D74B03;");
      }
    }
  }
};

d3plus.console.time = function(message) {
  if (!d3plus.ie) {
    console.time(message);
  }
};

d3plus.console.timeEnd = function(message) {
  if (!d3plus.ie) {
    console.timeEnd(message);
  }
};

d3plus.console.warning = function(message, url) {
  this("groupCollapsed", message, "color:#888;");
  this.stack();
  this.wiki(url);
  this.groupEnd();
};

d3plus.console.wiki = function(url) {
  if (url) {
    if (url in wiki) {
      url = d3plus.repo + "wiki/" + wiki[url];
    }
    this("log", "documentation: " + url, "color:#aaa;");
  }
};

module.exports = d3plus.console;


},{"./wiki.coffee":undefined}],59:[function(require,module,exports){

/**
 * Creates custom mouse events based on IE and Touch Devices.
 */
d3plus.touch = ("ontouchstart" in window) || window.DocumentTouch && document instanceof DocumentTouch ? true : false;

if (d3plus.touch) {
  d3plus.evt = {
    click: "click",
    down: "touchstart",
    up: "touchend",
    over: "touchstart",
    out: "touchend",
    move: "touchmove"
  };
} else {
  d3plus.evt = {
    click: "click",
    down: "mousedown",
    up: "mouseup",
    over: d3plus.ie ? "mouseenter" : "mouseover",
    out: d3plus.ie ? "mouseleave" : "mouseout",
    move: "mousemove"
  };
}


},{}],60:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Determines if the current browser is Internet Explorer.
//------------------------------------------------------------------------------
d3plus.ie = /*@cc_on!@*/false

},{}],61:[function(require,module,exports){

/**
 * Calculates the correct CSS vendor prefix based on the current browser.
 */
d3plus.prefix = function() {
  var val;
  if ("-webkit-transform" in document.body.style) {
    val = "-webkit-";
  } else if ("-moz-transform" in document.body.style) {
    val = "-moz-";
  } else if ("-ms-transform" in document.body.style) {
    val = "-ms-";
  } else if ("-o-transform" in document.body.style) {
    val = "-o-";
  } else {
    val = "";
  }
  d3plus.prefix = function() {
    return val;
  };
  return val;
};


},{}],62:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Detects right-to-left text direction on the page.
//------------------------------------------------------------------------------
d3plus.rtl = d3.select("html").attr("dir") == "rtl"

},{}],63:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Detects scrollbar width for current browser.
//------------------------------------------------------------------------------
d3plus.scrollbar = function() {

  var inner = document.createElement("p");
  inner.style.width = "100%";
  inner.style.height = "200px";

  var outer = document.createElement("div");
  outer.style.position = "absolute";
  outer.style.top = "0px";
  outer.style.left = "0px";
  outer.style.visibility = "hidden";
  outer.style.width = "200px";
  outer.style.height = "150px";
  outer.style.overflow = "hidden";
  outer.appendChild(inner);

  document.body.appendChild(outer);
  var w1 = inner.offsetWidth;
  outer.style.overflow = "scroll";
  var w2 = inner.offsetWidth;
  if (w1 == w2) w2 = outer.clientWidth;

  document.body.removeChild(outer);

  var val = (w1 - w2)

  d3plus.scrollbar = function(){
    return val
  }

  return val;

}

},{}],64:[function(require,module,exports){
d3plus.wiki = {
  active: "Segmenting-Data#active",
  aggs: "Custom-Aggregations",
  alt: "Alt-Text-Parameters",
  attrs: "Attribute-Data#axes",
  axes: "Axis-Parameters",
  background: "Background",
  color: "Color-Parameters",
  container: "Container-Element",
  coords: "Geography-Data",
  csv: "CSV-Export",
  data: "Data-Points",
  depth: "Visible-Depth",
  descs: "Value-Definitions",
  dev: "Verbose-Mode",
  draw: "Draw",
  edges: "Edges-List",
  error: "Custom-Error-Message",
  focus: "Focus-Element",
  font: "Font-Styles",
  footer: "Custom-Footer",
  format: "Value-Formatting",
  height: "Height",
  history: "User-History",
  hover: "Hover-Element",
  icon: "Icon-Parameters",
  id: "Unique-ID",
  keywords: "Keyword-Parameters",
  labels: "Data-Labels",
  legend: "Legend",
  links: "Link-Styles",
  margin: "Outer-Margins",
  messages: "Status-Messages",
  method: "Methods",
  nodes: "Node-Positions",
  open: "Open",
  order: "Data-Ordering",
  remove: "Remove",
  search: "Search-Box",
  select: "Selecting-Elements#select",
  selectAll: "Selecting-Elements#selectall",
  shape: "Data-Shapes",
  size: "Size-Parameters",
  temp: "Segmenting-Data#temp",
  text: "Text-Parameters",
  time: "Time-Parameters",
  timeline: "Timeline",
  timing: "Animation-Timing",
  title: "Custom-Titles",
  tooltip: "Tooltip-Parameters",
  total: "Segmenting-Data#total",
  type: "Output-Type",
  ui: "Custom-Interface",
  width: "Width",
  x: "Axis-Parameters",
  y: "Axis-Parameters",
  zoom: "Zooming"
};

module.exports = d3plus.wiki;


},{}],65:[function(require,module,exports){
var intersectPoints, lineIntersection, pointInPoly, pointInSegmentBox, polyInsidePoly, rayIntersectsSegment, rotatePoint, rotatePoly, segmentsIntersect, simplify, squaredDist;

simplify = require('simplify-js');

d3plus.geom.largestRect = function(poly, options) {
  var aRatio, aRatios, angle, angleRad, angleStep, angles, area, aspectRatioStep, aspectRatios, bBox, boxHeight, boxWidth, centroid, events, height, i, insidePoly, left, maxArea, maxAspectRatio, maxHeight, maxRect, maxWidth, maxx, maxy, minAspectRatio, minSqDistH, minSqDistW, minx, miny, modifOrigins, origOrigin, origin, origins, p, p1H, p1W, p2H, p2W, rectPoly, right, rndPoint, rndX, rndY, tempPoly, tolerance, width, widthStep, x0, y0, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
  if (poly.length < 3) {
    d3plus.console.error('polygon has to have at least 3 points');
    return null;
  }
  events = [];
  aspectRatioStep = 0.5;
  angleStep = 5;
  if (options == null) {
    options = {};
  }
  if (options.maxAspectRatio == null) {
    options.maxAspectRatio = 15;
  }
  if (options.minWidth == null) {
    options.minWidth = 0;
  }
  if (options.minHeight == null) {
    options.minHeight = 0;
  }
  if (options.tolerance == null) {
    options.tolerance = 0.02;
  }
  if (options.nTries == null) {
    options.nTries = 20;
  }
  if (options.angle != null) {
    if (options.angle instanceof Array) {
      angles = options.angle;
    } else if (typeof options.angle === 'number') {
      angles = [options.angle];
    } else if (typeof options.angle === 'string' && !isNaN(options.angle)) {
      angles = [Number(options.angle)];
    }
  }
  if (angles == null) {
    angles = d3.range(-90, 90 + angleStep, angleStep);
  }
  if (options.aspectRatio != null) {
    if (options.aspectRatio instanceof Array) {
      aspectRatios = options.aspectRatio;
    } else if (typeof options.aspectRatio === 'number') {
      aspectRatios = [options.aspectRatio];
    } else if (typeof options.aspectRatio === 'string' && !isNaN(options.aspectRatio)) {
      aspectRatios = [Number(options.aspectRatio)];
    }
  }
  if (options.origin != null) {
    if (options.origin instanceof Array) {
      if (options.origin[0] instanceof Array) {
        origins = options.origin;
      } else {
        origins = [options.origin];
      }
    }
  }
  area = Math.abs(d3.geom.polygon(poly).area());
  if (area === 0) {
    d3plus.console.error('polygon has 0 area');
    return null;
  }
  _ref = d3.extent(poly, function(d) {
    return d[0];
  }), minx = _ref[0], maxx = _ref[1];
  _ref1 = d3.extent(poly, function(d) {
    return d[1];
  }), miny = _ref1[0], maxy = _ref1[1];
  tolerance = Math.min(maxx - minx, maxy - miny) * options.tolerance;
  tempPoly = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = poly.length; _i < _len; _i++) {
      p = poly[_i];
      _results.push({
        x: p[0],
        y: p[1]
      });
    }
    return _results;
  })();
  if (tolerance > 0) {
    tempPoly = simplify(tempPoly, tolerance);
    poly = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = tempPoly.length; _i < _len; _i++) {
        p = tempPoly[_i];
        _results.push([p.x, p.y]);
      }
      return _results;
    })();
  }
  if (options.vdebug) {
    events.push({
      type: 'simplify',
      poly: poly
    });
  }
  _ref2 = d3.extent(poly, function(d) {
    return d[0];
  }), minx = _ref2[0], maxx = _ref2[1];
  _ref3 = d3.extent(poly, function(d) {
    return d[1];
  }), miny = _ref3[0], maxy = _ref3[1];
  bBox = [[minx, miny], [maxx, miny], [maxx, maxy], [minx, maxy]];
  _ref4 = [maxx - minx, maxy - miny], boxWidth = _ref4[0], boxHeight = _ref4[1];
  widthStep = Math.min(boxWidth, boxHeight) / 50;
  if (origins == null) {
    origins = [];
    centroid = d3.geom.polygon(poly).centroid();
    if (pointInPoly(centroid, poly)) {
      origins.push(centroid);
    }
    while (origins.length < options.nTries) {
      rndX = Math.random() * boxWidth + minx;
      rndY = Math.random() * boxHeight + miny;
      rndPoint = [rndX, rndY];
      if (pointInPoly(rndPoint, poly)) {
        origins.push(rndPoint);
      }
    }
  }
  if (options.vdebug) {
    events.push({
      type: 'origins',
      points: origins
    });
  }
  maxArea = 0;
  maxRect = null;
  for (_i = 0, _len = angles.length; _i < _len; _i++) {
    angle = angles[_i];
    angleRad = -angle * Math.PI / 180;
    if (options.vdebug) {
      events.push({
        type: 'angle',
        angle: angle
      });
    }
    for (i = _j = 0, _len1 = origins.length; _j < _len1; i = ++_j) {
      origOrigin = origins[i];
      _ref5 = intersectPoints(poly, origOrigin, angleRad), p1W = _ref5[0], p2W = _ref5[1];
      _ref6 = intersectPoints(poly, origOrigin, angleRad + Math.PI / 2), p1H = _ref6[0], p2H = _ref6[1];
      modifOrigins = [];
      if ((p1W != null) && (p2W != null)) {
        modifOrigins.push([(p1W[0] + p2W[0]) / 2, (p1W[1] + p2W[1]) / 2]);
      }
      if ((p1H != null) && (p2H != null)) {
        modifOrigins.push([(p1H[0] + p2H[0]) / 2, (p1H[1] + p2H[1]) / 2]);
      }
      if (options.vdebug) {
        events.push({
          type: 'modifOrigin',
          idx: i,
          p1W: p1W,
          p2W: p2W,
          p1H: p1H,
          p2H: p2H,
          modifOrigins: modifOrigins
        });
      }
      for (_k = 0, _len2 = modifOrigins.length; _k < _len2; _k++) {
        origin = modifOrigins[_k];
        if (options.vdebug) {
          events.push({
            type: 'origin',
            cx: origin[0],
            cy: origin[1]
          });
        }
        _ref7 = intersectPoints(poly, origin, angleRad), p1W = _ref7[0], p2W = _ref7[1];
        minSqDistW = Math.min(squaredDist(origin, p1W), squaredDist(origin, p2W));
        maxWidth = 2 * Math.sqrt(minSqDistW);
        _ref8 = intersectPoints(poly, origin, angleRad + Math.PI / 2), p1H = _ref8[0], p2H = _ref8[1];
        minSqDistH = Math.min(squaredDist(origin, p1H), squaredDist(origin, p2H));
        maxHeight = 2 * Math.sqrt(minSqDistH);
        if (maxWidth * maxHeight < maxArea) {
          continue;
        }
        if (aspectRatios != null) {
          aRatios = aspectRatios;
        } else {
          minAspectRatio = Math.max(1, options.minWidth / maxHeight, maxArea / (maxHeight * maxHeight));
          maxAspectRatio = Math.min(options.maxAspectRatio, maxWidth / options.minHeight, (maxWidth * maxWidth) / maxArea);
          aRatios = d3.range(minAspectRatio, maxAspectRatio + aspectRatioStep, aspectRatioStep);
        }
        for (_l = 0, _len3 = aRatios.length; _l < _len3; _l++) {
          aRatio = aRatios[_l];
          left = Math.max(options.minWidth, Math.sqrt(maxArea * aRatio));
          right = Math.min(maxWidth, maxHeight * aRatio);
          if (right * maxHeight < maxArea) {
            continue;
          }
          if ((right - left) >= widthStep) {
            if (options.vdebug) {
              events.push({
                type: 'aRatio',
                aRatio: aRatio
              });
            }
          }
          while ((right - left) >= widthStep) {
            width = (left + right) / 2;
            height = width / aRatio;
            x0 = origin[0], y0 = origin[1];
            rectPoly = [[x0 - width / 2, y0 - height / 2], [x0 + width / 2, y0 - height / 2], [x0 + width / 2, y0 + height / 2], [x0 - width / 2, y0 + height / 2]];
            rectPoly = rotatePoly(rectPoly, angleRad, origin);
            if (polyInsidePoly(rectPoly, poly)) {
              insidePoly = true;
              maxArea = width * height;
              maxRect = {
                cx: x0,
                cy: y0,
                width: width,
                height: height,
                angle: angle
              };
              left = width;
            } else {
              insidePoly = false;
              right = width;
            }
            if (options.vdebug) {
              events.push({
                type: 'rectangle',
                cx: x0,
                cy: y0,
                width: width,
                height: height,
                areaFraction: (width * height) / area,
                angle: angle,
                insidePoly: insidePoly
              });
            }
          }
        }
      }
    }
  }
  return [maxRect, maxArea, events];
};

squaredDist = function(a, b) {
  var deltax, deltay;
  deltax = b[0] - a[0];
  deltay = b[1] - a[1];
  return deltax * deltax + deltay * deltay;
};

rayIntersectsSegment = function(p, p1, p2) {
  var a, b, mAB, mAP, _ref;
  _ref = p1[1] < p2[1] ? [p1, p2] : [p2, p1], a = _ref[0], b = _ref[1];
  if (p[1] === b[1] || p[1] === a[1]) {
    p[1] += Number.MIN_VALUE;
  }
  if (p[1] > b[1] || p[1] < a[1]) {
    return false;
  } else if (p[0] > a[0] && p[0] > b[0]) {
    return false;
  } else if (p[0] < a[0] && p[0] < b[0]) {
    return true;
  } else {
    mAB = (b[1] - a[1]) / (b[0] - a[0]);
    mAP = (p[1] - a[1]) / (p[0] - a[0]);
    return mAP > mAB;
  }
};

pointInPoly = function(p, poly) {
  var a, b, c, i, n;
  i = -1;
  n = poly.length;
  b = poly[n - 1];
  c = 0;
  while (++i < n) {
    a = b;
    b = poly[i];
    if (rayIntersectsSegment(p, a, b)) {
      c++;
    }
  }
  return c % 2 !== 0;
};

pointInSegmentBox = function(p, p1, q1) {
  var eps, px, py;
  eps = 1e-9;
  px = p[0], py = p[1];
  if (px < Math.min(p1[0], q1[0]) - eps || px > Math.max(p1[0], q1[0]) + eps || py < Math.min(p1[1], q1[1]) - eps || py > Math.max(p1[1], q1[1]) + eps) {
    return false;
  }
  return true;
};

lineIntersection = function(p1, q1, p2, q2) {
  var cross1, cross2, denom, dx1, dx2, dy1, dy2, eps, px, py;
  eps = 1e-9;
  dx1 = p1[0] - q1[0];
  dy1 = p1[1] - q1[1];
  dx2 = p2[0] - q2[0];
  dy2 = p2[1] - q2[1];
  denom = dx1 * dy2 - dy1 * dx2;
  if (Math.abs(denom) < eps) {
    return null;
  }
  cross1 = p1[0] * q1[1] - p1[1] * q1[0];
  cross2 = p2[0] * q2[1] - p2[1] * q2[0];
  px = (cross1 * dx2 - cross2 * dx1) / denom;
  py = (cross1 * dy2 - cross2 * dy1) / denom;
  return [px, py];
};

segmentsIntersect = function(p1, q1, p2, q2) {
  var p;
  p = lineIntersection(p1, q1, p2, q2);
  if (p == null) {
    return false;
  }
  return pointInSegmentBox(p, p1, q1) && pointInSegmentBox(p, p2, q2);
};

polyInsidePoly = function(polyA, polyB) {
  var aA, aB, bA, bB, iA, iB, nA, nB;
  iA = -1;
  nA = polyA.length;
  nB = polyB.length;
  bA = polyA[nA - 1];
  while (++iA < nA) {
    aA = bA;
    bA = polyA[iA];
    iB = -1;
    bB = polyB[nB - 1];
    while (++iB < nB) {
      aB = bB;
      bB = polyB[iB];
      if (segmentsIntersect(aA, bA, aB, bB)) {
        return false;
      }
    }
  }
  return pointInPoly(polyA[0], polyB);
};

rotatePoint = function(p, alpha, origin) {
  var cosAlpha, sinAlpha, xshifted, yshifted;
  if (origin == null) {
    origin = [0, 0];
  }
  xshifted = p[0] - origin[0];
  yshifted = p[1] - origin[1];
  cosAlpha = Math.cos(alpha);
  sinAlpha = Math.sin(alpha);
  return [cosAlpha * xshifted - sinAlpha * yshifted + origin[0], sinAlpha * xshifted + cosAlpha * yshifted + origin[1]];
};

rotatePoly = function(poly, alpha, origin) {
  var point, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = poly.length; _i < _len; _i++) {
    point = poly[_i];
    _results.push(rotatePoint(point, alpha, origin));
  }
  return _results;
};

intersectPoints = function(poly, origin, alpha) {
  var a, b, closestPointLeft, closestPointRight, eps, i, idx, minSqDistLeft, minSqDistRight, n, p, shiftedOrigin, sqDist, x0, y0;
  eps = 1e-9;
  origin = [origin[0] + eps * Math.cos(alpha), origin[1] + eps * Math.sin(alpha)];
  x0 = origin[0], y0 = origin[1];
  shiftedOrigin = [x0 + Math.cos(alpha), y0 + Math.sin(alpha)];
  idx = 0;
  if (Math.abs(shiftedOrigin[0] - x0) < eps) {
    idx = 1;
  }
  i = -1;
  n = poly.length;
  b = poly[n - 1];
  minSqDistLeft = Number.MAX_VALUE;
  minSqDistRight = Number.MAX_VALUE;
  closestPointLeft = null;
  closestPointRight = null;
  while (++i < n) {
    a = b;
    b = poly[i];
    p = lineIntersection(origin, shiftedOrigin, a, b);
    if ((p != null) && pointInSegmentBox(p, a, b)) {
      sqDist = squaredDist(origin, p);
      if (p[idx] < origin[idx]) {
        if (sqDist < minSqDistLeft) {
          minSqDistLeft = sqDist;
          closestPointLeft = p;
        }
      } else if (p[idx] > origin[idx]) {
        if (sqDist < minSqDistRight) {
          minSqDistRight = sqDist;
          closestPointRight = p;
        }
      }
    }
  }
  return [closestPointLeft, closestPointRight];
};


},{"simplify-js":242}],66:[function(require,module,exports){
var d3plus, message, stylesheet;

d3plus = window.d3plus || {};

window.d3plus = d3plus;

d3plus.version = "1.5.0 - Aqua";

d3plus.repo = "https://github.com/alexandersimoes/d3plus/";

d3plus.array = {};

d3plus.color = {};

d3plus.data = {};

d3plus.draw = {};

d3plus.font = {};

d3plus.geom = {};

d3plus.locale = {};

d3plus.method = {};

d3plus.network = {};

d3plus.number = {};

d3plus.object = {};

d3plus.shape = {};

d3plus.string = {};

d3plus.style = {};

d3plus.tooltip = {};

d3plus.ui = {};

d3plus.util = {};

d3plus.zoom = {};

stylesheet = require("./style/sheet.coffee");

message = require("./general/console.coffee");

if (stylesheet("d3plus.css")) {
  message.warning("d3plus.css has been deprecated, you do not need to load this file.", "https://github.com/alexandersimoes/d3plus/releases/tag/v1.4.0");
}


},{"./general/console.coffee":undefined,"./style/sheet.coffee":undefined}],67:[function(require,module,exports){

},{}],68:[function(require,module,exports){
d3plus.locale.en_US = {

  "dev"          : {

    "accepted"     : "{0} is not an accepted value for {1}, please use one of the following: {2}.",
    "deprecated"   : "the {0} method has been removed, please update your code to use {1}.",
    "noChange"     : "{0} was not updated because it did not change.",
    "noContainer"  : "cannot find a container on the page matching {0}.",
    "of"           : "of",
    "oldStyle"     : "style properties for {0} have now been embedded directly into .{1}().",
    "sameEdge"     : "edges cannot link to themselves. automatically removing self-referencing edge {0}.",
    "set"          : "{0} has been set.",
    "setLong"      : "{0} has been set to {1}.",
    "setContainer" : "please define a container div using .container()"

  },

  "error"        : {

    "accepted"     : "{0} is not an accepted {1} for {2} visualizations, please use one of the following: {3}.",
    "connections"  : "no connections available for {0}.",
    "data"         : "no data available",
    "dataYear"     : "no data available for {0}.",
    "lib"          : "{0} visualizations require loading the {1} library.",
    "libs"         : "{0} visualizations require loading the following libraries: {1}.",
    "method"       : "{0} visualizations require setting the {1} method.",
    "methods"      : "{0} visualizations require setting the following methods: {1}."

  },

  "format"       : {
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["$", ""],
    dateTime: "%A, %B %-d, %Y %X",
    date: "%-m/%-d/%Y",
    time: "%I:%M:%S %p",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  },

  "lowercase"    : [ "a"
                   , "and"
                   , "at"
                   , "but"
                   , "in"
                   , "of"
                   , "or"
                   , "the"
                   , "to"
                   , "with"
  ],

  "message"      : {

    "data"         : "analyzing data",
    "draw"         : "drawing visualization",
    "initializing" : "initializing {0}",
    "loading"      : "loading data",
    "tooltipReset" : "resetting tooltips",
    "ui"           : "updating ui"

  },

  "method"       : {

    "active"       : "active segments",
    "color"        : "color",
    "depth"        : "depth",
    "dev"          : "verbose",
    "focus"        : "focus",
    "icon"         : "icon",
    "id"           : "id",
    "height"       : "height",
    "labels"       : "labels",
    "legend"       : "legend",
    "margin"       : "margin",
    "messages"     : "status messages",
    "mode"         : "mode",
    "order"        : "order",
    "search"       : "search",
    "shape"        : "shape",
    "size"         : "size",
    "style"        : "style",
    "temp"         : "temporary segments",
    "text"         : "text",
    "time"         : "time",
    "timeline"     : "timeline",
    "total"        : "total segments",
    "type"         : "type",
    "width"        : "width",
    "x"            : "x axis",
    "y"            : "y axis",
    "zoom"         : "zoom"

  },

  "time"         : [ "date"
                   , "day"
                   , "month"
                   , "time"
                   , "year"

  ],

  "timeFormat": {
    "FullYear": "%Y",
    "Month": "%B",
    "MonthSmall": "%b",
    "Date": "%A %-d",
    "DateSmall": "%-d",
    "Hours": "%I %p",
    "Minutes": "%I:%M",
    "Seconds": "%Ss",
    "Milliseconds": "%Lms",
    "FullYear-Month": "%b %Y",
    "FullYear-Date": "%-m/%-d/%Y",
    "Month-Date": "%b %-d",
    "Hours-Minutes": "%I:%M %p",
    "Hours-Seconds": "%I:%M:%S %p",
    "Hours-Milliseconds": "%H:%M:%S.%L"
  },

  "ui"           : {

    "and"          : "and",
    "back"         : "back",
    "collapse"     : "click to collapse",
    "error"        : "error",
    "expand"       : "click to expand",
    "including"    : "including",
    "loading"      : "loading...",
    "more"         : "{0} more",
    "moreInfo"     : "click for more info",
    "noResults"    : "no results matching {0}.",
    "primary"      : "primary connections",
    "share"        : "share",
    "total"        : "total",
    "values"       : "values"

  },

  "uppercase"    : [ "tv"
                   , "ui"
  ],

  "visualization": {

    "bubbles"      : "Bubbles",
    "chart"        : "Chart",
    "geo_map"      : "Geo Map",
    "line"         : "Line Plot",
    "network"      : "Network",
    "rings"        : "Rings",
    "scatter"      : "Scatter Plot",
    "stacked"      : "Stacked Area",
    "tree_map"     : "Tree Map"

  }

}

},{}],69:[function(require,module,exports){
d3plus.locale.mk_MK = {
    "dev": {
        "accepted": "{0}   a   {1},    a   : {2}.",
        "deprecated": "{0}   ,           {1}.",
        "noChange": "{0}   ,   .",
        "noContainer": " e           {0}.",
        "of": "",
        "oldStyle": "    {0}     . {1} ().",
        "sameEdge": "        .       - {0}.",
        "set": "{0}  .",
        "setLong": "{0}    {1}.",
        "setContainer": "    div  .container()"
    },
    "error": {
        "accepted": "{0}     {1} {2} ,      : {3}.",
        "connections": "     {0}.",
        "data": " ",
        "dataYear": "    {0}.",
        "lib": "{0}      {1} .",
        "libs": "{0}      : {1}.",
        "method": "{0}     {1} .",
        "methods": "{0}      : {1}."
    },
    "format": {
        decimal: ",",
        thousands: ".",
        grouping: [3],
        currency: ["", " ."],
        dateTime: "%A, %e %B %Y . %X",
        date: "%d.%m.%Y",
        time: "%H:%M:%S",
        periods: ["AM", "PM"],
        days: ["", "", "", "", "", "", ""],
        shortDays: ["", "", "", "", "", "", ""],
        months: ["", "", "", "", "", "", "", "", "", "", "", ""],
        shortMonths: ["", "", "", "", "", "", "", "", "", "", "", ""]
    },
    "lowercase": [
        "a",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
    ],
    "method": {
        "active": " ",
        "color": "",
        "depth": "",
        "dev": "",
        "focus": "",
        "icon": "",
        "id": "ID",
        "height": "",
        "labels": "",
        "legend": "",
        "margin": "",
        "messages": "  ",
        "order": "",
        "search": "",
        "shape": "",
        "size": "",
        "style": "",
        "temp": " ",
        "text": "",
        "time": "",
        "timeline": "",
        "total": " ",
        "type": "",
        "width": "",
        "x": "x ",
        "y": "y ",
        "zoom": "",
        "mode": ""
    },
    "time": [
        "",
        "",
        "",
        "",
        ""
    ],
    "visualization": {
        "bubbles": "",
        "chart": "",
        "geo_map": " ",
        "line": " ",
        "network": "",
        "rings": "",
        "scatter": " ",
        "stacked": " ",
        "tree_map": "    "
    },
    "ui": {
        "and": "",
        "back": "",
        "collapse": "    ",
        "error": "",
        "expand": "    ",
        "loading": "  ...",
        "more": "{0} ",
        "moreInfo": "   ",
        "noResults": "     {0}.",
        "primary": " ",
        "share": "",
        "total": "",
        "values": "",
        "including": ""
    },
    "message": {
        "data": "  ",
        "draw": "  ",
        "initializing": " {0}",
        "loading": "  ",
        "tooltipReset": "  ",
        "ui": "   "
    },
    "uppercase": [
        "TV",
        "UI"
    ]
}

},{}],70:[function(require,module,exports){
d3plus.locale.pt_BR = {
    "dev": {
        "accepted": "{0} no  um valor aceito para {1}, por favor, use um dos seguintes procedimentos: {2}.",
        "deprecated": "{0} mtodo foi removido, por favor atualize seu cdigo para utilizar {1}.",
        "noChange": "{0} no foi atualizado porque ele no mudou.",
        "noContainer": "No foi possvel encontrar um local na pgina correspondente a {0}.",
        "of": "de",
        "oldStyle": "propriedades de estilo para {0} j foram incorporados diretamente no. {1} ().",
        "sameEdge": "bordas no podem vincular a si mesmos. removendo automaticamente borda de auto-referncia {0}.",
        "set": "{0} foi definida.",
        "setLong": "{0} foi definida para {1}.",
        "setContainer": "por favor, defina um div utilizando .container()"
    },
    "error": {
        "accepted": "{0} no  um reconhecido {1} para {2} visualizaes, por favor, use um dos seguintes procedimentos: {3}.",
        "connections": "No h conexes disponveis para {0}.",
        "data": "No h dados disponveis",
        "dataYear": "No h dados disponveis para {0}.",
        "lib": "A visualizao {0} necessita que seja carregado a biblioteca {1}.",
        "libs": "A visualizao {0} necessita que seja carregado as bibliotecas {1}.",
        "method": "A visualizao {0} exige a definio do mtodo {1}.",
        "methods": "A visualizao {0} exige a definio dos mtodos {1}."
    },
    "format": {
        decimal: ',',
        thousands: '.',
        grouping: [3],
        currency: ['R$', ''],
        dateTime: '%A, %e de %B de %Y. %X',
        date: '%d/%m/%Y',
        time: '%H:%M:%S',
        periods: ['AM', 'PM'],
        days: ['Domingo', 'Segunda', 'Tera', 'Quarta', 'Quinta', 'Sexta', 'Sbado'],
        shortDays: ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sb'],
        months: ['Janeiro', 'Fevereiro', 'Maro', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'],
        shortMonths: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez']
    },
    "lowercase": [
        "a",
        "com",
        "de",
        "e",
        "em",
        "mas",
        "ou",
        "para",
        "um"
    ],
    "method": {
        "active": "segmentos ativos",
        "color": "cor",
        "depth": "profundidade",
        "dev": "verboso",
        "focus": "foco",
        "icon": "cone",
        "id": "id",
        "height": "altura",
        "labels": "rtulos",
        "legend": "legenda",
        "margin": "margem",
        "messages": "mensagens de status",
        "order": "ordenar",
        "search": "pesquisar",
        "shape": "forma",
        "size": "tamanho",
        "style": "estilo",
        "temp": "segmentos temporrios",
        "text": "texto",
        "time": "tempo",
        "timeline": "cronograma",
        "total": "segmentos totais",
        "type": "tipo",
        "width": "largura",
        "x": "eixo x",
        "y": "eixo y",
        "zoom": "zoom",
        "mode": "modo"
    },
    "time": [
        "ano",
        "data",
        "dia",
        "hora",
        "ms"
    ],
    "visualization": {
        "bubbles": "Bolhas",
        "chart": "Grfico",
        "geo_map": "Mapa",
        "line": "Grfico de Linha",
        "network": "Rede",
        "rings": "Anis",
        "scatter": "Disperso",
        "stacked": "Evoluo",
        "tree_map": "Tree Map"
    },
    "ui": {
        "and": "e",
        "back": "de volta",
        "collapse": "Clique para fechar",
        "error": "erro",
        "expand": "clique para expandir",
        "loading": "carregando ...",
        "more": "mais {0}",
        "moreInfo": "clique para mais informaes",
        "noResults": "nenhum resultado para {0}.",
        "primary": "conexes primrias",
        "share": "participao",
        "total": "total",
        "values": "valores",
        "including": "incluindo"
    },
    "message": {
        "data": "analisando dados",
        "draw": "desenhando visualizao",
        "initializing": "inicializando {0}",
        "loading": "carregando dados",
        "tooltipReset": "redefinindo as dicas",
        "ui": "atualizando interface"
    },
    "uppercase": [
        "TV"
    ]
}

},{}],71:[function(require,module,exports){
d3plus.locale.zh_CN = {
    "dev": {
        "accepted": "{0}{1}, :{2}",
        "deprecated": "{0}, {1}",
        "noChange": "{0}, ",
        "noContainer": "{0}",
        "of": "",
        "oldStyle": "{0}{1}",
        "sameEdge": "{0}",
        "set": "{0}",
        "setLong": "{0}{1}",
        "setContainer": "()div"
    },
    "error": {
        "accepted": "{0}{2}{1}, {3}.",
        "connections": "{0}",
        "data": "",
        "dataYear": "{0}",
        "lib": "{0}{1}",
        "libs": "{0}{1}",
        "method": "{0}{1}",
        "methods": "{0}{1}"
    },
    "format": {
        decimal: ".",
        thousands: ",",
        grouping: [3],
        currency: ["", ""],
        dateTime: "%A %B %e %Y %X",
        date: "%Y/%-m/%-d",
        time: "%H:%M:%S",
        periods: ["", ""],
        days: ["", "", "", "", "", "", ""],
        shortDays: ["", "", "", "", "", "", ""],
        months: ["", "", "", "", "", "", "", "", "", "", "", ""],
        shortMonths: ["", "", "", "", "", "", "", "", "", "", "", ""]
    },
    "lowercase": [
        "",
        "",
        "",
        "",
        "...",
        "",
        "",
        "",
        "",
        "..."
    ],
    "method": {
        "active": "",
        "color": "",
        "depth": "",
        "dev": "",
        "focus": "",
        "icon": "",
        "id": "",
        "height": "",
        "labels": "",
        "legend": "",
        "margin": "",
        "messages": "",
        "order": "",
        "search": "",
        "shape": "",
        "size": "",
        "style": "",
        "temp": "",
        "text": "",
        "time": "",
        "timeline": "",
        "total": "",
        "type": "",
        "width": "",
        "x": "X",
        "y": "Y",
        "zoom": "",
        "mode": ""
    },
    "time": [
        "",
        "",
        "",
        "",
        ""
    ],
    "visualization": {
        "bubbles": "",
        "chart": "",
        "geo_map": "",
        "line": "",
        "network": "",
        "rings": "",
        "scatter": "",
        "stacked": "",
        "tree_map": ""
    },
    "ui": {
        "and": "",
        "back": "",
        "collapse": "",
        "error": "",
        "expand": "",
        "loading": "...",
        "more": "{0}",
        "moreInfo": "",
        "noResults": "{0}",
        "primary": "",
        "share": "",
        "total": "",
        "values": "",
        "including": ""
    },
    "message": {
        "data": "",
        "draw": "",
        "initializing": "{0}",
        "loading": "",
        "tooltipReset": "",
        "ui": "UI"
    },
    "uppercase": [
        "",
        "",
        ""
    ]
}

},{}],72:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Create dummy methods to catch deprecates
//--------------------------------------------------------------------------
d3plus.method.axis = function( axis ) {

  var axis = axis || "x"

  return {
    "accepted"    : [ Array , Boolean , Function , Object , String ],
    "dataFilter"  : true,
    "deprecates"  : [ axis+"axis" , axis+"axis_val" , axis+"axis_var" ],
    "domain"      : false,
    "lines"       : [],
    "mute"        : d3plus.method.filter(true),
    "range"       : false,
    "reset"       : [ "range" ],
    "scale"       : {
      "accepted"   : [ "linear" , "log" , "continuous" , "share" ],
      "value"      : "linear",
      "deprecates" : [ "layout" , "unique_axis" , "yaxis_scale" ]
    },
    "solo"        : d3plus.method.filter(true),
    "stacked"     : {
      "accepted" : [ Boolean ],
      "value"    : false
    },
    "value"       : false,
    "zerofill"    : {
      "accepted" : [ Boolean ],
      "value"    : false
    }
  }

}

},{}],73:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Create dummy methods to catch deprecates
//--------------------------------------------------------------------------
d3plus.method.filter = function( global ) {

  var global = global || false

  return {
    "accepted" : [ Array , Boolean , Function , Number , Object , String ],
    "global"   : global,
    "process"  : Array,
    "value"    : [ ]
  }

}

},{}],74:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Get/set function for methods
//------------------------------------------------------------------------------
d3plus.method.function = function( key , vars ) {

  return function( user , callback ) {

    var accepted = key in vars && d3plus.object.validate(vars[key])
                   && "accepted" in vars[key] ? vars[key].accepted
                 : key in vars ? typeof vars[key] : null

    if ( typeof accepted === "function" ) {
      accepted = accepted( vars )
    }

    if ( accepted !== null && !(accepted instanceof Array) ) {
      accepted = [ accepted ]
    }

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // If no arguments have been passed, simply return the current object.
    //--------------------------------------------------------------------------
    if ( user === Object ) {
      return vars[key]
    }
    else if ( !arguments.length
              && ((accepted === null && !("value" in vars))
              || (accepted !== undefined && accepted.indexOf(undefined) < 0)) ) {
      if ("value" in vars[key]) {
        return vars[key].value
      }
      else {
        return vars[key]
      }
    }

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Warn if the user is trying to use the old .style() method.
    //--------------------------------------------------------------------------
    if ( key === "style" && typeof user === "object" ) {

      var str = vars.format.locale.value.dev.oldStyle

      if ( ( vars.dev.value || ( key === "dev" && user ) )
           && !vars.methodGroup && vars.methodGroup !== "wait" ) {
        vars.methodGroup = true
        d3plus.console.groupCollapsed("method behavior")
      }

      for ( var s in user ) {

        d3plus.console.warning( d3plus.string.format(str,"\""+s+"\"",s) , s )

        vars.self[s](user[s])

      }

      return vars.self

    }

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Set all font families and weights, if calling .font()
    //--------------------------------------------------------------------------
    if ( key === "font" && d3plus.object.validate(user)
         && "family" in user && typeof user.family === "string" ) {

      function checkFamily ( o ) {

        if ( d3plus.object.validate( o ) ) {

          if ( "family" in o ) {
            o.family.value = o.family.process( user.family )
          }
          else {

            for ( var m in o ) {
              checkFamily(o[m])
            }

          }

        }

      }

      checkFamily( vars )

    }

    d3plus.method.object( vars , key , vars , key , user )

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // If defining a callback function, set it.
    //--------------------------------------------------------------------------
    if ( typeof callback === "function" ) {
      vars[key].callback = callback
    }

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // If the method is not chainable, return the value associated with it.
    //--------------------------------------------------------------------------
    if (vars[key].chainable === false) {
      return vars[key].value
    }
    else {
      return vars.self
    }

  }

}

},{}],75:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Create dummy methods to catch deprecates
//------------------------------------------------------------------------------
d3plus.method.init = function( vars , obj , method ) {

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Initialize a few globals.
  //----------------------------------------------------------------------------
  obj.previous = false
  obj.changed  = false
  obj.initialized = false
  obj.getVars  = function(){
    return vars
  }

  if ( "init" in obj && !("value" in obj) ) {
    obj.value = obj.init( vars )
    delete obj.init
  }

  if ( "process" in obj ) {
    obj.value = d3plus.method.process( obj , obj.value )
  }

  for ( var o in obj ) {

    if ( o === "deprecates" ) {

      var deps = obj[o] instanceof Array ? obj[o] : [obj[o]]

      deps.forEach(function(d){

        vars.self[d] = (function(dep,n) {

          return function(x) {

            if ( vars.dev.value && vars.methodGroup ) {
              d3plus.console.groupEnd()
              vars.methodGroup = false
            }

            var str = vars.format.locale.value.dev.deprecated
            dep = "\."+dep+"()"
            d3plus.console.error( d3plus.string.format(str,dep,"\."+n+"()") , n )
            return vars.self;

          }

        })(d,method)

      })

    }
    else if ( o === "global" ) {

      if ( !(method in vars) ) {
        vars[method] = []
      }

    }
    else if ( d3plus.object.validate( obj[o] ) ) {

      d3plus.method.init( vars , obj[o] , o )

    }

  }

  obj.initialized = true

}

},{}],76:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Detects is we should set the object or check all keys of object.
//------------------------------------------------------------------------------
d3plus.method.object = function( vars , method , object , key , value ) {

  if ([ "accepted" , "getVars" ].indexOf(key) < 0) {

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Determine whether or not to just set the local variable or to dig into
    // the object passed looking for keys.
    //--------------------------------------------------------------------------
    var passingObject  = d3plus.object.validate(value)
      , approvedObject = passingObject && ( !("value" in value) &&
                         !(d3.keys(value)[0] in object[key]) )

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Set value of key.
    //--------------------------------------------------------------------------
    if ( value === null || !passingObject || approvedObject ) {

      if ( approvedObject ) {
        d3plus.method.set( vars , method , object[key] , "value" , value )
      }
      else {
        d3plus.method.set( vars , method , object , key , value )
      }

    }
    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // If it's an object, dig through it and set inner values.
    //--------------------------------------------------------------------------
    else if ( passingObject ) {

      for (d in value) {

        d3plus.method.object( vars , method , object[key] , d , value[d] )

      }

    }

  }

}

},{}],77:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Process object's value
//--------------------------------------------------------------------------
d3plus.method.process = function( object , value ) {

  if ( object.process === Array ) {
    return d3plus.array.update(d3plus.util.copy(object.value),value)
  }
  else if ( typeof object.process === "object" && typeof value === "string" ) {
    return object.process[value]
  }
  else if ( typeof object.process === "function" ) {
    return object.process(value)
  }
  else {
    return value
  }

}

},{}],78:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Function to process data by url or element.
//--------------------------------------------------------------------------
d3plus.method.processData = function ( value , self ) {

  if ( typeof value !== "string" && !d3plus.util.d3selection( value ) ) {

    return value

  }
  else {

    if ( self === undefined ) {
      var self = this
    }

    var vars = self.getVars()
      , maybeURL = value.indexOf("/") >= 0

    if ( !maybeURL && d3plus.util.d3selection( value ) ) {

      return value

    }
    else {

      if ( !maybeURL && !d3.selectAll( value ).empty() ) {

        return d3.selectAll( value )

      }
      else {

        self.url = value
        return []

      }

    }

    return []

  }

}

},{}],79:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Sets a method's value.
//------------------------------------------------------------------------------
d3plus.method.set = function( vars , method , object , key , value ) {

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Create reference text for console statements.
  //----------------------------------------------------------------------------
  if ( key === "value" || !key || key === method ) {

    var text = "\."+method+"()"

  }
  else {

    var of = vars.format.locale.value.dev.of
      , text = "\""+key+"\" "+of+" \."+method+"()"

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Find appropriate "accepted" list.
  //----------------------------------------------------------------------------
  if (key === "value" && "accepted" in object) {

    var accepted = object.accepted

  }
  else if ( d3plus.object.validate( object[key] ) && "accepted" in object[key] ) {

    var accepted = object[key].accepted

  }
  else {

    var accepted = null

  }

  if ( typeof accepted === "function" ) {
    accepted = accepted( vars )
  }

  if ( accepted !== null && !(accepted instanceof Array) ) {
    accepted = [ accepted ]
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Check to see if the given value is allowed.
  //----------------------------------------------------------------------------
  var allowed = true
  if (accepted instanceof Array) {

    var constructor = value === undefined
                    ? value : value.constructor

    allowed = accepted.indexOf(value) >= 0
              || accepted.indexOf(constructor) >= 0

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // If value is not allowed, show an error message in the console.
  //----------------------------------------------------------------------------
  if (allowed === false) {

    if ( value !== undefined ) {

      var str = vars.format.locale.value.dev.accepted
        , recs = []
        , val = JSON.stringify(value)
        , and = vars.format.locale.value.ui.and

      if ( typeof value !== "string" ) {
        val = "\""+val+"\""
      }

      accepted.forEach(function(a){

        if ( typeof a === "string" ) {
          recs.push("\""+a+"\"")
        }
        else if ( typeof a === "function" ) {
          recs.push(a.toString().split("()")[0].substring(9))
        }
        else {
          recs.push(a.toString())
        }

      })

      recs = d3plus.string.list(recs,and)
      d3plus.console.warning( d3plus.string.format(str,val,text,recs) , method )

    }

  }
  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Otherwise, set the value!
  //----------------------------------------------------------------------------
  else {

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // If the method we are setting has a nested "value" key, change the
    // reference object and key to reflect that.
    //--------------------------------------------------------------------------
    if ( d3plus.object.validate( object[key] ) && "value" in object[key] ) {

      var parentKey = key
      object = object[key]
      key = "value"

    }

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // If there is a process function, run it.
    //------------------------------------------------------------------------
    if ( key === "value" && "process" in object ) {

      value = d3plus.method.process( object , value )

    }

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // If value has not changed, show a comment in the console.
    //--------------------------------------------------------------------------
    if ( !(object[key] instanceof Array) && object[key] === value && value !== undefined ) {

      var str = vars.format.locale.value.dev.noChange
      if ( vars.dev.value ) d3plus.console.comment(d3plus.string.format(str,text))

    }
    else {

      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      // Mark the method as being changed.
      //------------------------------------------------------------------------
      object.changed = true

      if ( "history" in vars && method !== "draw" ) {
        var copy = d3plus.util.copy(object)
        copy.method = method
        vars.history.chain.push(copy)
      }

      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      // Before updating the value, store the previous one for reference.
      //------------------------------------------------------------------------
      object.previous = object[key]

      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      // Set the variable!
      //------------------------------------------------------------------------
      if ( "id" in vars && key === "value" && "nesting" in object ) {

        if ( method !== "id" ) {

          if ( typeof object.nesting !== "object" ) {
            object.nesting = {}
          }

          if ( d3plus.object.validate( value ) ) {

            for (var id in value) {

              if ( typeof value[id] === "string" ) {
                value[id] = [value[id]]
              }

            }

            object.nesting = d3plus.object.merge( object.nesting , value )

            if ( !(vars.id.value in object.nesting) ) {
              object.nesting[vars.id.value] = value[d3.keys(value)[0]]
            }

          }
          else if ( value instanceof Array ) {
            object.nesting[vars.id.value] = value
          }
          else {
            object.nesting[vars.id.value] = [ value ]
          }

          object[key] = object.nesting[vars.id.value][0]

        }
        else {

          if ( value instanceof Array ) {

            object.nesting = value

            if ("depth" in vars && vars.depth.value < value.length) {
              object[key] = value[vars.depth.value]
            }
            else {
              object[key] = value[0]
              if ("depth" in vars) {
                vars.depth.value = 0
              }
            }

          }
          else {

            object[key] = value
            object.nesting = [value]
            if ("depth" in vars) {
              vars.depth.value = 0
            }

          }

        }

      }
      else if ( method === "depth" ) {

        if (value >= vars.id.nesting.length) {
          vars.depth.value = vars.id.nesting.length-1
        }
        else if (value < 0) {
          vars.depth.value = 0
        }
        else {
          vars.depth.value = value
        }

        vars.id.value = vars.id.nesting[vars.depth.value]

        if ( typeof vars.text.nesting === "object" ) {

          var n = vars.text.nesting[vars.id.value]
          if ( n ) {
            vars.text.nesting[vars.id.value] = typeof n == "string" ? [n] : n
            vars.text.value = n instanceof Array ? n[0] : n
          }

        }
      }
      else if ( d3plus.object.validate(object[key]) && d3plus.object.validate(value) ) {

        object[key] = d3plus.object.merge( object[key] , value )

      }
      else {

        object[key] = value

      }

      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      // Add method to data solo/mute array if applicable.
      //------------------------------------------------------------------------
      if ( key === "value" && object.global ) {

        var hasValue = object[key].length > 0
          , k = parentKey || key

        if ( k in vars && ( ( hasValue && vars.data[k].indexOf(method) < 0 )
        || ( !hasValue && vars.data[k].indexOf(method) >= 0 ) ) ) {

          vars.data[k] = d3plus.array.update(vars.data[k],method)

        }

      }

      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      // Add method to data filter array if applicable.
      //------------------------------------------------------------------------
      if ( key === "value" && object.dataFilter && vars.data
      && vars.data.filters.indexOf(method) < 0 ) {

        vars.data.filters.push( method )

      }

      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      // Reset associated variables given if "value" is changed.
      //------------------------------------------------------------------------
      if (key === "value" && object.reset) {

        var reset = typeof object.reset == "string"
                  ? [ object.reset ] : object.reset

        reset.forEach(function(r){
          object[r] = false
        })

      }

      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      // Display console message, if applicable.
      //------------------------------------------------------------------------
      if ( ( vars.dev.value || key === "dev" ) && object.changed
           && object[key] !== undefined ) {

        var longArray = object[key] instanceof Array && object[key].length > 10
          , d3selection = d3plus.util.d3selection(object[key])
          , typeFunction = typeof object[key] === "function"

        var valString = !longArray && !d3selection && !typeFunction
                      ? typeof object[key] === "string" ? object[key]
                      : JSON.stringify(object[key]) : null

        if ( ( vars.dev.value || ( key === "dev" && user ) )
             && !vars.methodGroup && vars.methodGroup !== "wait" ) {
          vars.methodGroup = true
          d3plus.console.groupCollapsed("method behavior")
        }

        if ( valString !== null && valString.length < 260 ) {

          var str = vars.format.locale.value.dev.setLong
          d3plus.console.log(d3plus.string.format(str,text,"\""+valString+"\""))


        }
        else {

          var str = vars.format.locale.value.dev.set
          d3plus.console.log(d3plus.string.format(str,text))

        }

      }

    }

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // If there is a callback function not associated with a URL, run it.
    //--------------------------------------------------------------------------
    if ( key === "value" && object.callback && !object.url ) {

      object.callback(value)

    }

  }

}

},{}],80:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Global method shell.
//------------------------------------------------------------------------------
d3plus.method = function( vars , methods , styles ) {

  var methods   = methods || []
    , styles    = styles || []
    , initStyle = d3plus.style[ d3plus.method.style.value ]

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Loop through each specified method and apply it to the object.
  //----------------------------------------------------------------------------
  methods.forEach(function(m) {

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Clone method defaults.
    //--------------------------------------------------------------------------
    if ( !(m in vars) ) {
      vars[m] = {}
    }

    vars[m] = d3plus.object.merge( d3plus.method[m] , vars[m] )

    if ( styles.indexOf(m) >= 0 ) {
      vars[m] = d3plus.object.merge( initStyle[m] , vars[m] )
      styles.splice(styles.indexOf(m),1)
    }

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Run initialization on all inner properties.
    //--------------------------------------------------------------------------
    d3plus.method.init( vars , vars[m] , m )

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Create the main set/get function.
    //--------------------------------------------------------------------------
    vars.self[m] = (d3plus.method.function)( m , vars )

  })

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Loop through remaining styles and create methods for them.
  //----------------------------------------------------------------------------
  styles.forEach(function(m){

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Clone style defaults.
    //--------------------------------------------------------------------------
    vars[m] = d3plus.object.merge( vars[m] || {} , initStyle[m] )

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Run initialization on all inner properties.
    //--------------------------------------------------------------------------
    d3plus.method.init( vars , vars[m] , m )

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Create the main set/get function.
    //--------------------------------------------------------------------------
    vars.self[m] = (d3plus.method.function)( m , vars )

  })

}

},{}],81:[function(require,module,exports){
d3plus.method.active = {
  "accepted"   : [ false , Array , Function , Number , Object , String ],
  "deprecates" : "active_var",
  "mute"       : d3plus.method.filter(true),
  "solo"       : d3plus.method.filter(true),
  "spotlight"  : {
    "accepted"   : [ Boolean ],
    "deprecates" : "spotlight",
    "value"      : false
  },
  "value"      : false
}

},{}],82:[function(require,module,exports){
d3plus.method.aggs = {
  "accepted"   : [ Object ],
  "deprecated" : "nesting_aggs",
  "value"      : {}
}

},{}],83:[function(require,module,exports){
d3plus.method.alt = {
  "accepted" : [ false , Array , Function , Object , String ],
  "mute"     : d3plus.method.filter(true),
  "solo"     : d3plus.method.filter(true),
  "value"    : "alt"
}

},{}],84:[function(require,module,exports){
d3plus.method.attrs = {
  "accepted" : [ false , Array , Object , String ],
  "delimiter" : {
    "accepted" : [ String ],
    "value"    : "|"
  },
  "filetype" : {
    "accepted" : [ false , "json" , "xml" ,"html"
                 , "csv" , "dsv" , "tsv" , "txt" ],
    "value"    : false
  },
  "process"  : d3plus.method.processData,
  "value"    : false
}

},{}],85:[function(require,module,exports){
d3plus.method.axes = {
  "mirror" : {
    "accepted"   : [ Boolean ],
    "deprecates" : [ "mirror_axis" , "mirror_axes" ],
    "value"      : false
  },
  "values" : [ "x" , "y" ]
}

},{}],86:[function(require,module,exports){
d3plus.method.color = {
  "accepted"   : [ false , Array , Function , Object , String ],
  "deprecates" : "color_var",
  "init"       : function ( vars ) {

    if ( vars.shell === "form" ) {
      return "color"
    }
    else {
      return false
    }

  },
  "mute"      : d3plus.method.filter(true),
  "solo"      : d3plus.method.filter(true)
}

},{}],87:[function(require,module,exports){
d3plus.method.container = {
  "accepted" : [ Array , Object , String ],
  "element"  : false,
  "id"       : "default",
  "process"  : function ( value ) {

    if ( value === false ) {
      var shell = this.getVars().shell
      return shell === "form" ? d3.select("body") : value
    }
    else if ( d3plus.util.d3selection(value) ) {
      return value
    }
    else if ( value instanceof Array ) {
      return d3.select(value[0][0])
    }
    else {
      return d3.select(value)
    }

  },
  "value"    : false
}

},{}],88:[function(require,module,exports){
d3plus.method.coords = {
  "accepted" : [ false , Array , Function , Object , String ],
  "filetype" : {
    "accepted" : [ "json" ],
    "value"    : "json"
  },
  "mute"     : d3plus.method.filter(false),
  "process"  : d3plus.method.processData,
  "solo"     : d3plus.method.filter(false),
  "value"    : false
}

},{}],89:[function(require,module,exports){
var fetchValue = require("../../core/fetch/value.js")

d3plus.method.csv = {
  "accepted"  : [ undefined , Array , String ],
  "chainable" : false,
  "data"      : [],
  "process"   : function ( value ) {

    var vars = this.getVars()

    if ( vars.returned === undefined ) {
      return []
    }

    if ( value instanceof Array ) {
      var columns = value
    }
    else if ( typeof value === "string" ) {
      var columns = [ value ]
    }

    var csv_to_return = [],
        titles = [],
        title = vars.title.value || "My D3plus App Data"

    title = d3plus.string.strip(title)

    if (!columns) {
      var columns = [vars.id.value]
      if (vars.time.value) columns.push(vars.time.value)
      if (vars.size.value) columns.push(vars.size.value)
      if (vars.text.value) columns.push(vars.text.value)
    }

    columns.forEach(function(c){
      titles.push(vars.format.value(c))
    })

    csv_to_return.push(titles);

    vars.returned.nodes.forEach(function(n){
      var arr = []
      columns.forEach(function(c){
        arr.push(fetchValue(vars,n,c))
      })
      csv_to_return.push(arr)
    })

    var csv_data = "data:text/csv;charset=utf-8,"
    csv_to_return.forEach(function(c,i){
      dataString = c.join(",")
      csv_data += i < csv_to_return.length ? dataString + "\n" : dataString
    })

    if (d3plus.ie) {

      var blob = new Blob([csv_data],{
        type: "text/csv;charset=utf-8;",
      })
      navigator.msSaveBlob(blob,title+".csv")

    }
    else {

      var encodedUri = encodeURI(csv_data)
      var link = document.createElement("a")
      link.setAttribute("href", encodedUri)
      link.setAttribute("download",title+".csv")
      link.click()

    }

    this.data = csv_to_return

    return columns

  },
  "value"     : undefined
}

},{"../../core/fetch/value.js":undefined}],90:[function(require,module,exports){
d3plus.method.data = {
  "accepted" : [ false , Array , Function , String ],
  "cache"    : {},
  "delimiter" : {
    "accepted" : [ String ],
    "value"    : "|"
  },
  "element": {
    "process": function( value ) {

      if ( d3plus.util.d3selection(value) ) {
        var element = value
      }
      else if (typeof value === "string" && !d3.select(value).empty()) {
        var element = d3.select(value)
      }
      else {
        var element = false
      }

      if (element) {

        var vars = this.getVars()

        vars.self.container(d3.select(element.node().parentNode))

        element
          .style("position","absolute","important")
          .style("clip","rect(1px 1px 1px 1px)","important")
          .style("clip","rect(1px, 1px, 1px, 1px)","important")
          .style("width","1px","important")
          .style("height","1px","important")
          .style("margin","-1px","important")
          .style("padding","0","important")
          .style("border","0","important")
          .style("overflow","hidden","important")

      }

      return element

    },
    "value": false
  },
  "filetype" : {
    "accepted" : [ false , "json" , "xml" ,"html"
                 , "csv" , "dsv" , "tsv" , "txt" ],
    "value"    : false
  },
  "filters"  : [],
  "mute"     : [],
  "process"  : function( value ) {

    var vars = this.getVars()

    if ( vars.container.id === "default" && value.length ) {
      vars.self.container({"id": "default"+value.length})
    }

    return d3plus.method.processData( value , this )
  },
  "solo"     : [],
  "value"    : false
}

},{}],91:[function(require,module,exports){
d3plus.method.depth = {
  "accepted" : [ Function , Number ],
  "value"    : 0
}

},{}],92:[function(require,module,exports){
d3plus.method.descs = {
  "accepted" : [ false , Function , Object ],
  "value"    : false
}

},{}],93:[function(require,module,exports){
d3plus.method.dev = {
  "accepted" : [ Boolean ],
  "value"    : false
}

},{}],94:[function(require,module,exports){
var parseElement = require("../../core/parse/element.js")
d3plus.method.draw = {
  "accepted" : [ undefined , Function ],
  "first"    : true,
  "frozen"   : false,
  "process"  : function ( value ) {

    if ( this.initialized === false ) {
      this.initialized = true
      return value
    }

    var vars    = this.getVars()
      , changes = "history" in vars ? vars.history.chain : []

    if ( "data" in vars && vars.data.value && d3plus.util.d3selection( vars.data.value ) ) {
      vars.data.value = parseElement( vars )
    }

    if ( value === undefined && typeof this.value === "function" ) {
      value = this.value
    }

    if ( vars.container.value === false ) {

      var str = vars.format.locale.value.dev.setContainer
      d3plus.console.warning( str , "container" )

    }
    else if ( vars.container.value.empty() ) {

      var str = vars.format.locale.value.dev.noContainer
      d3plus.console.warning( d3plus.string.format(str,"\""+vars.container.value+"\"") , "container" )

    }
    else {

      if ( vars.dev.value ) {
        if ( vars.methodGroup ) {
          vars.methodGroup = "wait"
          d3plus.console.groupEnd()
        }
        d3plus.console.time("total draw time")
      }

      vars.container.value.call(vars.self)

    }

    if ( typeof value === "function" && changes.length ) {

      var changesObject = {}
      changes.forEach(function(c){
        var method = c.method
        delete c.method
        changesObject[method] = c
      })

      value(changesObject)

      vars.history.chain = []

    }

    return value

  },
  "update"   : true,
  "value"    : undefined
}

},{"../../core/parse/element.js":undefined}],95:[function(require,module,exports){
d3plus.method.edges = {
  "accepted"    : [ false , Array , Function , String ],
  "connections" : function(focus,id,objects) {

    var self = this

    if (!self.value) {
      return []
    }

    if (!id) var id = "id"

    var edges = self.restricted || self.value,
        targets = []

    if (!focus) {
      return edges
    }

    var connections = edges.filter(function(edge){

      var match = false

      if (edge[self.source][id] == focus) {
        match = true
        if (objects) {
          targets.push(edge[self.target])
        }
      }
      else if (edge[self.target][id] == focus) {
        match = true
        if (objects) {
          targets.push(edge[self.source])
        }
      }

      return match

    })

    return objects ? targets : connections

  },
  "delimiter" : {
    "accepted" : [ String ],
    "value"    : "|"
  },
  "filetype"    : {
    "accepted" : [ false , "json" , "xml" ,"html"
                 , "csv" , "dsv" , "tsv" , "txt" ],
    "value"    : false
  },
  "interpolate" : {
    "accepted"   : ["basis", "cardinal", "linear", "monotone", "step"],
    "value"      : "basis"
  },
  "label"       : false,
  "limit"       : {
    "accepted" : [false, Function, Number],
    "value"    : false
  },
  "process"     : d3plus.method.processData,
  "size"        : false,
  "source"      : "source",
  "target"      : "target",
  "value"       : false
}

},{}],96:[function(require,module,exports){
d3plus.method.error = {
  "accepted" : [ Boolean , String ],
  "value"    : false
}

},{}],97:[function(require,module,exports){
d3plus.method.focus = {
  "accepted"   : [ false , Array , Function , Number , String ],
  "deprecates" : "highlight",
  "process"    : function(value) {

    if (value === false) {
      return []
    }
    else {

      if (!(value instanceof Array)) value = [value]

      var vars = this.getVars()

      if ( ["string","number"].indexOf(typeof value[0]) >= 0 && vars.data.element.value ) {

        var elementTag  = vars.data.element.value.node().tagName.toLowerCase()
          , elementType = vars.data.element.value.attr("type")

        if (elementTag === "select") {

          vars.data.element.value.selectAll("option").each(function(d,i){

            if (d && d[vars.id.value] === value[0]) {
              vars.data.element.value.node().selectedIndex = i
            }

          })

        }
        else if (elementTag === "input" && elementType === "radio") {

          vars.data.element.value
            .each(function(d){

              if (d && d[vars.id.value] === value[0]) {
                this.checked = true
              }
              else {
                this.checked = false
              }

            })

        }

      }

      return value

    }

  },
  "tooltip"    : {
    "accepted" : [ Boolean ],
    "value"    : true
  },
  "value"      : []
}

},{}],98:[function(require,module,exports){
d3plus.method.footer = {
  "accepted" : [ false , Number , String ],
  "link"     : false,
  "value"    : false
}

},{}],99:[function(require,module,exports){
d3plus.method.format = {
  "accepted"   : [ Function , String ],
  "deprecates" : [ "number_format" , "text_format" ],
  "locale"     : {
    "accepted" : function(){
      return d3.keys(d3plus.locale)
    },
    "process"  : function( value ) {

      var defaultLocale = "en_US"
        , returnObject  = d3plus.locale[defaultLocale]

      if ( value !== defaultLocale ) {
        returnObject = d3plus.object.merge( returnObject , d3plus.locale[value] )
      }

      this.language = value

      return returnObject

    },
    "value"    : "en_US"
  },
  "number"     : {
    "accepted" : [ false , Function ],
    "value"    : false
  },
  "process"    : function( value ) {

    if ( typeof value === "string" ) {
      var vars = this.getVars()
      vars.self.format({"locale": value})
    }
    else if ( typeof value === "function" ) {
      return value
    }

    return this.value

  },
  "text"       : {
    "accepted" : [ false , Function ],
    "value"    : false
  },
  "value"      : function( value , key ) {

    var vars = this.getVars()

    if ( vars.time && vars.time.value && key === vars.time.value ) {
      var f = vars.time.format.value || vars.data.time.format
        , v = value.constructor === Date ? value : new Date(value)
      // console.log(d3.locale(vars.format.locale.value.format).timeFormat)
      // f = d3.locale(vars.format.locale.value.format).timeFormat
      return f( v )
    }
    else if ( typeof value === "number" ) {
      var f = this.number.value || d3plus.number.format
      return f( value , key )
    }
    else if ( typeof value === "string" ) {
      var f = this.text.value || d3plus.string.title
      return f( value , key )
    }
    else {
      return JSON.stringify(value)
    }

  }
}

},{}],100:[function(require,module,exports){
d3plus.method.height = {
  "accepted"  : [ false , Number ],
  "secondary" : false,
  "value"     : false
}

},{}],101:[function(require,module,exports){
d3plus.method.history = {
  "accepted" : [ Boolean ],
  "back"     : function() {

    if (this.states.length > 0) {

      var func = this.states.pop()

      func()

    }

  },
  "chain"    : [],
  "states"   : [],
  "value"    : true
}

},{}],102:[function(require,module,exports){
d3plus.method.hover = {
  "accepted" : [ false , Number , String ],
  "value"    : false
}

},{}],103:[function(require,module,exports){
d3plus.method.icon = {
  "accepted"   : [ false , Array , Function , Object , String ],
  "deprecates" : "icon_var",
  "style"      : {
    "accepted"   : [ Object , String ],
    "deprecates" : "icon_style",
    "value"      : "default"
  },
  "value"      : "icon"
}

},{}],104:[function(require,module,exports){
d3plus.method.id = {
  "accepted"    : [ Array , String ],
  "dataFilter"  : true,
  "deprecates"  : [ "id_var" , "nesting" ],
  "init"        : function ( vars ) {

    if ( vars.shell === "form" ) {
      this.nesting = [ "value" ]
      return "value"
    }
    else {
      this.nesting = [ "id" ]
      return "id"
    }

  },
  "mute"        : d3plus.method.filter(true),
  "solo"        : d3plus.method.filter(true)
}

},{}],105:[function(require,module,exports){
d3plus.method.keywords = {
  "accepted" : [ false , Array , Function , Object , String ],
  "mute"     : d3plus.method.filter(true),
  "solo"     : d3plus.method.filter(true),
  "value"    : "keywords"
}

},{}],106:[function(require,module,exports){
d3plus.method.labels = {
  "accepted" : [ Boolean ] ,
  "resize"   : {
    "accepted" : [ Boolean ],
    "value"    : true
  },
  "value"    : true
}

},{}],107:[function(require,module,exports){
d3plus.method.legend = {
  "accepted" : [ Boolean ],
  "value"    : true
}

},{}],108:[function(require,module,exports){
d3plus.method.margin = {
  "accepted" : [ Number , Object , String ],
  "process"  : function ( value ) {

    var self = this
      , sides = [ "top" , "right" , "bottom" , "left" ]

    if ( value === undefined ) {
      var value = self.value
    }

    var userValue = value

    if ( typeof value === "string" ) {

      value = value.split(" ")

      value.forEach(function(v,i){
        value[i] = parseFloat(v,10)
      })

      if ( value.length === 1 ) {
        value = value[0]
      }
      else if ( value.length === 2 ) {
        value = {
          "top"    : value[0],
          "right"  : value[1],
          "bottom" : value[0],
          "left"   : value[1]
        }
      }
      else if ( value.length === 3 ) {
        value = {
          "top"    : value[0],
          "right"  : value[1],
          "bottom" : value[2],
          "left"   : value[1]
        }
      }
      else if ( value.length === 4 ) {
        value = {
          "top"    : value[0],
          "right"  : value[1],
          "bottom" : value[2],
          "left"   : value[3]
        }
      }
      else {
        value = 0
      }

    }

    if ( typeof value === "number" ) {

      sides.forEach(function(side){
        self[side] = value
      })

    }
    else {

      for ( var side in value ) {

        var sideIndex = sides.indexOf(side)

        if (sideIndex >= 0) {

          sides.splice(sideIndex,1)
          self[side] = value[side]

        }

      }

      sides.forEach(function(k){
        self[k] = 0
      })

    }

    return userValue

  },
  "value"    : 0
}

},{}],109:[function(require,module,exports){
d3plus.method.messages = {
  "accepted" : [ Boolean , String ],
  "value"    : true
}

},{}],110:[function(require,module,exports){
d3plus.method.nodes = {
  "accepted" : [ false , Array , Function , String ],
  "delimiter" : {
    "accepted" : [ String ],
    "value"    : "|"
  },
  "filetype" : {
    "accepted" : [ false , "json" , "xml" ,"html"
                 , "csv" , "dsv" , "tsv" , "txt" ],
    "value"    : false
  },
  "process"  : d3plus.method.processData,
  "value"    : false
}

},{}],111:[function(require,module,exports){
d3plus.method.open = {
  "accepted" : [ Boolean ],
  "flipped"  : {
    "accepted" : [ Boolean ],
    "value"    : false
  },
  "value"    : false
}

},{}],112:[function(require,module,exports){
d3plus.method.order = {
  "accepted" : [ false , Function , String ],
  "sort"     : {
    "accepted"   : [ "asc" , "desc" ],
    "value"      : "asc",
    "deprecates" : [ "sort" ]
  },
  "value"    : false
}

},{}],113:[function(require,module,exports){
d3plus.method.remove = {
  "accepted" : undefined,
  "process"  : function ( value ) {

    if ( this.initialized ) {
      var vars = this.getVars()
      vars.container.value.remove()
    }
    else {
      return value
    }


  },
  "value"    : undefined
}

},{}],114:[function(require,module,exports){
d3plus.method.resize = {
  "accepted" : [ Boolean ],
  "value"    : false
}

},{}],115:[function(require,module,exports){
d3plus.method.search = {
  "accepted" : [ "auto" , Boolean ],
  "process"  : function(value) {

    if (typeof value == "Boolean") {
      this.enabled = value
    }

    return value

  },
  "value"    : "auto"
}

},{}],116:[function(require,module,exports){
d3plus.method.select = {
  "accepted"  : [ String ],
  "chainable" : false,
  "process"   : function ( value ) {

    var vars = this.getVars()

    return vars.container.value && value
         ? vars.container.value.select(value)
         : value

  },
  "value"     : undefined
}

},{}],117:[function(require,module,exports){
d3plus.method.selectAll = {
  "accepted"  : [ String ],
  "chainable" : false,
  "process"   : function ( value ) {

    var vars = this.getVars()

    return vars.container.value && value
         ? vars.container.value.selectAll(value)
         : value

  },
  "value"     : undefined
}

},{}],118:[function(require,module,exports){
d3plus.method.shape = {
  "accepted" : function( vars ) {
    return vars.shell === "textwrap" ? [ "circle" , "square" ]
         : [ "circle" , "donut" , "line"
         , "square" , "area" , "coordinates" ]
  },
  "value"    : false
}

},{}],119:[function(require,module,exports){
d3plus.method.size = {
  "accepted"    : function( vars ) {

    if ( vars.shell === "textwrap" ) {
      return [ Array , false ]
    }
    else {
      return [ Array , Boolean , Function , Object , String ]
    }

  },
  "dataFilter"  : true,
  "deprecates"  : [ "value" , "value_var" ],
  "mute"        : d3plus.method.filter(true),
  "scale"       : {
    "accepted"   : [ Function ],
    "deprecates" : "size_scale",
    "value"      : d3.scale.sqrt()
  },
  "solo"        : d3plus.method.filter(true),
  "threshold"   : true,
  "value"       : false
}

},{}],120:[function(require,module,exports){
d3plus.method.style = {
  "accepted" : function( vars ){
    return d3.keys(d3plus.style).filter(function(s){
      return typeof d3plus.style[s] === "object"
    })
  },
  "value"    : "default"
}

},{}],121:[function(require,module,exports){
d3plus.method.temp = {
  "accepted": [ false , Array , Function , Object , String ],
  "deprecates": [ "else_var" , "else" ],
  "mute": d3plus.method.filter(true),
  "solo": d3plus.method.filter(true),
  "value": false
}

},{}],122:[function(require,module,exports){
d3plus.method.text = {
  "accepted"   : [ Array , Boolean , Function , Object , String ],
  "deprecates" : [ "name_array" , "text_var" ],
  "html"     : {
    "accepted" : [ Boolean ],
    "value"    : false
  },
  "init"     : function ( vars ) {

    if ( vars.shell === "textwrap" ) {
      var s = this.split
      this.break = new RegExp("[^\\s\\"+s.join("\\")+"]+\\"+s.join("?\\")+"?","g")
    }

    return false

  },
  "nesting"    : true,
  "mute"       : d3plus.method.filter(true),
  "solo"       : d3plus.method.filter(true),
  "secondary"  : {
    "accepted" : [ Array , Boolean , Function , Object , String ],
    "nesting"  : true,
    "value"    : false
  },
  "split"      : [ "-" , "/" , ";" , ":" , "&" ]
}

},{}],123:[function(require,module,exports){
d3plus.method.time = {
  "accepted"    : [ Array , Boolean , Function , Object , String ],
  "dataFilter"  : true,
  "deprecates"  : [ "year" , "year_var" ],
  "fixed"       : {
    "accepted"   : [ Boolean ],
    "deprecates" : [ "static_axis" , "static_axes" ],
    "value"      : true
  },
  "format"      : {
    "accepted" : [false, String],
    "value"    : false
  },
  "mute"        : d3plus.method.filter(false),
  "solo"        : d3plus.method.filter(false),
  "value"       : false
}

},{}],124:[function(require,module,exports){
d3plus.method.timeline = {
  "accepted" : [ Boolean ],
  "value"    : true
}

},{}],125:[function(require,module,exports){
d3plus.method.title = {
  "accepted" : [ false , Function , String ],
  "link"     : false,
  "sub"      : {
    "accepted"   : [ false , String ],
    "deprecates" : "sub_title",
    "link"       : false,
    "value"      : false,
  },
  "total"    : {
    "accepted"   : [ Boolean , Object ],
    "deprecates" : "total_bar",
    "link"       : false,
    "value"      : false
  },
  "process"  : function ( value ) {

    var vars = this.getVars()

    if ( vars.container.id.indexOf("default") === 0 && value ) {
      var id = d3plus.string.strip(value).toLowerCase()
      vars.self.container({"id": id})
    }

    return value

  },
  "value"    : false
}

},{}],126:[function(require,module,exports){
d3plus.method.tooltip = {
  "accepted"   : [ false , Array , Function , Object , String ],
  "deprecates" : "tooltip_info",
  "html"       : {
    "accepted"   : [ false , Function , String ],
    "deprecates" : "click_function",
    "value"      : false
  },
  "value"      : false
}

},{}],127:[function(require,module,exports){
d3plus.method.total = {
  "accepted": [ false , Array , Function , Object , String ],
  "deprecates": [ "total_var" ],
  "mute": d3plus.method.filter(true),
  "solo": d3plus.method.filter(true),
  "value": false
}

},{}],128:[function(require,module,exports){
d3plus.method.type = {
  "accepted" : function( vars ) {
    return d3.keys(vars.types)
  },
  "init"     : function ( vars ) {

    var shell = vars.shell

    if ( shell === "viz" ) {
      return "tree_map"
    }
    else if ( shell === "form" ) {
      return "auto"
    }
    else {
      return undefined
    }

  },
  "mode"     : {
    "accepted" : function(vars){
      return vars.types[vars.type.value].modes || [ false ]
    },
    "value"    : false
  }
}

},{}],129:[function(require,module,exports){
d3plus.method.ui = {
  "accepted" : [ Array , Boolean ],
  "value"    : false
}

},{}],130:[function(require,module,exports){
d3plus.method.width = {
  "accepted"  : [ false , Number ],
  "secondary" : false,
  "value"     : false
}

},{}],131:[function(require,module,exports){
d3plus.method.x = d3plus.method.axis("x")

},{}],132:[function(require,module,exports){
d3plus.method.y = d3plus.method.axis("y")

},{}],133:[function(require,module,exports){
d3plus.method.zoom = {
  "accepted"   : [ Boolean ],
  "behavior"   : d3.behavior.zoom().scaleExtent([ 1 , 1 ]),
  "click"      : {
    "accepted" : [ Boolean ],
    "value"    : true
  },
  "direction"  : function( data ) {

    var vars          = this.getVars()
      , max_depth     = vars.id.nesting.length-1
      , current_depth = vars.depth.value
      , restricted    = vars.types[vars.type.value].nesting === false

    if (restricted) {
      return 0
    }
    else if ( data.d3plus.merged || current_depth < max_depth
              && ( !data || vars.id.nesting[vars.depth.value+1] in data ) ) {
      return 1
    }
    else if ( ( current_depth === max_depth || ( data && !(vars.id.nesting[vars.depth.value+1] in data) ) )
              && ( vars.small || !vars.tooltip.html.value ) ) {
      return -1
    }

    return 0

  },
  "pan"        : {
    "accepted" : [ Boolean ],
    "value"    : true
  },
  "scroll"     : {
    "accepted"   : [ Boolean ],
    "deprecates" : "scroll_zoom",
    "value"      : true
  },
  "touchEvent" : function() {

    var vars     = this.getVars()
      , zoomed   = vars.zoom.scale > vars.zoom.behavior.scaleExtent()[0]
      , enabled  = vars.types[vars.type.value].zoom
                 && vars.zoom.value && vars.zoom.scroll.value
      , zoomable = d3.event.touches.length > 1 && enabled

    if (!zoomable && !zoomed) {
      d3.event.stopPropagation()
    }

  },
  "value"      : true
}

},{}],134:[function(require,module,exports){
d3plus.network.cluster = function(edges, options) {
  var Q, a, b, cid, commSize, commSizes, communities, community, deltaQ, distance, edge, endpoint, events, id, iter, k, linksMap, m, maxa, maxb, node, nodeid, nodes, nodesMap, result, startpoint, _i, _j, _len, _len1, _ref, _ref1;
  events = [];
  if (options == null) {
    options = {};
  }
  if ((options.nodes == null) || typeof options.nodes !== 'object') {
    _ref = d3plus.network.normalize(edges, options), edges = _ref[0], options = _ref[1];
    if (options === null) {
      return null;
    }
  }
  distance = options.distance, nodeid = options.nodeid, startpoint = options.startpoint, endpoint = options.endpoint, nodes = options.nodes;
  nodesMap = {};
  for (id in nodes) {
    nodesMap[id] = {
      node: nodes[id].node,
      degree: 0
    };
  }
  m = 0;
  linksMap = {};
  for (_i = 0, _len = edges.length; _i < _len; _i++) {
    edge = edges[_i];
    a = nodeid(startpoint(edge));
    b = nodeid(endpoint(edge));
    if (!(a in linksMap)) {
      linksMap[a] = {};
    }
    if (!(b in linksMap)) {
      linksMap[b] = {};
    }
    if (!(b in linksMap[a])) {
      linksMap[a][b] = 0;
      linksMap[b][a] = 0;
      m++;
      nodesMap[a].degree += 1;
      nodesMap[b].degree += 1;
    }
  }
  communities = {};
  Q = 0;
  for (id in nodesMap) {
    node = nodesMap[id];
    communities[id] = {
      score: node.degree / (2.0 * m),
      nodes: [id]
    };
  }
  for (a in linksMap) {
    for (b in linksMap[a]) {
      linksMap[a][b] = 1.0 / (2 * m) - (nodesMap[a].degree * nodesMap[b].degree) / (4.0 * m * m);
    }
  }
  iter = 0;
  while (iter < 1000) {
    deltaQ = -1;
    maxa = void 0;
    maxb = void 0;
    for (a in linksMap) {
      for (b in linksMap[a]) {
        if (linksMap[a][b] > deltaQ) {
          deltaQ = linksMap[a][b];
          maxa = a;
          maxb = b;
        }
      }
    }
    if (deltaQ < 0) {
      break;
    }
    for (k in linksMap[maxa]) {
      if (k !== maxb) {
        if (k in linksMap[maxb]) {
          linksMap[maxb][k] += linksMap[maxa][k];
        } else {
          linksMap[maxb][k] = linksMap[maxa][k] - 2 * communities[maxb].score * communities[k].score;
        }
        linksMap[k][maxb] = linksMap[maxb][k];
      }
      delete linksMap[k][maxa];
    }
    for (k in linksMap[maxb]) {
      if (!(k in linksMap[maxa]) && k !== maxb) {
        linksMap[maxb][k] -= 2 * communities[maxa].score * communities[k].score;
        linksMap[k][maxb] = linksMap[maxb][k];
      }
    }
    _ref1 = communities[maxa].nodes;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      node = _ref1[_j];
      communities[maxb].nodes.push(node);
    }
    communities[maxb].score += communities[maxa].score;
    if (options.vdebug) {
      events.push({
        type: 'merge',
        father: maxb,
        child: maxa,
        nodes: communities[maxb].nodes
      });
    }
    delete communities[maxa];
    delete linksMap[maxa];
    Q += deltaQ;
    iter++;
  }
  commSizes = (function() {
    var _results;
    _results = [];
    for (cid in communities) {
      community = communities[cid];
      _results.push([cid, community.nodes.length]);
    }
    return _results;
  })();
  commSizes.sort(function(a, b) {
    return b[1] - a[1];
  });
  result = (function() {
    var _k, _len2, _results;
    _results = [];
    for (_k = 0, _len2 = commSizes.length; _k < _len2; _k++) {
      commSize = commSizes[_k];
      _results.push(communities[commSize[0]].nodes);
    }
    return _results;
  })();
  return [result, events];
};


},{}],135:[function(require,module,exports){
d3plus.network.normalize = function(edges, options) {
  var K, a, b, directed, distance, edge, edge2distance, endpoint, errormsg, i, id, id1, idA, idB, node, nodeA, nodeB, nodeid, nodes, source, startpoint, target, vdebug, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
  source = options.source, target = options.target, directed = options.directed, distance = options.distance, nodeid = options.nodeid, startpoint = options.startpoint, endpoint = options.endpoint, K = options.K, vdebug = options.vdebug;
  if (!directed) {
    directed = false;
  }
  if (K == null) {
    K = 1;
  }
  if (nodeid == null) {
    nodeid = function(node) {
      return node;
    };
  } else if (typeof nodeid === 'string') {
    nodeid = (function(nodeid) {
      return function(node) {
        return node[nodeid];
      };
    })(nodeid);
  }
  if ((source != null) && typeof source === 'object') {
    source = nodeid(source);
  }
  if ((target != null) && typeof target === 'object') {
    target = nodeid(target);
  }
  if (startpoint == null) {
    startpoint = function(edge) {
      return edge.source;
    };
  } else if (typeof startpoint === 'string') {
    startpoint = (function(startpoint) {
      return function(edge) {
        return edge[startpoint];
      };
    })(startpoint);
  }
  if (endpoint == null) {
    endpoint = function(edge) {
      return edge.target;
    };
  } else if (typeof endpoint === 'string') {
    endpoint = (function(endpoint) {
      return function(edge) {
        return edge[endpoint];
      };
    })(endpoint);
  }
  if (distance == null) {
    distance = function(edge) {
      return 1;
    };
  } else if (typeof distance === 'number') {
    distance = (function(distance) {
      return function(edge) {
        return distance;
      };
    })(distance);
  } else if (typeof distance === 'string') {
    distance = (function(distance) {
      return function(edge) {
        return edge[distance];
      };
    })(distance);
  } else if (distance instanceof Array) {
    edge2distance = {};
    for (i = _i = 0, _len = edges.length; _i < _len; i = ++_i) {
      edge = edges[i];
      a = nodeid(startpoint(edge));
      b = nodeid(endpoint(edge));
      edge2distance[a + '_' + b] = distance[i];
    }
    distance = function(edge) {
      a = nodeid(startpoint(edge));
      b = nodeid(endpoint(edge));
      return edge2distance[a + '_' + b];
    };
  }
  nodes = {};
  for (_j = 0, _len1 = edges.length; _j < _len1; _j++) {
    edge = edges[_j];
    nodeA = startpoint(edge);
    nodeB = endpoint(edge);
    idA = nodeid(nodeA);
    idB = nodeid(nodeB);
    _ref = [nodeA, nodeB];
    for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
      node = _ref[_k];
      id = nodeid(node);
      if (!(id in nodes)) {
        nodes[id] = {
          node: node,
          outedges: []
        };
      }
    }
    nodes[idA].outedges.push(edge);
    if (!directed) {
      nodes[idB].outedges.push(edge);
    }
  }
  errormsg = null;
  if (edges.length === 0) {
    errormsg = 'The length of edges is 0';
  } else if (K < 0) {
    errormsg = 'K can not have negative value';
  } else if (distance(edges[0]) == null) {
    errormsg = 'Check the distance function/attribute';
  } else if (startpoint(edges[0]) == null) {
    errormsg = 'Check the startpoint function/attribute';
  } else if (endpoint(edges[0]) == null) {
    errormsg = 'Check the endpoint function/attribute';
  } else {
    id1 = nodeid(startpoint(edges[0]));
    if ((id1 == null) || ((_ref1 = typeof id1) !== 'string' && _ref1 !== 'number')) {
      errormsg = 'Check the nodeid function/attribute';
    } else if ((source != null) && !(source in nodes)) {
      errormsg = 'The source is not in the graph';
    } else if ((target != null) && !(target in nodes)) {
      errormsg = 'The target is not in the graph';
    }
  }
  if (errormsg != null) {
    d3plus.console.error(errormsg);
    return null;
  }
  return [
    edges, {
      source: source,
      target: target,
      directed: directed,
      distance: distance,
      nodeid: nodeid,
      startpoint: startpoint,
      endpoint: endpoint,
      K: K,
      nodes: nodes,
      vdebug: vdebug
    }
  ];
};


},{}],136:[function(require,module,exports){
var Heap;

Heap = require('heap');

d3plus.network.shortestPath = function(edges, source, options) {
  var K, a, alt, b, directed, distance, edge, endpoint, getPath, heap, id, maxsize, node, nodeid, nodes, path, res, result, startpoint, target, u, visited, _i, _j, _len, _len1, _ref, _ref1, _ref2;
  if (options == null) {
    options = {};
  }
  options.source = source;
  if ((options.nodes == null) || typeof options.nodes !== 'object') {
    _ref = d3plus.network.normalize(edges, options), edges = _ref[0], options = _ref[1];
    if (options === null) {
      return null;
    }
  }
  source = options.source, target = options.target, directed = options.directed, distance = options.distance, nodeid = options.nodeid, startpoint = options.startpoint, endpoint = options.endpoint, K = options.K, nodes = options.nodes;
  for (id in nodes) {
    node = nodes[id];
    node.count = 0;
  }
  heap = new Heap(function(a, b) {
    return a.distance - b.distance;
  });
  visited = {};
  if (target == null) {
    visited[source] = true;
  }
  heap.push({
    edge: null,
    target: source,
    distance: 0
  });
  maxsize = 0;
  result = [];
  while (!heap.empty()) {
    maxsize = Math.max(maxsize, heap.size());
    path = heap.pop();
    u = path.target;
    nodes[u].count++;
    if (target == null) {
      result.push(path);
    } else if (u === target) {
      result.push(path);
    }
    if (result.length === K) {
      break;
    }
    if (nodes[u].count <= K) {
      _ref1 = nodes[u].outedges;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        edge = _ref1[_i];
        a = nodeid(startpoint(edge));
        b = nodeid(endpoint(edge));
        if (!directed && b === u) {
          _ref2 = [b, a], a = _ref2[0], b = _ref2[1];
        }
        if (target == null) {
          if (visited[b]) {
            continue;
          }
          visited[b] = true;
        }
        alt = path.distance + distance(edge);
        heap.push({
          edge: edge,
          previous: path,
          target: b,
          distance: alt
        });
      }
    }
  }
  getPath = function(path) {
    edges = [];
    while (path.edge != null) {
      edges.push(path.edge);
      path = path.previous;
    }
    return edges.reverse();
  };
  for (_j = 0, _len1 = result.length; _j < _len1; _j++) {
    res = result[_j];
    if (target != null) {
      delete res.target;
      res.edges = getPath(res);
    }
    delete res.edge;
    delete res.previous;
  }
  return result;
};

module.exports = d3plus.network.shortestPath;


},{"heap":239}],137:[function(require,module,exports){
d3plus.network.subgraph = function(edges, source, options) {
  var K, dfs, directed, distance, edge, endpoint, id, nodeid, nodes, startpoint, visited, _ref;
  if (options == null) {
    options = {};
  }
  options.source = source;
  if ((options.nodes == null) || typeof options.nodes !== 'object') {
    _ref = d3plus.network.normalize(edges, options), edges = _ref[0], options = _ref[1];
    if (options === null) {
      return null;
    }
  }
  source = options.source, directed = options.directed, distance = options.distance, nodeid = options.nodeid, startpoint = options.startpoint, endpoint = options.endpoint, K = options.K, nodes = options.nodes;
  visited = {};
  visited[source] = true;
  dfs = function(origin, curr_distance) {
    var a, b, edge, new_distance, _i, _len, _ref1, _ref2, _results;
    _ref1 = nodes[origin].outedges;
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      edge = _ref1[_i];
      a = nodeid(startpoint(edge));
      b = nodeid(endpoint(edge));
      if (!directed && b === origin) {
        _ref2 = [b, a], a = _ref2[0], b = _ref2[1];
      }
      if (!(b in visited)) {
        new_distance = curr_distance + distance(edge);
        if (new_distance <= K) {
          visited[b] = true;
          _results.push(dfs(b, new_distance));
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };
  dfs(source, 0);
  return {
    nodes: (function() {
      var _results;
      _results = [];
      for (id in visited) {
        _results.push(nodes[id].node);
      }
      return _results;
    })(),
    edges: (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = edges.length; _i < _len; _i++) {
        edge = edges[_i];
        if (nodeid(startpoint(edge)) in visited && nodeid(endpoint(edge)) in visited) {
          _results.push(edge);
        }
      }
      return _results;
    })()
  };
};


},{}],138:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Formats numbers to look "pretty"
//------------------------------------------------------------------------------
d3plus.number.format = function( number , key , vars ) {

  if ( !vars && "getVars" in this) {
    var vars = this.getVars()
  }

  if ( vars && key && (
       ( key === vars.x.value && vars.x.scale.value === "log" ) ||
       ( key === vars.y.value && vars.y.scale.value === "log" ) ) ) {

    var superscript = ""
      , formatPower = function(d) {
          return (d + "").split("").map(function(c) {
            return superscript[c]
          }).join("")
        }

    return 10 + "" + formatPower( Math.round(Math.log(number) / Math.LN10) )

  }

  if ( "locale" in this ) {
    var locale = this.locale.value
      , time = locale.time
  }
  else {
    var locale = d3plus.locale.en_US
      , time = locale.time
  }

  if ( vars && typeof vars.time.value === "string") {
    time.push(vars.time.value)
  }

  if (key && time.indexOf(key.toLowerCase()) >= 0) {
    return number
  }
  else if (number < 10 && number > -10) {
    return d3.round(number,2)
  }
  else if (number.toString().split(".")[0].length > 4) {
    var symbol = d3.formatPrefix(number).symbol
    symbol = symbol.replace("G", "B") // d3 uses G for giga

    // Format number to precision level using proper scale
    number = d3.formatPrefix(number).scale(number)
    number = parseFloat(d3.format(".3g")(number))
    return number + symbol;
  }
  else if (key == "share") {
    return d3.format(".2f")(number)
  }
  else {
    return d3.format(",f")(number)
  }

}

},{}],139:[function(require,module,exports){
var d3selection;

d3selection = require("../util/d3selection.js");


/**
 * Merge two objects to create a new one with the properties of both
 */

d3plus.object.merge = function(obj1, obj2) {
  var copyObject, obj3;
  copyObject = function(obj, ret) {
    var a, _results;
    _results = [];
    for (a in obj) {
      if (typeof obj[a] !== "undefined") {
        if (d3plus.object.validate(obj[a])) {
          if (typeof ret[a] !== "object") {
            ret[a] = {};
          }
          _results.push(copyObject(obj[a], ret[a]));
        } else if (!d3selection(obj[a]) && obj[a] instanceof Array) {
          _results.push(ret[a] = obj[a].slice(0));
        } else {
          _results.push(ret[a] = obj[a]);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };
  obj3 = {};
  if (obj1) {
    copyObject(obj1, obj3);
  }
  if (obj2) {
    copyObject(obj2, obj3);
  }
  return obj3;
};

module.exports = d3plus.object.merge;


},{"../util/d3selection.js":undefined}],140:[function(require,module,exports){

/**
 * Checks to see if the passed object has keys and is not an array.
 */
d3plus.object.validate = function(obj) {
  return obj !== null && typeof obj === "object" && (!(obj instanceof Array));
};

module.exports = d3plus.object.validate;


},{}],141:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Formats a string similar to Python's "format"
//------------------------------------------------------------------------------
d3plus.string.format = function() {

  var args = Array.prototype.slice.call(arguments)
    , str = args.shift()

  str.unkeyed_index = 0;
  return str.replace(/\{(\w*)\}/g, function(match, key) {
      if (key === '') {
          key = str.unkeyed_index;
          str.unkeyed_index++
      }
      if (key == +key) {
          return args[key] !== 'undefined'
              ? args[key]
              : match;
      } else {
          for (var i = 0; i < args.length; i++) {
              if (typeof args[i] === 'object' && typeof args[i][key] !== 'undefined') {
                  return args[i][key];
              }
          }
          return match;
      }
  }.bind(str));

}

},{}],142:[function(require,module,exports){

/**
 * Converts an array of strings into a string list using commas and "and".
 */
d3plus.string.list = function(list, andText, max, moreText) {
  var amount;
  if (!(list instanceof Array)) {
    return list;
  } else {
    list = list.slice(0);
  }
  if (!andText) {
    andText = d3plus.locale.en_US.ui.and;
  }
  if (!moreText) {
    moreText = d3plus.locale.en_US.ui.moreText;
  }
  if (list.length === 2) {
    return list.join(" " + andText + " ");
  } else {
    if (max && list.length > max) {
      amount = list.length - max + 1;
      list = list.slice(0, max - 1);
      list[max - 1] = d3plus.string.format(moreText, amount);
    }
    if (list.length > 1) {
      list[list.length - 1] = andText + " " + list[list.length - 1];
    }
    return list.join(", ");
  }
};


},{}],143:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Removes all non ASCII characters
//------------------------------------------------------------------------------
d3plus.string.strip = function(str) {

  var removed = [ "!","@","#","$","%","^","&","*","(",")",
                  "[","]","{","}",".",",","/","\\","|",
                  "'","\"",";",":","<",">","?","=","+"]
  str += ""

  return ""+str.replace(/[^A-Za-z0-9\-_]/g, function(chr) {

    if (" " == chr) {
      return "_"
    }
    else if (removed.indexOf(chr) >= 0) {
      return ""
    }

    var diacritics = [
        [/[\300-\306]/g, "A"],
        [/[\340-\346]/g, "a"],
        [/[\310-\313]/g, "E"],
        [/[\350-\353]/g, "e"],
        [/[\314-\317]/g, "I"],
        [/[\354-\357]/g, "i"],
        [/[\322-\330]/g, "O"],
        [/[\362-\370]/g, "o"],
        [/[\331-\334]/g, "U"],
        [/[\371-\374]/g, "u"],
        [/[\321]/g, "N"],
        [/[\361]/g, "n"],
        [/[\307]/g, "C"],
        [/[\347]/g, "c"],
    ];

    var ret = ""

    for ( var d in diacritics ) {

      if (diacritics[d][0].test(chr)) {
        ret = diacritics[d][1]
        break;
      }

    }

    return ret;

  });

}

},{}],144:[function(require,module,exports){

/**
 * Formats numbers to look "pretty"
 */
d3plus.string.title = function(text, key, vars) {
  var bigs, locale, smalls;
  if (!text) {
    return "";
  }
  if ("locale" in this) {
    locale = this.locale.value;
    if (typeof locale === "string") {
      locale = (locale in d3plus.locale ? d3plus.locale[locale] : d3plus.locale.en_US);
    }
  } else {
    locale = d3plus.locale.en_US;
  }
  if (text.charAt(text.length - 1) === ".") {
    return text.charAt(0).toUpperCase() + text.substr(1);
  }
  smalls = locale.lowercase;
  bigs = locale.uppercase;
  return text.replace(/\S*/g, function(txt, i) {
    if (bigs.indexOf(txt.toLowerCase()) >= 0) {
      return txt.toUpperCase();
    } else {
      if (smalls.indexOf(txt.toLowerCase()) >= 0 && i !== 0 && i !== text.length - 1) {
        return txt.toLowerCase();
      }
    }
    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
  });
};


},{}],145:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// D3plus Default Color Scheme
// Created by Dave Landry
//------------------------------------------------------------------------------
d3plus.style.default = {}

d3plus.style.default.fontFamily = [ "Helvetica Neue"
                                  , "HelveticaNeue"
                                  , "Helvetica"
                                  , "Arial"
                                  , "sans-serif" ]

},{}],146:[function(require,module,exports){
d3plus.style.default.axes = {
  "ticks" : {
    "color" : "#ccc",
    "font"  : {
      "color"      : "#888",
      "decoration" : {
        "accepted": [ "line-through" , "none" , "overline" , "underline" ],
        "value": "none"
      },
      "family"     : d3plus.style.fontFamily(d3plus.style.default.fontFamily),
      "size"       : 10,
      "transform"  : {
        "accepted" : [ "capitalize" , "lowercase" , "none" , "uppercase" ],
        "value"    : "none"
      },
      "weight"     : 200
    },
    "size"  : 10,
    "width" : 1
  }
}

},{}],147:[function(require,module,exports){
d3plus.style.default.background = {
  "accepted" : [ String ],
  "value"    : "#ffffff"
}

},{}],148:[function(require,module,exports){
d3plus.style.default.color = {
  "heatmap"   : [ "#27366c" , "#7b91d3" , "#9ed3e3"
                , "#f3d261" , "#c9853a" , "#d74b03" ],
  "focus"     : "#444444",
  "missing"   : "#eeeeee",
  "primary"   : "#d74b03",
  "range"     : [ "#d74b03" , "#eeeeee" , "#94b153" ],
  "scale"     : {
    "accepted": [ Array, "d3plus", "category10", "category20", "category20b", "category20c" ],
    "process": function(value) {

      if (value instanceof Array) {
        return d3.scale.ordinal().range(value)
      }
      else {
        if (value === "d3plus") {
          return d3plus.color.scale
        }
        else {
          console.log("Here!")
          return d3.scale[value]()
        }
      }

    },
    "value": "d3plus"
  },
  "secondary" : "#e5b3bb"
}

},{}],149:[function(require,module,exports){
d3plus.style.default.coords = {
  "center"     : [ 0 , 0 ],
  "fit"        : {
    "accepted" : [ "auto" , "height" , "width" ],
    "value"    : "auto"
  },
  "padding"    : 20,
  "projection" : {
    "accepted" : [ "mercator" , "equirectangular" ],
    "value"    : "mercator"
  },
  "threshold"  : 0.1
}

},{}],150:[function(require,module,exports){
d3plus.style.default.data = {
  "donut"   : {
    "size" : 0.35
  },
  "large"   : 400,
  "opacity" : 0.9,
  "stroke"  : {
    "width" : 1
  }
}

},{}],151:[function(require,module,exports){
d3plus.style.default.edges = {
  "arrows"  : {
    "accepted"  : [ Boolean , Number ],
    "direction" : {
      "accepted" : [ "source" , "target" ],
      "value"    : "target"
    },
    "value"     : false
  },
  "color"   : "#d0d0d0",
  "large"       : 100,
  "limit"       : false,
  "opacity" : 1,
  "width"   : 1
}

},{}],152:[function(require,module,exports){
d3plus.style.default.font = {
  "align"      : {
    "accepted" : [ "left" , "center" , "right" ],
    "process"  : function ( value ) {

      return d3plus.rtl ? value === "left" ? "right"
                        : value === "right" ? "left"
                        : value : value

    },
    "value"    : "left"
  },
  "color"      : "#444444",
  "decoration" : {
    "accepted" : [ "line-through" , "none" , "overline" , "underline" ],
    "value"    : "none"
  },
  "family"     : d3plus.style.fontFamily(d3plus.style.default.fontFamily),
  "secondary"  : {
    "align"      : {
      "accepted" : [ "left" , "center" , "right" ],
      "process"  : function ( value ) {

        return d3plus.rtl ? value === "left" ? "right"
                          : value === "right" ? "left"
                          : value : value

      },
      "value"    : "left"
    },
    "color"      : "#444444",
    "decoration" : {
      "accepted" : [ "line-through" , "none" , "overline" , "underline" ],
      "value"    : "none"
    },
    "family"     : d3plus.style.fontFamily(d3plus.style.default.fontFamily),
    "size"       : 12,
    "spacing"    : 0,
    "transform"  : {
      "accepted" : [ "capitalize" , "lowercase" , "none" , "uppercase" ],
      "value"    : "none"
    },
    "weight"     : 200
  },
  "size"       : 12,
  "spacing"    : 0,
  "transform"  : {
    "accepted" : [ "capitalize" , "lowercase" , "none" , "uppercase" ],
    "value"    : "none"
  },
  "weight"     : 200
}

},{}],153:[function(require,module,exports){
d3plus.style.default.footer = {
  "font"     : {
    "align"      : "center",
    "color"      : "#444",
    "decoration" : {
      "accepted" : [ "line-through" , "none" , "overline" , "underline" ],
      "value"    : "none"
    },
    "family"     : d3plus.style.fontFamily(d3plus.style.default.fontFamily),
    "size"       : 11,
    "transform"  : {
      "accepted" : [ "capitalize" , "lowercase" , "none" , "uppercase" ],
      "value"    : "none"
    },
    "weight"     : 200
  },
  "padding"  : 0,
  "position" : "bottom"
}

},{}],154:[function(require,module,exports){
d3plus.style.default.height = {
  "small" : 300,
  "max"   : 600
}

},{}],155:[function(require,module,exports){
d3plus.style.default.icon = {
  "back"   : {
    "accepted" : [ false , String ],
    "fallback" : "&#x276e;",
    "opacity"  : 1,
    "process"  : function ( value ) {

      var fallback = this.fallback
      return d3plus.style.default.icon.fontCheck( value , fallback )

    },
    "rotate"   : 0,
    "value"    : "fa-angle-left"
  },
  "button" : {
    "accepted" : [ false , String ],
    "fallback" : false,
    "opacity"  : 1,
    "process"  : function ( value ) {

      var fallback = this.fallback
      return d3plus.style.default.icon.fontCheck( value , fallback )

    },
    "rotate"   : 0,
    "value"    : false
  },
  "drop"   : {
    "accepted" : [ false , String ],
    "fallback" : "&#x276f;",
    "opacity"  : 1,
    "process"  : function ( value ) {

      var fallback = this.fallback
      return d3plus.style.default.icon.fontCheck( value , fallback )

    },
    "rotate"   : 0,
    "value"    : "fa-angle-down"
  },
  "fontCheck": function ( value , fallback ) {

    if ( value === false
         || ( value.indexOf("fa-") === 0 && d3plus.font.awesome )
         || value.indexOf("fa-") < 0 ) {
      return value
    }
    else {
      return fallback
    }

  },
  "next"   : {
    "accepted" : [ false , String ],
    "fallback" : "&#x276f;",
    "opacity"  : 1,
    "process"  : function ( value ) {

      var fallback = this.fallback
      return d3plus.style.default.icon.fontCheck( value , fallback )

    },
    "rotate"   : 0,
    "value"    : "fa-angle-right"
  },
  "select" : {
    "accepted" : [ false , String ],
    "fallback" : "&#x2713;",
    "opacity"  : 1,
    "process"  : function ( value ) {

      var fallback = this.fallback
      return d3plus.style.default.icon.fontCheck( value , fallback )

    },
    "rotate"   : 0,
    "value"    : "fa-check"
  }
}

},{}],156:[function(require,module,exports){
d3plus.style.default.labels = {
  "align"    : "middle",
  "font"     : {
    "decoration" : {
      "accepted" : [ "line-through" , "none" , "overline" , "underline" ],
      "value"    : "none"
    },
    "family"     : d3plus.style.fontFamily(d3plus.style.default.fontFamily),
    "size"       : 11,
    "transform"  : {
      "accepted" : [ "capitalize" , "lowercase" , "none" , "uppercase" ],
      "value"    : "none"
    },
    "weight"     : 200
  },
  "padding"  : 7,
  "segments" : 2
}

},{}],157:[function(require,module,exports){
d3plus.style.default.legend = {
  "align"    : "middle",
  "font"     : {
    "align"  : "middle",
    "color"  : "#444444",
    "family" : d3plus.style.fontFamily(d3plus.style.default.fontFamily),
    "size"   : 10,
    "weight" : 200
  },
  "gradient" : {
    "height" : 10
  },
  "order"    : {
    "accepted" : [ "color" , "id" , "size" , "text" ],
    "sort"     : {
      "accepted" : [ "asc" , "desc" ],
      "value"    : "asc"
    },
    "value"    : "color"
  },
  "size"     : [ 8 , 30 ]
}

},{}],158:[function(require,module,exports){
d3plus.style.default.links = {
  "font"  : {
    "color"      : "#444444",
    "decoration" : {
      "accepted" : [ "line-through" , "none" , "overline" , "underline" ],
      "value"    : "none"
    },
    "family"     : d3plus.style.fontFamily(d3plus.style.default.fontFamily),
    "transform"  : {
      "accepted" : [ "capitalize" , "lowercase" , "none" , "uppercase" ],
      "value"    : "none"
    },
    "weight"     : 200
  },
  "hover" : {
    "color"      : "#444444",
    "decoration" : {
      "accepted" : [ "line-through" , "none" , "overline" , "underline" ],
      "value"    : "underline"
    },
    "family"     : d3plus.style.fontFamily(d3plus.style.default.fontFamily),
    "transform"  : {
      "accepted" : [ "capitalize" , "lowercase" , "none" , "uppercase" ],
      "value"    : "none"
    },
    "weight"     : 200
  }
}

},{}],159:[function(require,module,exports){
d3plus.style.default.messages = {
  "font" : {
    "color"      : "#444",
    "decoration" : {
      "accepted" : [ "line-through" , "none" , "overline" , "underline" ],
      "value"    : "none"
    },
    "family"     : d3plus.style.fontFamily(d3plus.style.default.fontFamily),
    "size"       : 16,
    "transform"  : {
      "accepted" : [ "capitalize" , "lowercase" , "none" , "uppercase" ],
      "value"    : "none"
    },
    "weight"     : 200
  },
  "padding": 5
}

},{}],160:[function(require,module,exports){
d3plus.style.default.nodes = {
  "overlap" : 0.6
}

},{}],161:[function(require,module,exports){
d3plus.style.default.shape = {
  "interpolate" : {
    "accepted"   : [ "basis" , "basis-open" , "cardinal"
                   , "cardinal-open" , "linear" , "monotone"
                   , "step" , "step-before" , "step-after" ],
    "deprecates" : "stack_type",
    "value"      : "linear"
  },
  "rendering"   : {
    "accepted" : [ "auto" , "optimizeSpeed" , "crispEdges" , "geometricPrecision" ],
    "value"    : "auto"
  }
}

},{}],162:[function(require,module,exports){
d3plus.style.default.timeline = {
  "align"      : "middle",
  "hover": {
    "accepted": [ "all-scroll", "col-resize", "crosshair", "default", "grab", "grabbing", "move", "pointer" ],
    "value": "pointer"
  },
  "handles"    : {
    "accepted" : [ Boolean ],
    "color"    : "#e5e5e5",
    "hover"    : "#cccccc",
    "opacity"  : 1,
    "size"     : 2,
    "stroke"   : "#818181",
    "value"    : true
  },
  "height"    : {
    "accepted": [ Number ],
    "value": 23
  },
  "tick"      : "#818181"
}

},{}],163:[function(require,module,exports){
d3plus.style.default.timing = {
  "mouseevents" : 60,
  "transitions" : 600,
  "ui"          : 200
}

},{}],164:[function(require,module,exports){
d3plus.style.default.title = {
  "font"     : {
    "align"      : "center",
    "color"      : "#444444",
    "decoration" : {
      "accepted" : [ "line-through" , "none" , "overline" , "underline" ],
      "value"    : "none"
    },
    "family"     : d3plus.style.fontFamily(d3plus.style.default.fontFamily),
    "size"       : 16,
    "transform"  : {
      "accepted" : [ "capitalize" , "lowercase" , "none" , "uppercase" ],
      "value"    : "none"
    },
    "weight"     : 400
  },
  "height"   : false,
  "padding"  : 2,
  "position" : "top",
  "sub"      : {
    "font"     : {
      "align"      : "center",
      "color"      : "#444444",
      "decoration" : {
        "accepted" : [ "line-through" , "none" , "overline" , "underline" ],
        "value"    : "none"
      },
      "family"     : d3plus.style.fontFamily(d3plus.style.default.fontFamily),
      "size"       : 12,
      "transform"  : {
        "accepted" : [ "capitalize" , "lowercase" , "none" , "uppercase" ],
        "value"    : "none"
      },
      "weight"     : 200
    },
    "padding"  : 1,
    "position" : "top"
  },
  "total"    : {
    "font"     : {
      "align"      : "center",
      "color"      : "#444444",
      "decoration" : {
        "accepted" : [ "line-through" , "none" , "overline" , "underline" ],
        "value"    : "none"
      },
      "family"     : d3plus.style.fontFamily(d3plus.style.default.fontFamily),
      "size"       : 12,
      "transform"  : {
        "accepted" : [ "capitalize" , "lowercase" , "none" , "uppercase" ],
        "value"    : "none"
      },
      "weight"     : 200
    },
    "padding"  : 1,
    "position" : "top"
  },
  "width"    : false
}

},{}],165:[function(require,module,exports){
d3plus.style.default.tooltip = {
  "anchor"      : "top center",
  "background"  : "#ffffff",
  "children"    : {
    "accepted" : [ Boolean ],
    "value"    : true
  },
  "connections" : {
    "accepted" : [ Boolean ],
    "value"    : true
  },
  "curtain"     : {
    "color"   : "#ffffff",
    "opacity" : 0.8
  },
  "font"        : {
    "color"     : "#444",
    "family"    : d3plus.style.fontFamily(d3plus.style.default.fontFamily),
    "size"      : 12,
    "transform" : {
      "accepted" : [ "capitalize" , "lowercase" , "none" , "uppercase" ],
      "value"    : "none"
    },
    "weight"    : 200
  },
  "large"       : 250,
  "share"       : {
    "accepted" : [ Boolean ],
    "value"    : true
  },
  "size"        : {
    "accepted" : [ Boolean ],
    "value"    : true
  },
  "small"      : 225
}

},{}],166:[function(require,module,exports){
d3plus.style.default.ui = {
  "align"    : {
    "accepted" : [ "left" , "center" , "right" ],
    "process"  : function ( value ) {

      return d3plus.rtl ? value === "left" ? "right"
                        : value === "right" ? "left"
                        : value : value

    },
    "value"    : "center"
  },
  "border"   : 1,
  "color"    : {
    "primary"   : {
      "process" : function ( value ) {

        var vars = this.getVars()
          , primary = this.value
          , secondary = vars.ui.color.secondary.value

        if ( !secondary || secondary === d3.rgb(primary).darker(2).toString() ) {
          vars.ui.color.secondary.value = d3.rgb(value).darker(2).toString()
        }

        return value

      },
      "value"   : "#ffffff"
    },
    "secondary" : {
      "value" : false
    }
  },
  "display"  : {
    "acceped" : [ "block" , "inline-block" ],
    "value"   : "inline-block"
  },
  "font"     : {
    "align"      : "center",
    "color"      : "#444",
    "decoration" : {
      "accepted" : [ "line-through" , "none" , "overline" , "underline" ],
      "value"    : "none"
    },
    "family"     : d3plus.style.fontFamily(d3plus.style.default.fontFamily),
    "size": 11,
    "transform"  : {
      "accepted" : [ "capitalize" , "lowercase" , "none" , "uppercase" ],
      "value"    : "none"
    },
    "weight"     : 200
  },
  "margin"   : 5,
  "padding"  : 5,
  "position" : {
    "accepted" : [ "top" , "right" , "bottom" , "left" ],
    "value"    : "bottom"
  }
}

},{}],167:[function(require,module,exports){
d3plus.style.default.width = {
  "small" : 400
}

},{}],168:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Constructs font family property using the validate function
//------------------------------------------------------------------------------
d3plus.style.fontFamily = function( family ) {

  return {
    "process": d3plus.font.validate,
    "value": family
  }

}

},{}],169:[function(require,module,exports){
d3plus.style.sheet = function(name) {
  var i, returnBoolean, sheet;
  i = 0;
  returnBoolean = false;
  while (i < document.styleSheets.length) {
    sheet = document.styleSheets[i];
    if (sheet.href && sheet.href.indexOf(name) >= 0) {
      returnBoolean = true;
      break;
    }
    i++;
  }
  return returnBoolean;
};

module.exports = d3plus.style.sheet;


},{}],170:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Flows the text into the container
//------------------------------------------------------------------------------
d3plus.textwrap.flow = function( vars ) {

  if ( vars.text.html.value ) {
    this.foreign( vars )
  }
  else {
    this.tspan( vars )
  }

}

},{}],171:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Flows the text as a foreign element.
//------------------------------------------------------------------------------
d3plus.textwrap.foreign = function( vars ) {

  var text = vars.container.value
    , family = text.attr( "font-family" ) || text.style( "font-family" )
    , anchor = text.attr( "text-anchor" ) || text.style( "text-anchor" )
    , color = text.attr( "fill" ) || text.style( "fill" )
    , opacity = text.attr( "opacity" ) || text.style( "opacity" )

  anchor = anchor === "end"    ? "right"
         : anchor === "middle" ? "center"
         : "left"

  d3.select( text.node().parentNode ).append( "foreignObject" )
    .attr( "width"  , vars.width.value + "px" )
    .attr( "height" , vars.height.value + "px" )
    .attr( "x"      , "0px" )
    .attr( "y"      , "0px" )
    .append( "xhtml:div" )
      .style( "font-family" , family )
      .style( "font-size"   , vars.size.value[1] )
      .style( "color" , color )
      .style( "text-align" , anchor )
      .style( "opacity" , opacity )
      .text( vars.text.current )

}

},{}],172:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Checks width and height, and gets it if needed.
//------------------------------------------------------------------------------
d3plus.textwrap.getDimensions = function( vars ) {

  if ( !vars.width.value || !vars.height.value ) {

    var parent = d3.select(vars.container.value.node().parentNode)
      , rect   = parent.select("rect")
      , circle = parent.select("circle")

    if ( !rect.empty() ) {

      if ( !vars.width.value ) {
        var width = rect.attr("width") || rect.style("width")
        vars.self.width( parseFloat( width , 10 ) )
      }
      if ( !vars.height.value ) {
        var height = rect.attr("height") || rect.style("height")
        vars.self.height( parseFloat( height , 10 ) )
      }

    }
    else if ( !circle.empty() ) {

      var radius = circle.attr("r")

      if ( !vars.width.value ) {
        vars.self.width( parseFloat( radius * 2 , 10 ) )
      }
      if ( !vars.height.value ) {
        vars.self.height( parseFloat( radius * 2 , 10 ) )
      }

    }
    else {

      if ( !vars.width.value ) {
        vars.self.width(500)
      }
      if ( !vars.height.value ) {
        vars.self.height(500)
      }

    }
  }

}

},{}],173:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Fetches text if not specified, and formats text to array.
//------------------------------------------------------------------------------
d3plus.textwrap.getSize = function( vars ) {

  var size = vars.container.value.attr("font-size")
             || vars.container.value.style("font-size")

  if ( !vars.size.value ) {

    size = parseFloat( size , 10 )

    if ( vars.resize.value ) {
      vars.self.size( [ size , size*2 ] )
    }
    else {
      vars.self.size( [ size/2 , size ] )
    }

  }

  vars.container.fontSize = size

}

},{}],174:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Fetches text if not specified, and formats text to array.
//------------------------------------------------------------------------------
d3plus.textwrap.getText = function( vars ) {

  if ( !vars.text.value ) {

    var text = vars.container.value.text()

    if (text) {

      if ( text.indexOf("tspan") >= 0 ) {
        text.replace(/\<\/tspan\>\<tspan\>/g," ")
        text.replace(/\<\/tspan\>/g,"")
        text.replace(/\<tspan\>/g,"")
      }

      vars.self.text( text )

    }

  }

  if ( vars.text.value instanceof Array ) {
    vars.text.phrases = vars.text.value.filter(function(t){
      return [ "string" , "number" ].indexOf(typeof t) >= 0
    })
  }
  else {
    vars.text.phrases = [ vars.text.value + "" ]
  }

  vars.container.value.text("")

}

},{}],175:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Logic to determine the best size for text
//------------------------------------------------------------------------------
d3plus.textwrap.resize = function( vars , line ) {

  if ( vars.resize.value ) {

    var words = []
    for ( var i = 0 ; i < vars.text.words.length ; i++ ) {
      var addon = i === vars.text.words.length - 1 ? "" : " "
      words.push( vars.text.words[i] + addon )
    }

    // Start by trying the largest font size
    var sizeMax   = Math.floor( vars.size.value[1] )
      , lineWidth = vars.shape.value === "circle" ? vars.width.value * 0.785
                  : vars.width.value
      , sizes     = d3plus.font.sizes( words
                                     , { "font-size" : sizeMax + "px" }
                                     , vars.container.value )
      , maxWidth  = d3.max( sizes , function(d){ return d.width } )
      , areaMod   = 1.165 + (vars.width.value/vars.height.value*0.037)
      , textArea  = d3.sum( sizes , function(d){ return d.width * d.height } ) * areaMod
      , boxArea   = vars.shape.value === "circle"
                  ? Math.PI * Math.pow( vars.width.value / 2 , 2 )
                  : lineWidth * vars.height.value

    if ( maxWidth > lineWidth || textArea > boxArea ) {

      var areaRatio  = Math.sqrt( boxArea / textArea )
        , widthRatio = lineWidth / maxWidth
        , sizeRatio  = d3.min([ areaRatio , widthRatio ])

      sizeMax = d3.max([ vars.size.value[0] , Math.floor( sizeMax * sizeRatio ) ])

    }

    var heightMax = Math.floor(vars.height.value * 0.8)

    if ( sizeMax > heightMax ) {
      sizeMax = heightMax
    }

    if ( maxWidth * (sizeMax/vars.size.value[1]) <= lineWidth ) {

      if ( sizeMax !== vars.size.value[1] ) {
        vars.self.size([ vars.size.value[0] , sizeMax ])
      }

      vars.container.value.attr( "font-size" , vars.size.value[1]+"px" )
      this.flow( vars )

    }
    else {
      this.wrap( vars )
    }

  }

}

},{}],176:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Flows the text into tspans
//------------------------------------------------------------------------------
d3plus.textwrap.tspan = function( vars ) {

  var xPosition  = vars.container.value.attr("x") || "0px"
    , words      = vars.text.words.slice(0)
    , tspans     = false
    , fontSize   = vars.resize.value ? vars.size.value[1] : vars.container.fontSize || vars.size.value[0]
    , textBox    = vars.container.value.append("tspan").text( words[0] )
                     .attr( "dy" , fontSize + "px" )
    , textHeight = textBox.node().offsetHeight || textBox.node().getBoundingClientRect().height
    , line       = 1
    , newLine    = function( ) {
      return vars.container.value.append("tspan")
              .attr( "x" , xPosition )
              .attr( "dy" , fontSize + "px" )
    }
    , truncate   = function( ) {

      if ( !textBox.empty() ) {

        words = textBox.text().match(/[^\s-]+-?/g)

        ellipsis()

      }

    }
    , ellipsis   = function( ) {

      if ( words && words.length ) {

        var lastWord = words.pop()
          , lastChar = lastWord.charAt( lastWord.length-1 )

        if ( lastWord.length === 1
        && vars.text.split.indexOf( lastWord ) >= 0 ) {
          ellipsis()
        }
        else {

          if ( vars.text.split.indexOf( lastChar ) >= 0 ) {
            lastWord = lastWord.substr( 0 , lastWord.length - 1 )
          }

          textBox.text( words.join(" ") + " " + lastWord + " ..." )

          var baseline = (line-1) * textHeight
            , lineWidth = vars.shape.value === "circle"
                        ? 2*Math.sqrt( baseline*( (2*(vars.width.value/2))-baseline ) )
                        : vars.width.value

          if ( textBox.node().getComputedTextLength() > lineWidth ) {
            ellipsis()
          }

        }

      }
      else {

        textBox.remove()
        textBox = d3.select( vars.container.value.node().lastChild )
        if ( !textBox.empty() ) {
          line--
          truncate()
        }

      }

    }

  if ( vars.shape.value === "circle" ) {
    vars.container.value.attr( "text-anchor" , "middle" )
  }

  for ( var i = 1 ; i < words.length ; i++ ) {

    if ( line * textHeight > vars.height.value ) {
      textBox.remove()
      if ( i !== 1 ) {
        textBox = d3.select( vars.container.value.node().lastChild )
        if ( !textBox.empty() ) truncate()
      }
      break

    }

    var current   = textBox.text()
      , lastChar = current.slice(-1)
      , next_char = vars.text.current.charAt( vars.text.current.indexOf(current) + current.length )
      , joiner    = next_char == " " ? " " : ""

    textBox.text( current + joiner + words[i] )


    var baseline = (line-1) * textHeight
      , lineWidth = vars.shape.value === "circle"
                  ? 2*Math.sqrt( baseline*( (2*(vars.width.value/2))-baseline ) )
                  : vars.width.value

    if ( textBox.node().getComputedTextLength() > lineWidth ) {

      if ( !tspans ) {
        textBox.text("")
        textBox = newLine()
      }

      textBox.text( current )

      textBox = newLine()
      textBox.text( words[i] )

      line++

    }

  }

}

},{}],177:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Flows the text into the container
//------------------------------------------------------------------------------
d3plus.textwrap.wrap = function( vars ) {

  if ( vars.text.phrases.length ) {

    vars.text.current = vars.text.phrases.shift() + ""
    vars.text.words   = vars.text.current.match(vars.text.break)

    if ( vars.resize.value ) {
      this.resize( vars )
    }
    else {
      this.flow( vars )
    }

  }

}

},{}],178:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Word wraps SVG text
//------------------------------------------------------------------------------
d3plus.textwrap = function() {

  var vars = { "shell" : "textwrap" }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Main drawing function
  //----------------------------------------------------------------------------
  vars.self = function(selection) {

    selection.each(function() {

      d3plus.textwrap.getDimensions( vars )
      d3plus.textwrap.getSize( vars )

      if ( vars.size.value[0] <= vars.height.value ) {
        d3plus.textwrap.getText( vars )
        d3plus.textwrap.wrap( vars )
      }

    })

    return vars.self
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Define methods and expose public variables.
  //----------------------------------------------------------------------------
  var methods = [ "container" , "dev" , "draw" , "format" , "height"
                , "resize" , "text" , "shape" , "size" , "width" ]
  d3plus.method( vars , methods )

  return vars.self

}

},{}],179:[function(require,module,exports){
var fetchValue = require("../core/fetch/value.js"),
    fetchColor = require("../core/fetch/color.js"),
    fetchText  = require("../core/fetch/text.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates correctly formatted tooltip for Apps
//-------------------------------------------------------------------
d3plus.tooltip.app = function(params) {

  if ( !( "d3plus" in params.data ) ) {
    params.data.d3plus = {}
  }

  var vars = params.vars,
      d = params.data,
      dataDepth = "d3plus" in d && "depth" in d.d3plus ? d.d3plus.depth : vars.depth.value,
      ex = params.ex,
      mouse = params.mouseevents ? params.mouseevents : false,
      arrow = "arrow" in params ? params.arrow : true,
      id = fetchValue(vars,d,vars.id.value),
      tooltip_id = params.id || vars.type.value

  if ((d3.event && d3.event.type == "click") && (vars.tooltip.html.value || vars.tooltip.value.long) && !("fullscreen" in params)) {
    var fullscreen = true,
        arrow = false,
        mouse = true,
        length = "long",
        footer = vars.footer.value

    vars.covered = true
  }
  else {
    var fullscreen = false,
        align = params.anchor || vars.tooltip.anchor,
        length = params.length || "short",
        zoom = vars.zoom.direction(d)

    if (zoom === -1) {
      var key = vars.id.nesting[dataDepth-1],
          parent = fetchValue(vars,id,key)
    }

    if (zoom === 1 && vars.zoom.value) {
      var text = vars.format.value(vars.format.locale.value.ui.expand)
    }
    else if (zoom === -1 && vars.zoom.value && vars.history.states.length) {
      var text = vars.format.value(vars.format.locale.value.ui.collapse)
    }
    else if (!vars.small && length == "short" && (vars.tooltip.html.value || vars.tooltip.value.long) && (vars.focus.value.length !== 1 || vars.focus.value[0] != id)) {
      var text = vars.format.locale.value.ui.moreInfo
    }
    else if (length == "long") {
      var text = vars.footer.value || ""
    }
    else {
      var text = ""
    }

    var footer = text.length ? vars.format.value(text,"footer") : false

  }

  if ("x" in params) {
    var x = params.x
  }
  else if (vars.types[vars.type.value].tooltip == "follow") {
    var x = d3.mouse(vars.container.value.node())[0]
  }
  else {
    var x = d.d3plus.x
    if (vars.zoom.translate && vars.zoom.scale) {
      x = vars.zoom.translate[0]+x*vars.zoom.scale
    }
    x += vars.margin.left
  }

  if ("y" in params) {
    var y = params.y
  }
  else if (vars.types[vars.type.value].tooltip == "follow") {
    var y = d3.mouse(vars.container.value.node())[1]
  }
  else {
    var y = d.d3plus.y
    if (vars.zoom.translate && vars.zoom.scale) {
      y = vars.zoom.translate[1]+y*vars.zoom.scale
    }
    y += vars.margin.top
  }

  if ("offset" in params) {
    var offset = params.offset
  }
  else if (vars.types[vars.type.value].tooltip == "follow") {
    var offset = 3
  }
  else {
    var offset = d.d3plus.r ? d.d3plus.r : d.d3plus.height/2
    if (vars.zoom.scale) {
      offset = offset * vars.zoom.scale
    }
  }

  function make_tooltip(html) {

    var ex = {}
      , children = {}
      , depth     = vars.id.nesting[dataDepth+1] in d ? dataDepth+1 : dataDepth
      , nestKey   = vars.id.nesting[depth]
      , nameList  = "merged" in d.d3plus ? d.d3plus.merged : d[nestKey]
      , dataValue = fetchValue( vars , d , vars.size.value )
      , same = (!(nameList instanceof Array) || (nameList instanceof Array && nameList.length === 1)) && depth === vars.depth.value

    if ( !same && vars.tooltip.children.value ) {

      if ( nameList instanceof Array ) {

        nameList = nameList.slice(0)

        if (vars.size.value && d3plus.object.validate(nameList[0])) {

          var namesWithValues = nameList.filter(function(n){
            return vars.size.value in n
          })

          var namesNoValues = nameList.filter(function(n){
            return !(vars.size.value in n)
          })

          d3plus.array.sort( namesWithValues , vars.size.value , "desc" , [] , vars )

          nameList = namesWithValues.concat(namesNoValues)

        }

        var limit = length === "short" ? 3 : vars.data.large
          , max   = d3.min([nameList.length , limit])
          , objs  = []

        for ( var i = 0 ; i < max ; i++ ) {

          var id    = nameList[i]
            , name  = fetchText( vars , id , depth )[0]
            , value = fetchValue( vars , id , vars.size.value , nestKey )
            , color = fetchColor( vars , id , nestKey )

          children[name] = value ? vars.format.value( value , vars.size.value ) : ""

          if ( color ) {
            if ( !children.d3plus_colors ) children.d3plus_colors = {}
            children.d3plus_colors[name] = color
          }

        }

        if ( nameList.length > max ) {
          children.d3plusMore = nameList.length - max
        }

      }
      else if ( nameList && nameList !== "null" ) {

        var name  = fetchText( vars , nameList , depth )[0]
        children[name] = dataValue ? vars.format.value( dataValue , vars.size.value ) : ""

      }

    }

    if ( vars.size.value && vars.tooltip.size.value && dataValue && ( same || !nameList || nameList instanceof Array ) ) {
      ex[vars.size.value] = dataValue
    }

    var active = vars.active.value ? fetchValue(vars,d,vars.active.value) : d.d3plus.active,
        temp = vars.temp.value ? fetchValue(vars,d,vars.temp.value) : d.d3plus.temp,
        total = vars.total.value ? fetchValue(vars,d,vars.total.value) : d.d3plus.total

    if (typeof active == "number" && active > 0 && total) {
      var label = vars.active.value || "active"
      ex[label] = active+"/"+total+" ("+vars.format.value((active/total)*100,"share")+"%)"
    }

    if (typeof temp == "number" && temp > 0 && total) {
      var label = vars.temp.value || "temp"
      ex[label] = temp+"/"+total+" ("+vars.format.value((temp/total)*100,"share")+"%)"
    }

    if ( vars.tooltip.share.value && d.d3plus.share ) {
      ex.share = vars.format.value(d.d3plus.share*100,"share")+"%"
    }

    var depth = "depth" in params ? params.depth : dataDepth,
        title = params.title || fetchText(vars,d,depth)[0],
        icon = fetchValue(vars,d,vars.icon.value,vars.id.nesting[depth]),
        tooltip_data = d3plus.tooltip.data(vars,d,length,ex,children,depth)

    if (icon === "null") icon = false

    if ((tooltip_data.length > 0 || footer) || ((!d.d3plus_label && length == "short" && title) || (d.d3plus_label && (!("visible" in d.d3plus_label) || ("visible" in d.d3plus_label && d.d3plus_label.visible === false))))) {

      if (!title) {
        title = id
      }

      var depth = "d3plus" in d && "merged" in d.d3plus ? dataDepth - 1 : dataDepth

      if (depth < 0) depth = 0

      depth = vars.id.nesting[depth]

      if (typeof vars.icon.style.value == "string") {
        var icon_style = vars.icon.style.value
      }
      else if (typeof vars.icon.style.value == "object" && vars.icon.style.value[depth]) {
        var icon_style = vars.icon.style.value[depth]
      }
      else {
        var icon_style = "default"
      }

      if (params.width) {
        var width = params.width
      }
      else if (!fullscreen && tooltip_data.length == 0) {
        var width = "auto"
      }
      else {
        var width = vars.tooltip.small
      }

      d3plus.tooltip.create({
        "align": align,
        "arrow": arrow,
        "locale": vars.format.locale.value,
        "background": vars.tooltip.background,
        "curtain": vars.tooltip.curtain.color,
        "curtainopacity": vars.tooltip.curtain.opacity,
        "fontcolor": vars.tooltip.font.color,
        "fontfamily": vars.tooltip.font.family.value,
        "fontsize": vars.tooltip.font.size,
        "fontweight": vars.tooltip.font.weight,
        "data": tooltip_data,
        "color": fetchColor(vars,d),
        "allColors": true,
        "footer": params.footer === false ? params.footer : footer,
        "fullscreen": fullscreen,
        "html": html,
        "icon": icon,
        "id": tooltip_id,
        "max_height": params.maxheight,
        "max_width": vars.tooltip.small,
        "mouseevents": mouse,
        "offset": offset,
        "parent": vars.container.value,
        "style": icon_style,
        "title": title,
        "width": width,
        "x": x,
        "y": y
      })

    }
    else {
      d3plus.tooltip.remove(tooltip_id)
    }

  }

  if (fullscreen) {

    if (typeof vars.tooltip.html.value == "string") {
      make_tooltip(vars.tooltip.html.value)
    }
    else if (typeof vars.tooltip.html.value == "function") {
      make_tooltip(vars.tooltip.html.value(id))
    }
    else if (vars.tooltip.html.value && typeof vars.tooltip.html.value == "object" && vars.tooltip.html.value.url) {
      d3.json(vars.tooltip.html.value.url,function(data){
        var html = vars.tooltip.html.value.callback ? vars.tooltip.html.value.callback(data) : data
        make_tooltip(html)
      })
    }
    else {
      make_tooltip("")
    }

  }
  else {
    make_tooltip("")
  }

}

},{"../core/fetch/color.js":undefined,"../core/fetch/text.js":undefined,"../core/fetch/value.js":undefined}],180:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Correctly positions the tooltip's arrow
//-------------------------------------------------------------------
d3plus.tooltip.arrow = function(arrow) {
  arrow
    .style("bottom", function(d){
      if (d.anchor.y != "center" && !d.flip) return "-5px"
      else return "auto"
    })
    .style("top", function(d){
      if (d.anchor.y != "center" && d.flip) return "-5px"
      else if (d.anchor.y == "center") return "50%"
      else return "auto"
    })
    .style("left", function(d){
      if (d.anchor.y == "center" && d.flip) return "-5px"
      else if (d.anchor.y != "center") return "50%"
      else return "auto"
    })
    .style("right", function(d){
      if (d.anchor.y == "center" && !d.flip) return "-5px"
      else return "auto"
    })
    .style("margin-left", function(d){
      if (d.anchor.y == "center") {
        return "auto"
      }
      else {
        if (d.anchor.x == "right") {
          var arrow_x = -d.width/2+d.arrow_offset/2
        }
        else if (d.anchor.x == "left") {
          var arrow_x = d.width/2-d.arrow_offset*2 - 5
        }
        else {
          var arrow_x = -5
        }
        if (d.cx-d.width/2-5 < arrow_x) {
          arrow_x = d.cx-d.width/2-5
          if (arrow_x < 2-d.width/2) arrow_x = 2-d.width/2
        }
        else if (-(d.limit[0]-d.cx-d.width/2+5) > arrow_x) {
          var arrow_x = -(d.limit[0]-d.cx-d.width/2+5)
          if (arrow_x > d.width/2-11) arrow_x = d.width/2-11
        }
        return arrow_x+"px"
      }
    })
    .style("margin-top", function(d){
      if (d.anchor.y != "center") {
        return "auto"
      }
      else {
        if (d.anchor.y == "bottom") {
          var arrow_y = -d.height/2+d.arrow_offset/2 - 1
        }
        else if (d.anchor.y == "top") {
          var arrow_y = d.height/2-d.arrow_offset*2 - 2
        }
        else {
          var arrow_y = -9
        }
        if (d.cy-d.height/2-d.arrow_offset < arrow_y) {
          arrow_y = d.cy-d.height/2-d.arrow_offset
          if (arrow_y < 4-d.height/2) arrow_y = 4-d.height/2
        }
        else if (-(d.limit[1]-d.cy-d.height/2+d.arrow_offset) > arrow_y) {
          var arrow_y = -(d.limit[1]-d.cy-d.height/2+d.arrow_offset)
          if (arrow_y > d.height/2-22) arrow_y = d.height/2-22
        }
        return arrow_y+"px"
      }
    })
}
},{}],181:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Create a Tooltip
//-------------------------------------------------------------------
d3plus.tooltip.create = function(params) {

  var default_width = params.fullscreen ? 250 : 200
    , vendor = d3plus.prefix()
  params.width = params.width || default_width
  params.max_width = params.max_width || 386
  params.id = params.id || "default"
  params.size = params.fullscreen || params.html ? "large" : "small"
  params.offset = params.offset || 0
  params.arrow_offset = params.arrow ? 8 : 0
  params.x = params.x || 0
  params.y = params.y || 0
  params.parent = params.parent || d3.select("body")
  params.curtain = params.curtain || "#fff"
  params.curtainopacity = params.curtainopacity || 0.8
  params.background = params.background || "#fff"
  params.fontcolor = params.fontcolor || "#444"
  params.fontfamily = params.fontfamily || "sans-serif"
  params.fontweight = params.fontweight || "normal"
  params.fontsize = params.fontsize || "12px"
  params.style = params.style || "default"
  params.zindex = params.size == "small" ? 2000 : 500
  params.locale = params.locale || d3plus.locale.en_US


  var parentHeight = params.parent ? params.parent.node().offsetHeight
                  || params.parent.node().getBoundingClientRect().height : 0

  if (!params.iconsize) {
    params.iconsize = params.size == "small" ? 22 : 50
  }

  params.limit = [
    parseFloat(params.parent.style("width"),10),
    parseFloat(params.parent.style("height"),10)
  ]

  if ( params.title instanceof Array ) {

    var and = params.locale.ui.and
      , more = params.locale.ui.more

    params.title = d3plus.string.list( params.title , and , 3 , more )

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Function that closes ALL Descriptions
  //-------------------------------------------------------------------
  var close_descriptions = function() {
    d3.selectAll("div.d3plus_tooltip_data_desc").style("height","0px")
    d3.selectAll("div.d3plus_tooltip_data_help").style("background-color","#ccc")
  }

  d3plus.tooltip.remove(params.id)

  params.anchor = {}
  if (params.fullscreen) {
    params.anchor.x = "center"
    params.anchor.y = "center"
    params.x = params.parent ? params.parent.node().offsetWidth/2 : window.innerWidth/2
    params.y = params.parent ? parentHeight/2 : window.innerHeight/2
  }
  else if (params.align) {
    var a = params.align.split(" ")
    params.anchor.y = a[0]
    if (a[1]) params.anchor.x = a[1]
    else params.anchor.x = "center"
  }
  else {
    params.anchor.x = "center"
    params.anchor.y = "top"
  }

  var title_width = params.width - 30

  if (params.fullscreen) {
    var curtain = params.parent.append("div")
      .attr("id","d3plus_tooltip_curtain_"+params.id)
      .attr("class","d3plus_tooltip_curtain")
      .style("background-color",params.curtain)
      .style("opacity",params.curtainopacity)
      .style("position","absolute")
      .style("z-index",499)
      .style("top","0px")
      .style("right","0px")
      .style("bottom","0px")
      .style("left","0px")
      .on(d3plus.evt.click,function(){
        d3plus.tooltip.remove(params.id)
      })
  }

  var tooltip = params.parent.append("div")
    .datum(params)
    .attr("id","d3plus_tooltip_id_"+params.id)
    .attr("class","d3plus_tooltip d3plus_tooltip_"+params.size)
    .style("color",params.fontcolor)
    .style("font-family",params.fontfamily)
    .style("font-weight",params.fontweight)
    .style("font-size",params.fontsize+"px")
    .style(vendor+"box-shadow","0px 1px 3px rgba(0, 0, 0, 0.25)")
    .style("position","absolute")
    .style("z-index",params.zindex)
    .on(d3plus.evt.out,function(){
      close_descriptions()
    })

  if (params.max_height) {
    tooltip.style("max-height",params.max_height+"px")
  }

  if (params.fixed) {
    tooltip.style("z-index",500)
    params.mouseevents = true
  }
  else {
    tooltip.style("z-index",2000)
  }

  var container = tooltip.append("div")
    .datum(params)
    .attr("class","d3plus_tooltip_container")
    .style("background-color",params.background)
    .style("padding","6px")

  if (params.fullscreen && params.html) {

    w = params.parent ? params.parent.node().offsetWidth*0.75 : window.innerWidth*0.75
    h = params.parent ? parentHeight*0.75 : window.innerHeight*0.75

    container
      .style("width",w+"px")
      .style("height",h+"px")

    var body = container.append("div")
      .attr("class","d3plus_tooltip_body")
      .style("padding-right","6px")
      .style("display","inline-block")
      .style("z-index",1)
      .style("width",params.width+"px")

  }
  else {

    if (params.width == "auto") {
      var w = "auto"
      container.style("max-width",params.max_width+"px")
    }
    else var w = params.width-14+"px"

    var body = container
      .style("width",w)

  }

  if (params.title || params.icon) {
    var header = body.append("div")
      .attr("class","d3plus_tooltip_header")
      .style("position","relative")
      .style("z-index",1)
  }

  if (params.fullscreen) {
    var close = tooltip.append("div")
      .attr("class","d3plus_tooltip_close")
      .style("background-color",params.color)
      .style("color",d3plus.color.text(params.color))
      .style("position","absolute")
      .style(vendor+"box-shadow","0 1px 3px rgba(0, 0, 0, 0.25)")
      .style("font-size","20px")
      .style("height","18px")
      .style("line-height","14px")
      .style("text-align","center")
      .style("right","16px")
      .style("top","-10px")
      .style("width","18px")
      .style("z-index",10)
      .html("\&times;")
      .on(d3plus.evt.over,function(){
        d3.select(this)
          .style("cursor","pointer")
          .style(vendor+"box-shadow","0 1px 3px rgba(0, 0, 0, 0.5)")
      })
      .on(d3plus.evt.out,function(){
        d3.select(this)
          .style("cursor","auto")
          .style(vendor+"box-shadow","0 1px 3px rgba(0, 0, 0, 0.25)")
      })
      .on(d3plus.evt.click,function(){
        d3plus.tooltip.remove(params.id)
      })
  }

  if (!params.mouseevents) {
    tooltip.style("pointer-events","none")
  }
  else if (params.mouseevents !== true) {

    var oldout = d3.select(params.mouseevents).on(d3plus.evt.out)

    var newout = function() {

      var target = d3.event.toElement || d3.event.relatedTarget
      if (target) {
        var c = typeof target.className == "string" ? target.className : target.className.baseVal
        var istooltip = c.indexOf("d3plus_tooltip") == 0
      }
      else {
        var istooltip = false
      }
      if (!target || (!ischild(tooltip.node(),target) && !ischild(params.mouseevents,target) && !istooltip)) {
        oldout(d3.select(params.mouseevents).datum())
        close_descriptions()
        d3.select(params.mouseevents).on(d3plus.evt.out,oldout)
      }
    }

    var ischild = function(parent, child) {
       var node = child.parentNode;
       while (node !== null) {
         if (node == parent) {
           return true;
         }
         node = node.parentNode;
       }
       return false;
    }

    d3.select(params.mouseevents).on(d3plus.evt.out,newout)
    tooltip.on(d3plus.evt.out,newout)

    var move_event = d3.select(params.mouseevents).on(d3plus.evt.move)
    if (move_event) {
      tooltip.on(d3plus.evt.move,move_event)
    }

  }

  if (params.arrow) {
    var arrow = tooltip.append("div")
      .attr("class","d3plus_tooltip_arrow")
      .style("background-color",params.background)
      .style(vendor+"box-shadow","0px 1px 3px rgba(0, 0, 0, 0.25)")
      .style("position","absolute")
      .style("bottom","-5px")
      .style("height","10px")
      .style("left","50%")
      .style("margin-left","-5px")
      .style("width","10px")
      .style(vendor+"transform","rotate(45deg)")
      .style("z-index",-1)
  }

  if (params.icon) {

    var title_icon = header.append("div")
      .attr("class","d3plus_tooltip_icon")
      .style("width",params.iconsize+"px")
      .style("height",params.iconsize+"px")
      .style("z-index",1)
      .style("background-position","50%")
      .style("background-size","100%")
      .style("background-image","url("+params.icon+")")
      .style("display","inline-block")
      .style("margin","0px 3px 3px 0px")

    if (params.style == "knockout") {
      title_icon.style("background-color",params.color)
    }

    title_width -= title_icon.node().offsetWidth
  }

  if (params.title) {
    var mw = params.max_width-6
    if ( params.icon ) mw -= (params.iconsize+6)
    mw += "px"

    var title = header.append("div")
      .attr("class","d3plus_tooltip_title")
      .style("max-width",mw)
      .style("color",!params.icon ? d3plus.color.legible(params.color) : params.fontcolor)
      .style("vertical-align","top")
      .style("width",title_width+"px")
      .style("display","inline-block")
      .style("overflow","hidden")
      .style("text-overflow","ellipsis")
      .style("word-wrap","break-word")
      .style("z-index",1)
      .style("font-size",params.size === "large" ? "18px" : "16px")
      .style("line-height",params.size === "large" ? "20px" : "17px")
      .style("padding",params.size === "large" ? "3px 6px" : "3px")
      .text(params.title)
  }

  if (params.description) {
    var description = body.append("div")
      .attr("class","d3plus_tooltip_description")
      .style("font-size","12px")
      .style("padding","6px")
      .text(params.description)
  }

  if (params.data || params.html && !params.fullscreen) {

    var data_container = body.append("div")
      .attr("class","d3plus_tooltip_data_container")
      .style("overflow-y","auto")
      .style("z-index",-1)
  }

  if (params.data) {

    var val_width = 0, val_heights = {}

    var last_group = null
    params.data.forEach(function(d,i){

      if (d.group) {
        if (last_group != d.group) {
          last_group = d.group
          data_container.append("div")
            .attr("class","d3plus_tooltip_data_title")
            .style("font-size","12px")
            .style("font-weight","bold")
            .style("padding","6px 3px 0px 3px")
            .text(d.group)
        }
      }

      var block = data_container.append("div")
        .attr("class","d3plus_tooltip_data_block")
        .style("font-size","12px")
        .style("padding","3px 6px")
        .style("position","relative")
        .datum(d)

      if ( d.highlight === true ) {
        block.style("color",d3plus.color.legible(params.color))
      }
      else if ( d.allColors || d.highlight !== params.color ) {
        block.style("color",d3plus.color.legible(d.highlight))
      }

      var name = block.append("div")
          .attr("class","d3plus_tooltip_data_name")
          .style("display","inline-block")
          .html(d.name)
          .on(d3plus.evt.out,function(){
            d3.event.stopPropagation()
          })

      if ( d.value instanceof Array ) {

        var and = params.locale.ui.and
          , more = params.locale.ui.more

        d.value = d3plus.string.list( d.value , and , 3 , more )

      }

      var val = block.append("div")
          .attr("class","d3plus_tooltip_data_value")
          .style("display","block")
          .style("position","absolute")
          .style("text-align","right")
          .style("top","3px")
          .text(d.value)
          .on(d3plus.evt.out,function(){
            d3.event.stopPropagation()
          })

      if (d3plus.rtl) {
        val.style("left","6px")
      }
      else {
        val.style("right","6px")
      }

      if (params.mouseevents && d.desc) {
        var desc = block.append("div")
          .attr("class","d3plus_tooltip_data_desc")
          .style("color","#888")
          .style("overflow","hidden")
          .style(vendor+"transition","height 0.5s")
          .style("width","85%")
          .text(d.desc)
          .on(d3plus.evt.out,function(){
            d3.event.stopPropagation()
          })

        var dh = desc.node().offsetHeight || desc.node().getBoundingClientRect().height

        desc.style("height","0px")

        var help = name.append("div")
          .attr("class","d3plus_tooltip_data_help")
          .style("background-color","#ccc")
          .style(vendor+"border-radius","5px")
          .style("color","#fff")
          .style("cursor","pointer")
          .style("display","inline-block")
          .style("font-size","8px")
          .style("font-weight","bold")
          .style("height","10px")
          .style("margin","3px 0px 0px 3px")
          .style("padding-right","1px")
          .style("text-align","center")
          .style("width","10px")
          .style("vertical-align","top")
          .style(prefix+"transition","background-color 0.5s")
          .text("?")
          .on(d3plus.evt.over,function(){
            var c = d3.select(this.parentNode.parentNode).style("color")
            d3.select(this).style("background-color",c)
            desc.style("height",dh+"px")
          })
          .on(d3plus.evt.out,function(){
            d3.event.stopPropagation()
          })

        name
          .style("cursor","pointer")
          .on(d3plus.evt.over,function(){
            close_descriptions()
            var c = d3.select(this.parentNode).style("color")
            help.style("background-color",c)
            desc.style("height",dh+"px")
          })

        block.on(d3plus.evt.out,function(){
          d3.event.stopPropagation()
          close_descriptions()
        })
      }

      var w = parseFloat(val.style("width"),10)
      if (w > params.width/2) w = params.width/2
      if (w > val_width) val_width = w

      if (i != params.data.length-1) {
        if ((d.group && d.group == params.data[i+1].group) || !d.group && !params.data[i+1].group)
        data_container.append("div")
          .attr("class","d3plus_tooltip_data_seperator")
          .style("background-color","#ddd")
          .style("display","block")
          .style("height","1px")
          .style("margin","0px 3px")
      }

    })

    data_container.selectAll(".d3plus_tooltip_data_name")
      .style("width",function(){
        var w = parseFloat(d3.select(this.parentNode).style("width"),10)
        return (w-val_width-30)+"px"
      })

    data_container.selectAll(".d3plus_tooltip_data_value")
      .style("width",val_width+"px")
      .each(function(d){
        var h = parseFloat(d3.select(this).style("height"),10)
        val_heights[d.name] = h
      })

    data_container.selectAll(".d3plus_tooltip_data_name")
      .style("min-height",function(d){
        return val_heights[d.name]+"px"
      })

  }

  if (params.html && !params.fullscreen) {
    data_container.append("div")
      .html(params.html)
  }

  var footer = body.append("div")
    .attr("class","d3plus_tooltip_footer")
    .style("font-size","10px")
    .style("position","relative")
    .style("text-align","center")

  if (params.footer) {
    footer.html(params.footer)
  }

  params.height = tooltip.node().offsetHeight || tooltip.node().getBoundingClientRect().height

  if (params.html && params.fullscreen) {
    var h = params.height-12
    var w = tooltip.node().offsetWidth-params.width-44
    container.append("div")
      .attr("class","d3plus_tooltip_html")
      .style("width",w+"px")
      .style("height",h+"px")
      .style("display","inline-block")
      .style("vertical-align","top")
      .style("overflow-y","auto")
      .style("padding","0px 12px")
      .style("position","absolute")
      .html(params.html)
  }

  params.width = tooltip.node().offsetWidth

  if (params.anchor.y != "center") params.height += params.arrow_offset
  else params.width += params.arrow_offset

  if (params.data || (!params.fullscreen && params.html)) {

    if (!params.fullscreen) {
      var limit = params.fixed ? parentHeight-params.y-10 : parentHeight-10
      var h = params.height < limit ? params.height : limit
    }
    else {
      var h = params.height
    }
    h -= parseFloat(container.style("padding-top"),10)
    h -= parseFloat(container.style("padding-bottom"),10)
    if (header) {
      h -= header.node().offsetHeight || header.node().getBoundingClientRect().height
      h -= parseFloat(header.style("padding-top"),10)
      h -= parseFloat(header.style("padding-bottom"),10)
    }
    if (footer) {
      h -= footer.node().offsetHeight || footer.node().getBoundingClientRect().height
      h -= parseFloat(footer.style("padding-top"),10)
      h -= parseFloat(footer.style("padding-bottom"),10)
    }

    data_container
      .style("max-height",h+"px")
  }

  params.height = tooltip.node().offsetHeight || tooltip.node().getBoundingClientRect().height

  d3plus.tooltip.move(params.x,params.y,params.id);

}

},{}],182:[function(require,module,exports){
var fetchValue = require("../core/fetch/value.js"),
    fetchColor = require("../core/fetch/color.js"),
    fetchText  = require("../core/fetch/text.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates a data object for the Tooltip
//------------------------------------------------------------------------------
d3plus.tooltip.data = function(vars,id,length,extras,children,depth) {

  if (vars.small) {
    return []
  }

  if (!length) var length = "long"
  if (length == "long") {
    var other_length = "short"
  }
  else {
    var other_length = "long"
  }

  var extra_data = {}
  if (extras && typeof extras == "string") extras = [extras]
  else if (extras && typeof extras == "object") {
    extra_data = d3plus.object.merge(extra_data,extras)
    var extras = []
    for ( var k in extra_data ) {
      extras.push(k)
    }
  }
  else if (!extras) var extras = []

  var tooltip_highlights = []

  if (vars.tooltip.value instanceof Array) {
    var a = vars.tooltip.value
  }
  else if (typeof vars.tooltip.value == "string") {
    var a = [vars.tooltip.value]
  }
  else {

    if (vars.tooltip.value[vars.id.nesting[depth]]) {
      var a = vars.tooltip.value[vars.id.nesting[depth]]
    }
    else {
      var a = vars.tooltip.value
    }

    if (!(a instanceof Array)) {

      if (a[length]) {
        a = a[length]
      }
      else if (a[other_length]) {
        a = []
      }
      else {
        a = d3plus.object.merge({"":[]},a)
      }

    }

    if (typeof a == "string") {
      a = [a]
    }
    else if (!(a instanceof Array)) {
      a = d3plus.object.merge({"":[]},a)
    }

  }

  function format_key(key,group) {

    if (vars.attrs.value[group]) var id_var = group
    else var id_var = null

    if (group) group = vars.format.value(group)

    var value = extra_data[key] || fetchValue(vars,id,key,id_var)

    if (value != null && value != "undefined" && !(value instanceof Array) && ((typeof value === "string" && value.indexOf("d3plus_other") < 0) || !(typeof value === "string"))) {
      var name = vars.format.locale.value.ui[key]
               ? vars.format.value(vars.format.locale.value.ui[key])
               : vars.format.value(key),
          h = tooltip_highlights.indexOf(key) >= 0

      if ( value instanceof Array ) {
        value.forEach(function(v){
          v = vars.format.value(v,key)
        })
      }
      else {
        value = vars.format.value(value,key)
      }

      var obj = {"name": name, "value": value, "highlight": h, "group": group}

      if ( vars.descs.value ) {

        if ( typeof vars.descs.value === "function" ) {
          var descReturn = vars.descs.value( key )
          if ( typeof descReturn === "string" ) {
            obj.desc = descReturn
          }
        }
        else if ( key in vars.descs.value ) {
          obj.desc = vars.descs.value[key]
        }

      }

      tooltip_data.push(obj)

    }

  }

  var tooltip_data = []
  if (a instanceof Array) {

    extras.forEach(function(e){
      if (a.indexOf(e) < 0) a.push(e)
    })

    a.forEach(function(t){
      format_key(t)
    })

  }
  else {

    if (vars.id.nesting.length && depth < vars.id.nesting.length-1) {
      var a = d3plus.util.copy(a)
      vars.id.nesting.forEach(function(n,i){
        if (i > depth && a[n]) delete a[n]
      })
    }

    if (vars.tooltip.value.long && typeof vars.tooltip.value.long == "object") {
      var placed = []
      for ( var group in vars.tooltip.value.long ) {

        extras.forEach(function(e){
          if (vars.tooltip.value.long[group].indexOf(e) >= 0 && ((a[group] && a[group].indexOf(e) < 0) || !a[group])) {
            if (!a[group]) a[group] = []
            a[group].push(e)
            placed.push(e)
          }
          else if (a[group] && a[group].indexOf(e) >= 0) {
            placed.push(e)
          }
        })
      }
      extras.forEach(function(e){
        if (placed.indexOf(e) < 0) {
          if (!a[""]) a[""] = []
          a[""].push(e)
        }
      })
    }
    else {

      var present = []

      for ( var group in a ) {
        extras.forEach(function(e){
          if (a[group] instanceof Array && a[group].indexOf(e) >= 0) {
            present.push(e)
          }
          else if (typeof a[group] == "string" && a[group] == e) {
            present.push(e)
          }
        })
      }

      if (present.length != extras.length) {
        if (!a[""]) a[""] = []
        extras.forEach(function(e){
          if (present.indexOf(e) < 0) {
            a[""].push(e)
          }
        })
      }

    }

    if (a[""]) {
      a[""].forEach(function(t){
        format_key(t,"")
      })
      delete a[""]
    }

    for ( var group in a ) {
      if (a[group] instanceof Array) {
        a[group].forEach(function(t){
          format_key(t,group)
        })
      }
      else if (typeof a[group] == "string") {
        format_key(a[group],group)
      }
    }

  }

  if ( children ) {

    var title  = vars.format.locale.value.ui.including
      , colors = children.d3plus_colors

    for ( var child in children ) {

      if ( child !== "d3plus_colors" ) {

        if ( child === "d3plusMore" ) {

          var more = vars.format.locale.value.ui.more
            , name = d3plus.string.format(more,children[child])
            , highlight = true
          children[child] = ""

        }
        else {
          var name = child
            , highlight = colors && colors[name] ? colors[name] : false
        }

        tooltip_data.push({
          "group": vars.format.value(title),
          "highlight": highlight,
          "name": name,
          "value": children[child]
        })

      }

    }
  }

  if ( vars.tooltip.connections.value && length === "long" ) {

    var connections = vars.edges.connections( id[vars.id.value] , vars.id.value , true )

    if ( connections.length ) {
      connections.forEach(function(c){

        var name = fetchText(vars,c)[0],
            color = fetchColor(vars,c),
            size = vars.tooltip.font.size,
            radius = vars.shape.value == "square" ? 0 : size
            styles = [
              "background-color: "+color,
              "border-color: "+d3plus.color.legible(color),
              "border-style: solid",
              "border-width: "+vars.data.stroke.width+"px",
              "display: inline-block",
              "height: "+size+"px",
              "left: 0px",
              "position: absolute",
              "width: "+size+"px",
              "top: 0px",
              d3plus.prefix()+"border-radius: "+radius+"px",
            ]
            node = "<div style='"+styles.join("; ")+";'></div>"

        tooltip_data.push({
          "group": vars.format.value(vars.format.locale.value.ui.primary),
          "highlight": false,
          "name": "<div style='position:relative;padding-left:"+size*1.5+"px;'>"+node+name+"</div>",
          "value": ""
        })

      })
    }

  }

  return tooltip_data

}

},{"../core/fetch/color.js":undefined,"../core/fetch/text.js":undefined,"../core/fetch/value.js":undefined}],183:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Set X and Y position for Tooltip
//-------------------------------------------------------------------

d3plus.tooltip.move = function(x,y,id) {
  
  if (!id) var tooltip = d3.select("div#d3plus_tooltip_id_default")
  else var tooltip = d3.select("div#d3plus_tooltip_id_"+id)
  
  if (tooltip.node()) {
    
    var d = tooltip.datum()
  
    d.cx = x
    d.cy = y
    
    if (!d.fixed) {

      // Set initial values, based off of anchor
      if (d.anchor.y != "center") {

        if (d.anchor.x == "right") {
          d.x = d.cx - d.arrow_offset - 4
        }
        else if (d.anchor.x == "center") {
          d.x = d.cx - d.width/2
        }
        else if (d.anchor.x == "left") {
          d.x = d.cx - d.width + d.arrow_offset + 2
        }

        // Determine whether or not to flip the tooltip
        if (d.anchor.y == "bottom") {
          d.flip = d.cy + d.height + d.offset <= d.limit[1]
        }
        else if (d.anchor.y == "top") {
          d.flip = d.cy - d.height - d.offset < 0
        }
        
        if (d.flip) {
          d.y = d.cy + d.offset + d.arrow_offset
        }
        else {
          d.y = d.cy - d.height - d.offset - d.arrow_offset
        }
    
      }
      else {

        d.y = d.cy - d.height/2
        
        // Determine whether or not to flip the tooltip
        if (d.anchor.x == "right") {
          d.flip = d.cx + d.width + d.offset <= d.limit[0]
        }
        else if (d.anchor.x == "left") {
          d.flip = d.cx - d.width - d.offset < 0
        }
    
        if (d.anchor.x == "center") {
          d.flip = false
          d.x = d.cx - d.width/2
        }
        else if (d.flip) {
          d.x = d.cx + d.offset + d.arrow_offset
        }
        else {
          d.x = d.cx - d.width - d.offset
        }
      }
  
      // Limit X to the bounds of the screen
      if (d.x < 0) {
        d.x = 0
      }
      else if (d.x + d.width > d.limit[0]) {
        d.x = d.limit[0] - d.width
      }
  
      // Limit Y to the bounds of the screen
      if (d.y < 0) {
        d.y = 0
      }
      else if (d.y + d.height > d.limit[1]) {
        d.y = d.limit[1] - d.height
      }
      
    }
    
    tooltip
      .style("top",d.y+"px")
      .style("left",d.x+"px")
  
    if (d.arrow) {
      tooltip.selectAll(".d3plus_tooltip_arrow")
        .call(d3plus.tooltip.arrow)
    }
    
  }
    
}

},{}],184:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Destroy Tooltips
//-------------------------------------------------------------------

d3plus.tooltip.remove = function(id) {

  // If an ID is specified, only remove that tooltip
  if (id) {
    
    // First remove the background curtain, if the tooltip has one
    d3.selectAll("div#d3plus_tooltip_curtain_"+id).remove()
    // Finally, remove the tooltip itself
    d3.selectAll("div#d3plus_tooltip_id_"+id).remove()
    
  }
  // If no ID is given, remove ALL d3plus tooltips
  else {
    
    // First remove all background curtains on the page
    d3.selectAll("div#d3plus_tooltip_curtain").remove()
    // Finally, remove all tooltip
    d3.selectAll("div.d3plus_tooltip").remove()
    
  }

}

},{}],185:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Expands a min/max into a specified number of buckets
//------------------------------------------------------------------------------
d3plus.util.buckets = function(arr, buckets) {
  var return_arr = [], step = 1/(buckets-1)*(arr[1]-arr[0]), i = step

  for (var i = arr[0]; i <= arr[1]; i = i + step) {
    return_arr.push(i)
  }
  if (return_arr.length < buckets) {
    return_arr[buckets-1] = arr[1]
  }
  if (return_arr[return_arr.length-1] < arr[1]) {
    return_arr[return_arr.length-1] = arr[1]
  }
  return return_arr
}

},{}],186:[function(require,module,exports){
var d3selection;

d3selection = require("./d3selection.js");


/**
 * Checks to see if element is inside of another element
 */

d3plus.util.child = function(parent, child) {
  var node;
  if (!parent || !child) {
    return false;
  }
  if (d3selection(parent)) {
    parent = parent.node();
  }
  if (d3selection(parent)) {
    child = child.node();
  }
  node = child.parentNode;
  while (node !== null) {
    if (node === parent) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
};


},{"./d3selection.js":undefined}],187:[function(require,module,exports){

/**
 * Finds closest numeric value in array
 */
d3plus.util.closest = function(arr, value) {
  var closest;
  closest = arr[0];
  arr.forEach(function(p) {
    if (Math.abs(value - p) < Math.abs(value - closest)) {
      return closest = p;
    }
  });
  return closest;
};


},{}],188:[function(require,module,exports){
var objectMerge, objectValidate;

objectMerge = require("../object/merge.coffee");

objectValidate = require("../object/validate.coffee");

d3plus.util.copy = function(variable) {
  var ret;
  if (objectValidate(variable)) {
    return objectMerge(variable);
  } else if (variable instanceof Array) {
    ret = [];
    variable.forEach(function(o) {
      return ret.push(d3plus.util.copy(o));
    });
    return ret;
  } else {
    return variable;
  }
};


},{"../object/merge.coffee":undefined,"../object/validate.coffee":undefined}],189:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Cross-browser detect for D3 element
//------------------------------------------------------------------------------
d3plus.util.d3selection = function(selection) {
  return d3plus.ie ?
    typeof selection == "object" && selection instanceof Array
    : selection instanceof d3.selection
}

module.exports = d3plus.util.d3selection

},{}],190:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates a Base-64 Data URL from and Image URL
//------------------------------------------------------------------------------
d3plus.util.dataurl = function(url,callback) {

  var img = new Image();
  img.src = url;
  img.crossOrigin = "Anonymous";
  img.onload = function () {

    var canvas = document.createElement("canvas");
    canvas.width = this.width;
    canvas.height = this.height;

    var ctx = canvas.getContext("2d");
    ctx.drawImage(this, 0, 0);

    callback.call(this,canvas.toDataURL("image/png"))

    canvas = null

  }

}

},{}],191:[function(require,module,exports){

/**
 * Returns distances of all objects in array
 */
d3plus.util.distances = function(arr, accessor) {
  var checked, distances;
  distances = [];
  checked = [];
  arr.forEach(function(node1) {
    var n1;
    n1 = (accessor ? accessor(node1) : [node1.x, node1.y]);
    checked.push(node1);
    return arr.forEach(function(node2) {
      var n2, xx, yy;
      if (checked.indexOf(node2) < 0) {
        n2 = (accessor ? accessor(node2) : [node2.x, node2.y]);
        xx = Math.abs(n1[0] - n2[0]);
        yy = Math.abs(n1[1] - n2[1]);
        return distances.push(Math.sqrt((xx * xx) + (yy * yy)));
      }
    });
  });
  distances.sort(function(a, b) {
    return a - b;
  });
  return distances;
};


},{}],192:[function(require,module,exports){

/*
 * Gives X and Y offset based off angle and shape
 */
d3plus.util.offset = function(radians, distance, shape) {
  var adjacentLegLength, coords, diagonal, oppositeLegLength;
  coords = {
    x: 0,
    y: 0
  };
  if (radians < 0) {
    radians = Math.PI * 2 + radians;
  }
  if (shape === "square") {
    diagonal = 45 * (Math.PI / 180);
    if (radians <= Math.PI) {
      if (radians < (Math.PI / 2)) {
        if (radians < diagonal) {
          coords.x += distance;
          oppositeLegLength = Math.tan(radians) * distance;
          coords.y += oppositeLegLength;
        } else {
          coords.y += distance;
          adjacentLegLength = distance / Math.tan(radians);
          coords.x += adjacentLegLength;
        }
      } else {
        if (radians < (Math.PI - diagonal)) {
          coords.y += distance;
          adjacentLegLength = distance / Math.tan(Math.PI - radians);
          coords.x -= adjacentLegLength;
        } else {
          coords.x -= distance;
          oppositeLegLength = Math.tan(Math.PI - radians) * distance;
          coords.y += oppositeLegLength;
        }
      }
    } else {
      if (radians < (3 * Math.PI / 2)) {
        if (radians < (diagonal + Math.PI)) {
          coords.x -= distance;
          oppositeLegLength = Math.tan(radians - Math.PI) * distance;
          coords.y -= oppositeLegLength;
        } else {
          coords.y -= distance;
          adjacentLegLength = distance / Math.tan(radians - Math.PI);
          coords.x -= adjacentLegLength;
        }
      } else {
        if (radians < (2 * Math.PI - diagonal)) {
          coords.y -= distance;
          adjacentLegLength = distance / Math.tan(2 * Math.PI - radians);
          coords.x += adjacentLegLength;
        } else {
          coords.x += distance;
          oppositeLegLength = Math.tan(2 * Math.PI - radians) * distance;
          coords.y -= oppositeLegLength;
        }
      }
    }
  } else {
    coords.x += distance * Math.cos(radians);
    coords.y += distance * Math.sin(radians);
  }
  return coords;
};


},{}],193:[function(require,module,exports){
var objectValidate;

objectValidate = require("../object/validate.coffee");


/**
 * Returns list of unique values
 */

d3plus.util.uniques = function(data, value) {
  var d, lookup, lookups, val, vals, _i, _len;
  if (data === undefined || value === undefined) {
    return [];
  }
  if (!(data instanceof Array)) {
    data = [data];
  }
  vals = [];
  lookups = [];
  for (_i = 0, _len = data.length; _i < _len; _i++) {
    d = data[_i];
    if (objectValidate(d)) {
      val = typeof value === "function" ? value(d) : d[value];
      lookup = ["number", "string"].indexOf(typeof val) >= 0 ? val : JSON.stringify(val);
      if (lookups.indexOf(lookup) < 0) {
        vals.push(val);
        lookups.push(lookup);
      }
    }
  }
  return vals.sort(function(a, b) {
    return a - b;
  });
};


},{"../object/validate.coffee":undefined}],194:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Miscellaneous Error Checks
//------------------------------------------------------------------------------
d3plus.draw.app = function(vars) {

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Draw the specified app
  //-------------------------------------------------------------------
  // Set vars.group to the app's specific group element
  vars.group = vars.g.apps[vars.type.value]
  // Reset mouse events for the app to use
  vars.mouse = {}

  if (!vars.internal_error) {

    var app = vars.format.locale.value.visualization[vars.type.value]
    if ( vars.dev.value ) d3plus.console.time("running "+ app)
    var returned = vars.types[vars.type.value](vars)
    if ( vars.dev.value ) d3plus.console.timeEnd("running "+ app)

  }
  else {
    var returned = null
  }

  vars.returned = {
      "nodes": [],
      "edges": null
    }

  if (returned instanceof Array) {
    vars.returned.nodes = returned
  }
  else if (returned) {
    if (returned.nodes) {
      vars.returned.nodes = returned.nodes
    }
    if (returned.edges) {
      vars.returned.edges = returned.edges
    }
  }

}

},{}],195:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// If placing into a new container, remove it's contents
// and check text direction.
//
// Also initialized app width and height.
//------------------------------------------------------------------------------
d3plus.draw.container = function(vars) {

  if (vars.container.changed) {

    vars.container.value
      .style("position",function(){
        var current = d3.select(this).style("position"),
            remain = ["absolute","fixed"].indexOf(current) >= 0
        return remain ? current : "relative";
      })
      .html("")

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Get overall width and height, if not defined
    //--------------------------------------------------------------------------
    var sizes = ["width","height"]
    sizes.forEach(function(s){
      if (!vars[s].value) {

        function check_parent(element) {

          if (element.tagName === undefined || ["BODY","HTML"].indexOf(element.tagName) >= 0) {
            var val = window["inner"+s.charAt(0).toUpperCase()+s.slice(1)]
              , elem = document != element ? d3.select(element) : null
            if (elem && s == "width") {
              val -= parseFloat(elem.style("margin-left"),10)
              val -= parseFloat(elem.style("margin-right"),10)
              val -= parseFloat(elem.style("padding-left"),10)
              val -= parseFloat(elem.style("padding-right"),10)
            }
            else if (elem && s == "height") {
              val -= parseFloat(elem.style("margin-top"),10)
              val -= parseFloat(elem.style("margin-bottom"),10)
              val -= parseFloat(elem.style("padding-top"),10)
              val -= parseFloat(elem.style("padding-bottom"),10)
            }
            if (d3.selectAll("body > *:not(script)").size() == 1) {
              d3.select("body").style("overflow","hidden")
            }
            if (val <= 20) {
              val = vars[s].small
            }
            vars[s].value = val
          }
          else {

            var val = parseFloat(d3.select(element).style(s),10)
            if (typeof val == "number" && val > 0) {
              vars[s].value = val
            }
            else if (element.tagName != "BODY") {
              check_parent(element.parentNode)
            }

          }

        }

        check_parent(vars.container.value.node())
      }
    })

    vars.container.value
      .style("width",vars.width.value+"px")
      .style("height",vars.height.value+"px")

  }

  vars.width.viz = vars.width.value;
  vars.height.viz = vars.height.value;

}

},{}],196:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Enter Elements
//------------------------------------------------------------------------------
d3plus.draw.enter = function(vars) {

  if ( vars.dev.value ) d3plus.console.time("creating SVG elements")

  // Enter SVG
  vars.svg = vars.container.value.selectAll("svg#d3plus").data([0]);
  vars.svg.enter().insert("svg","#d3plus_message")
    .attr("id","d3plus")
    .attr("width",vars.width.value)
    .attr("height",vars.height.value)
    .attr("xmlns","http://www.w3.org/2000/svg")
    .attr("xmlns:xmlns:xlink","http://www.w3.org/1999/xlink")

  // Enter BG Rectangle
  vars.g.bg = vars.svg.selectAll("rect#bg").data(["bg"]);
  vars.g.bg.enter().append("rect")
    .attr("id","bg")
    .attr("fill",vars.background.value)
    .attr("width",vars.width.value)
    .attr("height",vars.height.value)

  // Enter Timeline Group
  vars.g.timeline = vars.svg.selectAll("g#timeline").data(["timeline"])
  vars.g.timeline.enter().append("g")
    .attr("id","timeline")
    .attr("transform","translate(0,"+vars.height.value+")")

  // Enter Key Group
  vars.g.legend = vars.svg.selectAll("g#key").data(["key"])
  vars.g.legend.enter().append("g")
    .attr("id","key")
    .attr("transform","translate(0,"+vars.height.value+")")

  // Enter Footer Group
  vars.g.footer = vars.svg.selectAll("g#footer").data(["footer"])
  vars.g.footer.enter().append("g")
    .attr("id","footer")
    .attr("transform","translate(0,"+vars.height.value+")")

  // Enter App Clipping Mask
  vars.g.clipping = vars.svg.selectAll("#clipping").data(["clipping"])
  vars.g.clipping.enter().append("clipPath")
    .attr("id","clipping")
    .append("rect")
      .attr("width",vars.width.viz)
      .attr("height",vars.height.viz)

  // Enter Container Group
  vars.g.container = vars.svg.selectAll("g#container").data(["container"])
  vars.g.container.enter().append("g")
    .attr("id","container")
    .attr("clip-path","url(#clipping)")
    .attr("transform","translate("+vars.margin.left+","+vars.margin.top+")")

  // Enter Zoom Group
  vars.g.zoom = vars.g.container.selectAll("g#zoom").data(["zoom"])
  vars.g.zoom.enter().append("g")
    .attr("id","zoom")

  // Enter App Background Group
  vars.g.viz = vars.g.zoom.selectAll("g#d3plus_viz").data(["d3plus_viz"])
  vars.g.viz.enter().append("g")
    .attr("id","d3plus_viz")

  // Enter App Overlay Rect
  vars.g.overlay = vars.g.viz.selectAll("rect#d3plus_overlay").data([{"id":"d3plus_overlay"}])
  vars.g.overlay.enter().append("rect")
    .attr("id","d3plus_overlay")
    .attr("width",vars.width.value)
    .attr("height",vars.height.value)
    .attr("opacity",0)

  if (!d3plus.touch) {

    vars.g.overlay
      .on(d3plus.evt.move,function(d){

        if (d.dragging) {

        }
        else if (vars.types[vars.type.value].zoom && vars.zoom.pan.value &&
          vars.zoom.behavior.scaleExtent()[0] < vars.zoom.scale) {
          d3.select(this).style("cursor",d3plus.prefix()+"grab")
        }
        else {
          d3.select(this).style("cursor","auto")
        }

      })
      .on(d3plus.evt.up,function(d){

        if (vars.types[vars.type.value].zoom && vars.zoom.pan.value &&
          vars.zoom.behavior.scaleExtent()[0] < vars.zoom.scale) {
          d.dragging = false
          d3.select(this).style("cursor",d3plus.prefix()+"grab")
        }
        else {
          d3.select(this).style("cursor","auto")
        }

      })
      .on(d3plus.evt.down,function(d){

        if (vars.types[vars.type.value].zoom && vars.zoom.pan.value &&
          vars.zoom.behavior.scaleExtent()[0] < vars.zoom.scale) {
          d.dragging = true
          d3.select(this).style("cursor",d3plus.prefix()+"grabbing")
        }
        else {
          d3.select(this).style("cursor","auto")
        }

      })

  }
  else {

    vars.g.overlay
      .on(d3plus.evt.over,vars.zoom.touchEvent)
      .on(d3plus.evt.move,vars.zoom.touchEvent)
      .on(d3plus.evt.out,vars.zoom.touchEvent)

  }

  // Enter App Background Group
  vars.g.app = vars.g.viz.selectAll("g#app").data(["app"])
  vars.g.app.enter().append("g")
    .attr("id","app")

  // Enter Edges Group
  vars.g.edges = vars.g.viz.selectAll("g#edges").data(["edges"])
  vars.g.edges.enter().append("g")
    .attr("id","edges")
    .attr("opacity",0)

  // Enter Edge Focus Group
  vars.g.edge_focus = vars.g.viz.selectAll("g#focus").data(["focus"])
  vars.g.edge_focus.enter().append("g")
    .attr("id","focus")

  // Enter Edge Hover Group
  vars.g.edge_hover = vars.g.viz.selectAll("g#edge_hover").data(["edge_hover"])
  vars.g.edge_hover.enter().append("g")
    .attr("id","edge_hover")
    .attr("opacity",0)

  // Enter App Data Group
  vars.g.data = vars.g.viz.selectAll("g#data").data(["data"])
  vars.g.data.enter().append("g")
    .attr("id","data")
    .attr("opacity",0)

  // Enter Data Focus Group
  vars.g.data_focus = vars.g.viz.selectAll("g#data_focus").data(["data_focus"])
  vars.g.data_focus.enter().append("g")
    .attr("id","data_focus")

  // Enter Top Label Group
  vars.g.labels = vars.g.viz.selectAll("g#d3plus_labels").data(["d3plus_labels"])
  vars.g.labels.enter().append("g")
    .attr("id","d3plus_labels")

  vars.defs = vars.svg.selectAll("defs").data(["defs"])
  vars.defs.enter().append("defs")

  if ( vars.dev.value ) d3plus.console.timeEnd("creating SVG elements")

}

},{}],197:[function(require,module,exports){
var fetchText = require("../../core/fetch/text.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Miscellaneous Error Checks
//------------------------------------------------------------------------------
d3plus.draw.errors = function(vars) {

  if ( vars.dev.value ) d3plus.console.time("checking for errors")

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Check to see if we have all required variables set
  //----------------------------------------------------------------------------
  var reqs = ["id"]
    , app_reqs = vars.types[vars.type.value].requirements
  if (app_reqs) {
    if (!(app_reqs instanceof Array)) reqs.push(app_reqs)
    else reqs = reqs.concat(vars.types[vars.type.value].requirements)
  }

  var missing = []
  reqs.forEach(function(r){
    if (typeof r === "string") {
      if (!vars[r].value) missing.push("\""+r+"\"")
    }
    else if (typeof r === "function") {
      var reqReturn = r(vars)
      if (!reqReturn.status && reqReturn.text) {
        missing.push("\""+reqReturn.text+"\"")
      }
    }
  })

  if ( missing.length > 1 ) {
    var str = vars.format.locale.value.error.methods
      , app = vars.format.locale.value.visualization[vars.type.value] || vars.type.value
      , and = vars.format.locale.value.ui.and
    missing = d3plus.string.list(missing,and)
    vars.internal_error = d3plus.string.format(str,app,missing)
  }
  else if ( missing.length === 1 ) {
    var str = vars.format.locale.value.error.method
      , app = vars.format.locale.value.visualization[vars.type.value] || vars.type.value
    vars.internal_error = d3plus.string.format(str,app,missing[0])
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Check to see if we have focus connections, if needed
  //----------------------------------------------------------------------------
  if (!vars.internal_error && reqs.indexOf("edges") >= 0 && reqs.indexOf("focus") >= 0) {
    var connections = vars.edges.connections(vars.focus.value[0],vars.id.value)
    if (connections.length == 0) {
      var name = fetchText(vars,vars.focus.value[0],vars.depth.value)
        , str = vars.format.locale.value.error.connections
      vars.internal_error = d3plus.string.format(str,"\""+name+"\"")
    }
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Check to see if we have all required libraries
  //----------------------------------------------------------------------------
  var reqs = ["d3"]
  if (vars.types[vars.type.value].libs) {
    reqs = reqs.concat(vars.types[vars.type.value].libs)
  }
  var missing = []
  reqs.forEach(function(r){
    if (!window[r]) missing.push("\""+r+"\"")
  })

  if ( missing.length > 1 ) {
    var str = vars.format.locale.value.error.libs
      , app = vars.format.locale.value.visualization[vars.type.value]
      , and = vars.format.locale.value.ui.and
    missing = d3plus.string.list(missing,and)
    vars.internal_error = d3plus.string.format(str,app,missing)
  }
  else if ( missing.length === 1 ) {
    var str = vars.format.locale.value.error.lib
      , app = vars.format.locale.value.visualization[vars.type.value]
    vars.internal_error = d3plus.string.format(str,app,missing[0])
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Check to see if the requested app supports the set shape
  //----------------------------------------------------------------------------
  var shapes = vars.types[vars.type.value].shapes || ["circle"]
  if (!(shapes instanceof Array)) shapes = [shapes]

  if (!vars.shape.value) {
    vars.self.shape(shapes.length ? shapes[0] : "circle")
  }
  else if (shapes.indexOf(vars.shape.value) < 0) {
    var shapes = vars.types[vars.type.value].shapes.join("\", \"")
      , str = vars.format.locale.value.error.accepted
      , shape = "\""+vars.shape.value+"\""
      , shapeStr = vars.format.locale.value.method.shape
      , app = vars.format.locale.value.visualization[vars.type.value] || vars.type.value
    d3plus.console.warning(d3plus.string.format(str,shape,shapeStr,app,"\""+shapes+"\""),"shape")
    vars.self.shape(shapes.length ? shapes[0] : "circle")
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Check to see if the requested app supports the set "mode"
  //----------------------------------------------------------------------------
  if ("modes" in vars.types[vars.type.value]) {
    if (!vars.type.mode.value) {
      vars.self.type({"mode": vars.types[vars.type.value].modes[0]})
    }
    else if (vars.types[vars.type.value].modes.indexOf(vars.type.mode.value) < 0) {
      var modes = vars.types[vars.type.value].modes.join("\", \"")
        , str = vars.format.locale.value.error.accepted
        , mode = "\""+vars.type.mode.value+"\""
        , modeStr = vars.format.locale.value.method.mode
        , app = vars.format.locale.value.visualization[vars.type.value] || vars.type.value
      d3plus.console.warning(d3plus.string.format(str,mode,modeStr,app,"\""+modes+"\""))
      vars.self.type({"mode": vars.types[vars.type.value].modes[0]})
    }
  }

  if ( vars.dev.value ) d3plus.console.timeEnd("checking for errors")

}

},{"../../core/fetch/text.js":undefined}],198:[function(require,module,exports){
var methodReset = require("../../core/method/reset.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Finalize Visualization
//------------------------------------------------------------------------------
d3plus.draw.finish = function(vars) {

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Zoom to fit bounds, if applicable
  //----------------------------------------------------------------------------
  var zoom = vars.zoom.viewport || vars.zoom.bounds
  if (vars.types[vars.type.value].zoom && vars.zoom.value && zoom) {

    if ( vars.dev.value ) d3plus.console.time("calculating zoom")

    if (vars.draw.first) {
      d3plus.zoom.bounds(vars,zoom,0)
    }
    else if (vars.focus.changed || vars.height.changed || vars.width.changed || vars.nodes.changed) {
      d3plus.zoom.bounds(vars,zoom)
    }

    if ( vars.dev.value ) d3plus.console.timeEnd("calculating zoom")

  }
  else {
    vars.zoom.scale = 1
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Resize/Reposition Overlay Rect for Mouse events
  //----------------------------------------------------------------------------
  var w = vars.zoom.size ? vars.zoom.size.width : vars.width.viz,
      h = vars.zoom.size ? vars.zoom.size.height : vars.height.viz,
      x = vars.zoom.bounds ? vars.zoom.bounds[0][0] : 0,
      y = vars.zoom.bounds ? vars.zoom.bounds[0][1] : 0

  vars.g.overlay
    .attr("width",w)
    .attr("height",h)
    .attr("x",x)
    .attr("y",y)

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Create labels
  //----------------------------------------------------------------------------
  if (vars.draw.update) {
    d3plus.shape.edges(vars)
    if (vars.draw.timing || (!vars.types[vars.type.value].zoom && !vars.draw.timing)) {
      d3plus.shape.labels( vars , "data" )
      if (vars.edges.label) {

        setTimeout(function(){
          d3plus.shape.labels( vars , "edges" )
        },vars.draw.timing+200)

      }
    }
  }
  else if (vars.types[vars.type.value].zoom && vars.zoom.value && vars.draw.timing) {
    setTimeout(function(){
      d3plus.zoom.labels(vars)
    },vars.draw.timing)
  }

  if (vars.types[vars.type.value].zoom && vars.zoom.value && vars.focus.value.length && !vars.draw.timing) {
    if ( vars.dev.value ) d3plus.console.time("focus labels")
    d3plus.shape.labels( vars , "data_focus" )
    if (vars.edges.label) {

      setTimeout(function(){
        d3plus.shape.labels( vars , "edge_focus" )
      },vars.draw.timing+200)

    }
    if ( vars.dev.value ) d3plus.console.timeEnd("focus labels")
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Check for Errors
  //----------------------------------------------------------------------------
  var reqs = vars.types[vars.type.value].requirements || []
  if (!(reqs instanceof Array)) reqs = [reqs]
  var data_req = reqs.indexOf("data") >= 0
  if (!vars.internal_error) {
    if ((!vars.data.app || !vars.returned.nodes.length) && data_req) {
      vars.internal_error = vars.format.locale.value.error.data
    }
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Hide the previous app, if applicable
  //----------------------------------------------------------------------------
  var prev = vars.type.previous
  if (prev && vars.type.value != prev && vars.g.apps[prev]) {
    if ( vars.dev.value ) d3plus.console.time("hiding \"" + prev + "\"")
    if (vars.draw.timing) {
      vars.g.apps[prev].transition().duration(vars.draw.timing)
        .attr("opacity",0)
    }
    else {
      vars.g.apps[prev].attr("opacity",0)
    }
    if ( vars.dev.value ) d3plus.console.timeEnd()
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Show the current app, data, and edges groups
  //----------------------------------------------------------------------------
  var new_opacity = (data_req && vars.data.app.length == 0) || vars.internal_error
        ? 0 : vars.focus.value.length && vars.types[vars.type.value].zoom && vars.zoom.value ? 0.4 : 1,
      old_opacity = vars.group.attr("opacity")

  if (new_opacity != old_opacity) {

    var timing = vars.draw.timing

    vars.group.transition().duration(timing)
      .attr("opacity",new_opacity)
    vars.g.data.transition().duration(timing)
      .attr("opacity",new_opacity)
    vars.g.edges.transition().duration(timing)
      .attr("opacity",new_opacity)

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Display and reset internal_error, if applicable
  //----------------------------------------------------------------------------
  if (vars.internal_error) {
    vars.internal_error = d3plus.string.title( vars.internal_error )
    d3plus.console.warning(vars.internal_error)
    d3plus.ui.message(vars,vars.internal_error)
    vars.internal_error = null
  }
  else {
    d3plus.ui.message(vars)
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Unfreeze controls and apply zoom behavior, if applicable
  //----------------------------------------------------------------------------
  setTimeout(function(){

    methodReset( vars )

    if (vars.types[vars.type.value].zoom && vars.zoom.value) {
      vars.g.zoom
        .datum(vars)
        .call(vars.zoom.behavior.on("zoom",d3plus.zoom.mouse))
      if (!vars.zoom.scroll.value) {
        vars.g.zoom.on("wheel.zoom",null)
      }
      if (!vars.zoom.click.value) {
        vars.g.zoom.on("dblclick.zoom",null)
      }
      if (!vars.zoom.pan.value) {
        vars.g.zoom.on("mousemove.zoom",null)
        vars.g.zoom.on("mousedown.zoom",null)
      }
    }
    else {
      vars.g.zoom
        .call(vars.zoom.behavior.on("zoom",null))
    }

  },vars.draw.timing)

}

},{"../../core/method/reset.js":undefined}],199:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates focus elements, if available
//------------------------------------------------------------------------------
d3plus.draw.focus = function(vars) {

  vars.g.edge_focus
    .selectAll("g")
    .remove()

  vars.g.data_focus
    .selectAll("g")
    .remove()

  if (vars.focus.value.length && vars.types[vars.type.value].zoom && vars.zoom.value) {

    if ( vars.dev.value ) d3plus.console.time("drawing focus elements")

    var edges = vars.g.edges.selectAll("g")

    if (edges.size() > 0) {

      edges.each(function(l){

          var source = l[vars.edges.source][vars.id.value],
              target = l[vars.edges.target][vars.id.value]

          if (source == vars.focus.value[0] || target == vars.focus.value[0]) {
            var elem = vars.g.edge_focus.node().appendChild(this.cloneNode(true))
            d3.select(elem).datum(l).attr("opacity",1)
              .selectAll("line, path").datum(l)
          }

        })


      var marker = vars.edges.arrows.value

      vars.g.edge_focus.selectAll("line, path")
        .attr("vector-effect","non-scaling-stroke")
        .style("stroke",vars.color.focus)
        .style("stroke-width",function(){
          return vars.edges.size ? d3.select(this).style("stroke-width")
               : vars.data.stroke.width*2
        })
        .attr("marker-start",function(e){

          var direction = vars.edges.arrows.direction.value

          if ("bucket" in e.d3plus) {
            var d = "_"+e.d3plus.bucket
          }
          else {
            var d = ""
          }

          return direction == "source" && marker
               ? "url(#d3plus_edge_marker_focus"+d+")" : "none"

        })
        .attr("marker-end",function(e){

          var direction = vars.edges.arrows.direction.value

          if ("bucket" in e.d3plus) {
            var d = "_"+e.d3plus.bucket
          }
          else {
            var d = ""
          }

          return direction == "target" && marker
               ? "url(#d3plus_edge_marker_focus"+d+")" : "none"

        })

      vars.g.edge_focus.selectAll("text")
        .style("fill",vars.color.focus)

    }

    var focii = d3plus.util.uniques(vars.edges.connections(vars.focus.value[0],vars.id.value,true),vars.id.value)
    focii.push(vars.focus.value[0])

    var x_bounds = [], y_bounds = [], x_buffer = [0], y_buffer = [0]

    var groups = vars.g.data.selectAll("g")
      .each(function(d){
        if (focii.indexOf(d[vars.id.value]) >= 0) {
          var elem = vars.g.data_focus.node().appendChild(this.cloneNode(true))
          var elem = d3.select(elem).datum(d).attr("opacity",1)

          if (vars.shape.value == "coordinates") {

            vars.zoom.viewport = vars.path.bounds(vars.zoom.coords[d.d3plus.id])

          }
          else if ("d3plus" in d) {
            if ("x" in d.d3plus) {
              x_bounds.push(d.d3plus.x)
            }
            if ("y" in d.d3plus) {
              y_bounds.push(d.d3plus.y)
            }
            if ("r" in d.d3plus) {
              x_buffer.push(d.d3plus.r)
              y_buffer.push(d.d3plus.r)
            }
            else {
              if ("width" in d.d3plus) {
                x_buffer.push(d.d3plus.width/2)
              }
              if ("height" in d.d3plus) {
                y_buffer.push(d.d3plus.height/2)
              }
            }
          }

          for (e in d3plus.evt) {
            var evt = d3.select(this).on(d3plus.evt[e])
            if (evt) {
              elem.on(d3plus.evt[e],evt)
            }
          }

        }
      })

    if (x_bounds.length && y_bounds.length) {

      var xcoords = d3.extent(x_bounds),
          ycoords = d3.extent(y_bounds),
          xmax = d3.max(x_buffer),
          ymax = d3.max(y_buffer)

      vars.zoom.viewport = [
        [xcoords[0]-xmax,ycoords[0]-ymax],
        [xcoords[1]+xmax,ycoords[1]+ymax]
      ]

    }

    vars.g.data_focus.selectAll("path")
      .style("stroke-width",vars.data.stroke.width*2)

    if ( vars.dev.value ) d3plus.console.timeEnd("drawing focus elements")

  }
  else {
    vars.zoom.viewport = false
  }

}

},{}],200:[function(require,module,exports){
var dataFormat = require("../../core/data/format.js"),
    dataColor  = require("../../core/data/color.js"),
    dataKeys   = require("../../core/data/keys.js"),
    dataLoad   = require("../../core/data/load.coffee"),
    fetchData  = require("../../core/fetch/data.js"),
    parseEdges = require("../../core/parse/edges.js"),
    parseNodes = require("../../core/parse/nodes.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Calculate steps needed to redraw the visualization
//------------------------------------------------------------------------------
d3plus.draw.steps = function(vars) {

  var steps       = []
    , appType     = vars.type.value
    , locale      = vars.format.locale.value
    , uiMessage   = locale.message.ui
    , drawMessage = locale.message.draw

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Check to see if any data needs to be loaded with JSON
  //----------------------------------------------------------------------------
  var urlLoads = [ "data" , "attrs" , "coords" , "nodes" , "edges" ]
  urlLoads.forEach(function(u){

    if ( !vars[u].loaded && vars[u].url ) {

      steps.push({
        "function": function( vars , next ){
          dataLoad( vars , u , next )
        },
        "message": locale.message.loading,
        "wait": true
      })

    }

  })

  if (vars.draw.update) {

    var appName     = locale.visualization[appType] || appType
      , appSetup    = vars.types[appType].setup || false
      , appReqs     = vars.types[appType].requirements || []
      , appMessage  = d3plus.string.format(locale.message.initializing,appName)
      , dataMessage = locale.message.data

    if (!(appReqs instanceof Array)) appReqs = [appReqs]
    appName = appName.toLowerCase()

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // If it has one, run the current app's setup function.
    //--------------------------------------------------------------------------
    if ( typeof appSetup === "function" ) {

      steps.push({
        "function": function( vars ) {

          if ( vars.dev.value ) {
            var timerString = "running " + appName + " setup"
            d3plus.console.time( timerString )
          }

          appSetup( vars )

          if ( vars.dev.value ) d3plus.console.timeEnd( timerString )

        },
        "message": appMessage
      })

    }

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Create SVG group elements if the container is new or has changed
    //--------------------------------------------------------------------------
    if ( vars.container.changed ) {

      steps.push({ "function" : d3plus.draw.enter , "message" : appMessage })

    }

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Create group for current app, if it doesn't exist.
    //--------------------------------------------------------------------------
    if ( !( appType in vars.g.apps ) ) {

      steps.push({
        "function": function( vars ) {

          if ( vars.dev.value ) {
            var timerString = "creating " + appName + " group"
            d3plus.console.time( timerString )
          }

          vars.g.apps[appType] = vars.g.app
            .selectAll("g#"+appType)
            .data([appType])

          vars.g.apps[appType].enter().append("g")
            .attr("id",appType)
            .attr("opacity",0)

          if ( vars.dev.value ) d3plus.console.timeEnd( timerString )

        },
        "message": appMessage
      })

    }

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // If new data is detected, analyze and reset it.
    //--------------------------------------------------------------------------
    if ( vars.data.changed ) {

      steps.push({
        "function": function(vars) {
          vars.data.cache = {}
          delete vars.nodes.restricted
          delete vars.edges.restricted
          dataKeys( vars , "data" )
        },
        "message": dataMessage
      })

    }

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // If new attributes are detected, analyze them.
    //--------------------------------------------------------------------------
    if ( vars.attrs.changed ) {

      steps.push({
        "function": function( vars ) {
          dataKeys( vars , "attrs" )
        },
        "message": dataMessage
      })

    }

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Determine color type
    //--------------------------------------------------------------------------
    steps.push({
      "function": function(vars) {

          if ( vars.color.changed && vars.color.value ) {

            vars.color.valueScale = null

            if ( vars.dev.value ) {
              var timerString = "determining color type"
              d3plus.console.time( timerString )
            }

            var colorKey = vars.color.value

            if ( d3plus.object.validate(colorKey) ) {
              if (colorKey[vars.id.value]) {
                colorKey = colorKey[vars.id.value]
              }
              else {
                colorKey = colorKey[d3.keys(colorKey)[0]]
              }
            }

            if ( vars.data.keys && colorKey in vars.data.keys ) {
              vars.color.type = vars.data.keys[colorKey]
            }
            else if ( vars.attrs.keys && colorKey in vars.attrs.keys ) {
              vars.color.type = vars.attrs.keys[colorKey]
            }
            else {
              vars.color.type = undefined
            }

            if ( vars.dev.value ) d3plus.console.timeEnd( timerString )

          }
          else if (!vars.color.value) {
            vars.color.type = "keys" in vars.data
                            ? vars.data.keys[vars.id.value] : false
          }

      },
      "message": dataMessage
    })

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Format nodes/edges if needed
    //--------------------------------------------------------------------------
    if ( appReqs.indexOf("edges") >= 0 && vars.edges.value
    && ( !vars.edges.linked || vars.edges.changed ) ) {
      steps.push({ "function" : parseEdges, "message" : dataMessage })
    }

    if ( appReqs.indexOf("nodes") >= 0 && vars.edges.value
    && ( !vars.nodes.positions || vars.nodes.changed ) ) {
      steps.push({ "function" : parseNodes , "message" : dataMessage })
    }

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Groups data by time and nesting.
    //--------------------------------------------------------------------------
    if ( vars.data.changed || vars.time.changed || vars.id.changed ) {
      steps.push({ "function" : dataFormat , "message" : dataMessage })
    }

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Fetches data for app and "pool"
    //--------------------------------------------------------------------------
    steps.push({
      "function": function(vars) {

        var year = !vars.time.fixed.value ? ["all"] : null
        if ( vars.dev.value ) {
          var timerString = year ? "fetching pool data" : "fetching data"
          d3plus.console.time( timerString )
        }
        vars.data.pool = fetchData( vars , year )
        if ( vars.dev.value ) d3plus.console.timeEnd( timerString )
        if ( !year ) {
          vars.data.app = vars.data.pool
        }
        else {
          if ( vars.dev.value ) d3plus.console.time("fetching data for current year")
          vars.data.app = fetchData( vars )
          if ( vars.dev.value ) d3plus.console.timeEnd("fetching data for current year")
        }

      },
      "message": dataMessage
    })

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Calculate color scale if type is number
    //--------------------------------------------------------------------------
    steps.push({
      "check": function(vars) {

        return vars.color.value && vars.color.type === "number" &&
               vars.id.nesting.indexOf(vars.color.value) < 0 &&
               vars.data.value && vars.color.value != vars.id.value &&
                 (vars.color.changed || vars.data.changed || vars.depth.changed ||
                   (vars.time.fixed.value &&
                     (vars.time.solo.changed || vars.time.mute.changed)
                   )
                 )

      },
      "function": dataColor,
      "message": dataMessage
    })

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Remove any lingering tooltips.
  //----------------------------------------------------------------------------
  steps.push({
    "function": function(vars) {
      if ( vars.dev.value ) {
        var str = vars.format.locale.value.message.tooltipReset
        d3plus.console.time(str)
      }
      if ( vars.type.previous && appType !== vars.type.previous ) {
        d3plus.tooltip.remove(vars.type.previous)
      }
      d3plus.tooltip.remove(appType)
      if ( vars.dev.value ) d3plus.console.timeEnd(str)
    },
    "message": uiMessage
  })

  steps.push({"function": d3plus.draw.errors, "message": uiMessage})

  steps.push({
    "function": function(vars) {

      vars.margin.process()
      d3plus.ui.titles(vars)

      if ( vars.draw.update ) {

        d3plus.ui.drawer(vars)
        d3plus.ui.timeline(vars)
        d3plus.ui.legend(vars)

      }
      else {

        if ( vars.dev.value ) d3plus.console.time("calculating margins")

        var drawer = vars.container.value.select("div#d3plus_drawer").node().offsetHeight
                  || vars.container.value.select("div#d3plus_drawer").node().getBoundingClientRect().height

        var timeline = vars.g.timeline.node().getBBox()
        timeline = vars.timeline.value ? timeline.height+timeline.y : 0

        var legend = vars.g.legend.node().getBBox()
        legend = vars.legend.value ? legend.height+legend.y : 0

        vars.margin.bottom += drawer+timeline+legend

        if ( vars.dev.value ) d3plus.console.timeEnd("calculating margins")

      }

      d3plus.ui.history(vars)
      vars.height.viz -= (vars.margin.top+vars.margin.bottom)
      vars.width.viz -= (vars.margin.left+vars.margin.right)

    },
    "message": uiMessage
  })

  steps.push({
    "function": d3plus.ui.focus,
    "message": uiMessage
  })

  steps.push({
    "function": d3plus.draw.update,
    "message": drawMessage
  })

  if ( vars.draw.update ) {
    steps.push({
      "function" : [ d3plus.draw.app
                   , d3plus.shape.draw ],
      "message"  : drawMessage
    })
  }

  steps.push({
    "function" : [ d3plus.draw.focus , d3plus.draw.finish ],
    "message" : drawMessage
  })

  return steps

}

},{"../../core/data/color.js":undefined,"../../core/data/format.js":undefined,"../../core/data/keys.js":undefined,"../../core/data/load.coffee":undefined,"../../core/fetch/data.js":undefined,"../../core/parse/edges.js":undefined,"../../core/parse/nodes.js":undefined}],201:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Updating Elements
//------------------------------------------------------------------------------
d3plus.draw.update = function(vars) {

  if ( vars.dev.value ) d3plus.console.time("updating SVG elements")

  if ( vars.draw.timing ) {

    // Update Parent Element
    vars.container.value.transition().duration(vars.draw.timing)
      .style("width",vars.width.value+"px")
      .style("height",vars.height.value+"px")

    // Update SVG
    vars.svg.transition().duration(vars.draw.timing)
        .attr("width",vars.width.value)
        .attr("height",vars.height.value)

    // Update Background Rectangle
    vars.g.bg.transition().duration(vars.draw.timing)
        .attr("width",vars.width.value)
        .attr("height",vars.height.value)

    // Update App Clipping Rectangle
    vars.g.clipping.select("rect").transition().duration(vars.draw.timing)
      .attr("width",vars.width.viz)
      .attr("height",vars.height.viz)

    // Update Container Groups
    vars.g.container.transition().duration(vars.draw.timing)
      .attr("transform","translate("+vars.margin.left+","+vars.margin.top+")")

  }
  else {

    // Update Parent Element
    vars.container.value
      .style("width",vars.width.value+"px")
      .style("height",vars.height.value+"px")

    // Update SVG
    vars.svg
      .attr("width",vars.width.value)
      .attr("height",vars.height.value)

    // Update Background Rectangle
    vars.g.bg
      .attr("width",vars.width.value)
      .attr("height",vars.height.value)

    // Update App Clipping Rectangle
    vars.g.clipping.select("rect")
      .attr("width",vars.width.viz)
      .attr("height",vars.height.viz)

    // Update Container Groups
    vars.g.container
      .attr("transform","translate("+vars.margin.left+","+vars.margin.top+")")

  }

  if ( vars.dev.value ) d3plus.console.timeEnd("updating SVG elements")

}

},{}],202:[function(require,module,exports){
var fetchText = require("../../core/fetch/text.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Draws "square" and "circle" shapes using svg:rect
//------------------------------------------------------------------------------
d3plus.shape.area = function(vars,selection,enter,exit) {

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // D3 area definition
  //----------------------------------------------------------------------------
  var area = d3.svg.area()
    .x(function(d) { return d.d3plus.x; })
    .y0(function(d) { return d.d3plus.y0; })
    .y1(function(d) { return d.d3plus.y; })
    .interpolate(vars.shape.interpolate.value)

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // "paths" Enter
  //----------------------------------------------------------------------------
  enter.append("path").attr("class","d3plus_data")
    .attr("d",function(d){ return area(d.values) })
    .call(d3plus.shape.style,vars)

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // "paths" Update
  //----------------------------------------------------------------------------
  selection.selectAll("path.d3plus_data")
    .data(function(d) {

      if (vars.labels.value && d.values.length > 1) {

        var tops = []
          , bottoms = []
          , names = fetchText(vars,d)

        d.values.forEach(function(v){
          tops.push([v.d3plus.x,v.d3plus.y])
          bottoms.push([v.d3plus.x,v.d3plus.y0])
        })
        tops = tops.concat(bottoms.reverse())

        var style = {
          "font-weight": vars.labels.font.weight,
          "font-family": vars.labels.font.family.value
        }

        if (names.length) {
          var size = d3plus.font.sizes(names[0],style)
            , ratio = size[0].width/size[0].height
        }
        else {
          var ratio = null
        }

        var lr = d3plus.geom.largestRect(tops,{
          "angle": d3.range(-70,71,1),
          "aspectRatio": ratio,
          "tolerance": 0
        })

        if (lr && lr[0]) {

          var label = {
            "w": Math.floor(lr[0].width),
            "h": Math.floor(lr[0].height),
            "x": Math.floor(lr[0].cx),
            "y": Math.floor(lr[0].cy),
            "angle": lr[0].angle*-1,
            "padding": 2,
            "names": names
          }

          if (lr[0].angle !== 0) {
            label.translate = {
              "x":label.x,
              "y":label.y
            }
          }
          else {
            label.translate = false
          }

          if (label.w >= 10 && label.h >= 10) {
            d.d3plus_label = label
          }

        }

      }

      return [d];
    })

  if (vars.draw.timing) {
    selection.selectAll("path.d3plus_data")
      .transition().duration(vars.draw.timing)
        .attr("d",function(d){ return area(d.values) })
        .call(d3plus.shape.style,vars)
  }
  else {
    selection.selectAll("path.d3plus_data")
      .attr("d",function(d){ return area(d.values) })
      .call(d3plus.shape.style,vars)
  }

}

},{"../../core/fetch/text.js":undefined}],203:[function(require,module,exports){
var fetchValue = require("../../core/fetch/value.js")
  , fetchColor = require("../../core/fetch/color.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Returns the correct fill color for a node
//-------------------------------------------------------------------
d3plus.shape.color = function(d,vars) {

  var shape = d.d3plus ? d.d3plus.shapeType : vars.shape.value

  if (vars.shape.value == "line") {
    if (shape == "circle") {
      return fetchColor(vars,d)
    }
    else {
      return "none"
    }
  }
  else if (vars.shape.value == "area" || shape == "active") {
    return fetchColor(vars,d)
  }
  else if (shape == "temp") {
    return "url(#d3plus_hatch_"+d.d3plus.id+")"
  }
  else if (shape == "active") {
    return fetchColor(vars,d)
  }

  if (d.d3plus.static) {
    return d3plus.color.lighter(fetchColor(vars,d),.75);
  }

  var active = vars.active.value ? fetchValue(vars,d,vars.active.value) : d.d3plus.active,
      temp = vars.temp.value ? fetchValue(vars,d,vars.temp.value) : d.d3plus.temp,
      total = vars.total.value ? fetchValue(vars,d,vars.total.value) : d.d3plus.total

  if ((!vars.active.value && !vars.temp.value) || active === true || (active && total && active == total && !temp) || (active && !total)) {
    return fetchColor(vars,d)
  }
  else if (vars.active.spotlight.value) {
    return "#eee"
  }
  else {
    return d3plus.color.lighter(fetchColor(vars,d),.75);
  }

}

},{"../../core/fetch/color.js":undefined,"../../core/fetch/value.js":undefined}],204:[function(require,module,exports){
var fetchText = require("../../core/fetch/text.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Draws "square" and "circle" shapes using svg:rect
//------------------------------------------------------------------------------
d3plus.shape.coordinates = function(vars,selection,enter,exit) {

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Define the geographical projection
  //----------------------------------------------------------------------------
  var projection = d3.geo[vars.coords.projection.value]()
    .center(vars.coords.center)

  if (!vars.zoom.scale) {
    vars.zoom.scale = 1
  }

  vars.zoom.area = 1/vars.zoom.scale/vars.zoom.scale

  vars.path = d3.geo.path()
    .projection(projection)

  enter.append("path")
    .attr("id",function(d){
      return d.id
    })
    .attr("class","d3plus_data")
    .attr("d",vars.path)
    .call(d3plus.shape.style,vars)

  if (vars.draw.timing) {
    selection.selectAll("path.d3plus_data")
      .transition().duration(vars.draw.timing)
        .call(d3plus.shape.style,vars)
  }
  else {
    selection.selectAll("path.d3plus_data")
      .call(d3plus.shape.style,vars)
  }

  var size_change = vars.old_height != vars.height.viz || vars.height.changed
    || vars.old_width != vars.width.viz || vars.width.changed

  vars.old_height = vars.height.viz
  vars.old_width = vars.width.viz

  if (vars.coords.changed || size_change || vars.coords.mute.changed || vars.coords.solo.changed) {

    vars.zoom.bounds = null
    vars.zoom.coords = {}
    vars.zoom.labels = {}

    selection.each(function(d){

      var b = vars.path.bounds(d)

      var areas = []
      d.geometry.coordinates = d.geometry.coordinates.filter(function(c,i){

        var test = d3plus.util.copy(d)
        test.geometry.coordinates = [test.geometry.coordinates[i]]
        var a = vars.path.area(test)
        if (a >= vars.coords.threshold) {
          areas.push(a)
          return true
        }
        return false

      })
      areas.sort(function(a,b){
        return a-b
      })

      var reduced = d3plus.util.copy(d),
          largest = d3plus.util.copy(d)
      reduced.geometry.coordinates = reduced.geometry.coordinates.filter(function(c,i){

        var test = d3plus.util.copy(d)
        test.geometry.coordinates = [test.geometry.coordinates[i]]
        var a = vars.path.area(test)
        if (a == areas[areas.length-1]) {
          largest.geometry.coordinates = test.geometry.coordinates
        }
        return a >= d3.quantile(areas,.9)

      })
      vars.zoom.coords[d.d3plus.id] = reduced

      var coords = largest.geometry.coordinates[0]
      if (coords && largest.geometry.type === "MultiPolygon") {
        coords = coords[0]
        largest.geometry.coordinates[0] = coords
        largest.geometry.type = "Polygon"
      }

      if (coords) {

        var path = vars.path(largest).split("M")[1].split("Z")[0].split("L")
        for (var i = 0; i < path.length; i++) {
          path[i] = path[i].split(",")
          path[i][0] = parseFloat(path[i][0])
          path[i][1] = parseFloat(path[i][1])
        }

        var style = {
          "font-weight": vars.labels.font.weight,
          "font-family": vars.labels.font.family.value
        }

        var names = fetchText(vars,d)

        if (names.length && names[0].split(" ").length === 1) {
          var size = d3plus.font.sizes(names[0],style)[0]
            , ratio = size.width/size.height
        }
        else {
          var ratio = null
        }

        var rect = d3plus.geom.largestRect(path,{
          "angle": 0,
          "aspectRatio": ratio
        })[0]

        if (rect) {

          var label = {
            "anchor": "middle",
            "valign": "center",
            "group": vars.g.labels,
            "h": Math.floor(rect.height),
            "w": Math.floor(rect.width),
            "x": Math.floor(rect.cx),
            "y": Math.floor(rect.cy),
            "names": names
          }

          vars.zoom.labels[d.d3plus.id] = label

        }
        else {
          delete vars.zoom.labels[d.d3plus.id]
        }

      }
      else {
        delete vars.zoom.labels[d.d3plus.id]
      }

      if (!vars.zoom.bounds) {
        vars.zoom.bounds =  b
      }
      else {
        if (vars.zoom.bounds[0][0] > b[0][0]) {
          vars.zoom.bounds[0][0] = b[0][0]
        }
        if (vars.zoom.bounds[0][1] > b[0][1]) {
          vars.zoom.bounds[0][1] = b[0][1]
        }
        if (vars.zoom.bounds[1][0] < b[1][0]) {
          vars.zoom.bounds[1][0] = b[1][0]
        }
        if (vars.zoom.bounds[1][1] < b[1][1]) {
          vars.zoom.bounds[1][1] = b[1][1]
        }
      }

    })

  }
  else if (!vars.focus.value.length) {
    vars.zoom.viewport = false
  }

}

},{"../../core/fetch/text.js":undefined}],205:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Draws "donut" shapes using svg:path with arcs
//------------------------------------------------------------------------------
d3plus.shape.donut = function(vars,selection,enter,exit) {

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // In order to correctly animate each donut's size and arcs, we need to store
  // it's previous values in a lookup object that does not get destroyed when
  // redrawing the visualization.
  //----------------------------------------------------------------------------
  if (!vars.arcs) {
    vars.arcs = {
      "donut": {},
      "active": {},
      "temp": {}
    }
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // This is the main arc function that determines what values to use for each
  // arc angle and radius.
  //----------------------------------------------------------------------------
  var arc = d3.svg.arc()
    .startAngle(0)
    .endAngle(function(d){
      var a = vars.arcs[d.d3plus.shapeType][d.d3plus.id].a
      return a > Math.PI*2 ? Math.PI*2 : a;
    })
    .innerRadius(function(d){
      if (shape == "donut" && !d.d3plus.static) {
        var r = vars.arcs[d.d3plus.shapeType][d.d3plus.id].r
        return r * vars.data.donut.size
      }
      else {
        return 0
      }
    })
    .outerRadius(function(d){
      var r = vars.arcs[d.d3plus.shapeType][d.d3plus.id].r
      if (d.d3plus.shapeType != "donut") return r*2
      else return r
    })

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // This is the main "arcTween" function where all of the animation happens
  // for each arc.
  //----------------------------------------------------------------------------
  function size(path,mod,rad,ang) {
    if (!mod) var mod = 0
    if (typeof rad != "number") var rad = undefined
    if (typeof ang != "number") var ang = undefined
    path.attrTween("d", function(d){
      if (rad == undefined) var r = d.d3plus.r ? d.d3plus.r : d3.max([d.d3plus.width,d.d3plus.height])
      else var r = rad
      if (ang == undefined) var a = d.d3plus.segments[d.d3plus.shapeType]
      else var a = ang
      if (!vars.arcs[d.d3plus.shapeType][d.d3plus.id]) {
        vars.arcs[d.d3plus.shapeType][d.d3plus.id] = {"r": 0}
        vars.arcs[d.d3plus.shapeType][d.d3plus.id].a = d.d3plus.shapeType == "donut" ? Math.PI * 2 : 0
      }
      var radius = d3.interpolate(vars.arcs[d.d3plus.shapeType][d.d3plus.id].r,r+mod),
          angle = d3.interpolate(vars.arcs[d.d3plus.shapeType][d.d3plus.id].a,a)
      return function(t) {
        vars.arcs[d.d3plus.shapeType][d.d3plus.id].r = radius(t)
        vars.arcs[d.d3plus.shapeType][d.d3plus.id].a = angle(t)
        return arc(d)
      }
    })
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // "paths" Exit
  //----------------------------------------------------------------------------
  exit.selectAll("path.d3plus_data")
  .transition().duration(vars.draw.timing)
    .call(size,0,0)
    .each("end",function(d){
      delete vars.arcs[d.d3plus.shapeType][d.d3plus.id]
    })

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // "paths" Update
  //----------------------------------------------------------------------------
  selection.selectAll("path.d3plus_data")
    .data(function(d) { return [d]; })
    .transition().duration(vars.draw.timing)
      .call(size)
      .call(d3plus.shape.style,vars)

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // "paths" Enter
  //----------------------------------------------------------------------------
  enter.append("path")
    .attr("class","d3plus_data")
    .transition().duration(0)
      .call(size,0,0)
      .call(d3plus.shape.style,vars)

}

},{}],206:[function(require,module,exports){
var fetchValue = require("../../core/fetch/value.js"),
    fetchColor = require("../../core/fetch/color.js"),
    fetchText  = require("../../core/fetch/text.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Draws the appropriate shape based on the data
//------------------------------------------------------------------------------
d3plus.shape.draw = function(vars) {

  var data = vars.returned.nodes || [],
      edges = vars.returned.edges || []

  vars.draw.timing = data.length < vars.data.large
                     && edges.length < vars.edges.large
                     ? vars.timing.transitions : 0

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Match vars.shape types to their respective d3plus.shape functions. For
  // example, both "square", and "circle" shapes use "rect" as their drawing
  // class.
  //----------------------------------------------------------------------------
  var shape_lookup = {
    "area": "area",
    "circle": "rect",
    "donut": "donut",
    "line": "line",
    "square": "rect",
    "coordinates": "coordinates"
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Split the data by each shape type in the data.
  //----------------------------------------------------------------------------
  var shapes = {}
  data.forEach(function(d){
    if (!d.d3plus) {
      var s = shape_lookup[vars.shape.value]
    }
    else if (!d.d3plus.shape) {
      var s = shape_lookup[vars.shape.value]
      d.d3plus.shapeType = s
    }
    else {
      var s = d.d3plus.shape
      d.d3plus.shapeType = s
    }
    if (!shapes[s]) {
      shapes[s] = []
    }
    shapes[s].push(d)
  })

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Resets the "id" of each data point to use with matching.
  //----------------------------------------------------------------------------
  function id(d) {

    d.d3plus.id = ""
    for (var i = 0; i <= vars.depth.value; i++) {
      d.d3plus.id += fetchValue(vars,d,vars.id.nesting[i])+"_"
    }

    d.d3plus.id += shape

    vars.axes.values.forEach(function(axis){
      if (vars[axis].scale.value == "continuous") {
        d.d3plus.id += "_"+fetchValue(vars,d,vars[axis].value)
      }
    })

    d.d3plus.id = d3plus.string.strip(d.d3plus.id)

    return d
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Transforms the positions and scale of each group.
  //----------------------------------------------------------------------------
  function transform(g,grow) {

    var scales = vars.types[vars.type.value].scale
    if (grow && scales && scales[vars.shape.value]) {
       var scale = scales[vars.shape.value]
    }
    else if (grow && scales && typeof scales == "number") {
      var scale = scales
    }
    else {
      var scale = 1
    }

    g
      .attr("transform",function(d){

        var x = d.d3plus.x || 0
          , y = d.d3plus.y || 0

        if (["line","area","coordinates"].indexOf(shape) < 0) {
          return "translate("+x+","+y+")scale("+scale+")"
        }
        else {
          return "scale("+scale+")"
        }

      })

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Remove old groups
  //----------------------------------------------------------------------------
  for (shape in shape_lookup) {
    if (!(shape_lookup[shape] in shapes) || d3.keys(shapes).length === 0) {
      if (vars.draw.timing) {
        vars.g.data.selectAll("g.d3plus_"+shape_lookup[shape])
          .transition().duration(vars.draw.timing)
          .attr("opacity",0)
          .remove()
      }
      else {
        vars.g.data.selectAll("g.d3plus_"+shape_lookup[shape])
          .remove()
      }
    }
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Initialize arrays for labels and sizes
  //----------------------------------------------------------------------------
  var labels = [],
      shares = []

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Create groups by shape, apply data, and call specific shape drawing class.
  //----------------------------------------------------------------------------
  for (var shape in shapes) {

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Bind Data to Groups
    //--------------------------------------------------------------------------
    var selection = vars.g.data.selectAll("g.d3plus_"+shape)
      .data(shapes[shape],function(d){

        if (!d.d3plus) d.d3plus = {}

        if ( shape === "coordinates" ) {
          d.d3plus.id = d.id
          return d.id
        }

        if ( !d.d3plus.id ) {

          if (d.values) {

            d.values.forEach(function(v){
              v = id(v)
              v.d3plus.shapeType = "circle"
            })
            d.d3plus.id = d.key

          }
          else {

            d = id(d)

            if (!d.d3plus.segments) {

              d.d3plus.segments = {"donut": Math.PI*2}
              var active = vars.active.value ? d.d3plus[vars.active.value] : d.d3plus.active,
                  temp = vars.temp.value ? d.d3plus[vars.temp.value] : d.d3plus.temp,
                  total = vars.total.value ? d.d3plus[vars.total.value] : d.d3plus.total

              if (total) {
                if (active) {
                  d.d3plus.segments.active = (active/total) * (Math.PI * 2)
                }
                else {
                  d.d3plus.segments.active = 0
                }
                if (temp) {
                  d.d3plus.segments.temp = ((temp/total) * (Math.PI * 2)) + d.d3plus.segments.active
                }
                else {
                  d.d3plus.segments.temp = 0
                }
              }

            }

          }

        }

        return d.d3plus ? d.d3plus.id : false;

      })

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Groups Exit
    //--------------------------------------------------------------------------
    if (vars.draw.timing) {
      var exit = selection.exit()
        .transition().duration(vars.draw.timing)
        .attr("opacity",0)
        .remove()
    }
    else {
      var exit = selection.exit()
        .remove()
    }

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Existing Groups Update
    //--------------------------------------------------------------------------
    if (vars.draw.timing) {
      selection
        .transition().duration(vars.draw.timing)
        .call(transform)
    }
    else {
      selection.call(transform)
    }

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Groups Enter
    //--------------------------------------------------------------------------
    var opacity = vars.draw.timing ? 0 : 1
    var enter = selection.enter().append("g")
      .attr("class","d3plus_"+shape)
      .attr("opacity",opacity)
      .call(transform)

    if (vars.draw.timing) {
      enter.transition().duration(vars.draw.timing)
        .attr("opacity",1)
    }

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // All Groups Sort Order
    //--------------------------------------------------------------------------
    selection.order()

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Draw appropriate graphics inside of each group
    //--------------------------------------------------------------------------
    if ( vars.dev.value ) d3plus.console.time("drawing \"" + shape + "\" shapes")
    d3plus.shape[shape]( vars , selection , enter , exit , transform )
    if ( vars.dev.value ) d3plus.console.timeEnd("drawing \"" + shape + "\" shapes")

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Check for active and temp fills for rects and donuts
    //--------------------------------------------------------------------------
    if (["rect","donut"].indexOf(shape) >= 0 && vars.types[vars.type.value].fill) {
      if ( vars.dev.value ) d3plus.console.time("filling \"" + shape + "\" shapes")
      d3plus.shape.fill( vars , selection , enter , exit , transform )
      if ( vars.dev.value ) d3plus.console.timeEnd("filling \"" + shape + "\" shapes")
    }

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Function to Update Edges
  //----------------------------------------------------------------------------
  function edge_update(d) {

    if (d && vars.g.edges.selectAll("g").size() > 0) {

      vars.g.edge_hover
        .selectAll("*")
        .remove()

      vars.g.edges.selectAll("g")
        .each(function(l){

          var id = d[vars.id.value],
              source = l[vars.edges.source][vars.id.value],
              target = l[vars.edges.target][vars.id.value]

          if (source == id || target == id) {
            var elem = vars.g.edge_hover.node().appendChild(this.cloneNode(true))
            d3.select(elem).datum(l).attr("opacity",1)
              .selectAll("line, path").datum(l)
          }

        })


      var marker = vars.edges.arrows.value

      vars.g.edge_hover
        .attr("opacity",0)
        .selectAll("line, path")
          .style("stroke",vars.color.primary)
          .style("stroke-width",function(){
            return vars.edges.size ? d3.select(this).style("stroke-width")
                 : vars.data.stroke.width*2
          })
          .attr("marker-start",function(e){

            var direction = vars.edges.arrows.direction.value

            if ("bucket" in e.d3plus) {
              var d = "_"+e.d3plus.bucket
            }
            else {
              var d = ""
            }

            return direction == "source" && marker
                 ? "url(#d3plus_edge_marker_highlight"+d+")" : "none"

          })
          .attr("marker-end",function(e){

            var direction = vars.edges.arrows.direction.value

            if ("bucket" in e.d3plus) {
              var d = "_"+e.d3plus.bucket
            }
            else {
              var d = ""
            }

            return direction == "target" && marker
                 ? "url(#d3plus_edge_marker_highlight"+d+")" : "none"

          })


      vars.g.edge_hover.selectAll("text")
        .style("fill",vars.color.primary)

      if (vars.draw.timing) {

        vars.g.edge_hover
          .transition().duration(vars.timing.mouseevents)
          .attr("opacity",1)

        vars.g.edges
          .transition().duration(vars.timing.mouseevents)
          .attr("opacity",0.5)

      }
      else {

        vars.g.edge_hover
          .attr("opacity",1)

      }

    }
    else {

      if (vars.draw.timing) {

        vars.g.edge_hover
          .transition().duration(vars.timing.mouseevents)
          .attr("opacity",0)
          .transition()
          .selectAll("*")
          .remove()

        vars.g.edges
          .transition().duration(vars.timing.mouseevents)
          .attr("opacity",1)

      }
      else {

        vars.g.edge_hover
          .selectAll("*")
          .remove()

      }

    }

  }

  edge_update()

  if (!d3plus.touch) {

    vars.g.data.selectAll("g")
      .on(d3plus.evt.over,function(d){

        if (!vars.draw.frozen && (!d.d3plus || !d.d3plus.static)) {

          d3.select(this).style("cursor","pointer")
            .transition().duration(vars.timing.mouseevents)
            .call(transform,true)

          d3.select(this).selectAll(".d3plus_data")
            .transition().duration(vars.timing.mouseevents)
            .attr("opacity",1)

          vars.covered = false

          if (vars.focus.value.length !== 1 || vars.focus.value[0] != d[vars.id.value]) {

            if (d.values && vars.continuous_axis) {

              var index = vars.continuous_axis === "x" ? 0 : 1
                , mouse = d3.mouse(vars.container.value.node())[index]
                , positions = d3plus.util.uniques(d.values,function(x){return x.d3plus[vars.continuous_axis]})
                , closest = d3plus.util.closest(positions,mouse)

              d.d3plus_data = d.values[positions.indexOf(closest)]
              d.d3plus = d.values[positions.indexOf(closest)].d3plus

            }

            var tooltip_data = d.d3plus_data ? d.d3plus_data : d
            d3plus.tooltip.app({
              "vars": vars,
              "data": tooltip_data
            })

          }

          if (typeof vars.mouse == "function") {
            vars.mouse(d)
          }
          else if (vars.mouse[d3plus.evt.over]) {
            vars.mouse[d3plus.evt.over](d)
          }

          edge_update(d)

        }

      })
      .on(d3plus.evt.move,function(d){

        if (!vars.draw.frozen && (!d.d3plus || !d.d3plus.static)) {

          vars.covered = false

          if (d.values || (vars.types[vars.type.value].tooltip == "follow" && vars.focus.value[0] != d[vars.id.value])) {

            if (d.values && vars.continuous_axis) {

              var index = vars.continuous_axis === "x" ? 0 : 1
                , mouse = d3.mouse(vars.container.value.node())[index]
                , positions = d3plus.util.uniques(d.values,function(x){return x.d3plus[vars.continuous_axis]})
                , closest = d3plus.util.closest(positions,mouse)

              d.d3plus_data = d.values[positions.indexOf(closest)]
              d.d3plus = d.values[positions.indexOf(closest)].d3plus

            }

            var tooltip_data = d.d3plus_data ? d.d3plus_data : d
            d3plus.tooltip.app({
              "vars": vars,
              "data": tooltip_data
            })

          }

          if (typeof vars.mouse == "function") {
            vars.mouse(d)
          }
          else if (vars.mouse[d3plus.evt.move]) {
            vars.mouse[d3plus.evt.move](d)
          }

        }

      })
      .on(d3plus.evt.out,function(d){

        var child = d3plus.util.child(this,d3.event.toElement)

        if (!child && !vars.draw.frozen && (!d.d3plus || !d.d3plus.static)) {

          d3.select(this)
            .transition().duration(vars.timing.mouseevents)
            .call(transform)

          d3.select(this).selectAll(".d3plus_data")
            .transition().duration(vars.timing.mouseevents)
            .attr("opacity",vars.data.opacity)


          if (!vars.covered) {
            d3plus.tooltip.remove(vars.type.value)
          }

          if (typeof vars.mouse == "function") {
            vars.mouse(d)
          }
          else if (vars.mouse[d3plus.evt.out]) {
            vars.mouse[d3plus.evt.out](d)
          }

          edge_update()

        }

      })

  }
  else {

    vars.g.data.selectAll("g")
      .on(d3plus.evt.over,vars.zoom.touchEvent)
      .on(d3plus.evt.move,vars.zoom.touchEvent)
      .on(d3plus.evt.out,vars.zoom.touchEvent)

  }

  vars.g.data.selectAll("g")
    .on(d3plus.evt.click,function(d){

      if (!d3.event.defaultPrevented && !vars.draw.frozen && (!d.d3plus || !d.d3plus.static)) {

        if (typeof vars.mouse == "function") {
          vars.mouse(d)
        }
        else if (vars.mouse[d3plus.evt.out]) {
          vars.mouse[d3plus.evt.out](d)
        }
        else if (vars.mouse[d3plus.evt.click]) {
          vars.mouse[d3plus.evt.click](d)
        }

        var depth_delta = vars.zoom.direction(d.d3plus_data || d)
          , previous = vars.id.solo.value
          , title = fetchText(vars,d)[0]
          , color = d3plus.color.legible(fetchColor(vars,d))
          , prev_sub = vars.title.sub.value || false
          , prev_color = vars.title.sub.font.color
          , prev_total = vars.title.total.font.color

        if (d.d3plus.threshold && d.d3plus.merged && vars.zoom.value) {

          vars.history.states.push(function(){

            vars.self
              .id({"solo": previous})
              .title({
                "sub": {
                  "font": {
                    "color": prev_color
                  },
                  "value": prev_sub
                },
                "total": {
                  "font": {
                    "color": prev_total
                  }
                }
              })
              .draw()

          })

          vars.self
            .id({"solo": d3plus.util.uniques(d.d3plus.merged,vars.id.value)})
            .title({
              "sub": {
                "font": {
                  "color": color
                },
                "value": title
              },
              "total": {
                "font": {
                  "color": color
                }
              }
            })
            .draw()

        }
        else if (depth_delta === 1 && vars.zoom.value) {

          var id = fetchValue(vars,d,vars.id.value)

          vars.history.states.push(function(){

            vars.self
              .depth(vars.depth.value-1)
              .id({"solo": previous})
              .title({
                "sub": {
                  "font": {
                    "color": prev_color
                  },
                  "value": prev_sub
                },
                "total": {
                  "font": {
                    "color": prev_total
                  }
                }
              })
              .draw()

          })

          vars.self
            .depth(vars.depth.value+1)
            .id({"solo": [id]})
            .title({
              "sub": {
                "font": {
                  "color": color
                },
                "value": title
              },
              "total": {
                "font": {
                  "color": color
                }
              }
            })
            .draw()

        }
        else if (depth_delta === -1 && vars.zoom.value) {

          vars.history.back()

        }
        else if (vars.types[vars.type.value].zoom && vars.zoom.value) {

          edge_update()

          d3.select(this)
            .transition().duration(vars.timing.mouseevents)
            .call(transform)

          d3.select(this).selectAll(".d3plus_data")
            .transition().duration(vars.timing.mouseevents)
            .attr("opacity",vars.data.opacity)

          d3plus.tooltip.remove(vars.type.value)
          vars.draw.update = false

          if (!d || d[vars.id.value] == vars.focus.value[0]) {
            vars.self.focus(false).draw()
          }
          else {
            vars.self.focus(d[vars.id.value]).draw()
          }

        }
        else if (vars.focus.value.length !== 1 || d[vars.id.value] != vars.focus.value[0]) {

          edge_update()

          var tooltip_data = d.d3plus_data ? d.d3plus_data : d

          d3plus.tooltip.app({
            "vars": vars,
            "data": tooltip_data
          })

        }

      }

    })

}

},{"../../core/fetch/color.js":undefined,"../../core/fetch/text.js":undefined,"../../core/fetch/value.js":undefined}],207:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Draws "square" and "circle" shapes using svg:rect
//------------------------------------------------------------------------------
d3plus.shape.edges = function(vars) {

  var edges = vars.returned.edges || [],
      scale = vars.zoom.behavior.scaleExtent()[0]

  if (typeof vars.edges.size === "string") {

    var strokeDomain = d3.extent(edges, function(e){
                         return e[vars.edges.size]
                       })
      , maxSize = d3.min(vars.returned.nodes || [], function(n){
                        return n.d3plus.r
                      })*.5

    vars.edges.scale = d3.scale.sqrt()
                        .domain(strokeDomain)
                        .range([vars.edges.width,maxSize*scale])

  }
  else {

    var defaultWidth = typeof vars.edges.size == "number"
                     ? vars.edges.size : vars.edges.width

    vars.edges.scale = function(){
      return defaultWidth
    }

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Initialization of Lines
  //----------------------------------------------------------------------------
  function init(l) {

    var opacity = vars.edges.opacity == 1 ? vars.edges.opacity : 0

    l
      .attr("opacity",opacity)
      .style("stroke-width",0)
      .style("stroke",vars.background.value)
      .style("fill","none")
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Styling of Lines
  //----------------------------------------------------------------------------
  function style(edges) {

    var marker = vars.edges.arrows.value

    edges
      .style("stroke-width",function(e){
        return vars.edges.scale(e[vars.edges.size])
      })
      .style("stroke",vars.edges.color)
      .attr("opacity",vars.edges.opacity)
      .attr("marker-start",function(e){

        var direction = vars.edges.arrows.direction.value

        if ("bucket" in e.d3plus) {
          var d = "_"+e.d3plus.bucket
        }
        else {
          var d = ""
        }

        return direction == "source" && marker
             ? "url(#d3plus_edge_marker_default"+d+")" : "none"

      })
      .attr("marker-end",function(e){

        var direction = vars.edges.arrows.direction.value

        if ("bucket" in e.d3plus) {
          var d = "_"+e.d3plus.bucket
        }
        else {
          var d = ""
        }

        return direction == "target" && marker
             ? "url(#d3plus_edge_marker_default"+d+")" : "none"

      })
      .attr("vector-effect","non-scaling-stroke")
      .attr("pointer-events","none")
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Positioning of Lines
  //----------------------------------------------------------------------------
  function line(l) {
    l
      .attr("x1",function(d){
        return d[vars.edges.source].d3plus.edges[d[vars.edges.target][vars.id.value]].x
      })
      .attr("y1",function(d){
        return d[vars.edges.source].d3plus.edges[d[vars.edges.target][vars.id.value]].y
      })
      .attr("x2",function(d){
        return d[vars.edges.target].d3plus.edges[d[vars.edges.source][vars.id.value]].x
      })
      .attr("y2",function(d){
        return d[vars.edges.target].d3plus.edges[d[vars.edges.source][vars.id.value]].y
      })
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Positioning of Splines
  //----------------------------------------------------------------------------
  var curve = d3.svg.line().interpolate(vars.edges.interpolate.value)

  function spline(l) {
    l
      .attr("d", function(d) {

        return curve(d.d3plus.spline);

      })
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Calculates and Draws Label for edge
  //----------------------------------------------------------------------------
  function label(d) {

    delete d.d3plus_label

    if (vars.g.edges.selectAll("line, path").size() < vars.edges.large && vars.edges.label && d[vars.edges.label]) {

      if ("spline" in d.d3plus) {

        var length = this.getTotalLength(),
            center = this.getPointAtLength(length/2),
            prev = this.getPointAtLength((length/2)-(length*.1)),
            next = this.getPointAtLength((length/2)+(length*.1)),
            radians = Math.atan2(next.y-prev.y,next.x-prev.x),
            angle = radians*(180/Math.PI),
            bounding = this.parentNode.getBBox(),
            width = length*.8,
            x = center.x,
            y = center.y

      }
      else {

        var bounds = this.getBBox(),
            source = d[vars.edges.source],
            target = d[vars.edges.target],
            start = {"x": source.d3plus.edges[target[vars.id.value]].x, "y": source.d3plus.edges[target[vars.id.value]].y},
            end = {"x": target.d3plus.edges[source[vars.id.value]].x, "y": target.d3plus.edges[source[vars.id.value]].y},
            xdiff = end.x-start.x,
            ydiff = end.y-start.y,
            center = {"x": end.x-(xdiff)/2, "y": end.y-(ydiff)/2},
            radians = Math.atan2(ydiff,xdiff),
            angle = radians*(180/Math.PI),
            length = Math.sqrt((xdiff*xdiff)+(ydiff*ydiff)),
            width = length,
            x = center.x,
            y = center.y

      }

      width += vars.labels.padding*2

      var m = 0
      if (vars.edges.arrows.value) {
        m = typeof vars.edges.arrows.value === "number"
          ? vars.edges.arrows.value : 8
        m = m/vars.zoom.behavior.scaleExtent()[1]
        width -= m*2
      }

      if (angle < -90 || angle > 90) {
        angle -= 180
      }

      if (width*vars.zoom.behavior.scaleExtent()[0] > 20) {

        d.d3plus_label = {
          "x": x,
          "y": y,
          "translate": {"x": x, "y": y},
          "w": width,
          "h": 15+vars.labels.padding*2,
          "angle": angle,
          "anchor": "middle",
          "valign": "center",
          "color": vars.edges.color,
          "resize": false,
          "names": [vars.format.value(d[vars.edges.label])],
          "background": 1
        }

      }

    }

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Enter/update/exit the Arrow Marker
  //----------------------------------------------------------------------------
  var markerData = vars.edges.arrows.value ? typeof vars.edges.size == "string"
                  ? [ "default_0", "default_1", "default_2",
                      "highlight_0", "highlight_1", "highlight_2",
                      "focus_0", "focus_1", "focus_2" ]
                  : [ "default", "highlight", "focus" ] : []

  if (typeof vars.edges.size == "string") {
    var buckets = d3plus.util.buckets(vars.edges.scale.range(),4)
      , markerSize = []
    for (var i = 0; i < 3; i++) {
      markerSize.push(buckets[i+1]+(buckets[1]-buckets[0])*(i+2)*2)
    }
  }
  else {
    var m = typeof vars.edges.arrows.value === "number"
          ? vars.edges.arrows.value : 8

    var markerSize = typeof vars.edges.size === "number"
                    ? vars.edges.size/m : m
  }

  var marker = vars.defs.selectAll(".d3plus_edge_marker")
    .data(markerData, String)

  var marker_style = function(path) {
    path
      .attr("d",function(id){

        var depth = id.split("_")

        if (depth.length == 2 && vars.edges.scale) {
          depth = parseInt(depth[1])
          var m = markerSize[depth]
        }
        else {
          var m = markerSize
        }

        if (vars.edges.arrows.direction.value == "target") {
          return "M 0,-"+m/2+" L "+m*.85+",0 L 0,"+m/2+" L 0,-"+m/2
        }
        else {
          return "M 0,-"+m/2+" L -"+m*.85+",0 L 0,"+m/2+" L 0,-"+m/2
        }
      })
      .attr("fill",function(d){

        var type = d.split("_")[0]

        if (type == "default") {
          return vars.edges.color
        }
        else if (type == "focus") {
          return vars.color.focus
        }
        else {
          return vars.color.primary
        }
      })
      .attr("transform","scale("+1/scale+")")
  }

  if (vars.draw.timing) {
    marker.exit().transition().duration(vars.draw.timing)
      .attr("opacity",0)
      .remove()

    marker.select("path").transition().duration(vars.draw.timing)
      .attr("opacity",1)
      .call(marker_style)
  }
  else {
    marker.exit().remove()

    marker.select("path")
      .attr("opacity",1)
      .call(marker_style)
  }

  var opacity = vars.draw.timing ? 0 : 1
  var enter = marker.enter().append("marker")
    .attr("id",function(d){
      return "d3plus_edge_marker_"+d
    })
    .attr("class","d3plus_edge_marker")
    .attr("orient","auto")
    .attr("markerUnits","userSpaceOnUse")
    .style("overflow","visible")
    .append("path")
    .attr("opacity",opacity)
    .attr("vector-effect","non-scaling-stroke")
    .call(marker_style)

  if (vars.draw.timing) {
    enter.transition().duration(vars.draw.timing)
      .attr("opacity",1)
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Bind "edges" data to lines in the "edges" group
  //----------------------------------------------------------------------------
  var strokeBuckets = typeof vars.edges.size == "string"
                    ? d3plus.util.buckets(vars.edges.scale.domain(),4)
                    : null
    , direction = vars.edges.arrows.direction.value

  var line_data = edges.filter(function(l){

    if (!l.d3plus) l.d3plus = {}

    l.d3plus.id = "edge_"+l[vars.edges.source][vars.id.value]+"_"+l[vars.edges.target][vars.id.value]

    if ( l.d3plus.spline !== true ) {

      if (strokeBuckets) {
        var size = l[vars.edges.size]
        l.d3plus.bucket = size < strokeBuckets[1] ? 0
                        : size < strokeBuckets[2] ? 1 : 2
        var marker = markerSize[l.d3plus.bucket]*.85/scale
      }
      else {
        delete l.d3plus.bucket
        var marker = markerSize*.85/scale
      }

      var source = l[vars.edges.source]
        , target = l[vars.edges.target]

      if (!source.d3plus || !target.d3plus) return false

      var sourceAngle = Math.atan2( source.d3plus.y - target.d3plus.y
                                  , source.d3plus.x - target.d3plus.x )
        , targetAngle = Math.atan2( target.d3plus.y - source.d3plus.y
                                  , target.d3plus.x - source.d3plus.x )
        , sourceRadius = direction == "source" && vars.edges.arrows.value
                       ? source.d3plus.r + marker
                       : source.d3plus.r
        , targetRadius = direction == "target" && vars.edges.arrows.value
                       ? target.d3plus.r + marker
                       : target.d3plus.r
        , sourceOffset = d3plus.util.offset( sourceAngle
                                           , sourceRadius
                                           , vars.shape.value )
        , targetOffset = d3plus.util.offset( targetAngle
                                           , targetRadius
                                           , vars.shape.value )

      if (!("edges" in source.d3plus)) source.d3plus.edges = {}
      source.d3plus.edges[target[vars.id.value]] = {
          "x": source.d3plus.x - sourceOffset.x,
          "y": source.d3plus.y - sourceOffset.y
      }

      if (!("edges" in target.d3plus)) target.d3plus.edges = {}
      target.d3plus.edges[source[vars.id.value]] = {
          "x": target.d3plus.x - targetOffset.x,
          "y": target.d3plus.y - targetOffset.y
      }

      return true
    }

    return false

  })

  var lines = vars.g.edges.selectAll("g.d3plus_edge_line")
    .data(line_data,function(d){

      return d.d3plus.id

    })

  var spline_data = edges.filter(function(l){

    if (l.d3plus.spline) {

      if (strokeBuckets) {
        var size = l[vars.edges.size]
        l.d3plus.bucket = size < strokeBuckets[1] ? 0
                        : size < strokeBuckets[2] ? 1 : 2
        var marker = markerSize[l.d3plus.bucket]*.85/scale
      }
      else {
        delete l.d3plus.bucket
        var marker = markerSize*.85/scale
      }

      var source = l[vars.edges.source]
        , target = l[vars.edges.target]
        , sourceEdge = source.d3plus.edges ? source.d3plus.edges[target[vars.id.value]] || {} : {}
        , targetEdge = target.d3plus.edges ? target.d3plus.edges[source[vars.id.value]] || {} : {}
        , sourceMod = vars.edges.arrows.value && direction == "source" ? marker : 0
        , targetMod = vars.edges.arrows.value && direction == "target" ? marker : 0
        , angleTweak = 0.1
        , sourceTweak = source.d3plus.x > target.d3plus.x ? 1-angleTweak : 1+angleTweak
        , targetTweak = source.d3plus.x > target.d3plus.x ? 1+angleTweak : 1-angleTweak
        , sourceAngle = typeof sourceEdge.angle === "number" ? sourceEdge.angle
                      : Math.atan2( source.d3plus.y - target.d3plus.y
                                  , source.d3plus.x - target.d3plus.x ) * sourceTweak
        , sourceOffset = d3plus.util.offset(sourceAngle, source.d3plus.r + sourceMod, vars.shape.value )
        , targetAngle = typeof targetEdge.angle === "number" ? targetEdge.angle
                      : Math.atan2( target.d3plus.y - source.d3plus.y
                                  , target.d3plus.x - source.d3plus.x ) * targetTweak
        , targetOffset = d3plus.util.offset(targetAngle, target.d3plus.r + targetMod, vars.shape.value )
        , start = [source.d3plus.x-sourceOffset.x, source.d3plus.y-sourceOffset.y]
        , startOffset = sourceEdge.offset ? d3plus.util.offset(sourceAngle,sourceEdge.offset) : false
        , startPoint = startOffset ? [start[0]-startOffset.x,start[1]-startOffset.y] : start
        , end = [target.d3plus.x-targetOffset.x, target.d3plus.y-targetOffset.y]
        , endOffset = targetEdge.offset ? d3plus.util.offset(targetAngle,targetEdge.offset) : false
        , endPoint = endOffset ? [end[0]-endOffset.x,end[1]-endOffset.y] : end
        , xd = endPoint[0] - startPoint[0]
        , yd = endPoint[1] - startPoint[1]
        , sourceDistance = typeof sourceEdge.radius === "number" ? sourceEdge.radius : Math.sqrt(xd*xd+yd*yd)/4
        , targetDistance = typeof targetEdge.radius === "number" ? targetEdge.radius : Math.sqrt(xd*xd+yd*yd)/4
        , startAnchor = d3plus.util.offset(sourceAngle,sourceDistance-source.d3plus.r-sourceMod*2)
        , endAnchor = d3plus.util.offset(targetAngle,targetDistance-target.d3plus.r-targetMod*2)

      l.d3plus.spline = [ start, end ]
      var testAngle = Math.abs(Math.atan2( source.d3plus.y - target.d3plus.y
                                         , source.d3plus.x - target.d3plus.x )).toFixed(5)
        , testStart = Math.abs(sourceAngle).toFixed(5)
        , testEnd   = Math.abs(targetAngle - Math.PI).toFixed(5)

      if (testStart !== testEnd || [testStart,testEnd].indexOf(testAngle) < 0) {

        l.d3plus.spline.splice(1,0,[startPoint[0]-startAnchor.x,startPoint[1]-startAnchor.y],
                                   [endPoint[0]-endAnchor.x,endPoint[1]-endAnchor.y])

        if (startOffset) l.d3plus.spline.splice(1,0,startPoint)
        if (endOffset) l.d3plus.spline.splice(l.d3plus.spline.length-1,0,endPoint)

      }

      return true

    }

    return false

  })

  var splines = vars.g.edges.selectAll("g.d3plus_edge_path")
    .data(spline_data,function(d){

      return d.d3plus.id

    })

  if (vars.draw.timing) {

    lines.exit().transition().duration(vars.draw.timing)
      .attr("opacity",0)
      .remove()

    splines.exit().transition().duration(vars.draw.timing)
      .attr("opacity",0)
      .remove()

    lines.selectAll("text.d3plus_label, rect.d3plus_label_bg")
      .transition().duration(vars.draw.timing/2)
      .attr("opacity",0)
      .remove()

    splines.selectAll("text.d3plus_label, rect.d3plus_label_bg")
      .transition().duration(vars.draw.timing/2)
      .attr("opacity",0)
      .remove()

    lines.selectAll("line")
      .data(function(d){ return [d] })
      .transition().duration(vars.draw.timing)
        .call(line)
        .call(style)
        .each("end",label)

    splines.selectAll("path")
      .data(function(d){ return [d] })
      .transition().duration(vars.draw.timing)
        .call(spline)
        .call(style)
        .each("end",label)

    lines.enter().append("g")
      .attr("class","d3plus_edge_line")
      .append("line")
      .call(line)
      .call(init)
      .transition().duration(vars.draw.timing)
        .call(style)
        .each("end",label)

    splines.enter().append("g")
      .attr("class","d3plus_edge_path")
      .append("path")
      .call(spline)
      .call(init)
      .transition().duration(vars.draw.timing)
        .call(style)
        .each("end",label)

  }
  else {

    lines.exit().remove()

    splines.exit().remove()

    lines.selectAll("text.d3plus_label, rect.d3plus_label_bg")
      .remove()

    splines.selectAll("text.d3plus_label, rect.d3plus_label_bg")
      .remove()

    lines.selectAll("line")
      .data(function(d){ return [d] })
      .call(line)
      .call(style)
      .call(label)

    splines.selectAll("path")
      .data(function(d){ return [d] })
      .call(spline)
      .call(style)
      .call(label)

    lines.enter().append("g")
      .attr("class","d3plus_edge_line")
      .append("line")
      .call(line)
      .call(init)
      .call(style)
      .call(label)

    splines.enter().append("g")
      .attr("class","d3plus_edge_path")
      .append("path")
      .call(spline)
      .call(init)
      .call(style)
      .call(label)

  }

}

},{}],208:[function(require,module,exports){
var fetchColor = require("../../core/fetch/color.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Draws "square" and "circle" shapes using svg:rect
//------------------------------------------------------------------------------
d3plus.shape.fill = function(vars,selection,enter,exit) {

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // The position and size of each rectangle on enter and exit.
  //----------------------------------------------------------------------------
  function init(nodes) {

    nodes
      .attr("x",0)
      .attr("y",0)
      .attr("width",0)
      .attr("height",0)

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // The position and size of each rectangle on update.
  //----------------------------------------------------------------------------
  function update(nodes,mod) {
    if (!mod) var mod = 0
    nodes
      .attr("x",function(d){
        var w = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.width
        return (-w/2)-(mod/2)
      })
      .attr("y",function(d){
        var h = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.height
        return (-h/2)-(mod/2)
      })
      .attr("width",function(d){
        var w = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.width
        return w+mod
      })
      .attr("height",function(d){
        var h = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.height
        return h+mod
      })
      .attr("rx",function(d){
        var w = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.width
        var rounded = ["circle","donut"].indexOf(vars.shape.value) >= 0
        return rounded ? (w+mod)/2 : 0
      })
      .attr("ry",function(d){
        var h = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.height
        var rounded = ["circle","donut"].indexOf(vars.shape.value) >= 0
        return rounded ? (h+mod)/2 : 0
      })
      .attr("shape-rendering",function(d){
        if (["square"].indexOf(vars.shape.value) >= 0) {
          return vars.shape.rendering.value
        }
        else {
          return "auto"
        }
      })
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // In order to correctly animate each donut's size and arcs, we need to store
  // it's previous values in a lookup object that does not get destroyed when
  // redrawing the visualization.
  //----------------------------------------------------------------------------
  if (!vars.arcs) {
    vars.arcs = {
      "donut": {},
      "active": {},
      "temp": {}
    }
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // This is the main arc function that determines what values to use for each
  // arc angle and radius.
  //----------------------------------------------------------------------------
  var arc = d3.svg.arc()
    .startAngle(0)
    .endAngle(function(d){
      var a = vars.arcs[d.d3plus.shapeType][d.d3plus.id].a
      return a > Math.PI*2 ? Math.PI*2 : a;
    })
    .innerRadius(function(d){
      if (shape == "donut" && !d.d3plus.static) {
        var r = vars.arcs[d.d3plus.shapeType][d.d3plus.id].r
        return r * vars.data.donut.size
      }
      else {
        return 0
      }
    })
    .outerRadius(function(d){
      var r = vars.arcs[d.d3plus.shapeType][d.d3plus.id].r
      if (d.d3plus.shapeType != "donut") return r*2
      else return r
    })

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // This is the main "arcTween" function where all of the animation happens
  // for each arc.
  //----------------------------------------------------------------------------
  function size(path,mod,rad,ang) {
    if (!mod) var mod = 0
    if (typeof rad != "number") var rad = undefined
    if (typeof ang != "number") var ang = undefined
    path.attrTween("d", function(d){
      if (rad == undefined) var r = d.d3plus.r ? d.d3plus.r : d3.max([d.d3plus.width,d.d3plus.height])
      else var r = rad
      if (ang == undefined) var a = d.d3plus.a[d.d3plus.shapeType]
      else var a = ang
      if (!vars.arcs[d.d3plus.shapeType][d.d3plus.id]) {
        vars.arcs[d.d3plus.shapeType][d.d3plus.id] = {"r": 0}
        vars.arcs[d.d3plus.shapeType][d.d3plus.id].a = d.d3plus.shapeType == "donut" ? Math.PI * 2 : 0
      }
      var radius = d3.interpolate(vars.arcs[d.d3plus.shapeType][d.d3plus.id].r,r+mod),
          angle = d3.interpolate(vars.arcs[d.d3plus.shapeType][d.d3plus.id].a,a)

      return function(t) {
        vars.arcs[d.d3plus.shapeType][d.d3plus.id].r = radius(t)
        vars.arcs[d.d3plus.shapeType][d.d3plus.id].a = angle(t)
        return arc(d)
      }
    })
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Check each data point for active and temp data
  //----------------------------------------------------------------------------
  selection.each(function(d){

    var active = vars.active.value ? d.d3plus[vars.active.value] : d.d3plus.active,
        temp = vars.temp.value ? d.d3plus[vars.temp.value] : d.d3plus.temp,
        total = vars.total.value ? d.d3plus[vars.total.value] : d.d3plus.total,
        group = d3.select(this),
        color = fetchColor(vars,d)

    var fill_data = [], hatch_data = []

    if (total && vars.types[vars.type.value].fill) {

      if (temp) {
        var copy = d3plus.util.copy(d)
        copy.d3plus.shapeType = "temp"
        fill_data.push(copy)
        hatch_data = ["temp"]
      }

      if (active && (active < total || temp)) {
        var copy = d3plus.util.copy(d)
        copy.d3plus.shapeType = "active"
        fill_data.push(copy)
      }

    }

    function hatch_lines(l) {
      l
        .attr("stroke",color)
        .attr("stroke-width",1)
        .attr("shape-rendering",vars.shape.rendering.value)
    }

    var pattern = vars.defs.selectAll("pattern#d3plus_hatch_"+d.d3plus.id)
      .data(hatch_data)

    if (vars.draw.timing) {

      pattern.selectAll("rect")
        .transition().duration(vars.draw.timing)
        .style("fill",color)

      pattern.selectAll("line")
        .transition().duration(vars.draw.timing)
        .style("stroke",color)

    }
    else {

      pattern.selectAll("rect").style("fill",color)

      pattern.selectAll("line").style("stroke",color)

    }

    var pattern_enter = pattern.enter().append("pattern")
      .attr("id","d3plus_hatch_"+d.d3plus.id)
      .attr("patternUnits","userSpaceOnUse")
      .attr("x","0")
      .attr("y","0")
      .attr("width","10")
      .attr("height","10")
      .append("g")

    pattern_enter.append("rect")
      .attr("x","0")
      .attr("y","0")
      .attr("width","10")
      .attr("height","10")
      .attr("fill",color)
      .attr("fill-opacity",0.25)

    pattern_enter.append("line")
      .attr("x1","0")
      .attr("x2","10")
      .attr("y1","0")
      .attr("y2","10")
      .call(hatch_lines)

    pattern_enter.append("line")
      .attr("x1","-1")
      .attr("x2","1")
      .attr("y1","9")
      .attr("y2","11")
      .call(hatch_lines)

    pattern_enter.append("line")
      .attr("x1","9")
      .attr("x2","11")
      .attr("y1","-1")
      .attr("y2","1")
      .call(hatch_lines)

    var clip_data = fill_data.length ? [d] : []

    var clip = group.selectAll("#d3plus_clip_"+d.d3plus.id)
      .data(clip_data)

    clip.enter().insert("clipPath",".d3plus_mouse")
      .attr("id","d3plus_clip_"+d.d3plus.id)
      .append("rect")
      .attr("class","d3plus_clipping")
      .call(init)

    if (vars.draw.timing) {

      clip.selectAll("rect").transition().duration(vars.draw.timing)
        .call(update)

      clip.exit().transition().delay(vars.draw.timing)
        .remove()

    }
    else {

      clip.selectAll("rect").call(update)

      clip.exit().remove()

    }

    var fills = group.selectAll("path.d3plus_fill")
      .data(fill_data)

    fills.transition().duration(vars.draw.timing)
      .call(d3plus.shape.style,vars)
      .call(size)

    fills.enter().insert("path","rect.d3plus_mouse")
      .attr("class","d3plus_fill")
      .attr("clip-path","url(#d3plus_clip_"+d.d3plus.id+")")
      .transition().duration(0)
        .call(size,0,undefined,0)
        .call(d3plus.shape.style,vars)
        .transition().duration(vars.draw.timing)
          .call(size)

    fills.exit().transition().duration(vars.draw.timing)
      .call(size,0,undefined,0)
      .remove()

  })

}

},{"../../core/fetch/color.js":undefined}],209:[function(require,module,exports){
var fetchText = require("../../core/fetch/text.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Draws "labels" using svg:text and d3plus.textwrap
//------------------------------------------------------------------------------
d3plus.shape.labels = function( vars , group ) {

  var scale = vars.zoom.behavior.scaleExtent()
    , selection = vars.g[ group ].selectAll("g")

  var opacity = function(elem) {

    elem
      .attr("opacity",function(d){
        if (!d) var d = {"scale": scale[1]}
        var size = parseFloat(d3.select(this).attr("font-size"),10)
        d.visible = size/d.scale*vars.zoom.scale >= 7
        return d.visible ? 1 : 0
      })

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Label Exiting
  //----------------------------------------------------------------------------
  remove = function(text) {

    if (vars.draw.timing) {
      text
        .transition().duration(vars.draw.timing)
        .attr("opacity",0)
        .remove()
    }
    else {
      text.remove()
    }

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Label Styling
  //----------------------------------------------------------------------------
  style = function(text,wrap) {

    function x_pos(t) {

      if ( t.shape === "circle" ) {
        return "0px"
      }

      var align = t.anchor || vars.labels.align,
          tspan = this.tagName.toLowerCase() === "tspan",
          share = tspan ? this.parentNode.className.baseVal == "d3plus_share" : this.className.baseVal == "d3plus_share",
          width = d3.select(this).node().getComputedTextLength()/scale[1]

      if (align == "middle" || share) {
        var pos = t.x-width/2
      }
      else if ((align == "end" && !d3plus.rtl) || (align == "start" && d3plus.rtl)) {
        var pos = t.x+(t.w-t.padding)/2-width
      }
      else {
        var pos = t.x-(t.w-t.padding)/2
      }

      if (tspan) {
        var t_width = this.getComputedTextLength()/scale[1]
        if (align == "middle") {
          if (d3plus.rtl) {
            pos -= (width-t_width)/2
          }
          else {
            pos += (width-t_width)/2
          }
        }
        else if (align == "end") {
          if (d3plus.rtl) {
            pos -= (width-t_width)
          }
          else {
            pos += (width-t_width)
          }
        }
      }

      if (d3plus.rtl) {
        pos += width
      }

      return pos*scale[1]

    }

    function y_pos(t) {

      if (d3.select(this).select("tspan").empty()) {
        return 0
      }
      else {

        var align = vars.labels.align,
            height = d3.select(this).node().getBBox().height/scale[1],
            diff = (parseFloat(d3.select(this).style("font-size"),10)/5)/scale[1]

        if (this.className.baseVal == "d3plus_share") {
          var data = d3.select(this.parentNode).datum()
          var pheight = data.d3plus.r ? data.d3plus.r*2 : data.d3plus.height
          pheight = pheight/scale[1]
          if (align == "end") {
            var y = t.y-pheight/2+diff/2
          }
          else {
            var y = t.y+pheight/2-height-diff/2
          }
        }
        else {

          if (t.shape === "circle" || align === "middle" || t.valign === "center") {
            var y = t.y-height/2-diff/2
          }
          else if (align == "end") {
            var y = t.y+(t.h-t.padding)/2-height+diff/2
          }
          else {
            var y = t.y-(t.h-t.padding)/2-diff
          }

        }

        return y*scale[1]

      }
    }

    text
      .attr("font-weight",vars.labels.font.weight)
      .attr("font-family",vars.labels.font.family.value)
      .style("text-anchor",function(t){
        return t.shape === "circle" ? "middle" : "start"
      })
      .attr("pointer-events",function(t){
        return t.mouse ? "auto": "none"
      })
      .attr("fill", function(t){

        if ( t.color ) return t.color

        var color = d3plus.shape.color(t.parent,vars)
          , legible = d3plus.color.text(color)
          , opacity = t.text ? 0.15 : 1

        return d3plus.color.mix( color , legible , 0.2 , opacity )

      })
      .attr("x",x_pos)
      .attr("y",y_pos)

    if (wrap) {

      text
        .each(function(t){

          if (t.resize instanceof Array) {
            var min = t.resize[0]
              , max = t.resize[1]
          }

          if (t.text) {


            if ( !(t.resize instanceof Array) ) {
              var size = [ 9 / t.scale , 50 * t.scale ]
                , resize = t.resize
            }
            else {
              var size = t.resize
                , resize = true
            }

            d3plus.textwrap()
              .container( d3.select(this) )
              .height( t.h * t.scale - t.padding )
              .resize( resize )
              .size( size )
              .text( vars.format.value(t.text*100,"share")+"%" )
              .width( t.w * t.scale - t.padding )
              .draw()

          }
          else {

            if (vars.labels.align !== "middle" && t.share) {
              var height = t.h - t.share - t.padding
            }
            else {
              var height = t.h
            }

            if ( !(t.resize instanceof Array) ) {
              var size = [ 9 / t.scale , 40 * t.scale ]
                , resize = t.resize
            }
            else {
              var size = t.resize
                , resize = true
            }

            var shape = t.shape || "square"

            d3plus.textwrap()
              .container( d3.select(this) )
              .height( height * t.scale - t.padding )
              .resize( resize )
              .size( size )
              .shape( shape )
              .text( t.names )
              .width( t.w * t.scale - t.padding )
              .draw()

          }

        })
        .attr("x",x_pos)
        .attr("y",y_pos)

    }

    text
      .attr("transform",function(t){
        var a = t.angle || 0,
            x = t.translate && t.translate.x ? t.translate.x : 0,
            y = t.translate && t.translate.y ? t.translate.y : 0

        return "rotate("+a+","+x+","+y+")scale("+1/scale[1]+")"
      })
      .selectAll("tspan")
        .attr("x",x_pos)

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Loop through each selection and analyze the labels
  //----------------------------------------------------------------------------
  if (group === "edges" || vars.labels.value) {

    if ( vars.dev.value ) {
      var timerString = "drawing " + group + " labels"
      d3plus.console.time( timerString )
    }

    selection.each(function(d){

      var disabled = d.d3plus && "label" in d.d3plus && !d.d3plus.label,
          stat = d.d3plus && "static" in d.d3plus && d.d3plus.static
          label = d.d3plus_label ? d.d3plus_label : vars.zoom.labels ? vars.zoom.labels[d.d3plus.id] : null,
          share = d.d3plus_share,
          names = label && label.names ? label.names : fetchText(vars,d),
          group = label && "group" in label ? label.group : d3.select(this),
          share_size = 0,
          fill = vars.types[vars.type.value].fill

      if (label) {

        if (["line","area"].indexOf(vars.shape.value) >= 0) {
          var background = true
        }
        else if (d && "d3plus" in d) {
          var active = vars.active.value ? d.d3plus[vars.active.value] : d.d3plus.active,
              temp = vars.temp.value ? d.d3plus[vars.temp.value] : d.d3plus.temp,
              total = vars.total.value ? d.d3plus[vars.total.value] : d.d3plus.total,
              background = (!temp && !active) || (active == total)
        }

      }

      if (!disabled && (background || !fill) && !stat) {

        if (share && d.d3plus.share && vars.labels.align != "middle") {

          share.resize = vars.labels.resize.value === false ? false :
            share && "resize" in share ? share.resize : true

          share.scale = share.resize ? scale[1] : scale[0]

          share.padding = (vars.labels.padding/share.scale)*2

          share.text = d.d3plus.share
          share.parent = d

          var text = group.selectAll("text#d3plus_share_"+d.d3plus.id)
            .data([share],function(t){
              return t.w+""+t.h+""+t.text
            })

          if (vars.draw.timing) {

            text
              .transition().duration(vars.draw.timing/2)
              .call(style)

            text.enter().append("text")
              .attr("id","d3plus_share_"+d.d3plus.id)
              .attr("class","d3plus_share")
              .attr("opacity",0)
              .call(style,true)
              .transition().duration(vars.draw.timing/2)
              .delay(vars.draw.timing/2)
              .attr("opacity",1)

          }
          else {

            text
              .attr("opacity",1)
              .call(style)

            text.enter().append("text")
              .attr("id","d3plus_share_"+d.d3plus.id)
              .attr("class","d3plus_share")
              .attr("opacity",1)
              .call(style,true)

          }

          share_size = text.node().getBBox().height

          text.exit().call(remove)

        }
        else {
          group.selectAll("text.d3plus_share")
            .call(remove)
        }

        if (label) {

          label.resize = vars.labels.resize.value === false ? false :
            label && "resize" in label ? label.resize : true

          label.scale = label.resize ? scale[1] : scale[0]

          var padding = typeof label.padding === "number" ? label.padding : vars.labels.padding
          label.padding = (padding/label.scale)*2

        }

        if (label && label.w*label.scale-label.padding >= 20 && label.h*label.scale-label.padding >= 10 && names.length) {

          var and = vars.format.locale.value.ui.and
            , more = vars.format.locale.value.ui.more

          for (var i = 0; i < names.length; i++) {
            if (names[i] instanceof Array) {
              names[i] = d3plus.string.list(names[i],and,3,more)
            }
          }

          label.names = names

          label.share = share_size
          label.parent = d

          var text = group.selectAll("text#d3plus_label_"+d.d3plus.id)
            .data([label],function(t){
              if (!t) return false
              return t.w+"_"+t.h+"_"+t.x+"_"+t.y+"_"+t.names.join("_")
            })
            , fontSize = label.resize ? undefined
                       : vars.labels.font.size * label.scale

          if ( vars.draw.timing ) {

            text
              .transition().duration(vars.draw.timing/2)
              .call(style)
              .call(opacity)

            text.enter().append("text")
              .attr("font-size",fontSize)
              .attr("id","d3plus_label_"+d.d3plus.id)
              .attr("class","d3plus_label")
              .attr("opacity",0)
              .call(style,true)
              .transition().duration(vars.draw.timing/2)
              .delay(vars.draw.timing/2)
              .call(opacity)

          }
          else {

            text
              .attr("opacity",1)
              .call(style)
              .call(opacity)

            text.enter().append("text")
              .attr("font-size",fontSize)
              .attr("id","d3plus_label_"+d.d3plus.id)
              .attr("class","d3plus_label")
              .call(style,true)
              .call(opacity)

          }

          text.exit().call(remove)

          if (text.size() == 0 || text.html() == "") {
            delete d.d3plus_label
            group.selectAll("text#d3plus_label_"+d.d3plus.id+", rect#d3plus_label_bg_"+d.d3plus.id)
              .call(remove)
          }
          else {

            if (label.background) {

              var background_data = ["background"]

              var bounds = text.node().getBBox()

              bounds.width += vars.labels.padding*scale[0]
              bounds.height += vars.labels.padding*scale[0]
              bounds.x -= (vars.labels.padding*scale[0])/2
              bounds.y -= (vars.labels.padding*scale[0])/2

            }
            else {
              var background_data = [],
                  bounds = {}
            }

            var bg = group.selectAll("rect#d3plus_label_bg_"+d.d3plus.id)
                       .data(background_data)
              , bg_opacity = typeof label.background === "number"
                           ? label.background : 0.6

            function bg_style(elem) {

              var color = vars.background.value === "none"
                        ? "#ffffff" : vars.background.value
                , fill = typeof label.background === "string"
                       ? label.background : color
                , a = label.angle || 0
                , x = label.translate ? bounds.x+bounds.width/2 : 0
                , y = label.translate ? bounds.y+bounds.height/2 : 0
                , transform = "scale("+1/scale[1]+")rotate("+a+","+x+","+y+")"

              elem
                .attr("fill",fill)
                .attr(bounds)
                .attr("transform",transform)

            }

            if (vars.draw.timing) {

              bg.exit().transition().duration(vars.draw.timing)
                .attr("opacity",0)
                .remove()

              bg.transition().duration(vars.draw.timing)
                .attr("opacity",bg_opacity)
                .call(bg_style)

              bg.enter().insert("rect",".d3plus_label")
                .attr("id","d3plus_label_bg_"+d.d3plus.id)
                .attr("class","d3plus_label_bg")
                .attr("opacity",0)
                .call(bg_style)
                .transition().duration(vars.draw.timing)
                  .attr("opacity",bg_opacity)

            }
            else {

              bg.exit().remove()

              bg.enter().insert("rect",".d3plus_label")
                .attr("id","d3plus_label_bg_"+d.d3plus.id)
                .attr("class","d3plus_label_bg")

              bg.attr("opacity",bg_opacity)
                .call(bg_style)

            }

          }

        }
        else {
          delete d.d3plus_label
          group.selectAll("text#d3plus_label_"+d.d3plus.id+", rect#d3plus_label_bg_"+d.d3plus.id)
            .call(remove)
        }

      }
      else {
        delete d.d3plus_label
        group.selectAll("text#d3plus_label_"+d.d3plus.id+", rect#d3plus_label_bg_"+d.d3plus.id)
          .call(remove)
      }
    })

    if ( vars.dev.value ) d3plus.console.timeEnd( timerString )

  }
  else {

    if ( vars.dev.value ) {
      var timerString = "removing " + group + " labels"
      d3plus.console.time( timerString )
    }

    selection.selectAll("text.d3plus_label, rect.d3plus_label_bg")
      .call(remove)

    vars.g.labels.selectAll("text.d3plus_label, rect.d3plus_label_bg")
      .call(remove)

    if ( vars.dev.value ) d3plus.console.timeEnd( timerString )

  }
}

},{"../../core/fetch/text.js":undefined}],210:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Draws "line" shapes using svg:line
//------------------------------------------------------------------------------
d3plus.shape.line = function(vars,selection,enter,exit) {

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // The D3 line function that determines what variables to use for x and y
  // positioning, as well as line interpolation defined by the user.
  //----------------------------------------------------------------------------
  var line = d3.svg.line()
    .x(function(d){ return d.d3plus.x; })
    .y(function(d){ return d.d3plus.y; })
    .interpolate(vars.shape.interpolate.value)

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Divide each line into it's segments. We do this so that there can be gaps
  // in the line and mouseover.
  //
  // Then, create new data group from values to become small nodes at each
  // point on the line.
  //----------------------------------------------------------------------------

  var hitarea = vars.data.stroke.width
  if (hitarea < 30) {
    hitarea = 30
  }

  selection.each(function(d){

    var step = false,
        segments = [],
        nodes = [],
        temp = d3plus.util.copy(d),
        group = d3.select(this)

    temp.values = []
    d.values.forEach(function(v,i,arr){

      nodes.push(v)

      var k = v[vars[vars.continuous_axis].value],
          index = vars.tickValues[vars.continuous_axis].indexOf(k)

      if (step === false) {
        step = index
      }

      if ( i + step === index ) {
        temp.values.push(v)
        temp.key += "_"+segments.length
      }
      else {
        if (i > 0) {
          segments.push(temp)
          temp = d3plus.util.copy(d)
          temp.values = []
        }
        temp.values.push(v)
        temp.key += "_"+segments.length
        step++
      }

      if ( i === arr.length - 1 ) {
        segments.push(temp)
      }

    })

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Bind segment data to "paths"
    //--------------------------------------------------------------------------
    var paths = group.selectAll("path.d3plus_line")
      .data(segments, function(d){
        return d.key
      })

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Bind node data to "rects"
    //--------------------------------------------------------------------------
    var rects = group.selectAll("rect.d3plus_anchor")
      .data(nodes, function(d){
        return d.d3plus.id
      })

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // "paths" and "rects" Enter/Update
    //--------------------------------------------------------------------------
    if (vars.draw.timing) {

      paths.transition().duration(vars.draw.timing)
        .attr("d",function(d){ return line(d.values) })
        .call(d3plus.shape.style,vars)

      paths.enter().append("path")
        .attr("class","d3plus_line")
        .attr("d",function(d){ return line(d.values) })
        .call(d3plus.shape.style,vars)

      rects.enter().append("rect")
        .attr("class","d3plus_anchor")
        .attr("id",function(d){
          return d.d3plus.id
        })
        .call(init)
        .call(d3plus.shape.style,vars)

      rects.transition().duration(vars.draw.timing)
        .call(update)
        .call(d3plus.shape.style,vars)

      rects.exit().transition().duration(vars.draw.timing)
        .call(init)
        .remove()

    }
    else {

      paths.enter().append("path")
        .attr("class","d3plus_line")

      paths
        .attr("d",function(d){ return line(d.values) })
        .call(d3plus.shape.style,vars)

      rects.enter().append("rect")
        .attr("class","d3plus_anchor")
        .attr("id",function(d){
          return d.d3plus.id
        })

      rects.call(update)
        .call(d3plus.shape.style,vars)

    }

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Create mouse event lines
    //--------------------------------------------------------------------------
    var mouse = group.selectAll("path.d3plus_mouse")
      .data(segments, function(d){
        return d.key
      })

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Mouse "paths" Enter
    //--------------------------------------------------------------------------
    mouse.enter().append("path")
      .attr("class","d3plus_mouse")
      .attr("d",function(l){ return line(l.values) })
      .style("stroke","black")
      .style("stroke-width",hitarea)
      .style("fill","none")
      .style("stroke-linecap","round")
      .attr("opacity",0)

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Mouse "paths" Update
    //--------------------------------------------------------------------------
    mouse
      .on(d3plus.evt.over,function(m){

        if (!vars.draw.frozen) {

          d3.select(this.parentNode).selectAll("path.d3plus_line")
            .transition().duration(vars.timing.mouseevents)
            .style("stroke-width",vars.data.stroke.width*2)

          d3.select(this.parentNode).selectAll("rect")
            .transition().duration(vars.timing.mouseevents)
            .style("stroke-width",vars.data.stroke.width*2)
            .call(update,2)

        }

      })
      .on(d3plus.evt.out,function(d){

        if (!vars.draw.frozen) {

          d3.select(this.parentNode).selectAll("path.d3plus_line")
            .transition().duration(vars.timing.mouseevents)
            .style("stroke-width",vars.data.stroke.width)

          d3.select(this.parentNode).selectAll("rect")
            .transition().duration(vars.timing.mouseevents)
            .style("stroke-width",vars.data.stroke.width)
            .call(update)

        }

      })

    if (vars.draw.timing) {

      mouse.transition().duration(vars.draw.timing)
        .attr("d",function(l){ return line(l.values) })
        .style("stroke-width",hitarea)

    }
    else {

      mouse.attr("d",function(l){ return line(l.values) })
        .style("stroke-width",hitarea)

    }

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Mouse "paths" Exit
    //--------------------------------------------------------------------------
    mouse.exit().remove()

  })

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // The position and size of each anchor point on enter and exit.
  //----------------------------------------------------------------------------
  function init(n) {

    n
      .attr("x",function(d){
        return d.d3plus.x
      })
      .attr("y",function(d){
        return d.d3plus.y
      })
      .attr("width",0)
      .attr("height",0)

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // The position and size of each anchor point on update.
  //----------------------------------------------------------------------------
  function update(n,mod) {

    if (!mod) var mod = 0

    n
      .attr("x",function(d){
        var w = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.width
        return d.d3plus.x - ((w/2)+(mod/2))
      })
      .attr("y",function(d){
        var h = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.height
        return d.d3plus.y - ((h/2)+(mod/2))
      })
      .attr("width",function(d){
        var w = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.width
        return w+mod
      })
      .attr("height",function(d){
        var h = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.height
        return h+mod
      })
      .attr("rx",function(d){
        var w = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.width
        return (w+mod)/2
      })
      .attr("ry",function(d){
        var h = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.height
        return (h+mod)/2
      })

  }

}

},{}],211:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Draws "square" and "circle" shapes using svg:rect
//------------------------------------------------------------------------------
d3plus.shape.rect = function(vars,selection,enter,exit) {

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Calculate label position and pass data from parent.
  //----------------------------------------------------------------------------
  function data(d) {

    if (vars.labels.value && !d.d3plus.label) {

      d.d3plus_label = {
        "w": 0,
        "h": 0,
        "x": 0,
        "y": 0
      }

      var w = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.width,
          h = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.height

      d.d3plus_share = {
        "w": w,
        "h": d3.max([25,h/3]),
        "x": 0,
        "y": 0
      }

      d.d3plus_label.w = w
      d.d3plus_label.h = h

      d.d3plus_label.shape = vars.shape.value === "circle" ? "circle" : "square"

    }
    else if (d.d3plus.label) {
      d.d3plus_label = d.d3plus.label
    }

    return [d];

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // The position and size of each rectangle on enter and exit.
  //----------------------------------------------------------------------------
  function init(nodes) {

    nodes
      .attr("x",0)
      .attr("y",0)
      .attr("width",0)
      .attr("height",0)

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // The position and size of each rectangle on update.
  //----------------------------------------------------------------------------
  function update(nodes) {

    nodes
      .attr("x",function(d){
        var w = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.width
        return -w/2
      })
      .attr("y",function(d){
        var h = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.height
        return -h/2
      })
      .attr("width",function(d){
        var w = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.width
        return w
      })
      .attr("height",function(d){
        var h = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.height
        return h
      })
      .attr("rx",function(d){
        var rounded = vars.shape.value == "circle"
        var w = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.width
        return rounded ? (w+2)/2 : 0
      })
      .attr("ry",function(d){
        var rounded = vars.shape.value == "circle"
        var h = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.height
        return rounded ? (h+2)/2 : 0
      })
      .attr("transform",function(d){
        if ("rotate" in d.d3plus) {
          return "rotate("+d.d3plus.rotate+")"
        }
        return ""
      })
      .attr("shape-rendering",function(d){
        if (vars.shape.value == "square" && !("rotate" in d.d3plus)) {
          return vars.shape.rendering.value
        }
        else {
          return "auto"
        }
      })

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // "rects" Enter
  //----------------------------------------------------------------------------
  if (vars.draw.timing) {
    enter.append("rect")
      .attr("class","d3plus_data")
      .call(init)
      .call(d3plus.shape.style,vars)
  }
  else {
    enter.append("rect")
      .attr("class","d3plus_data")
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // "rects" Update
  //----------------------------------------------------------------------------
  if (vars.draw.timing) {
    selection.selectAll("rect.d3plus_data")
      .data(data)
      .transition().duration(vars.draw.timing)
        .call(update)
        .call(d3plus.shape.style,vars)
  }
  else {
    selection.selectAll("rect.d3plus_data")
      .data(data)
      .call(update)
      .call(d3plus.shape.style,vars)
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // "rects" Exit
  //----------------------------------------------------------------------------
  if (vars.draw.timing) {
    exit.selectAll("rect.d3plus_data")
      .transition().duration(vars.draw.timing)
      .call(init)
  }

}

},{}],212:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Fill style for all shapes
//-------------------------------------------------------------------
d3plus.shape.style = function(nodes,vars) {

  nodes
    .attr("fill",function(d){

      if (d.d3plus && d.d3plus.spline) {
        return "none"
      }
      else {
        return d3plus.shape.color(d,vars)
      }

    })
    .style("stroke", function(d){
      if (d.values) {
        var color = d3plus.shape.color(d.values[0],vars)
      }
      else {
        var color = d3plus.shape.color(d,vars)
      }
      return d3.rgb(color).darker(0.5)
    })
    .style("stroke-width",vars.data.stroke.width)
    .attr("opacity",vars.data.opacity)
    .attr("vector-effect","non-scaling-stroke")

}

},{}],213:[function(require,module,exports){
var fetchValue = require("../../core/fetch/value.js"),
    fetchColor = require("../../core/fetch/color.js"),
    fetchText  = require("../../core/fetch/text.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Bubbles
//------------------------------------------------------------------------------
var bubbles = function(vars) {

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Test for labels
  //----------------------------------------------------------------------------
  var label_height = vars.labels.value && !vars.small ? 50 : 0

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Sort Data
  //----------------------------------------------------------------------------
  d3plus.array.sort( vars.data.app , vars.order.value || vars.size.value
                   , vars.order.sort.value , vars.color.value , vars )

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Calculate rows and columns
  //----------------------------------------------------------------------------
  var dataLength = vars.data.app.length

  if (dataLength < 4) {

    var columns = dataLength
      , rows    = 1
  }
  else {

    var screenRatio = vars.width.viz / vars.height.viz
      , columns     = Math.ceil( Math.sqrt( dataLength * screenRatio ) )
      , rows        = Math.ceil( Math.sqrt( dataLength / screenRatio ) )

  }

  if (dataLength > 0) {

    while ((rows-1)*columns >= vars.data.app.length) {
      rows--
    }

  }

  var column_width = vars.width.viz/columns,
      column_height = vars.height.viz/rows

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Define size scale
  //----------------------------------------------------------------------------
  var domain_min = d3.min(vars.data.app, function(d){
    if (!vars.size.value) return 0
    return fetchValue(vars,d,vars.size.value,null,"min")
  })

  var domain_max = d3.max(vars.data.app, function(d){
    if (!vars.size.value) return 0
    return fetchValue(vars,d,vars.size.value)
  })

  var padding = 5

  var size_min = 20
  var size_max = (d3.min([column_width,column_height])/2)-(padding*2)
  size_max -= label_height

  var size = vars.size.scale.value
    .domain([domain_min,domain_max])
    .rangeRound([size_min,size_max])

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Calculate bubble packing
  //----------------------------------------------------------------------------
  var pack = d3.layout.pack()
    .size([column_width-padding*2,column_height-padding*2-label_height])
    .value(function(d) {
      if (!vars.size.value) return 0
      return fetchValue(vars,d,vars.size.value)
    })
    .padding(padding)
    .radius(function(d){
      return size(d)
    })

  var data = []

  var row = 0
  vars.data.app.forEach(function(d,i){

    var temp = pack.nodes(d)

    var xoffset = (column_width*i) % vars.width.viz,
        yoffset = column_height*row

    temp.forEach(function(t){
      t.xoffset = xoffset
      t.yoffset = yoffset+label_height
      if (t.depth < vars.depth.value) {
        t.d3plus.static = true
      }
      else {
        t.d3plus.static = false
      }
      if (temp.length == 1) {
        t.d3plus.label = false
      }
      else {
        t.d3plus.label = true
      }
    })

    data = data.concat(temp)

    if ((i+1) % columns == 0) {
      row++
    }

  })

  var downscale = size_max/d3.max(data,function(d){ return d.r })

  data.forEach(function(d){
    d.x = ((d.x-column_width/2)*downscale)+column_width/2
    d.d3plus.x = d.x+d.xoffset
    d.y = ((d.y-column_height/2)*downscale)+column_height/2
    d.d3plus.y = d.y+d.yoffset
    d.r = d.r*downscale
    d.d3plus.r = d.r
  })

  data.sort(function( a , b ){
    return a.depth - b.depth
  })

  var label_data = data.filter(function(d){
    return d.depth == 0
  })

  var labels = vars.group.selectAll("text.d3plus_bubble_label")
    .data(label_data,function(d){
      if (!d.d3plus.label_height) d.d3plus.label_height = 0
      return d[vars.id.nesting[d.depth]]
    })

  function label_style(l) {
    l
      .attr("x",function(d){
        return d.d3plus.x
      })
      .attr("y",function(d){
        return d.d3plus.y-d.r-d.d3plus.label_height-padding
      })
      .style("text-anchor","middle")
      .attr("font-weight",vars.labels.font.weight)
      .attr("font-family",vars.labels.font.family.value)
      .attr("font-size","12px")
      .style("fill",function(d){
        var color = fetchColor(vars,d)
        return d3plus.color.legible(color)
      })
      .each(function(d){
        if (d.r > 10 && label_height > 10) {

          var names = fetchText(vars,d,d.depth)

          d3plus.textwrap()
            .container( d3.select(this) )
            .height( label_height )
            .text( names )
            .width( column_width - padding * 2 )
            .draw()

        }
      })
      .attr("y",function(d){
        d.d3plus.label_height = d3.select(this).node().getBBox().height
        return d.d3plus.y-d.r-d.d3plus.label_height-padding
      })
      .selectAll("tspan")
        .attr("x",function(d){
          return d.d3plus.x
        })
  }

  labels.enter().append("text")
    .attr("class","d3plus_bubble_label")
    .call(label_style)
    .attr("opacity",0)

  labels.transition().duration(vars.draw.timing)
    .call(label_style)
    .attr("opacity",1)

  labels.exit()
    .attr("opacity",0)
    .remove()

  return data

}

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Visualization Settings and Helper Functions
//------------------------------------------------------------------------------
bubbles.fill         = true
bubbles.requirements = [ "data" ]
bubbles.scale        = 1.05
bubbles.shapes       = [ "circle" , "donut" ]
bubbles.tooltip      = "static"

module.exports = bubbles

},{"../../core/fetch/color.js":undefined,"../../core/fetch/text.js":undefined,"../../core/fetch/value.js":undefined}],214:[function(require,module,exports){
var fetchValue = require("../../core/fetch/value.js")
  , fetchColor = require("../../core/fetch/color.js")
  , fetchData  = require("../../core/fetch/data.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Chart
//------------------------------------------------------------------------------
var chart = function(vars) {

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Calculate size and position of graph
  //-------------------------------------------------------------------
  if (vars.small) {
    var graph = {"margin": {"top": 0, "right": 0, "bottom": 0, "left": 0}}
  }
  else {
    var graph = {"margin": {"top": 10, "right": 10, "bottom": 40, "left": 40}}
  }
  graph.width = vars.width.viz-graph.margin.left-graph.margin.right
  graph.height = vars.height.viz-graph.margin.top-graph.margin.bottom

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // If there is data, run the needed calculations
  //-------------------------------------------------------------------
  if (vars.data.app.length) {

    if (!vars.tickValues) vars.tickValues = {}

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Determine X and Y axis
    //-------------------------------------------------------------------
    vars.continuous_axis = null
    vars.opp_axis = null
    vars.stacked_axis = null

    vars.axes.values.forEach(function(axis){

      if (vars[axis].stacked.value) {
        vars.stacked_axis = axis
      }
      if (!vars.continuous_axis && vars[axis].scale.value == "continuous") {
        vars.continuous_axis = axis
        vars.opp_axis = axis == "x" ? "y" : "x"
      }

      if (vars.data.changed || vars.depth.changed || !vars[axis+"_range"] || vars.time.fixed.value) {

        if ( vars.dev.value ) d3plus.console.time("determining "+axis+"-axis")
        if (vars[axis].scale.value == "share") {
          vars[axis+"_range"] = [0,1]
          vars.tickValues[axis] = d3plus.util.buckets([0,1],11)
          vars.stacked_axis = axis
        }
        else if (vars[axis].stacked.value) {
          if (vars.time.fixed.value) {
            var range_data = vars.data.app
          }
          else {
            var range_data = fetchData(vars,["all"])
          }
          var xaxis_sums = d3.nest()
            .key(function(d){return d[vars.x.value] })
            .rollup(function(leaves){
              return d3.sum(leaves, function(d){
                return fetchValue(vars,d,vars[axis].value)
              })
            })
            .entries(range_data)

          vars[axis+"_range"] = [0,d3.max(xaxis_sums, function(d){ return d.values; })]
        }
        else if (vars[axis].domain instanceof Array) {
          vars[axis+"_range"] = vars[axis].domain
          vars.tickValues[axis] = d3plus.util.uniques(vars.data.app,vars[axis].value)
          vars.tickValues[axis] = vars.tickValues[axis].filter(function(t){
            return t >= vars[axis+"_range"][0] && t <= vars[axis+"_range"][1]
          })
        }
        else if (vars.time.fixed.value) {
          vars[axis+"_range"] = d3.extent(vars.data.app,function(d){
            return fetchValue(vars,d,vars[axis].value)
          })
          vars.tickValues[axis] = d3plus.util.uniques(vars.data.app,vars[axis].value)
        }
        else {
          var all_depths = []
          for (id in vars.id.nesting) {
            all_depths = all_depths.concat(vars.data.grouped[vars.id.nesting[id]].all)
          }
          vars[axis+"_range"] = d3.extent(all_depths,function(d){
            return fetchValue(vars,d,vars[axis].value)
          })
          vars.tickValues[axis] = d3plus.util.uniques(fetchData(vars,["all"]),vars[axis].value)
        }

        // add padding to axis if there is only 1 value
        if (vars[axis+"_range"][0] === vars[axis+"_range"][1]) {
          if (vars[axis].value === vars.time.value) {
            var closestTime = d3plus.util.closest(vars.data.time.ticks,vars[axis+"_range"][0])
              , timeIndex = vars.data.time.ticks.indexOf(closestTime)

            if (timeIndex > 0) {
              vars[axis+"_range"][0] = vars.data.time.ticks[timeIndex-1]
            }
            else {
              var diff = vars.data.time.ticks[timeIndex+1] - closestTime
              vars[axis+"_range"][0] = new Date(closestTime.getTime() - diff)
            }
            if (timeIndex < vars.data.time.ticks.length - 1) {
              vars[axis+"_range"][1] = vars.data.time.ticks[timeIndex+1]
            }
            else {
              var diff = closestTime - vars.data.time.ticks[timeIndex-1]
              vars[axis+"_range"][1] = new Date(closestTime.getTime() + diff)
            }
          }
          else {
            vars[axis+"_range"][0] -= 1
            vars[axis+"_range"][1] += 1
          }
        }

        // reverse Y axis
        if (axis == "y") vars.y_range = vars.y_range.reverse()

        if ( vars.dev.value ) d3plus.console.timeEnd("determining "+axis+"-axis")
      }
      else if (!vars[axis+"_range"]) {
        vars[axis+"_range"] = [-1,1]
      }

    })

    //===================================================================

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Mirror axes, if applicable
    //-------------------------------------------------------------------
    if (vars.axes.mirror.value) {
      var domains = vars.y_range.concat(vars.x_range)
      vars.x_range = d3.extent(domains)
      vars.y_range = d3.extent(domains).reverse()
    }

    //===================================================================

    var data = vars.data.app

    //===================================================================

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Determine size of nodes
    //-------------------------------------------------------------------

    if (data) {

      if ( vars.dev.value ) d3plus.console.time("determining size scale")
      if (vars.size.value) {
        if (vars.time.fixed.value) {
          var size_domain = d3.extent(vars.data.app,function(d){
            var val = fetchValue(vars,d,vars.size.value)
            return val == 0 ? null : val
          })
        }
        else {
          var all_depths = []
          for (id in vars.id.nesting) {
            all_depths = all_depths.concat(vars.data.grouped[vars.id.nesting[id]].all)
          }
          var size_domain = d3.extent(all_depths,function(d){
            var val = fetchValue(vars,d,vars.size.value)
            return val == 0 ? null : val
          })
        }
        if (!size_domain[0] || !size_domain[1]) size_domain = [0,0]
      }
      else {
        var size_domain = [0,0]
      }

      var max_size = Math.floor(d3.max([d3.min([graph.width,graph.height])/15,10])),
          min_size = 10

      if (size_domain[0] == size_domain[1]) var min_size = max_size

      var size_range = [min_size,max_size]

      var radius = vars.size.scale.value
        .domain(size_domain)
        .rangeRound(size_range)

      if ( vars.dev.value ) d3plus.console.timeEnd("determining size scale")

    }

    //===================================================================

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Create axis scales and add buffer if necessary
    //-------------------------------------------------------------------
    var tickAttrs = {
      "font-size":   vars.axes.ticks.font.size,
      "fill":        vars.axes.ticks.font.color,
      "font-family": vars.axes.ticks.font.family.value,
      "font-weight": vars.axes.ticks.font.weight
    }

    vars.axes.values.forEach(function(axis){

      // Create Axes
      var range_max = axis == "x" ? graph.width : graph.height

      if (["continuous","share"].indexOf(vars[axis].scale.value) >= 0) {
        var s = "linear"
      }
      else {
        var s = vars[axis].scale.value
      }

      vars[axis+"_scale"] = d3.scale[s]()
        .domain(vars[axis+"_range"])
        .rangeRound([0,range_max])

      // set buffer room (take into account largest size var)
      if (["square","circle","donut"].indexOf(vars.shape.value) >= 0 &&
          ["share"].indexOf(vars[axis].scale.value) < 0) {

        var scale = vars[axis+"_scale"]
          , largest_size = radius.range()[1]*2
          , domainHigh = scale.invert(-largest_size)
          , domainLow= scale.invert(range_max+largest_size)

        vars[axis+"_scale"].domain([domainHigh,domainLow])

      }

      var orient = axis == "x" ? "bottom" : "left"

      vars[axis+"_axis"] = d3.svg.axis()
        .tickSize(vars.axes.ticks.size)
        .tickPadding(5)
        .orient(orient)
        .scale(vars[axis+"_scale"])
        .tickFormat(function(d, i) {

          var visible = true
          if (vars[axis].value == vars.time.value && d % 1 != 0) {
            visible = false
          }

          if (((vars[axis].scale.value == "log" && d.toString().charAt(0) == "1")
              || vars[axis].scale.value != "log") && visible) {

            if (vars[axis].scale.value == "share") {
              var text = d*100+"%"
            }
            else if (d.constructor === Date) {
              var text = vars.data.time.multiFormat(d)
            }
            else {
              var text = vars.format.value(d,vars[axis].value);
            }

          }
          else {
            var text = null
          }

          return text;

        })

      if (vars[axis].value === vars.time.value) {
        var range = vars[axis+"_range"]
        vars[axis].ticks = vars.data.time.ticks.filter(function(t){
          return t <= range[1] && t >= range[0]
        })

        var minClosest = d3plus.util.closest(vars.data.time.ticks,range[0])
        var maxClosest = d3plus.util.closest(vars.data.time.ticks,range[1])
        if (vars[axis].ticks.indexOf(minClosest) < 0) {
          vars[axis].ticks.unshift(minClosest)
        }
        if (vars[axis].ticks.indexOf(maxClosest) < 0) {
          vars[axis].ticks.push(maxClosest)
        }
      }
      else if (vars.continuous_axis === axis) {
        vars[axis].ticks = vars.tickValues[axis]
      }
      else {
        vars[axis].ticks = vars[axis+"_scale"].ticks()
      }

      vars[axis+"_axis"].tickValues(vars[axis].ticks)

    })

  }

  // Function for Tick Styling
  function tick_style(t,axis) {
    t
      .attr("stroke",vars.axes.ticks.color)
      .attr("stroke-width",vars.axes.ticks.width)
      .attr("shape-rendering",vars.shape.rendering.value)
      .style("opacity",function(d){
        var lighter = vars[axis].scale.value == "log" && d.toString().charAt(0) != "1"
        return lighter ? 0.25 : 1
      })
  }

  // Function for Tick Styling
  function tick_position(t,axis) {
    t
      .attr("x1",function(d){
        return axis == "x" ? vars.x_scale(d) : 0
      })
      .attr("x2",function(d){
        return axis == "x" ? vars.x_scale(d) : graph.width
      })
      .attr("y1",function(d){
        return axis == "y" ? vars.y_scale(d) : 0
      })
      .attr("y2",function(d){
        return axis == "y" ? vars.y_scale(d) : graph.height
      })
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Calculate Spacing Needed for Axes Labels
  //-------------------------------------------------------------------
  var yTicks = vars.y.ticks.map(function(d){
        return vars.format.value(d,vars.y.value)
      })
    , yAxisWidth = d3.max(d3plus.font.sizes(yTicks,tickAttrs),function(d){return d.width}) + vars.labels.padding
  graph.margin.left += yAxisWidth
  graph.width -= yAxisWidth

  var xTicks = vars.x.ticks.map(function(d){
        return vars.format.value(d,vars.x.value)
      })
    , xSizes = d3plus.font.sizes(xTicks,tickAttrs)
    , xAxisWidth = d3.max(xSizes,function(d){return d.width})
    , xAxisHeight = d3.max(xSizes,function(d){return d.height})
    , xMaxWidth = d3.min([graph.width/(xTicks.length+1),graph.margin.left*2]) - vars.labels.padding*2

  if (xAxisWidth < xMaxWidth) {
    xAxisWidth += vars.labels.padding
    var xAnchor = "middle"
      , xDy     = "0ex"
      , xTransform = "translate(0,10)"
  }
  else {
    xAxisWidth = xAxisHeight + vars.labels.padding
    xAxisHeight = d3.max(xSizes,function(d){return d.width})
    var xRotate = true
      , xAnchor = "start"
      , xDy     = "0.5ex"
      , xTransform = "translate(15,10)rotate(70)"
  }

  graph.height -= xAxisHeight
  graph.width -= xAxisWidth/2
  vars.x_scale.rangeRound([0,graph.width])
  vars.y_scale.rangeRound([0,graph.height])

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Enter SVG Elements
  //-------------------------------------------------------------------

  // Enter Background Plane
  var plane = vars.group.selectAll("g#plane").data(["plane"])
  plane.enter().append("g")
    .attr("id","plane")
    .attr("transform", "translate(" + graph.margin.left + "," + graph.margin.top + ")")

  // Enter Background Rectangle
  var bg = plane.selectAll("rect#background").data(["background"])
  bg.enter().append("rect")
    .attr("id","background")
    .attr("x",0)
    .attr("y",0)
    .attr("width", graph.width)
    .attr("height", graph.height)
    .attr("stroke-width",1)
    .attr("stroke","#ccc")
    .attr("shape-rendering",vars.shape.rendering.value)
    .attr("fill","#fafafa")

  // Enter Background Mirror
  var mirror = plane.selectAll("path#mirror").data(["mirror"])
  mirror.enter().append("path")
    .attr("id","mirror")
    .attr("fill","#000")
    .attr("fill-opacity",0.03)
    .attr("stroke-width",1)
    .attr("stroke","#ccc")
    .attr("stroke-dasharray","10,10")
    .attr("opacity",0)

  // Enter Axes
  var axes = vars.group.selectAll("g#axes").data(["axes"])
  axes.enter().append("g")
    .attr("id","axes")

  // Enter X Axis Grid
  var xgrid = plane.selectAll("g#xgrid").data(["xgrid"])
  xgrid.enter().append("g")
    .attr("id","xgrid")

  // Enter Y Axis Grid
  var ygrid = plane.selectAll("g#ygrid").data(["ygrid"])
  ygrid.enter().append("g")
    .attr("id","ygrid")

  // Enter X Axis Scale
  var xaxis = plane.selectAll("g#xaxis").data(["xaxis"])
  xaxis.enter().append("g")
    .attr("id","xaxis")
    .attr("transform", "translate(0," + graph.height + ")")
    .call(vars.x_axis.scale(vars.x_scale))
    .selectAll("g.tick").select("text")
      .attr(tickAttrs)
      .style("text-anchor",xAnchor)
      .attr("dy",xDy)
      .attr("transform",xTransform)

  // Enter Y Axis Scale
  var yaxis = plane.selectAll("g#yaxis").data(["yaxis"])
  yaxis.enter().append("g")
    .attr("id","yaxis")
    .call(vars.y_axis.scale(vars.y_scale))
    .selectAll("g.tick").select("text")
      .attr(tickAttrs)

  // Enter X Axis Label
  var xlabel = axes.selectAll("text#xlabel").data(vars.small ? [] : ["xlabel"])
  xlabel.enter().append("text")
    .attr("id", "xlabel")
    .attr("x", vars.width.viz/2)
    .attr("y", vars.height.viz-10)
    .text(vars.format.value(vars.x.value))
    .attr("font-family",vars.labels.font.family.value)
    .attr("font-weight",vars.labels.font.weight)
    .attr("font-size",vars.labels.font.size)
    .attr("fill",vars.labels.font.color)
    .style("text-anchor",vars.labels.font.align)
  xlabel.exit().remove()

  // Enter Y Axis Label
  var ylabel = axes.selectAll("text#ylabel").data(vars.small ? [] : ["ylabel"])
  ylabel.enter().append("text")
    .attr("id", "ylabel")
    .attr("y", 15)
    .attr("x", -(graph.height/2+graph.margin.top))
    .text(vars.format.value(vars.y.value))
    .attr("transform","rotate(-90)")
    .attr("font-family",vars.labels.font.family.value)
    .attr("font-weight",vars.labels.font.weight)
    .attr("font-size",vars.labels.font.size)
    .attr("fill",vars.labels.font.color)
    .style("text-anchor",vars.labels.font.align)
  ylabel.exit().remove()

  // Enter Mouse Event Group
  var mouseevents = vars.group.selectAll("g#mouseevents").data(["mouseevents"])
  mouseevents.enter().append("g")
    .attr("id","mouseevents")

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Update SVG Elements
  //-------------------------------------------------------------------

  // Update Plane Group
  plane.transition().duration(vars.draw.timing)
    .attr("transform", "translate(" + graph.margin.left + "," + graph.margin.top + ")")

  // Update Plane Background
  bg.attr("width", graph.width)
    .attr("height", graph.height)

  // Update Mirror Triangle
  mirror.transition().duration(vars.draw.timing)
    .attr("opacity",function(){
      return vars.axes.mirror.value ? 1 : 0
    })
    .attr("d",function(){
      var w = graph.width, h = graph.height
      return "M "+w+" "+h+" L 0 "+h+" L "+w+" 0 Z"
    })

  // Update Y Axis
  yaxis.transition().duration(vars.draw.timing)
    .call(vars.y_axis.scale(vars.y_scale))
    .selectAll("g.tick").select("text")
      .attr(tickAttrs)

  yaxis.selectAll("line").transition().duration(vars.draw.timing)
      .call(tick_style,"y")

  yaxis.selectAll("path").attr("fill","none")

  // Update X Axis
  xaxis.transition().duration(vars.draw.timing)
    .attr("transform", "translate(0," + graph.height + ")")
    .call(vars.x_axis.scale(vars.x_scale))
    .selectAll("g.tick").select("text")
      .attr(tickAttrs)
      .style("text-anchor",xAnchor)
      .attr("dy",xDy)
      .attr("transform",xTransform)

  xaxis.selectAll("line").transition().duration(vars.draw.timing)
      .call(tick_style,"x")

  xaxis.selectAll("path").attr("fill","none")

  // Update Y Grid
  var ylines = ygrid.selectAll("line")
    .data(vars.y.ticks)

  ylines.enter().append("line")
    .style("opacity",0)
    .call(tick_position,"y")
    .call(tick_style,"y")

  ylines.transition().duration(vars.draw.timing)
    .style("opacity",1)
    .call(tick_position,"y")
    .call(tick_style,"y")

  ylines.exit().transition().duration(vars.draw.timing)
    .style("opacity",0)
    .remove()

  // Update X Grid
  var xlines = xgrid.selectAll("line")
    .data(vars.x.ticks)

  xlines.enter().append("line")
    .style("opacity",0)
    .call(tick_position,"x")
    .call(tick_style,"x")

  xlines.transition().duration(vars.draw.timing)
    .style("opacity",1)
    .call(tick_position,"x")
    .call(tick_style,"x")

  xlines.exit().transition().duration(vars.draw.timing)
    .style("opacity",0)
    .remove()

  // Update X Axis Label
  xlabel.text(vars.format.value(vars.x.value))
    .attr("x", vars.width.viz/2)
    .attr("y", vars.height.viz-10)
    .attr("opacity",function(){
      if (vars.data.app.length == 0) return 0
      else return 1
    })

  // Update Y Axis Label
  ylabel.text(vars.format.value(vars.y.value))
    .attr("y", 15)
    .attr("x", -(graph.height/2+graph.margin.top))
    .attr("opacity",function(){
      if (vars.data.app.length == 0) return 0
      else return 1
    })

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Enter/Update User-Defined Axis Lines
  //-------------------------------------------------------------------

  function get_name(d) {
    if (typeof d == "number" || typeof d == "string") {
      return null;
    }
    else {
      return d3.keys(d)[0]
    }
  }

  function get_val(d) {
    if (typeof d == "number") {
      return d;
    }
    else if (typeof d == "string") {
      return parseFloat(d);
    }
    else {
      var v = d[d3.keys(d)[0]]
      if (typeof v == "string") {
        return parseFloat(v);
      }
      else {
        return v;
      }
    }
  }

  vars.axes.values.forEach(function(axis){

    var lines = plane.selectAll("g.d3plus_"+axis+"line")
      .data(vars[axis].lines,function(l){
        if (typeof l == "number" || typeof l == "string") {
          return l
        }
        else {
          return d3.keys(l)[0]
        }
      })

    var enter = lines.enter().append("g")
      .attr("class","d3plus_"+axis+"line")

    var max = axis == "x" ? "height" : "width",
        pos = axis == "x" ? (graph.height-8)+"px" : "10px",
        padding = axis == "x" ? 10 : 20

    enter.append("line")
      .attr(axis+"1",0)
      .attr(axis+"2",graph[max])
      .attr("stroke","#ccc")
      .attr("stroke-width",3)
      .attr("stroke-dasharray","10,10")

    enter.append("text")
      .attr("font-size",vars.axes.ticks.font.size)
      .attr("fill",vars.axes.ticks.font.color)
      .attr("text-align","start")
      .attr(axis,pos)

    lines.selectAll("line").transition().duration(vars.draw.timing)
      .attr(axis+"1",function(d){
        return get_val(d) ? vars[axis+"_scale"](get_val(d)) : 0
      })
      .attr(axis+"2",function(d){
        return get_val(d) ? vars[axis+"_scale"](get_val(d)) : 0
      })
      .attr("opacity",function(d){
        var yes = get_val(d) > vars[axis+"_scale"].domain()[1] && get_val(d) < vars[axis+"_scale"].domain()[0]
        return get_val(d) !== null && yes ? 1 : 0
      })

    lines.selectAll("text").transition().duration(vars.draw.timing)
      .text(function(){
        if (get_val(d) !== null) {
          var v = vars.format.value(get_val(d),y_name)
          return get_name(d) ? vars.format.value(get_name(d)) + ": " + v : v
        }
        else return null
      })
      .attr(axis,function(d){
        return (vars[axis+"_scale"](get_val(d))+padding)+"px"
      })

  })

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Format Data for Plotting
  //-------------------------------------------------------------------

  if (["line","area"].indexOf(vars.shape.value) >= 0) {
    radius.rangeRound([2,2])
  }

  vars.axis_offset = {
    "x": graph.margin.left,
    "y": graph.margin.top
  }

  data.forEach(function(d){
    d.d3plus.x = vars.x_scale(fetchValue(vars,d,vars.x.value))
    d.d3plus.x += vars.axis_offset.x

    d.d3plus.r = radius(fetchValue(vars,d,vars.size.value))

    if (!vars.stacked_axis) {

      d.d3plus.y = vars.y_scale(fetchValue(vars,d,vars.y.value))
      d.d3plus.y += vars.axis_offset.y

      if (vars.shape.value == "area") {
        d.d3plus[vars.opp_axis+"0"] = vars[vars.opp_axis+"_scale"].range()[1]
        d.d3plus[vars.opp_axis+"0"] += vars.axis_offset[vars.opp_axis]
      }

    }

  })

  var sort = vars.order.value ? vars.order.value : vars.continuous_axis
           ? vars[vars.opp_axis].value : vars.size.value || vars.id.value

  if (["line","area"].indexOf(vars.shape.value) >= 0) {

    data = d3.nest()
      .key(function(d){
        var id = fetchValue(vars,d,vars.id.value),
            depth = d.d3plus.depth ? d.d3plus.depth : 0
        return d3plus.string.strip(id)+"_"+depth+"_"+vars.shape.value
      })
      .rollup(function(leaves){

        var availables = d3plus.util.uniques(leaves,vars[vars.continuous_axis].value),
            previousMissing = false,
            timeVars = vars[vars.continuous_axis].value === vars.time.value

        if (timeVars && availables[0].constructor === Date) {
          availables = availables.map(function(t){return t.getTime()})
        }

        vars[vars.continuous_axis].ticks.forEach(function(v,i,arr){

          var tester = timeVars ? v.getTime() : v

          if(availables.indexOf(tester) < 0){

            var obj = {}
            obj[vars[vars.continuous_axis].value] = v
            obj[vars.id.value] = leaves[0][vars.id.value]
            obj[vars[vars.opp_axis].value] = vars[vars.opp_axis+"_scale"].domain()[1]
            obj.d3plus = {}

            obj.d3plus.r = radius(radius.domain()[0])
            obj.d3plus[vars.continuous_axis] += vars.axis_offset[vars.continuous_axis]

            if (!vars.stacked_axis) {
              obj.d3plus[vars.opp_axis] = vars[vars.opp_axis+"_scale"].range()[1]
              obj.d3plus[vars.opp_axis] += vars.axis_offset[vars.opp_axis]
              obj.d3plus[vars.opp_axis+"0"] = obj.d3plus[vars.opp_axis]
            }

            if (vars[vars.continuous_axis].zerofill.value || vars[vars.opp_axis].stacked.value) {
              var position = vars[vars.continuous_axis+"_scale"](v)
              position += vars.axis_offset[vars.continuous_axis]
              obj.d3plus[vars.continuous_axis] = position
              leaves.push(obj)
            }
            else if (vars.shape.value != "line") {
              if (!previousMissing && i > 0) {
                var position = vars[vars.continuous_axis+"_scale"](arr[i-1])
                position += vars.axis_offset[vars.continuous_axis]
                obj.d3plus[vars.continuous_axis] = position
                leaves.push(obj)
              }
              if (i < arr.length-1) {
                var position = vars[vars.continuous_axis+"_scale"](arr[i+1])
                position += vars.axis_offset[vars.continuous_axis]
                var obj2 = d3plus.util.copy(obj)
                obj2.d3plus[vars.continuous_axis] = position
                leaves.push(obj2)
              }
            }
            previousMissing = true

          }
          else {
            previousMissing = false
          }

        })

        leaves.sort(function(a,b){
          var xsort = a.d3plus[vars.continuous_axis] - b.d3plus[vars.continuous_axis]
          if (xsort) return xsort
          var ksort = a[vars[vars.continuous_axis].value] - b[vars[vars.continuous_axis].value]
          return ksort
        })

        return leaves
      })
      .entries(data)

    data.forEach(function(d,i){

      if ("d3plus" in d.values[0]) {

        if (!d.d3plus) d.d3plus = {}

        d.values.forEach(function(l){
          if (l.d3plus.merged instanceof Array) {
            if (!d.d3plus.merged) d.d3plus.merged = []
            d.d3plus.merged = d.d3plus.merged.concat(l.d3plus.merged)
          }
          if (l.d3plus.text) d.d3plus.text = l.d3plus.text
        })
      }

      vars.id.nesting.forEach(function(n,i){
        if (i <= vars.depth.value && !d[n]) {
          d[n] = d3plus.util.uniques(d.values,n).filter(function(unique){
            return unique && unique != "undefined"
          })[0]
        }
      })

      if ( !(sort in d) ) {
        d[sort] = 0
        d.values.forEach(function(v){
          var val = fetchValue(vars,v,sort)
          if (val) {
            if (typeof val == "number") {
              d[sort] += val
            }
            else {
              d[sort] = val
            }
          }
        })
      }

    })

  }

  if (sort) {

    d3plus.array.sort( data , sort
                     , vars.order.sort.value === "desc" ? "asc" : "desc"
                     , vars.color.value || [] , vars )

  }

  if (vars.stacked_axis) {

    var stack = d3.layout.stack()
      .values(function(d) { return d.values; })
      .x(function(d) { return d.d3plus.x; })
      // .x(function(d) { return d.d3plus.y; })
      .y(function(d) {
        var flip = graph.height,
            val = fetchValue(vars,d,vars.y.value)
        return flip-vars.y_scale(val);
      })
      .out(function(d,y0,y){

        var flip = graph.height

        if (vars[vars.stacked_axis].scale.value == "share") {
          d.d3plus.y0 = (1-y0)*flip
          d.d3plus.y = d.d3plus.y0-(y*flip)
        }
        else {
          d.d3plus.y0 = flip-y0
          d.d3plus.y = d.d3plus.y0-y
        }
        d.d3plus.y += graph.margin.top
        d.d3plus.y0 += graph.margin.top

      })

    var offset = vars[vars.stacked_axis].scale.value == "share" ? "expand" : "zero";
    var data = stack.offset(offset)(data)

  }
  else if (["area","line"].indexOf(vars.shape.value) < 0) {

    function data_tick(l,axis) {
      l
        .attr("x1",function(d){
          return axis == "y" ? 0 : d.d3plus.x-graph.margin.left
        })
        .attr("x2",function(d){
          return axis == "y" ? -5 : d.d3plus.x-graph.margin.left
        })
        .attr("y1",function(d){
          return axis == "x" ? graph.height : d.d3plus.y-graph.margin.top
        })
        .attr("y2",function(d){
          return axis == "x" ? graph.height+5 : d.d3plus.y-graph.margin.top
        })
        .style("stroke",function(d){
          return d3plus.color.legible(fetchColor(vars,d));
        })
        .style("stroke-width",vars.data.stroke.width)
        .attr("shape-rendering",vars.shape.rendering.value)
    }

    var data_ticks = plane.selectAll("g.d3plus_data_ticks")
      .data(data,function(d){
        return d[vars.id.value]+"_"+d.d3plus.depth
      })

    var tick_enter = data_ticks.enter().append("g")
      .attr("class","d3plus_data_ticks")
      .attr("opacity",0)

    tick_enter.append("line")
      .attr("class","d3plus_data_y")
      .call(data_tick,"y")

    data_ticks.selectAll("line.d3plus_data_y")
      .call(data_tick,"y")

    tick_enter.append("line")
      .attr("class","d3plus_data_x")
      .call(data_tick,"x")

    data_ticks.selectAll("line.d3plus_data_x")
      .call(data_tick,"x")

    data_ticks.transition().duration(vars.draw.timing)
      .attr("opacity",1)

    data_ticks.exit().transition().duration(vars.draw.timing)
      .attr("opacity",0)
      .remove()

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Plot data on chart!
  //-------------------------------------------------------------------

  function axis_lines(node) {

    var click_remove = d3.event.type == d3plus.evt.click && (vars.tooltip.value.long || vars.tooltip.html.value),
        create = [d3plus.evt.over,d3plus.evt.move].indexOf(d3.event.type) >= 0

    if (!click_remove && create && vars.shape.value != "area") {

      if (node.data) var node = node.data

      var line_data = [
        d3plus.util.copy(node.d3plus),
        d3plus.util.copy(node.d3plus)
      ]
      line_data[0].axis = "x"
      line_data[1].axis = "y"

    }
    else {
      var line_data = []
    }

    function line_init(l) {
      l
        .attr("x2",function(d){
          var ret = d.axis == "x" ? d.x : d.x-d.r
          return ret
        })
        .attr("y2",function(d){
          var ret = d.axis == "y" ? d.y : d.y+d.r
          return ret
        })
        .style("stroke-width",0)
        .attr("opacity",0)
    }

    var lines = mouseevents.selectAll("line.d3plus_axis_label")
      .data(line_data,function(d){
        return d.axis+"_"+d.id
      })

    lines.enter().append("line")
      .attr("class","d3plus_axis_label")
      .call(line_init)
      .attr("x1",function(d){
        return d.axis == "x" ? d.x : d.x-d.r
      })
      .attr("y1",function(d){
        return d.axis == "y" ? d.y : d.y+d.r
      })
      .style("stroke",function(d){
        return fetchColor(vars,node)
      })
      .attr("shape-rendering",vars.shape.rendering.value)

    lines.transition().duration(vars.timing.mouseevents)
      .attr("class","d3plus_axis_label")
      .attr("x2",function(d){
        return d.axis == "x" ? d.x : graph.margin.left-vars.axes.ticks.size
      })
      .attr("y2",function(d){
        return d.axis == "y" ? d.y : graph.height+graph.margin.top+vars.axes.ticks.size
      })
      .style("stroke",function(d){
        return d3plus.color.legible(fetchColor(vars,node));
      })
      .style("stroke-width",vars.data.stroke.width)
      .attr("opacity",1)

    lines.exit().transition().duration(vars.timing.mouseevents)
      .call(line_init)
      .remove()

    var texts = mouseevents.selectAll("text.d3plus_axis_label")
      .data(line_data,function(d){
        return d.axis+"_"+d.id
      })

    texts.enter().append("text")
      .attr("class","d3plus_axis_label")
      .attr("id",function(d){
        return d.axis+"_"+d.id
      })
      .text(function(d){
        var val = fetchValue(vars,node.d3plus_data || node,vars[d.axis].value)
        return vars.format.value(val,vars[d.axis].value)
      })
      .attr("x",function(d){
        return d.axis == "x" ? d.x : graph.margin.left-5-vars.axes.ticks.size
      })
      .attr("y",function(d){
        return d.axis == "y" ? d.y : graph.height+graph.margin.top+5+vars.axes.ticks.size
      })
      .attr("dy",function(d){
        return d.axis == "y" ? (vars.axes.ticks.font.size*.35) : vars.axes.ticks.font.size
      })
      .style("text-anchor",function(d){
        return d.axis == "y" ? "end": "middle"
      })
      .attr("fill",function(d){
        return d3plus.color.legible(fetchColor(vars,node));
      })
      .attr("font-size",vars.axes.ticks.font.size)
      .attr("font-family",vars.axes.ticks.font.family.value)
      .attr("font-weight",vars.axes.ticks.font.weight)
      .attr("opacity",0)

    texts.transition().duration(vars.timing.mouseevents)
      .delay(vars.timing.mouseevents)
      .attr("opacity",1)

    texts.exit().transition().duration(vars.timing.mouseevents)
      .attr("opacity",0)
      .remove()

    var rects = mouseevents.selectAll("rect.d3plus_axis_label")
      .data(line_data,function(d){
        return d.axis+"_"+d.id
      })

    rects.enter().insert("rect","text")
      .attr("class","d3plus_axis_label")
      .attr("x",function(d){
        var width = d3.select("text#"+d.axis+"_"+d.id).node().getBBox().width
        var ret = d.axis == "x" ? d.x : graph.margin.left-vars.axes.ticks.size
        return d.axis == "x" ? ret-width/2-5 : ret-width-10
      })
      .attr("y",function(d){
        var height = d3.select("text#"+d.axis+"_"+d.id).node().getBBox().height
        var ret = d.axis == "y" ? d.y : graph.height+graph.margin.top
        return d.axis == "x" ? ret+vars.axes.ticks.size : ret-height/2-5
      })
      .attr("width",function(d){
        var text = d3.select("text#"+d.axis+"_"+d.id).node().getBBox()
        return text.width + 10
      })
      .attr("height",function(d){
        var text = d3.select("text#"+d.axis+"_"+d.id).node().getBBox()
        return text.height + 10
      })
      .style("stroke",function(d){
        return d3plus.color.legible(fetchColor(vars,node));
      })
      .attr("fill","white")
      .style("stroke-width",vars.data.stroke.width)
      .attr("shape-rendering",vars.shape.rendering.value)
      .attr("opacity",0)

    rects.transition().duration(vars.timing.mouseevents)
      .delay(vars.timing.mouseevents)
      .attr("opacity",1)

    rects.exit().transition().duration(vars.timing.mouseevents)
      .attr("opacity",0)
      .remove()

  }

  vars.mouse = axis_lines

  return data

}

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Visualization Settings and Helper Functions
//------------------------------------------------------------------------------
chart.fill         = true
chart.requirements = ["data","x","y"]
chart.scale        = {"circle": 1.1, "donut": 1.1, "square": 1.1 }
chart.setup        = function(vars) {
  if (vars.x.value === vars.time.value) vars.self.x({"scale": "continuous"})
  if (vars.y.value === vars.time.value) vars.self.y({"scale": "continuous"})
}
chart.shapes       = ["circle","donut","line","square","area"]
chart.tooltip      = "static"

module.exports = chart

},{"../../core/fetch/color.js":undefined,"../../core/fetch/data.js":undefined,"../../core/fetch/value.js":undefined}],215:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Geo Map
//------------------------------------------------------------------------------
var geo_map = function(vars) {

  topojson.presimplify(vars.coords.value)

  var coords = vars.coords.value
    , key = d3.keys(coords.objects)[0]
    , topo = topojson.feature(coords, coords.objects[key])
    , features = topo.features

  var features = features.filter(function(f){

    f[vars.id.value] = f.id

    if (vars.coords.solo.value.length) {

      return vars.coords.solo.value.indexOf(f.id) >= 0

    }
    else if (vars.coords.mute.value.length) {

      return vars.coords.mute.value.indexOf(f.id) < 0

    }

    return true

  })

  return features

};

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Visualization Settings and Helper Functions
//------------------------------------------------------------------------------
geo_map.libs         = [ "topojson" ];
geo_map.nesting      = false
geo_map.requirements = [ "color" , "coords" ];
geo_map.scale        = 1
geo_map.shapes       = [ "coordinates" ];
geo_map.tooltip      = "follow"
geo_map.zoom         = true

module.exports = geo_map

},{}],216:[function(require,module,exports){
var chart = require("./chart.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Line Plot
//------------------------------------------------------------------------------
var line = function(vars) {

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // This visualization is an extention of the Chart visualization.
  //----------------------------------------------------------------------------
  return chart(vars)

}

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Visualization Settings and Helper Functions
//------------------------------------------------------------------------------
line.requirements = [ "data" , "x" , "y" ]
line.setup = function(vars) {
  vars.self.x({ "scale" : "continuous" })
}
line.shapes       = [ "line" ]
line.tooltip      = "static"

module.exports = line

},{"./chart.js":undefined}],217:[function(require,module,exports){
var fetchValue = require("../../core/fetch/value.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Network
//------------------------------------------------------------------------------
var network = function(vars) {

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Use filtered lists if they are available
  //----------------------------------------------------------------------------
  var nodes = vars.nodes.restricted || vars.nodes.value,
      edges = vars.edges.restricted || vars.edges.value

  var x_range = d3.extent(nodes,function(n){return n.x}),
      y_range = d3.extent(nodes,function(n){return n.y})

  var val_range = vars.size.value ? d3.extent(nodes, function(d){
    var val = fetchValue( vars , d , vars.size.value )
    return val === 0 ? null : val
  }) : [ 1 , 1 ]

  if (typeof val_range[0] == "undefined") val_range = [1,1]

  var max_size = d3.min(d3plus.util.distances(nodes))

  var overlap = vars.size.value ? vars.nodes.overlap : 0.4
  max_size = max_size * overlap

  if (vars.edges.arrows.value) {
    max_size = max_size * 0.5
  }

  if ( val_range[0] === val_range[1] ) {
    var min_size = max_size
  }
  else {

    var width = (x_range[1]+max_size*1.1)-(x_range[0]-max_size*1.1),
        height = (y_range[1]+max_size*1.1)-(y_range[0]-max_size*1.1)
        aspect = width/height,
        app = vars.width.viz/vars.height.viz

    if ( app > aspect ) {
      var scale = vars.height.viz/height
    }
    else {
      var scale = vars.width.viz/width
    }
    var min_size = max_size * 0.25
    if ( min_size * scale < 2 ) {
      min_size = 2/scale
    }

  }

  // Create size scale
  var radius = vars.size.scale.value
    .domain(val_range)
    .range([min_size, max_size])

  vars.zoom.bounds = [ [ x_range[0]-max_size*1.1 , y_range[0]-max_size*1.1 ]
                     , [ x_range[1]+max_size*1.1 , y_range[1]+max_size*1.1 ] ]

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Match nodes to data
  //----------------------------------------------------------------------------
  var data = [], lookup = {}
  nodes.forEach(function(n){

    var d = vars.data.app.filter(function(a){
      return a[vars.id.value] == n[vars.id.value]
    })[0]

    if (d) {
      var obj = d3plus.object.merge(n,d)
    }
    else {
      var obj = d3plus.util.copy(n)
    }

    obj.d3plus = {}
    obj.d3plus.x = n.x
    obj.d3plus.y = n.y
    var val = fetchValue(vars,obj,vars.size.value)
    obj.d3plus.r = val ? radius(val) : radius.range()[0]
    lookup[obj[vars.id.value]] = {
      "x": obj.d3plus.x,
      "y": obj.d3plus.y,
      "r": obj.d3plus.r
    }
    data.push(obj)
  })

  data.sort(function(a,b){
    return b.d3plus.r - a.d3plus.r
  })

  edges.forEach(function(l,i){

    l[vars.edges.source].d3plus = {}
    var source = lookup[l[vars.edges.source][vars.id.value]]
    l[vars.edges.source].d3plus.r = source.r
    l[vars.edges.source].d3plus.x = source.x
    l[vars.edges.source].d3plus.y = source.y

    l[vars.edges.target].d3plus = {}
    var target = lookup[l[vars.edges.target][vars.id.value]]
    l[vars.edges.target].d3plus.r = target.r
    l[vars.edges.target].d3plus.x = target.x
    l[vars.edges.target].d3plus.y = target.y

  })

  return {"nodes": data, "edges": edges}

}

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Visualization Settings and Helper Functions
//------------------------------------------------------------------------------
network.nesting      = false
network.requirements = ["nodes","edges"]
network.scale        = 1.05
network.shapes       = [ "circle" , "square" , "donut" ]
network.tooltip      = "static"
network.zoom         = true

module.exports = network

},{"../../core/fetch/value.js":undefined}],218:[function(require,module,exports){
var fetchValue, shortestPath, viz,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

shortestPath = require("../../network/shortestPath.coffee");

fetchValue = require("../../core/fetch/value.js");

viz = function(vars) {
  var col, colIndex, columnWidth, columns, edge, edgeInt, edges, i, id, labelSpace, lastDir, lastHop, maxRadius, minRadius, newPath, next, nextDir, nextHop, nextIndex, node, path, pathInt, pathLookup, paths, prev, prevIndex, rowHeight, rows, size, sizeDomain, val, x, xDiff, y, yDomain, _base, _base1, _base2, _base3, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _m, _n, _o, _p, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
  edges = [];
  pathLookup = {};
  pathLookup[vars.focus.value[0]] = 0;
  pathLookup[vars.focus.value[1]] = 0;
  paths = {
    all: [[vars.focus.value[0]], [vars.focus.value[1]]]
  };
  _ref = viz.paths;
  for (pathInt = _i = 0, _len = _ref.length; _i < _len; pathInt = ++_i) {
    path = _ref[pathInt];
    edges = edges.concat(path.edges);
    lastHop = vars.focus.value[0];
    paths[pathInt] = [lastHop];
    _ref1 = path.edges;
    for (edgeInt = _j = 0, _len1 = _ref1.length; _j < _len1; edgeInt = ++_j) {
      edge = _ref1[edgeInt];
      edge[vars.edges.source] = vars.data.app.filter(function(d) {
        return edge[vars.edges.source][vars.id.value] === d[vars.id.value];
      })[0];
      edge[vars.edges.target] = vars.data.app.filter(function(d) {
        return edge[vars.edges.target][vars.id.value] === d[vars.id.value];
      })[0];
      nextDir = edge[vars.edges.source][vars.id.value] === lastHop ? "target" : "source";
      nextHop = edge[vars.edges[nextDir]][vars.id.value];
      if (pathLookup[nextHop] === void 0) {
        pathLookup[nextHop] = pathInt;
      }
      paths[pathInt].push(nextHop);
      lastHop = nextHop;
    }
  }
  rows = 0;
  for (pathInt in paths) {
    path = paths[pathInt];
    if (pathInt !== "all") {
      newPath = 0;
      for (i = _k = 0, _len2 = path.length; _k < _len2; i = ++_k) {
        id = path[i];
        if ((i !== 0 && i !== (path.length - 1)) && pathLookup[id] === parseFloat(pathInt)) {
          newPath = 1;
          prev = path[i - 1];
          next = path[i + 1];
          prevIndex = null;
          nextIndex = null;
          _ref2 = paths.all;
          for (colIndex = _l = 0, _len3 = _ref2.length; _l < _len3; colIndex = ++_l) {
            col = _ref2[colIndex];
            if (__indexOf.call(col, prev) >= 0) {
              prevIndex = colIndex;
            }
            if (__indexOf.call(col, next) >= 0) {
              nextIndex = colIndex;
            }
          }
          if (prevIndex !== null && nextIndex === null) {
            if (prevIndex + 1 === paths.all.length - 1) {
              paths.all.splice(prevIndex + 1, 0, [id]);
            } else {
              paths.all[prevIndex + 1].push(id);
            }
          } else if (nextIndex - prevIndex === 1) {
            paths.all.splice(nextIndex, 0, [id]);
          } else if (nextIndex - prevIndex > 1) {
            paths.all[nextIndex - 1].push(id);
          }
        }
      }
      rows += newPath;
    }
  }
  rowHeight = Math.floor(vars.height.viz / rows);
  yDomain = [];
  i = 0;
  while (i < rows) {
    if (i % 2 === 0) {
      yDomain.push(i);
    } else {
      yDomain.unshift(i);
    }
    i++;
  }
  labelSpace = vars.size.value && !vars.small ? 30 : 0;
  y = d3.scale.ordinal().domain(yDomain).range(d3.range(rowHeight / 2 - labelSpace, vars.height.viz + rowHeight / 2 - labelSpace, (vars.height.viz - rowHeight) / (rows - 1)));
  columns = paths["all"].length;
  columnWidth = Math.floor(vars.width.viz / columns);
  x = d3.scale.linear().domain([0, columns - 1]).rangeRound([columnWidth / 2, vars.width.viz - columnWidth / 2]);
  minRadius = 5;
  maxRadius = d3.min([columnWidth, rowHeight - labelSpace]) * 0.4;
  sizeDomain = d3.extent(vars.data.app, function(node) {
    var val;
    val = fetchValue(vars, node, vars.size.value);
    return val || 0;
  });
  size = vars.size.scale.value.domain(sizeDomain).rangeRound([minRadius, maxRadius]);
  _ref3 = vars.data.app;
  for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
    node = _ref3[_m];
    if (node.d3plus == null) {
      node.d3plus = {};
    }
    _ref4 = paths["all"];
    for (colIndex = _n = 0, _len5 = _ref4.length; _n < _len5; colIndex = ++_n) {
      col = _ref4[colIndex];
      if (_ref5 = node[vars.id.value], __indexOf.call(col, _ref5) >= 0) {
        node.d3plus.x = x(colIndex);
      }
    }
    node.d3plus.y = y(pathLookup[node[vars.id.value]]);
    if (vars.size.value) {
      val = fetchValue(vars, node, vars.size.value);
      node.d3plus.r = val ? size(val) : minRadius;
    } else {
      node.d3plus.r = maxRadius;
    }
    if (node.d3plus.r < columnWidth * 0.1 && !vars.small) {
      node.d3plus.label = {
        x: 0,
        y: node.d3plus.r + vars.labels.padding * 2,
        w: columnWidth * 0.6,
        h: labelSpace + maxRadius - node.d3plus.r,
        resize: false
      };
    } else {
      delete node.d3plus.label;
    }
  }
  _ref6 = viz.paths;
  for (pathInt = _o = 0, _len6 = _ref6.length; _o < _len6; pathInt = ++_o) {
    path = _ref6[pathInt];
    lastHop = vars.focus.value[0];
    _ref7 = path.edges;
    for (edgeInt = _p = 0, _len7 = _ref7.length; _p < _len7; edgeInt = ++_p) {
      edge = _ref7[edgeInt];
      nextDir = edge[vars.edges.source][vars.id.value] === lastHop ? "target" : "source";
      lastDir = nextDir === "target" ? "source" : "target";
      nextHop = edge[vars.edges[nextDir]][vars.id.value];
      if (pathLookup[lastHop] !== pathLookup[nextHop]) {
        edge.d3plus = {
          spline: true
        };
        if ((_base = edge[vars.edges.source]).d3plus == null) {
          _base.d3plus = {};
        }
        if ((_base1 = edge[vars.edges.source].d3plus).edges == null) {
          _base1.edges = {};
        }
        if ((_base2 = edge[vars.edges.target]).d3plus == null) {
          _base2.d3plus = {};
        }
        if ((_base3 = edge[vars.edges.target].d3plus).edges == null) {
          _base3.edges = {};
        }
        xDiff = edge[nextDir].d3plus.x - edge[lastDir].d3plus.x;
        edge[lastDir].d3plus.edges[edge[nextDir][vars.id.value]] = {
          angle: Math.PI,
          radius: columnWidth / 2
        };
        edge[nextDir].d3plus.edges[edge[lastDir][vars.id.value]] = {
          angle: 0,
          radius: columnWidth / 2,
          offset: xDiff - columnWidth
        };
      } else {
        delete edge.d3plus;
      }
      lastHop = nextHop;
    }
  }
  return {
    nodes: vars.data.app,
    edges: edges
  };
};

viz.filter = function(vars, data) {
  var added, d, edge, edges, id, ids, obj, path, returnData, source, target, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
  edges = vars.edges.filtered || vars.edges.value;
  viz.paths = shortestPath(edges, vars.focus.value[0], {
    target: vars.focus.value[1],
    distance: vars.edges.size || void 0,
    nodeid: vars.id.value,
    startpoint: vars.edges.source,
    endpoint: vars.edges.target,
    K: vars.edges.limit.value || 5
  });
  viz.nodes = [];
  added = [];
  _ref = viz.paths;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    path = _ref[_i];
    _ref1 = path.edges;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      edge = _ref1[_j];
      source = edge[vars.edges.source];
      target = edge[vars.edges.target];
      if (added.indexOf(source[vars.id.value]) < 0) {
        viz.nodes.push(source);
        added.push(source[vars.id.value]);
      }
      if (added.indexOf(target[vars.id.value]) < 0) {
        viz.nodes.push(target);
        added.push(target[vars.id.value]);
      }
    }
  }
  ids = d3plus.util.uniques(viz.nodes, vars.id.value);
  returnData = [];
  for (_k = 0, _len2 = ids.length; _k < _len2; _k++) {
    id = ids[_k];
    d = data.filter(function(d) {
      return d[vars.id.value] === id;
    });
    if (!d[0]) {
      obj = {
        d3plus: {}
      };
      obj[vars.id.value] = id;
      returnData.push(obj);
    } else {
      returnData.push(d[0]);
    }
  }
  return returnData;
};

viz.nesting = false;

viz.requirements = [
  function(vars) {
    return {
      status: vars.focus.value.length === 2,
      text: vars.format.locale.value.method.focus + " x 2"
    };
  }, "edges"
];

viz.scale = 1;

viz.shapes = ["circle", "square", "donut"];

viz.tooltip = "static";

module.exports = viz;


},{"../../core/fetch/value.js":undefined,"../../network/shortestPath.coffee":undefined}],219:[function(require,module,exports){
var fetchValue = require("../../core/fetch/value.js")
  , fetchColor = require("../../core/fetch/color.js")
var rings = function(vars) {

  var radius = d3.min([vars.height.viz,vars.width.viz])/2
    , ring_width = vars.small || !vars.labels.value
                 ? (radius-vars.labels.padding*2)/2 : radius/3
    , primaryRing = vars.small || !vars.labels.value
                  ? ring_width*1.4 : ring_width
    , secondaryRing = ring_width*2
    , edges = []
    , nodes = []

  var center = vars.data.app.filter(function(d){
    return d[vars.id.value] === vars.focus.value[0]
  })[0]

  if ( !center ) {
    center = { "d3plus" : {} }
    center[vars.id.value] = vars.focus.value[0]
  }

  center.d3plus.x = vars.width.viz/2
  center.d3plus.y = vars.height.viz/2
  center.d3plus.r = primaryRing*.65

  var primaries = [], claimed = [vars.focus.value[0]]
  vars.edges.connections(vars.focus.value[0],vars.id.value).forEach(function(edge){

    var c = edge[vars.edges.source][vars.id.value] == vars.focus.value[0] ? edge[vars.edges.target] : edge[vars.edges.source]
    var n = vars.data.app.filter(function(d){
      return d[vars.id.value] === c[vars.id.value]
    })[0]

    if ( !n ) {
      n = { "d3plus" : {} }
      n[vars.id.value] = c[vars.id.value]
    }

    n.d3plus.edges = vars.edges.connections(n[vars.id.value],vars.id.value).filter(function(c){
      return c[vars.edges.source][vars.id.value] != vars.focus.value[0] && c[vars.edges.target][vars.id.value] != vars.focus.value[0]
    })
    n.d3plus.edge = edge
    claimed.push(n[vars.id.value])
    primaries.push(n)

  })

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Sort primary nodes by children (smallest to largest) and then by sort
  // order.
  //--------------------------------------------------------------------------
  var sort = vars.order.value || vars.color.value
          || vars.size.value || vars.id.value

  primaries.sort(function(a,b){

    var lengthdiff = a.d3plus.edges.length - b.d3plus.edges.length

    if ( lengthdiff ) {

      return lengthdiff

    }
    else {

      return d3plus.array.sort( [a,b] , sort , vars.order.sort.value
                              , vars.color.value || [] , vars)

    }

  })

  if (typeof vars.edges.limit.value == "number") {
    primaries = primaries.slice(0,vars.edges.limit.value)
  }
  else if (typeof vars.edges.limit.value == "function") {
    primaries = vars.edges.limit.value(primaries)
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Check for similar children and give preference to nodes with less
  // overall children.
  //----------------------------------------------------------------------------
  var secondaries = [], total = 0
  primaries.forEach(function(p){

    var primaryId = p[vars.id.value]

    p.d3plus.edges = p.d3plus.edges.filter(function(c){

      var source = c[vars.edges.source][vars.id.value]
        , target = c[vars.edges.target][vars.id.value]
      return (claimed.indexOf(source) < 0 && target == primaryId)
          || (claimed.indexOf(target) < 0 && source == primaryId)

    })

    total += p.d3plus.edges.length || 1

    p.d3plus.edges.forEach(function(c){

      var source = c[vars.edges.source]
        , target = c[vars.edges.target]
      var claim = target[vars.id.value] == primaryId ? source : target
      claimed.push(claim[vars.id.value])

    })
  })

  d3plus.array.sort( primaries , sort , vars.order.sort.value
                   , vars.color.value || [] , vars)

  var offset = 0,
      radian = Math.PI*2,
      start = 0

  primaries.forEach(function(p,i){

    var children = p.d3plus.edges.length || 1,
        space = (radian/total)*children

    if (i == 0) {
      start = angle
      offset -= space/2
    }

    var angle = offset+(space/2)
    angle -= radian/4

    p.d3plus.radians = angle
    p.d3plus.x = vars.width.viz/2 + (primaryRing * Math.cos(angle))
    p.d3plus.y = vars.height.viz/2 + (primaryRing * Math.sin(angle))

    offset += space
    p.d3plus.edges.sort(function(a,b){

      var a = a[vars.edges.source][vars.id.value] == p[vars.id.value]
            ? a[vars.edges.target] : a[vars.edges.source]
        , b = b[vars.edges.source][vars.id.value] == p[vars.id.value]
            ? b[vars.edges.target] : b[vars.edges.source]

      return d3plus.array.sort( [a,b] , sort , vars.order.sort.value
                              , vars.color.value || [] , vars)

    })

    p.d3plus.edges.forEach(function(edge,i){

      var c = edge[vars.edges.source][vars.id.value] == p[vars.id.value]
          ? edge[vars.edges.target] : edge[vars.edges.source]
        , s = radian/total

      var d = vars.data.app.filter(function(a){
        return a[vars.id.value] === c[vars.id.value]
      })[0]

      if ( !d ) {
        d = { "d3plus" : {} }
        d[vars.id.value] = c[vars.id.value]
      }

      a = (angle-(s*children/2)+(s/2))+((s)*i)
      d.d3plus.radians = a
      d.d3plus.x = vars.width.viz/2 + ((secondaryRing) * Math.cos(a))
      d.d3plus.y = vars.height.viz/2 + ((secondaryRing) * Math.sin(a))
      secondaries.push(d)
    })

  })

  var primaryDistance = d3.min(d3plus.util.distances(primaries,function(n){
        return [n.d3plus.x,n.d3plus.y]
      }))
    , secondaryDistance = d3.min(d3plus.util.distances(secondaries,function(n){
        return [n.d3plus.x,n.d3plus.y]
      }))

  if (!primaryDistance) {
    primaryDistance = ring_width/2
  }

  if (!secondaryDistance) {
    secondaryDistance = ring_width/4
  }

  if (primaryDistance/2 - 4 < 8) {
    var primaryMax = d3.min([primaryDistance/2,8])
  }
  else {
    var primaryMax = primaryDistance/2 - 4
  }

  if (secondaryDistance/2 - 4 < 4) {
    var secondaryMax = d3.min([secondaryDistance/2,4])
  }
  else {
    var secondaryMax = secondaryDistance/2 - 4
  }

  if (secondaryMax > ring_width/10) {
    secondaryMax = ring_width/10
  }

  if (secondaryMax > primaryMax) {
    secondaryMax = primaryMax*.75
  }
  else if (primaryMax > secondaryMax*1.5) {
    primaryMax = secondaryMax*1.5
  }

  primaryMax = Math.floor(primaryMax)
  secondaryMax = Math.floor(secondaryMax)

  var ids = d3plus.util.uniques(primaries,vars.id.value)
  ids = ids.concat(d3plus.util.uniques(secondaries,vars.id.value))
  ids.push(vars.focus.value[0])

  var data = vars.data.app.filter(function(d){
    return ids.indexOf(d[vars.id.value]) >= 0
  })

  if (vars.size.value) {

    var domain = d3.extent(data,function(d){
      return fetchValue(vars,d,vars.size.value)
    })

    if (domain[0] == domain[1]) {
      domain[0] = 0
    }

    var radius = d3.scale.linear()
      .domain(domain)
      .rangeRound([3,d3.min([primaryMax,secondaryMax])])

    var val = fetchValue(vars,center,vars.size.value)
    center.d3plus.r = radius(val)

  }
  else {

    var radius = d3.scale.linear()
      .domain([1,2])
      .rangeRound([primaryMax,secondaryMax])


    if (vars.edges.label) {
      center.d3plus.r = radius(1)*1.5
    }

  }

  secondaries.forEach(function(s){
    s.d3plus.ring = 2
    var val = vars.size.value ? fetchValue(vars,s,vars.size.value) : 2
    s.d3plus.r = radius(val)
  })

  primaries.forEach(function(p){
    p.d3plus.ring = 1
    var val = vars.size.value ? fetchValue(vars,p,vars.size.value) : 1
    p.d3plus.r = radius(val)
  })

  nodes = [center].concat(primaries).concat(secondaries)

  primaries.forEach(function(p,i){

    var check = [vars.edges.source,vars.edges.target]
      , edge = p.d3plus.edge

    check.forEach(function(node){

      edge[node] = nodes.filter(function(n){
        return n[vars.id.value] == edge[node][vars.id.value]
      })[0]

    })

    delete edge.d3plus
    edges.push(edge)

    vars.edges.connections(p[vars.id.value],vars.id.value).forEach(function(edge){

      var c = edge[vars.edges.source][vars.id.value] == p[vars.id.value]
            ? edge[vars.edges.target] : edge[vars.edges.source]

      if (c[vars.id.value] != center[vars.id.value]) {

        var target = secondaries.filter(function(s){
          return s[vars.id.value] == c[vars.id.value]
        })[0]

        if (!target) {
          var r = primaryRing
          target = primaries.filter(function(s){
            return s[vars.id.value] == c[vars.id.value]
          })[0]
        }
        else {
          var r = secondaryRing
        }

        if (target) {

          edge.d3plus = {
            "spline": true,
            "translate": {
              "x": vars.width.viz/2,
              "y": vars.height.viz/2
            }
          }

          var check = [vars.edges.source,vars.edges.target]

          check.forEach(function(node,i){

            edge[node] = nodes.filter(function(n){
              return n[vars.id.value] == edge[node][vars.id.value]
            })[0]

            if (edge[node].d3plus.edges === undefined) edge[node].d3plus.edges = {}

            var oppID = i === 0 ? edge[vars.edges.target][vars.id.value] : edge[vars.edges.source][vars.id.value]

            if (edge[node][vars.id.value] == p[vars.id.value]) {

              edge[node].d3plus.edges[oppID] = {
                "angle": p.d3plus.radians + Math.PI,
                "radius": ring_width/2
              }

            }
            else {

              edge[node].d3plus.edges[oppID] = {
                "angle": target.d3plus.radians,
                "radius": ring_width/2
              }

            }
          })

          edges.push(edge)

        }

      }

    })

  })

  nodes.forEach(function(n) {

    if (!vars.small && vars.labels.value) {

      if (n[vars.id.value] != vars.focus.value[0]) {

        n.d3plus.rotate = n.d3plus.radians*(180/Math.PI)

        var angle = n.d3plus.rotate,
            width = ring_width-(vars.labels.padding*3)-n.d3plus.r

        if (angle < -90 || angle > 90) {
          angle = angle-180
          var buffer = -(n.d3plus.r+width/2+vars.labels.padding),
              anchor = "end"
        }
        else {
          var buffer = n.d3plus.r+width/2+vars.labels.padding,
              anchor = "start"
        }

        var background = primaries.indexOf(n) >= 0 ? true : false

        var height = n.d3plus.ring == 1 ? primaryDistance : secondaryDistance
        height += vars.labels.padding*2

        n.d3plus.label = {
          "x": buffer,
          "y": 0,
          "w": width,
          "h": height,
          "angle": angle,
          "anchor": anchor,
          "valign": "center",
          "color": d3plus.color.legible(fetchColor(vars,n[vars.id.value])),
          "resize": [8,vars.labels.font.size],
          "background": background,
          "mouse": true
        }

      }
      else if (vars.size.value || vars.edges.label) {

        var height = primaryRing-n.d3plus.r*2-vars.labels.padding*2

        n.d3plus.label = {
          "x": 0,
          "y": n.d3plus.r+height/2,
          "w": primaryRing,
          "h": height,
          "color": d3plus.color.legible(fetchColor(vars,n[vars.id.value])),
          "resize": [10,40],
          "background": true,
          "mouse": true
        }

      }
      else {
        delete n.d3plus.rotate
        delete n.d3plus.label
      }

    }
    else {
      delete n.d3plus.rotate
      delete n.d3plus.label
    }

  })

  vars.mouse[d3plus.evt.click] = function(d) {
    if (d[vars.id.value] != vars.focus.value[0]) {
      d3plus.tooltip.remove(vars.type.value)
      vars.self.focus(d[vars.id.value]).draw()
    }
  }

  return {"edges": edges, "nodes": nodes, "data": data}

};

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Visualization Settings and Helper Functions
//------------------------------------------------------------------------------
rings.filter       = function( vars , data ) {

  var primaries = vars.edges.connections(vars.focus.value[0],vars.id.value,true)
    , secondaries = []

  primaries.forEach(function(p){
    secondaries = secondaries.concat(vars.edges.connections(p[vars.id.value],vars.id.value,true))
  })

  var connections = primaries.concat(secondaries)
    , ids = d3plus.util.uniques(connections,vars.id.value)
    , returnData = []

  ids.forEach(function(id){

    var d = data.filter(function(d){
      return d[vars.id.value] == id
    })[0]

    if ( !d ) {
      var obj = {"d3plus": {}}
      obj[vars.id.value] = id
      returnData.push(obj)
    }
    else {
      returnData.push(d)
    }

  })

  return returnData

}
rings.nesting      = false
rings.scale        = 1
rings.shapes       = [ "circle" , "square" , "donut" ]
rings.requirements = [ "edges" , "focus" ]
rings.tooltip      = "static"

module.exports = rings

},{"../../core/fetch/color.js":undefined,"../../core/fetch/value.js":undefined}],220:[function(require,module,exports){
var chart = require("./chart.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Scatterplot
//------------------------------------------------------------------------------
var scatter = function(vars) {

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // This visualization is an extention of the Chart visualization.
  //----------------------------------------------------------------------------
  return chart(vars)

}

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Visualization Settings and Helper Functions
//------------------------------------------------------------------------------
scatter.fill         = true
scatter.requirements = [ "data" , "x" , "y" ]
scatter.scale        = chart.scale
scatter.setup        = chart.setup
scatter.shapes       = [ "circle" , "square" , "donut" ]
scatter.tooltip      = "static"

module.exports = scatter

},{"./chart.js":undefined}],221:[function(require,module,exports){
var chart = require("./chart.js"),
    dataThreshold = require("../../core/data/threshold.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Stacked Area Chart
//------------------------------------------------------------------------------
var stacked = function(vars) {

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // This visualization is an extention of the Chart visualization.
  //----------------------------------------------------------------------------
  return chart(vars)

}

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Visualization Settings and Helper Functions
//------------------------------------------------------------------------------
stacked.filter       = function( vars , data ) {

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Merge data points below the threshold
  //----------------------------------------------------------------------------
  return dataThreshold( vars , data , vars.x.value )

}
stacked.requirements = [ "data" , "x" , "y" ]

stacked.setup        = function( vars ) {

  vars.self
    .x({ "scale" : "continuous" , "zerofill" : true })
    .y({ "stacked" : true })

  var y    = vars.y
    , size = vars.size

  if ( ( !y.value && size.value ) || ( size.changed && size.previous === y.value ) ) {

    vars.self.y( size.value )

  }
  else if ( ( !size.value && y.value ) || ( y.changed && y.previous === size.value ) ) {

    vars.self.size( y.value )

  }

}

stacked.shapes       = [ "area" ]
stacked.threshold    = function( vars ) {
  return 20 / vars.height.viz
}
stacked.tooltip      = "static"

module.exports = stacked

},{"../../core/data/threshold.js":undefined,"./chart.js":undefined}],222:[function(require,module,exports){
var dataThreshold = require("../../core/data/threshold.js"),
    fetchValue = require("../../core/fetch/value.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Tree Map
//------------------------------------------------------------------------------
var tree_map = function(vars) {

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Group the data by each depth defined by the .id() method.
  //----------------------------------------------------------------------------
  var grouped_data = d3.nest()

  vars.id.nesting.forEach(function(n,i){

    if (i < vars.depth.value) {

      grouped_data.key(function(d){

        return fetchValue(vars,d.d3plus,n)

      })

    }

  })

  var strippedData = []
  vars.data.app.forEach(function(d){

    var val = fetchValue(vars,d,vars.size.value)

    if (val && typeof val === "number") {

      strippedData.push({
        "d3plus" : d,
        "id"     : d[vars.id.value],
        "value"  : fetchValue(vars,d,vars.size.value)
      })

    }

  })

  grouped_data = grouped_data.entries(strippedData)

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Pass data through the D3js .treemap() layout.
  //----------------------------------------------------------------------------
  var data = d3.layout.treemap()
    .mode(vars.type.mode.value)
    .round(true)
    .size([ vars.width.viz , vars.height.viz ])
    .children(function(d) {

      return d.values

    })
    .padding(1)
    .sort(function(a, b) {

      var sizeDiff = a.value - b.value
      return sizeDiff === 0 ? a.id < b.id : sizeDiff

    })
    .nodes({
      "name":"root",
      "values": grouped_data
    })
    .filter(function(d) {

      return !d.values && d.area

    })

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // If the "data" array has entries...
  //----------------------------------------------------------------------------
  if (data.length) {

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Create the "root" node to use when calculating share percentage.
    //--------------------------------------------------------------------------
    var root = data[0]

    while (root.parent) {

      root = root.parent

    }

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Calculate the position, size, and share percentage of each square.
    //--------------------------------------------------------------------------
    var returnData = []
    data.forEach(function(d){

      d.d3plus.d3plus = d3plus.object.merge(d.d3plus.d3plus,{
        "x": d.x+d.dx/2,
        "y": d.y+d.dy/2,
        "width": d.dx,
        "height": d.dy,
        "share": d.value/root.value
      })

      returnData.push(d.d3plus)

    })

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Return the data array.
  //----------------------------------------------------------------------------
  return returnData

}

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Visualization Settings and Helper Functions
//------------------------------------------------------------------------------
tree_map.filter       = function( vars , data ) {

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Merge data points below the threshold
  //----------------------------------------------------------------------------
  return dataThreshold( vars , data )

}
tree_map.modes        = ["squarify", "slice", "dice", "slice-dice"]
tree_map.requirements = ["data", "size"]
tree_map.shapes       = ["square"]
tree_map.threshold    = function( vars ) {
  return ( 40 * 40 ) / (vars.width.viz * vars.height.viz)
}
tree_map.tooltip      = "follow"

module.exports = tree_map

},{"../../core/data/threshold.js":undefined,"../../core/fetch/value.js":undefined}],223:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Draws a UI drawer, if defined.
//------------------------------------------------------------------------------
d3plus.ui.drawer = function( vars ) {

  var enabled = vars.ui.value && vars.ui.value.length
    , position = vars.ui.position.value

  if ( vars.dev.value && enabled ) d3plus.console.time("drawing custom UI elements")

  var drawer = vars.container.value.selectAll("div#d3plus_drawer")
    .data(["d3plus_drawer"])

  drawer.enter().append("div")
    .attr("id","d3plus_drawer")

  var positionStyles = {}
  vars.ui.position.accepted.forEach(function(p){
    positionStyles[p] = p == position ? vars.margin.bottom+"px" : "auto"
  })

  drawer
    .style("text-align",vars.ui.align.value)
    .style("position","absolute")
    .style("width",vars.width.value-(vars.ui.padding*2)+"px")
    .style("height","auto")
    .style(positionStyles)

  var ui = drawer.selectAll("div.d3plus_drawer_ui")
    .data(enabled ? vars.ui.value : [], function(d){
      return d.method || false
    })

  ui.enter().append("div")
    .attr("class","d3plus_drawer_ui")
    .style("padding",vars.ui.padding+"px")
    .style("display","inline-block")
    .each(function(d){

      var container = d3.select(this)

      d.form = d3plus.form()
        .container(container)
        .focus(vars[d.method].value,function(value){

          if ( value[0] !== vars[d.method].value ) {
            vars.self[d.method](value[0]).draw()
          }

        })
        .id("id")
        .text("text")
        .type("auto")

    })

  ui.each(function(d){

    var data = []
      , title = vars.format.locale.value.method[d.method] || d.method

    d.value.forEach(function(o){

      var obj = {
        "id": o,
        "text": vars.format.value(o)
      }
      data.push(obj)

    })

    var font = d3plus.util.copy(vars.ui.font)
    font.secondary = vars.ui.font

    d.form
      .data(data)
      .font(font)
      .format(vars.format.locale.language)
      .title(vars.format.value(title))
      .ui({
        "align": vars.ui.align.value,
        "padding": vars.ui.padding,
        "margin": 0
      })
      .width(d.width || false)
      .draw()

  })

  ui.exit().remove()

  var drawerHeight = drawer.node().offsetHeight || drawer.node().getBoundingClientRect().height

  if ( drawerHeight ) {
    vars.margin[position] += drawerHeight
  }

  if ( vars.dev.value && enabled ) d3plus.console.timeEnd("drawing custom UI elements")

}

},{}],224:[function(require,module,exports){
var fetchValue = require("../../core/fetch/value.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates focus tooltip, if applicable
//-------------------------------------------------------------------
d3plus.ui.focus = function(vars) {

  if (!vars.internal_error && vars.focus.value.length === 1 && vars.focus.value.length && !vars.small && vars.focus.tooltip.value) {

    if ( vars.dev.value ) d3plus.console.time("drawing focus tooltip")

    var data = vars.data.pool.filter(function(d){
      return fetchValue(vars,d,vars.id.value) == vars.focus.value[0]
    })

    if (data.length >= 1) {
      data = data[0]
    }
    else {
      data = {}
      data[vars.id.value] = vars.focus.value[0]
    }

    var offset = vars.labels.padding

    d3plus.tooltip.app({
      "anchor": "top left",
      "arrow": false,
      "data": data,
      "length": "long",
      "fullscreen": false,
      "id": vars.type.value+"_focus",
      "maxheight": vars.height.viz-offset*2,
      "mouseevents": true,
      "offset": 0,
      "vars": vars,
      "x": vars.width.value-vars.margin.right-offset,
      "y": vars.margin.top+offset,
      "width": vars.tooltip.large
    })

    if(!d3.select("div#d3plus_tooltip_id_"+vars.type.value+"_focus").empty()) {
      vars.width.viz -= (vars.tooltip.large+offset*2)
    }

    if ( vars.dev.value ) d3plus.console.timeEnd("drawing focus tooltip")

  }
  else {
    d3plus.tooltip.remove(vars.type.value+"_focus")
  }

}

},{"../../core/fetch/value.js":undefined}],225:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates "back" button, if applicable
//------------------------------------------------------------------------------
d3plus.ui.history = function(vars) {

  if (!vars.small && vars.history.states.length > 0) {

    if ( vars.dev.value ) d3plus.console.time("drawing back button")

    var button = vars.container.value.selectAll("div#d3plus_back_button")
      .data(["d3plus_back_button"])

    var size = vars.title.value
      ? vars.title.font.size : vars.title.sub.font.size

    var color = vars.title.sub.value
      ? vars.title.sub.font.color : vars.title.font.color

    var family = vars.title.sub.value
      ? vars.title.sub.font.family.value : vars.title.font.family.value

    var weight = vars.title.sub.value
      ? vars.title.sub.font.weight : vars.title.font.weight

    var padding = vars.title.sub.value
      ? vars.title.sub["padding"] : vars.title["padding"]

    function style(elem) {

        elem
          .style("position","absolute")
          .style("left",vars.ui.padding+"px")
          .style("top",vars.margin.top/2-size/2+"px")
          .style("color", color)
          .style("font-family", family)
          .style("font-weight", weight)
          .style("font-size",size+"px")
          .style("z-index",2000)

    }

    var min_height = size + padding*2
    if (vars.margin.top < min_height) {
      vars.margin.top = min_height
    }

    var enter = button.enter().append("div")
      .attr("id","d3plus_back_button")
      .style("opacity",0)
      .call(style)
      .html(function(){

        if (d3plus.font.awesome) {
          var arrow = "<span style='font-family:FontAwesome;margin-right:5px;'>&#xf104</span>"
        }
        else {
          var arrow = "&laquo; "
        }

        return arrow+vars.format.value(vars.format.locale.value.ui.back)

      })

    button
      .on(d3plus.evt.over,function(){

        if (!vars.small && vars.history.states.length > 0) {

          d3.select(this)
            .style("cursor","pointer")
            .transition().duration(vars.timing.mouseevents)
              .style("color",d3plus.color.lighter(color,.25))

        }

      })
      .on(d3plus.evt.out,function(){

        if (!vars.small && vars.history.states.length > 0) {

          d3.select(this)
            .style("cursor","auto")
            .transition().duration(vars.timing.mouseevents)
              .style("color",color)

        }

      })
      .on(d3plus.evt.click,function(){

        vars.history.back()

      })
      .transition().duration(vars.draw.timing)
        .style("opacity",1)
        .call(style)

    if ( vars.dev.value ) d3plus.console.timeEnd("drawing back button")

  }
  else {
    vars.container.value.selectAll("div#d3plus_back_button")
      .transition().duration(vars.draw.timing)
      .style("opacity",0)
      .remove()
  }

}

},{}],226:[function(require,module,exports){
var dataNest   = require("../../core/data/nest.js"),
    fetchValue = require("../../core/fetch/value.js"),
    fetchColor = require("../../core/fetch/color.js"),
    fetchText  = require("../../core/fetch/text.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates color key
//------------------------------------------------------------------------------
d3plus.ui.legend = function(vars) {

  var key_display = true,
      square_size = 0,
      key = vars.color.value
    , colorName = vars.color.value || "d3plus_color"

  if (!vars.internal_error && key && !vars.small && vars.legend.value) {

    if (!vars.color.valueScale) {

      if ( vars.dev.value ) d3plus.console.time("grouping data by colors")

      if ( vars.nodes.value && vars.types[vars.type.value].requirements.indexOf("nodes") >= 0 ) {
        var data = vars.nodes.restriced || vars.nodes.value
        if ( vars.data.app.length ) {
          for ( var i = 0 ; i < data.length ; i++ ) {
            var appData = vars.data.app.filter(function(a){
              return a[vars.id.value] === data[i][vars.id.value]
            })
            if (appData.length) {
              data[i] = d3plus.object.merge(data[i],appData[0])
            }
          }
        }
      }
      else {
        var data = vars.data.app
        // var data = dataNest(vars, vars.data.app, vars.id.nesting, [])
      }

      // for ( var z = 0 ; z < data.length ; z++ ) {
      //
      //   d = data[z]
      //
      //   for ( var i = 0 ; i < vars.id.nesting.length ; i++ ) {
      //
      //     var colorKey = vars.id.nesting[i]
      //
      //     if ( !(colorKey in d) ) {
      //       var nextKey = vars.id.nesting[ i + 1 ]
      //       d[colorKey] = fetchValue( vars , d[nextKey] , colorKey , nextKey )
      //     }
      //
      //   }
      //
      // }

      var colorFunction = function( d ){
            return fetchColor( vars , d , colorKey )
          }
        , colorDepth = 0
        , colorKey = vars.id.value

      if (vars.id.nesting.indexOf(colorName) >= 0) {
        colorDepth = vars.id.nesting.indexOf(vars.color.value)
        colorKey = vars.id.nesting[vars.id.nesting.indexOf(colorName)]
      }
      else {

        for ( var i = 0 ; i <= vars.depth.value ; i++ ) {

          colorDepth = i
          colorKey   = vars.id.nesting[i]

          var uniqueIDs = d3plus.util.uniques( data , function(d){
                return fetchValue(vars, d, colorKey)
              } )
            , uniqueColors = d3plus.util.uniques( data , colorFunction )

          if ( uniqueIDs.length === uniqueColors.length && uniqueColors.length > 1 ) {
            break
          }

        }

      }

      var colors = dataNest( vars , data , [ colorFunction ] , [] )

      // for ( var z = 0 ; z < colors.length ; z++ ) {
      //
      //   var d = colors[z]
      //
      //   // var nextKey = vars.id.nesting[ colorDepth + 1 ]
      //   //
      //   // d[colorKey] = d[colorKey]
      //   //   || fetchValue( vars , d[nextKey] , colorKey , nextKey )
      //   //
      //   // d[colorName] = d[colorName]
      //   //   || fetchValue( vars , d[colorKey][0] , colorName, colorKey )
      //
      //   d.d3plus.colorDepth = colorDepth
      //
      // }

      if ( vars.dev.value ) d3plus.console.timeEnd("grouping data by color")

      var available_width = vars.width.value

      square_size = vars.legend.size

      var key_width = square_size*colors.length+vars.ui.padding*(colors.length+1)

      if (square_size instanceof Array) {

        if ( vars.dev.value ) d3plus.console.time("calculating legend size")

        for (var i = square_size[1]; i >= square_size[0]; i--) {
          key_width = i*colors.length+vars.ui.padding*(colors.length+1)
          if (available_width >= key_width) {
            square_size = i
            break;
          }
        }

        if ( vars.dev.value ) d3plus.console.timeEnd("calculating legend size")

      }
      else if (typeof square_size != "number" && square_size !== false) {
        square_size = 30
      }

      if (available_width < key_width || colors.length == 1) {
        key_display = false
      }
      else {

        key_width -= vars.ui.padding*2

        if ( vars.dev.value ) d3plus.console.time("sorting legend")

        var order = vars[vars.legend.order.value].value

        d3plus.array.sort( colors , order , vars.legend.order.sort.value
                         , colorName , vars )

        if ( vars.dev.value ) d3plus.console.timeEnd("sorting legend")

        if ( vars.dev.value ) d3plus.console.time("drawing legend")

        if (vars.legend.align == "start") {
          var start_x = vars.ui.padding
        }
        else if (vars.legend.align == "end") {
          var start_x = available_width - vars.ui.padding - key_width
        }
        else {
          var start_x = available_width/2 - key_width/2
        }

        vars.g.legend.selectAll("g.d3plus_scale")
          .transition().duration(vars.draw.timing)
          .attr("opacity",0)
          .remove()

        var keys = vars.g.legend.selectAll("g.d3plus_color")
          .data(colors,function(d){
            var col = fetchColor(vars,d,colorKey)
              , val = fetchValue(vars,d,colorName)
            return col+val
          })

        function position(group) {

          group
            .attr("transform",function(g,i){
              var x = start_x + (i*(vars.ui.padding+square_size))
              return "translate("+x+","+vars.ui.padding+")"
            })

        }

        function style(rect) {

          rect
            .attr("width",square_size)
            .attr("height",square_size)
            .attr("fill",function(g){

              d3.select(this.parentNode).selectAll("text").remove()

              var depth = "depth" in g.d3plus ? g.d3plus.depth : vars.depth.value
                , depthId = vars.id.nesting[depth]
                , icon = fetchValue( vars , g , vars.icon.value , depthId )
                , color = fetchColor( vars , g , depthId )

              if (icon && icon !== "null") {

                var short_url = d3plus.string.strip(icon+"_"+color)
                  , iconStyle = vars.icon.style.value
                  , pattern = vars.defs.selectAll("pattern#"+short_url)
                      .data([short_url])

                if (typeof iconStyle === "string") {
                  var icon_style = vars.icon.style.value
                }
                else if (d3plus.object.validate(iconStyle) && iconStyle[depthId]) {
                  var icon_style = iconStyle[depthId]
                }
                else {
                  var icon_style = "default"
                }

                var color = icon_style == "knockout" ? color : "none"

                pattern.select("rect").transition().duration(vars.draw.timing)
                  .attr("fill",color)
                  .attr("width",square_size)
                  .attr("height",square_size)

                pattern.select("image").transition().duration(vars.draw.timing)
                  .attr("width",square_size)
                  .attr("height",square_size)

                var pattern_enter = pattern.enter().append("pattern")
                  .attr("id",short_url)
                  .attr("width",square_size)
                  .attr("height",square_size)

                pattern_enter.append("rect")
                  .attr("fill",color)
                  .attr("width",square_size)
                  .attr("height",square_size)

                pattern_enter.append("image")
                  .attr("xlink:href",icon)
                  .attr("width",square_size)
                  .attr("height",square_size)
                  .each(function(d){

                    if (icon.indexOf("/") == 0 || icon.indexOf(window.location.hostname) >= 0) {

                      d3plus.util.dataurl(icon,function(base64){

                        pattern.select("image")
                          .attr("xlink:href",base64)

                      })

                    }
                    else {

                      pattern.select("image")
                        .attr("xlink:href",icon)

                    }

                  })

                return "url(#"+short_url+")"
              }
              else {

                var text = d3.select(this.parentNode).append("text")

                text
                  .attr("font-size",vars.legend.font.size)
                  .attr("font-weight",vars.legend.font.weight)
                  .attr("font-family",vars.legend.font.family.value)
                  .style("text-anchor","start")
                  .attr("fill",d3plus.color.text(color))
                  .attr("x",0)
                  .attr("y",0)
                  .each(function(t){

                    var idIndex = vars.id.nesting.indexOf(colorKey)
                      , text = idIndex >= 0 ? fetchText(vars,t,idIndex) : [vars.format.value(fetchValue(vars,t,colorName,colorKey))]

                    if (text.length === 1 && text[0].length) {

                      d3plus.textwrap()
                        .container( d3.select(this) )
                        .height( square_size - vars.ui.padding * 2 )
                        .resize( vars.labels.resize.value )
                        .text( text[0] )
                        .width( square_size - vars.ui.padding * 2 )
                        .draw()

                    }

                  })
                  .attr("y",function(t){
                    var h = this.getBBox().height,
                        diff = parseFloat(d3.select(this).style("font-size"),10)/5
                    return square_size/2 - h/2 - diff/2
                  })
                  .selectAll("tspan")
                    .attr("x",function(t){
                      var w = this.getComputedTextLength()
                      return square_size/2 - w/2
                    })

                if (text.select("tspan").empty()) {
                  text.remove()
                }

                return color
              }

            })

        }

        var key_enter = keys.enter().append("g")
          .attr("class","d3plus_color")
          .attr("opacity",0)
          .call(position)

        key_enter
          .append("rect")
            .attr("class","d3plus_color")
            .call(style)

        if (!d3plus.touch) {

          keys
            .on(d3plus.evt.over,function(d,i){

              d3.select(this).style("cursor","pointer")

              var x = start_x + (i*(vars.ui.padding+square_size)),
                  y = d3.transform(d3.select(this.parentNode).attr("transform")).translate[1]

              x += square_size/2
              y += vars.ui.padding+square_size/2

              var idIndex = vars.id.nesting.indexOf(colorKey)
                , title = idIndex >= 0 ? fetchText(vars,d,idIndex)[0] : vars.format.value(fetchValue(vars,d,colorName,colorKey))

              d3plus.tooltip.app({
                "data": d,
                "footer": false,
                "vars": vars,
                "x": x,
                "y": y,
                "title": title,
                "offset": square_size*.4
              })

            })
            .on(d3plus.evt.out,function(d){
              d3plus.tooltip.remove(vars.type.value)
            })

        }

        keys.order()
          .transition().duration(vars.draw.timing)
          .attr("opacity",1)
          .call(position)

        keys.selectAll("rect.d3plus_color").transition().duration(vars.draw.timing)
          .call(style)

        keys.exit()
          .transition().duration(vars.draw.timing)
          .attr("opacity",0)
          .remove()

        if ( vars.dev.value ) d3plus.console.timeEnd("drawing legend")

      }

    }
    else if (vars.color.valueScale) {

      if ( vars.dev.value ) d3plus.console.time("drawing color scale")

      vars.g.legend.selectAll("g.d3plus_color")
        .transition().duration(vars.draw.timing)
        .attr("opacity",0)
        .remove()

      var values = vars.color.valueScale.domain(),
          colors = vars.color.valueScale.range()

      if (values.length <= 2) {
        values = d3plus.util.buckets(values,6)
      }

      var scale = vars.g.legend.selectAll("g.d3plus_scale")
        .data(["scale"])

      scale.enter().append("g")
        .attr("class","d3plus_scale")
        .attr("opacity",0)

      var heatmap = scale.selectAll("#d3plus_legend_heatmap")
        .data(["heatmap"])

      heatmap.enter().append("linearGradient")
        .attr("id", "d3plus_legend_heatmap")
        .attr("x1", "0%")
        .attr("y1", "0%")
        .attr("x2", "100%")
        .attr("y2", "0%")
        .attr("spreadMethod", "pad");

      var stops = heatmap.selectAll("stop")
        .data(d3.range(0,colors.length))

      stops.enter().append("stop")
        .attr("stop-opacity",1)

      stops
        .attr("offset",function(i){
          return Math.round((i/(colors.length-1))*100)+"%"
        })
        .attr("stop-color",function(i){
          return colors[i]
        })

      stops.exit().remove()

      var gradient = scale.selectAll("rect#gradient")
        .data(["gradient"])

      gradient.enter().append("rect")
        .attr("id","gradient")
        .attr("x",function(d){
          if (vars.legend.align == "middle") {
            return vars.width.value/2
          }
          else if (vars.legend.align == "end") {
            return vars.width.value
          }
          else {
            return 0
          }
        })
        .attr("y",vars.ui.padding)
        .attr("width", 0)
        .attr("height", vars.legend.gradient.height)
        .attr("stroke",vars.legend.font.color)
        .attr("stroke-width",1)
        .style("fill", "url(#d3plus_legend_heatmap)")

      var text = scale.selectAll("text.d3plus_tick")
        .data(d3.range(0,values.length))

      text.enter().append("text")
        .attr("class","d3plus_tick")
        .attr("x",function(d){
          if (vars.legend.align == "middle") {
            return vars.width.value/2
          }
          else if (vars.legend.align == "end") {
            return vars.width.value
          }
          else {
            return 0
          }
        })
        .attr("y",function(d){
          return this.getBBox().height+vars.legend.gradient.height+vars.ui.padding*2
        })

      var label_width = 0

      text
        .order()
        .attr("font-weight",vars.legend.font.weight)
        .attr("font-family",vars.legend.font.family.value)
        .attr("font-size",vars.legend.font.size)
        .style("text-anchor",vars.legend.font.align)
        .attr("fill",vars.legend.font.color)
        .text(function(d){
          return vars.format.value(values[d],key)
        })
        .attr("y",function(d){
          return this.getBBox().height+vars.legend.gradient.height+vars.ui.padding*2
        })
        .each(function(d){
          var w = this.offsetWidth
          if (w > label_width) label_width = w
        })

      label_width += vars.labels.padding*2

      var key_width = label_width * (values.length-1)

      if (key_width+label_width < vars.width.value) {

        if (key_width+label_width < vars.width.value/2) {
          key_width = vars.width.value/2
          label_width = key_width/values.length
          key_width -= label_width
        }

        if (vars.legend.align == "start") {
          var start_x = vars.ui.padding
        }
        else if (vars.legend.align == "end") {
          var start_x = vars.width.value - vars.ui.padding - key_width
        }
        else {
          var start_x = vars.width.value/2 - key_width/2
        }

        text.transition().duration(vars.draw.timing)
          .attr("x",function(d){
            return start_x + (label_width*d)
          })

        text.exit().transition().duration(vars.draw.timing)
          .attr("opacity",0)
          .remove()

        var ticks = scale.selectAll("rect.d3plus_tick")
          .data(d3.range(0,values.length))

        ticks.enter().append("rect")
          .attr("class","d3plus_tick")
          .attr("x",function(d){
            if (vars.legend.align == "middle") {
              return vars.width.value/2
            }
            else if (vars.legend.align == "end") {
              return vars.width.value
            }
            else {
              return 0
            }
          })
          .attr("y",vars.ui.padding)
          .attr("width",0)
          .attr("height",vars.ui.padding+vars.legend.gradient.height)
          .attr("fill",vars.legend.font.color)

        ticks.transition().duration(vars.draw.timing)
          .attr("x",function(d){
            var mod = d == 0 ? 1 : 0
            return start_x + (label_width*d) - mod
          })
          .attr("y",vars.ui.padding)
          .attr("width",1)
          .attr("height",vars.ui.padding+vars.legend.gradient.height)
          .attr("fill",vars.legend.font.color)

        ticks.exit().transition().duration(vars.draw.timing)
          .attr("width",0)
          .remove()

        gradient.transition().duration(vars.draw.timing)
          .attr("x",function(d){
            if (vars.legend.align == "middle") {
              return vars.width.value/2 - key_width/2
            }
            else if (vars.legend.align == "end") {
              return vars.width.value - key_width - vars.ui.padding
            }
            else {
              return vars.ui.padding
            }
          })
          .attr("y",vars.ui.padding)
          .attr("width", key_width)
          .attr("height", vars.legend.gradient.height)

        scale.transition().duration(vars.draw.timing)
          .attr("opacity",1)

        if ( vars.dev.value ) d3plus.console.timeEnd("drawing color scale")

      }
      else {
        key_display = false
      }

    }
    else {
      key_display = false
    }

  }
  else {
    key_display = false
  }
  if (vars.legend.value && key && key_display) {

    if ( vars.dev.value ) d3plus.console.time("positioning legend")

    if (square_size) {
      var key_height = square_size+vars.ui.padding
    }
    else {
      var key_box = vars.g.legend.node().getBBox(),
          key_height = key_box.height+key_box.y-vars.ui.padding
    }

    if (vars.margin.bottom === 0) {
      vars.margin.bottom += vars.ui.padding
    }
    vars.margin.bottom += key_height

    vars.g.legend.transition().duration(vars.draw.timing)
      .attr("transform","translate(0,"+(vars.height.value-vars.margin.bottom)+")")

    if ( vars.dev.value ) d3plus.console.timeEnd("positioning legend")

  }
  else {

    if ( vars.dev.value ) d3plus.console.time("hiding legend")

    vars.g.legend.transition().duration(vars.draw.timing)
      .attr("transform","translate(0,"+vars.height.value+")")

    if ( vars.dev.value ) d3plus.console.timeEnd("hiding legend")

  }


}

},{"../../core/data/nest.js":undefined,"../../core/fetch/color.js":undefined,"../../core/fetch/text.js":undefined,"../../core/fetch/value.js":undefined}],227:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates Centered Server Message
//------------------------------------------------------------------------------
d3plus.ui.message = function(vars,message) {

  var message = vars.messages.value ? message : null,
      size = message == vars.internal_error ? "large" : vars.messages.style

  if (size == "large") {
    var font = vars.messages,
        position = "center"
  }
  else {

    if (vars.footer.value) {
      var font = vars.footer
    }
    else if (vars.title.value) {
      var font = vars.title
    }
    else if (vars.title.sub.value) {
      var font = vars.title.sub
    }
    else if (vars.title.total.value) {
      var font = vars.title.total
    }
    else {
      var font = vars.title.sub
    }

    var position = font.position

  }

  var font = {
    "color": font.font.color,
    "font-family": font.font.family.value,
    "font-weight": font.font.weight,
    "font-size": font.font.size+"px",
    "padding": font.padding+"px"
  }

  var background = vars.background.value != "none" ? vars.background.value : "white"

  function style(elem) {

    elem
      .style(font)
      .style("position","absolute")
      .style("background",background)
      .style("text-align","center")
      .style("left",function(){
        return position == "center" ? "50%" : "0px"
      })
      .style("width",function(){
        return position == "center" ? "auto" : vars.width.value+"px"
      })
      .style("margin-left",function(){
        var offset = vars.width.value-vars.width.viz
        return position == "center" ? -(this.offsetWidth/2+offset/2)+"px" : "0px"
      })
      .style("top",function(){
        if (position == "center") {
          return "50%";
        }
        else if (position == "top") {
          return "0px"
        }
        else {
          return "auto"
        }
      })
      .style("bottom",function(){
        if (position == "bottom") {
          return "0px"
        }
        else {
          return "auto"
        }
      })
      .style("margin-top",function(){
        if (size == "large") {
          var height = this.offsetHeight || this.getBoundingClientRect().height
          return -height/2+"px"
        }
        return "0px"
      })

  }

  // Enter Message Group
  vars.g.message = vars.container.value.selectAll("div#d3plus_message")
    .data(["message"])

  vars.g.message.enter().append("div")
    .attr("id","d3plus_message")
    .attr("opacity",0)

  var opacity = message ? 1 : 0,
      text = message ? message : vars.g.message.text(),
      display = message ? "inline-block" : "none"

  vars.g.message
    .text(text)
    .style("opacity",opacity)
    .style("display",display)
    .call(style)

}

},{}],228:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates color key
//-------------------------------------------------------------------

d3plus.ui.timeline = function(vars) {

  if ((!vars.internal_error || !vars.data.missing) && !vars.small && vars.data.time && vars.data.time.values.length > 1 && vars.timeline.value) {

    var years = []
    vars.data.time.values.forEach(function(d){
      years.push(new Date(d))
    })

    if ( vars.dev.value ) d3plus.console.time("drawing timeline")

    var timeFormat = vars.time.format.value || vars.data.time.format
      , timeMultiFormat = vars.time.format.value || vars.data.time.multiFormat

    if ((vars.time.value == vars.x.value && vars.x.scale.value == "continuous") || (vars.time.value == vars.y.value && vars.y.scale.value == "continuous")) {
      var min_required = 2
    }
    else {
      var min_required = 1
    }

    if (vars.time.solo.value.length) {
      var init = d3.extent(vars.time.solo.value)
      for (var i = 0; i < init.length; i++) {
        if (init[i].constructor !== Date) {
          var d = new Date(init[i].toString())
          d.setTime( d.getTime() + d.getTimezoneOffset() * 60 * 1000 )
          init[i] = d
        }
      }
    }
    else {
      var init = d3.extent(years)
    }

    var min = years[0],
        start = new Date(init[0]),
        end = new Date(init[1])

    years = vars.data.time.ticks
    var year_ticks = years.slice()
    var d = new Date(min)
    d["set"+vars.data.time.stepType](d["get"+vars.data.time.stepType]() + years.length)
    year_ticks.push(d)

    end["set"+vars.data.time.stepType](end["get"+vars.data.time.stepType]() + 1)
    start = d3plus.util.closest(year_ticks,start)
    end = d3plus.util.closest(year_ticks,end)

    var yearMS = year_ticks.slice(0)
    for (var i = 0; i < yearMS.length; i++) {
      yearMS[i] = yearMS[i].getTime()
    }

    var min_index = yearMS.indexOf(start.getTime())
      , max_index = yearMS.indexOf(end.getTime())

    var brushed = function() {

      if (d3.event.sourceEvent !== null) {

        brushExtent = brush.extent()

        var min_val = d3plus.util.closest(year_ticks,brushExtent[0]),
            max_val = d3plus.util.closest(year_ticks,brushExtent[1])

        if (min_val === max_val) {
          min_index = yearMS.indexOf(min_val.getTime())
          if (min_val < brushExtent[0] || min_index === 0) {
            max_val = year_ticks[min_index + 1]
          }
          else {
            min_val = year_ticks[min_index - 1]
          }

        }

        min_index = yearMS.indexOf(min_val.getTime())
        max_index = yearMS.indexOf(max_val.getTime())

        if (max_index-min_index >= min_required) {
          var extent = [min_val,max_val]
        }
        else if (min_index+min_required <= years.length) {
          var extent = [min_val,year_ticks[min_index+min_required]]
        }
        else {

          var extent = [min_val]
          for (var i = 1; i <= min_required; i++) {
            if (min_index+i <= years.length) {
              extent.push(year_ticks[min_index+i])
            }
            else {
              extent.unshift(year_ticks[min_index-((min_index+i)-(years.length))])
            }
          }
          extent = [extent[0],extent[extent.length-1]]
        }

        brushExtent = extent

        text.attr("fill",textFill)

        d3.select(this).call(brush.extent(extent))

      }
      else {
        return;
      }

    }

    var brushend = function() {

      if (d3.event.sourceEvent !== null) {

        if (vars.time.solo.value.length) {
          var solod = d3.extent(vars.time.solo.value)
            , old_min = yearMS.indexOf(d3plus.util.closest(year_ticks,solod[0]).getTime())
            , old_max = yearMS.indexOf(d3plus.util.closest(year_ticks,solod[1]).getTime())+1
            , change = old_min !== min_index || old_max !== max_index
        }
        else {
          var change = max_index-min_index !== years.length
        }

        if (change) {

          if (max_index-min_index == years.length) {
            var newYears = []
          }
          else {

            var newYears = d3.range(min_index,max_index)
              .map(function(y){
                var i = vars.data.time.dataSteps.indexOf(y)
                return i >= 0 ? vars.data.time.values[i] : years[y]
              })

          }

          vars.self.time({"solo": newYears}).draw()

        }

      }
      else {
        return;
      }

    }

    var textStyle = {
      "font-weight": vars.ui.font.weight,
      "font-family": vars.ui.font.family.value,
      "font-size": vars.ui.font.size,
      "text-anchor": "middle"
    }

    var timeFormatter = function(v,i) {
      if (i === 0 || i === years.length-1) return timeFormat(v)
      else return timeMultiFormat(v)
    }

    var textSizes = d3plus.font.sizes(years.map(timeFormatter),textStyle)
      , yearWidths = textSizes.map(function(t){return t.width})
      , year_width = d3.max(yearWidths)
      , year_height = d3.max(textSizes.map(function(t){return t.height}))

    var label_width = year_width+vars.ui.padding*2,
        timelineHeight = year_height+vars.ui.padding*2
        timeline_width = label_width*years.length,
        available_width = vars.width.value-vars.ui.padding*2,
        tickStep = 1,
        textRotate = 0

    if (timeline_width > available_width) {
      label_width = year_height+vars.ui.padding*2
      timelineHeight = year_width+vars.ui.padding*2
      timeline_width = label_width*years.length
      textRotate = 90
    }

    timelineHeight = d3.max([timelineHeight,vars.timeline.height.value])

    var old_width = label_width
    if (timeline_width > available_width) {
      timeline_width = available_width
      old_width = label_width-vars.ui.padding*2
      label_width = timeline_width/years.length
      if (old_width > label_width) {
        tickStep = Math.ceil(old_width/(timeline_width/years.length))
        for (tickStep; tickStep < years.length-1; tickStep++) {
          if ((years.length-1)%tickStep == 0) {
            break;
          }
        }

      }
    }

    if (vars.timeline.align == "start") {
      var start_x = vars.ui.padding
    }
    else if (vars.timeline.align == "end") {
      var start_x = vars.width.value - vars.ui.padding - timeline_width
    }
    else {
      var start_x = vars.width.value/2 - timeline_width/2
    }

    var brushExtent = [start,end]

    var textFill = function(d) {

      if (d >= brushExtent[0] && d < brushExtent[1]) {
        var opacity = 1
          , color = d3plus.color.text(vars.ui.color.primary.value)
      }
      else {
        var opacity = 0.5
          , color = d3plus.color.text(vars.ui.color.secondary.value)
      }

      var color = d3.rgb(color)

      return "rgba("+color.r+","+color.g+","+color.b+","+opacity+")"

    }

    var background = vars.g.timeline.selectAll("rect.d3plus_timeline_background")
      .data(["background"])

    background.enter().append("rect")
      .attr("class","d3plus_timeline_background")
      .attr("shape-rendering","crispEdges")
      .attr("width",timeline_width+2)
      .attr("height",timelineHeight+2)
      .attr("fill",vars.ui.color.secondary.value)
      .attr("x",start_x-1)
      .attr("y",vars.ui.padding)

    background.transition().duration(vars.draw.timing)
      .attr("width",timeline_width+2)
      .attr("height",timelineHeight+2)
      .attr("fill",vars.ui.color.secondary.value)
      .attr("x",start_x-1)
      .attr("y",vars.ui.padding)

    var ticks = vars.g.timeline.selectAll("g#ticks")
      .data(["ticks"])

    ticks.enter().append("g")
      .attr("id","ticks")
      .attr("transform","translate("+vars.width.value/2+","+vars.ui.padding+")")

    var brush_group = vars.g.timeline.selectAll("g#brush")
      .data(["brush"])

    brush_group.enter().append("g")
      .attr("id","brush")

    var labels = vars.g.timeline.selectAll("g#labels")
      .data(["labels"])

    labels.enter().append("g")
      .attr("id","labels")

    var text = labels.selectAll("text")
      .data(years,function(d,i){
        return i
      })

    text.enter().append("text")
      .attr("y",0)
      .attr("dy","0.5ex")
      .attr("x",0)

    text
      .order()
      .attr(textStyle)
      .text(function(d,i){
        if (i === 0 || i === years.length-1) return timeFormat(d)

        var prev = (i-1)%tickStep === 0
          , next = (i+1)%tickStep === 0
          , data = vars.data.time.dataSteps.indexOf(i) >= 0
          , fits = (yearWidths[i-1]/2 + yearWidths[i] + yearWidths[i+1]/2 + vars.ui.padding*4) < label_width*2

        return i%tickStep === 0 || (!prev && !next && data && old_width < label_width*3) ? timeMultiFormat(d) : ""
      })
      .attr("opacity",function(d,i){
        return vars.data.time.dataSteps.indexOf(i) >= 0 ? 1 : 0.4
      })
      .attr("fill",textFill)
      .attr("transform",function(d,i){
        var x = start_x + (label_width*i) + label_width/2
          , y = timelineHeight/2 + vars.ui.padding + 1

        // var diff = diff = parseFloat(d3.select(this).style("font-size"),10)/4
        // var y = vars.ui.padding+vars.timeline.height/2+this.getBBox().height/2 - diff

        if (textRotate) {
          // x -= vars.ui.padding
          // y += vars.ui.padding
        }
        else {
          // x += vars.ui.padding
          // y += vars.ui.padding
        }
        return "translate("+Math.round(x)+","+Math.round(y)+")rotate("+textRotate+")"
      })

    text.exit().transition().duration(vars.draw.timing)
      .attr("opacity",0)
      .remove()

    var x = d3.time.scale()
      .domain(d3.extent(year_ticks))
      .rangeRound([0,timeline_width])

    var brush = d3.svg.brush()
      .x(x)
      .extent(brushExtent)
      .on("brush", brushed)
      .on("brushend", brushend)

    ticks
      .attr("transform","translate("+start_x+","+vars.ui.padding+")")
      .transition().duration(vars.draw.timing)
      .call(d3.svg.axis()
        .scale(x)
        .orient("top")
        .ticks(function(){
          return year_ticks
        })
        .tickFormat("")
        .tickSize(-timelineHeight)
        .tickPadding(0))
        .selectAll("path").attr("fill","none")

    ticks.selectAll("line")
      .attr("stroke",vars.timeline.tick)
      .attr("stroke-width",1)
      .attr("shape-rendering","crispEdges")

    brush_group
      .attr("transform","translate("+start_x+","+(vars.ui.padding+1)+")")
      .attr("opacity",1)
      .call(brush)

    text.attr("pointer-events","none")

    brush_group.selectAll("rect.background")
      .attr("fill","none")
      // .attr("stroke-width",1)
      // .attr("stroke",vars.ui.color.secondary.value)
      .style("visibility","visible")
      .attr("height",timelineHeight)
      .attr("shape-rendering","crispEdges")
      .on(d3plus.evt.move,function(){
        var c = vars.timeline.hover.value
        if (["grab","grabbing"].indexOf(c) >= 0) c = d3plus.prefix()+c
        d3.select(this).style("cursor",c)
      })

    brush_group.selectAll("rect.extent")
      // .attr("stroke-width",1)
      // .attr("stroke",vars.ui.color.secondary.value)
      .attr("height",timelineHeight)
      .attr("fill",vars.ui.color.primary.value)
      .attr("shape-rendering","crispEdges")
      .on(d3plus.evt.move,function(){
        var c = vars.timeline.hover.value
        if (["grab","grabbing"].indexOf(c) >= 0) c = d3plus.prefix()+c
        d3.select(this).style("cursor",c)
      })

    if (vars.timeline.handles.value) {

      var handles = brush_group.selectAll("g.resize").selectAll("rect.d3plus_handle")
        .data(["d3plus_handle"])

      handles.enter().insert("rect","rect")
        .attr("class","d3plus_handle")

      handles
        .attr("fill",vars.timeline.handles.color)
        .attr("transform",function(d){
          var mod = this.parentNode.className.baseVal === "resize e" ? -vars.timeline.handles.size : 0
          return "translate("+mod+",0)"
        })
        .attr("width",vars.timeline.handles.size)
        .style("visibility","visible")
        .attr("shape-rendering","crispEdges")
        .attr("opacity",vars.timeline.handles.opacity)
        .on(d3plus.evt.over,function(){
          d3.select(this).select("rect")
            .transition().duration(vars.timing.mouseevents)
            .attr("fill",vars.timeline.handles.hover)
        })
        .on(d3plus.evt.out,function(){
          d3.select(this).select("rect")
            .transition().duration(vars.timing.mouseevents)
            .attr("fill",vars.timeline.handles.color)
        })

      brush_group.selectAll("g.resize").selectAll("rect")
        .attr("height",timelineHeight)

    }
    else {

      brush_group.selectAll("g.resize")
        .remove()

    }

    if ( vars.margin.bottom === 0 ) {
      vars.margin.bottom += vars.ui.padding
    }

    var timelineBox = vars.g.timeline.node().getBBox()

    vars.margin.bottom += timelineBox.height+timelineBox.y

    vars.g.timeline.transition().duration(vars.draw.timing)
      .attr("transform","translate(0,"+Math.round(vars.height.value-vars.margin.bottom-vars.ui.padding/2)+")")

    vars.margin.bottom += vars.ui.padding

    if ( vars.dev.value ) d3plus.console.time("drawing timeline")

  }
  else {

    vars.g.timeline.transition().duration(vars.draw.timing)
      .attr("transform","translate(0,"+vars.height.value+")")

  }

}

},{}],229:[function(require,module,exports){
var fetchValue = require("../../core/fetch/value.js")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Draws appropriate titles
//------------------------------------------------------------------------------
d3plus.ui.titles = function(vars) {

  var total_key = vars.size.value ? vars.size.value
    : vars.color.type === "number" ? vars.color.value : false

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // If there is no data or the title bar is not needed,
  // set the total value to 'null'
  //----------------------------------------------------------------------------
  if (!vars.data.app || !vars.title.total.value || vars.small) {
    var total = false
  }
  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Otherwise, let's calculate it!
  //----------------------------------------------------------------------------
  else if (total_key) {

    if ( vars.dev.value ) {
      d3plus.console.time("calculating total value")
    }

    if (vars.focus.value.length) {
      var total = vars.data.app.filter(function(d){
        return d[vars.id.value] == vars.focus.value[0]
      })
      total = d3.sum(total,function(d){
        return fetchValue(vars,d,total_key)
      })
    }
    else {
      var total = d3.sum(vars.data.pool,function(d){
        return fetchValue(vars,d,total_key)
      })
    }

    if (total === 0) {
      total = false
    }

    if (typeof total === "number") {

      var pct = ""

      if (vars.data.mute.length || vars.data.solo.length || vars.focus.value.length) {

        var overall_total = d3.sum(vars.data.value, function(d){
          if (vars.time.solo.value.length > 0) {
            var match = vars.time.solo.value.indexOf(fetchValue(vars,d,vars.time.value)) >= 0
          }
          else if (vars.time.mute.value.length > 0) {
            var match = vars.time.solo.value.indexOf(fetchValue(vars,d,vars.time.value)) < 0
          }
          else {
            var match = true
          }
          if (match) {
            return fetchValue(vars,d,total_key)
          }
        })

        if (overall_total > total) {

          var pct = (total/overall_total)*100,
              ot = vars.format.value(overall_total,vars.size.value)

          var pct = " ("+vars.format.value(pct,"share")+"% of "+ot+")"

        }
      }

      total = vars.format.value(total,vars.size.value)
      var obj = vars.title.total.value
        , prefix = obj.prefix || vars.format.value(vars.format.locale.value.ui.total)+": "
      total = prefix + total
      obj.suffix ? total = total + obj.suffix : null
      total += pct

    }

    if ( vars.dev.value ) {
      d3plus.console.timeEnd("calculating total value")
    }

  }
  else {
    var total = false
  }


  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Initialize titles and detect footer
  //----------------------------------------------------------------------------
  var title_data = []

  if (vars.footer.value) {
    title_data.push({
      "link": vars.footer.link,
      "style": vars.footer,
      "type": "footer",
      "value": vars.footer.value
    })
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // If not in "small" mode, detect titles available
  //----------------------------------------------------------------------------
  if (!vars.small) {

    if (vars.title.value) {
      title_data.push({
        "link": vars.title.link,
        "style": vars.title,
        "type": "title",
        "value": vars.title.value
      })
    }
    if (vars.title.sub.value) {
      title_data.push({
        "link": vars.title.sub.link,
        "style": vars.title.sub,
        "type": "sub",
        "value": vars.title.sub.value
      })
    }
    if (vars.title.total.value && total) {
      title_data.push({
        "link": vars.title.total.link,
        "style": vars.title.total,
        "type": "total",
        "value": total
      })
    }

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Title positioning
  //----------------------------------------------------------------------------
  function position(title) {

    title
      .style("text-anchor",function(t){

        var align = t.style.font.align

        if (align == "center") {
          return "middle"
        }
        else if ((align == "left" && !d3plus.rtl) || (align == "right" && d3plus.rtl)) {
          return "start"
        }
        else if ((align == "left" && d3plus.rtl) || (align == "right" && !d3plus.rtl)) {
          return "end"
        }

      })
      .attr("x",function(t){

        var align = t.style.font.align

        if (align == "center") {
          return vars.width.value/2
        }
        else if ((align == "left" && !d3plus.rtl) || (align == "right" && d3plus.rtl)) {
          return vars.padding
        }
        else if ((align == "left" && d3plus.rtl) || (align == "right" && !d3plus.rtl)) {
          return vars.width.value-vars.padding
        }

      })
      .attr("y",0)

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Enter Titles
  //----------------------------------------------------------------------------
  function style(title) {

    title
      .attr("font-size",function(t){
        return t.style.font.size
      })
      .attr("fill",function(t){
        return t.link ? vars.links.font.color : t.style.font.color
      })
      .attr("font-family",function(t){
        return t.link ? vars.links.font.family.value : t.style.font.family.value
      })
      .attr("font-weight",function(t){
        return t.link ? vars.links.font.weight : t.style.font.weight
      })
      .style("text-decoration",function(t){
        return t.link ? vars.links.font.decoration.value : t.style.font.decoration.value
      })
      .style("text-transform",function(t){
        return t.link ? vars.links.font.transform.value : t.style.font.transform.value
      })

  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Enter Titles
  //----------------------------------------------------------------------------
  if ( vars.dev.value ) d3plus.console.time("drawing titles")
  var titles = vars.svg.selectAll("g.d3plus_title")
    .data(title_data,function(t){
      return t.type
    })

  var titleWidth = vars.title.width || vars.width.value

  titles.enter().append("g")
    .attr("class","d3plus_title")
    .attr("opacity",0)
    .attr("transform",function(t){
      var y = t.style.position == "top" ? 0 : vars.height.value
      return "translate(0,"+y+")"
    })
    .append("text")
      .call(position)
      .call(style)

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Wrap text and calculate positions, then transition style and opacity
  //----------------------------------------------------------------------------
  titles
    .each(function(d){

      d3plus.textwrap()
        .container( d3.select(this).select("text") )
        .height( vars.height.value / 8 )
        .size(false)
        .text( d.value )
        .width( titleWidth )
        .draw()

      d.y = vars.margin[d.style.position]
      vars.margin[d.style.position] += this.getBBox().height + d.style.padding*2

    })
    .on(d3plus.evt.over,function(t){
      if (t.link) {
        d3.select(this)
          .transition().duration(vars.timing.mouseevents)
          .style("cursor","pointer")
          .select("text")
            .attr("fill",vars.links.hover.color)
            .attr("font-family",vars.links.hover.family.value)
            .attr("font-weight",vars.links.hover.weight)
            .style("text-decoration",vars.links.hover.decoration.value)
            .style("text-transform",vars.links.hover.transform.value)
      }
    })
    .on(d3plus.evt.out,function(t){
      if (t.link) {
        d3.select(this)
          .transition().duration(vars.timing.mouseevents)
          .style("cursor","auto")
          .select("text")
            .call(style)
      }
    })
    .on(d3plus.evt.click,function(t){
      if (t.link) {
        var target = t.link.charAt(0) != "/" ? "_blank" : "_self"
        window.open(t.link,target)
      }
    })
    .transition().duration(vars.draw.timing)
      .attr("opacity",1)
      .attr("transform",function(t){
        var pos = t.style.position,
            y = pos == "top" ? 0+t.y : vars.height.value-t.y
        if (pos == "bottom") {
          y -= this.getBBox().height+t.style.padding
        }
        else {
          y += t.style.padding
        }
        return "translate(0,"+y+")"
      })
      .select("text")
        .call(position)
        .call(style)

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Exit unused titles
  //----------------------------------------------------------------------------
  titles.exit().transition().duration(vars.draw.timing)
    .attr("opacity",0)
    .remove()

  if ( vars.margin.top > 0 ) {
    vars.margin.top += vars.title.padding
  }

  if ( vars.margin.bottom > 0 ) {
    vars.margin.bottom += vars.title.padding
  }

  var min = vars.title.height
  if (min && vars.margin[vars.title.position] < min) {
    vars.margin[vars.title.position] = min
  }

  if ( vars.dev.value ) d3plus.console.timeEnd("drawing titles")

}

},{"../../core/fetch/value.js":undefined}],230:[function(require,module,exports){
d3plus.viz = function() {

  var vars = {
    "g"     : {"apps": {} },
    "types" : {
      "bubbles":  require("./types/bubbles.js"),
      "chart":    require("./types/chart.js"),
      "geo_map":  require("./types/geo_map.js"),
      "line":     require("./types/line.js"),
      "network":  require("./types/network.js"),
      "paths":    require("./types/paths.coffee"),
      "rings":    require("./types/rings.js"),
      "scatter":  require("./types/scatter.js"),
      "stacked":  require("./types/stacked.js"),
      "tree_map": require("./types/tree_map.js")
    },
    "shell" : "viz"
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Main drawing function
  //----------------------------------------------------------------------------
  vars.self = function(selection) {
    selection.each(function() {

      vars.draw.frozen = true
      vars.internal_error = null
      d3plus.draw.container(vars)

      if ( !("timing" in vars.draw) ) {
        vars.draw.timing = vars.timing.transitions
      }

      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      // Determine if in "small" mode
      //------------------------------------------------------------------------
      var small_width = vars.width.value <= vars.width.small,
          small_height = vars.height.value <= vars.height.small
      vars.small = small_width || small_height

      var lastMessage = false

      if (vars.error.value) {

        var timing = vars.draw.timing

        vars.group.transition().duration(timing)
          .attr("opacity",0)
        vars.g.data.transition().duration(timing)
          .attr("opacity",0)
        vars.g.edges.transition().duration(timing)
          .attr("opacity",0)

        vars.messages.style = "large"
        var message = vars.error.value === true
                    ? vars.format.value(vars.format.locale.value.ui.error)
                    : vars.error.value

        lastMessage = message
        d3plus.ui.message(vars,message)

      }
      else {

        var steps = d3plus.draw.steps( vars )
          , step  = false

        vars.container.value.style("cursor","wait")
        vars.messages.style = vars.group && vars.group.attr("opacity") === "1"
                            ? "small" : "large"

        var nextStep = function() {

          if ( steps.length ) {
            runStep()
          }
          else {

            vars.methodGroup = false
            if ( vars.dev.value ) {
              d3plus.console.timeEnd("total draw time")
              d3plus.console.groupEnd()
              d3plus.console.log("\n")
            }
            vars.container.value.style("cursor","auto")

          }

        }

        var runFunction = function( name ) {

          var name = name || "function"

          if ( step[name] instanceof Array ) {
            step[name].forEach(function(f){
              f( vars , nextStep )
            })
          }
          else if ( typeof step[name] == "function" ) {
            step[name]( vars , nextStep )
          }

          if ( !step.wait ) {
            nextStep()
          }

        }

        function runStep() {

          step = steps.shift()

          var same = vars.g.message && lastMessage === step.message,
              run = "check" in step ? step.check : true

          if ( typeof run === "function" ) {
            run = run( vars )
          }

          if ( run ) {

            if ( !same && vars.draw.update ) {

              if ( vars.dev.value ) {
                if ( lastMessage !== false ) {
                  d3plus.console.groupEnd()
                }
                d3plus.console.groupCollapsed(step.message)
              }

              lastMessage = typeof vars.messages.value === "string"
                          ? vars.messages.value
                          : step.message

              var message = typeof vars.messages.value === "string"
                          ? vars.messages.value
                          : vars.format.value(step.message)

              d3plus.ui.message(vars,message)

              setTimeout( runFunction , 10 )

            }
            else {

              runFunction()

            }

          }
          else {

            if ( "otherwise" in step ) {

              setTimeout(function(){

                runFunction( "otherwise" )

              },10)

            }
            else {

              nextStep()

            }

          }

        }

        runStep()

      }

    })

    return vars.self
  }

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Define methods and expose public variables.
  //----------------------------------------------------------------------------
  var methods = [ "active" , "aggs" , "attrs" , "axes" , "color" , "container"
                , "coords" , "csv" , "data" , "depth" , "descs" , "dev"
                , "draw" , "edges" , "error" , "focus" , "footer" , "format"
                , "height" , "history" , "icon" , "id" , "labels"
                , "legend" , "margin" , "messages" , "nodes" , "order"
                , "shape" , "size" , "style" , "temp" , "text" , "time"
                , "timeline" , "title" , "tooltip" , "total" , "type" , "ui"
                , "width" , "x" , "y" , "zoom" ]
    , styles  = [ "axes" , "background" , "color" , "coords" , "data" , "edges"
                , "font" , "footer" , "height" , "labels" , "legend" , "links"
                , "messages" , "nodes" , "shape" , "timeline" , "timing"
                , "title" , "tooltip" , "ui" , "width "]
  d3plus.method( vars , methods , styles )

  return vars.self

}

},{"./types/bubbles.js":undefined,"./types/chart.js":undefined,"./types/geo_map.js":undefined,"./types/line.js":undefined,"./types/network.js":undefined,"./types/paths.coffee":undefined,"./types/rings.js":undefined,"./types/scatter.js":undefined,"./types/stacked.js":undefined,"./types/tree_map.js":undefined}],231:[function(require,module,exports){
d3plus.zoom.bounds = function( vars , b , timing ) {

  if (!b) {
    var b = vars.zoom.bounds
  }

  if (typeof timing !== "number") {
    var timing = vars.timing.transitions
  }

  vars.zoom.size = {
    "height": b[1][1]-b[0][1],
    "width": b[1][0]-b[0][0]
  }

  var fit = vars.coords.fit.value
  if (fit == "auto" || vars.types[vars.type.value].requirements.indexOf("coords") < 0) {
    var aspect = d3.max([vars.zoom.size.width/vars.width.viz,vars.zoom.size.height/vars.height.viz])
  }
  else {
    var aspect = vars.zoom.size[fit]/vars["app_"+fit]
  }

  var min = d3.min([vars.width.viz,vars.height.viz])

  var scale = ((min-(vars.coords.padding*2)) / min) / aspect

  var extent = vars.zoom.behavior.scaleExtent()

  if (extent[0] == extent[1] || b == vars.zoom.bounds) {
    vars.zoom.behavior.scaleExtent([scale,scale*16])
  }

  var max_scale = vars.zoom.behavior.scaleExtent()[1]
  if (scale > max_scale) {
    scale = max_scale
  }
  vars.zoom.scale = scale

  var translate = []

  translate[0] = vars.width.viz/2-(vars.zoom.size.width*scale)/2-(b[0][0]*scale)
  translate[1] = vars.height.viz/2-(vars.zoom.size.height*scale)/2-(b[0][1]*scale)

  vars.zoom.translate = translate
  vars.zoom.behavior.translate(translate).scale(scale)

  vars.zoom.size = {
    "height": vars.zoom.bounds[1][1]-vars.zoom.bounds[0][1],
    "width": vars.zoom.bounds[1][0]-vars.zoom.bounds[0][0]
  }

  d3plus.zoom.transform(vars,timing)

}

},{}],232:[function(require,module,exports){
d3plus.zoom.controls = function() {

  d3.select("#d3plus.utilsts.zoom_controls").remove()
  
  if (!vars.small) {
    // Create Zoom Controls
    var zoom_enter = vars.container.value.append("div")
      .attr("id","d3plus.utilsts.zoom_controls")
      .style("top",(vars.margin.top+5)+"px")

    zoom_enter.append("div")
      .attr("id","zoom_in")
      .attr("unselectable","on")
      .on(d3plus.evt.click,function(){ vars.zoom("in") })
      .text("+")

    zoom_enter.append("div")
      .attr("id","zoom_out")
      .attr("unselectable","on")
      .on(d3plus.evt.click,function(){ vars.zoom("out") })
      .text("-")

    zoom_enter.append("div")
      .attr("id","zoom_reset")
      .attr("unselectable","on")
      .on(d3plus.evt.click,function(){
        vars.zoom("reset")
        vars.draw.update()
      })
      .html("\&#8634;")
  }

  /* Old Styles

  #zoom_controls {
    position: absolute;
    top: 5px;
    left: 5px;
    z-index: 50;
  }

  #zoom_in, #zoom_out, #zoom_reset {
    background-color: #ffffff;
    background-position: 50% 50%;
    background-repeat: no-repeat;
    -webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.25);
       -moz-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.25);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.25);
    color: #333333;
    display: block;
    height: 18px;
    margin-bottom: 5px;
    opacity: 0.75;
    text-align: center;
    width: 18px;
    -webkit-text-size-adjust: none;
         -webkit-user-select: none;
            -moz-user-select: none;
  }

  #zoom_in:hover, #zoom_out:hover, #zoom_reset:hover {
    opacity: 1;
  }

  #zoom_in {
    cursor: pointer;
    font: normal 18px/20px Arial, Helvetica, sans-serif;
  }

  #zoom_out {
    cursor: pointer;
    font: normal 22px/16px Tahoma, Verdana, sans-serif;
  }

  #zoom_reset {
    cursor: pointer;
    font: bold 15px/19px Arial, Helvetica, sans-serif;
  }

  */

}

},{}],233:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Sets label opacity based on zoom
//------------------------------------------------------------------------------
d3plus.zoom.labels = function(vars) {

  var max_scale = vars.zoom.behavior.scaleExtent()[1]

  if ( vars.dev.value ) d3plus.console.time("determining label visibility")

  if (vars.draw.timing) {

    vars.g.viz.selectAll("text.d3plus_label")
      .transition().duration(vars.draw.timing)
      .attr("opacity",function(d){
        if (!d) var d = {"scale": max_scale}
        var size = parseFloat(d3.select(this).attr("font-size"),10)
        d.visible = size/d.scale*vars.zoom.scale >= 7
        return d.visible ? 1 : 0
      })

  }
  else {

    vars.g.viz.selectAll("text.d3plus_label")
      .attr("opacity",function(d){
        if (!d) var d = {"scale": max_scale}
        var size = parseFloat(d3.select(this).attr("font-size"),10)
        d.visible = size/d.scale*vars.zoom.scale >= 7
        return d.visible ? 1 : 0
      })

  }

  if ( vars.dev.value ) d3plus.console.timeEnd("determining label visibility")

}

},{}],234:[function(require,module,exports){
d3plus.zoom.mouse = function(vars) {

  var translate = d3.event.translate,
      scale = d3.event.scale,
      limits = vars.zoom.bounds,
      xoffset = (vars.width.viz-(vars.zoom.size.width*scale))/2,
      xmin = xoffset > 0 ? xoffset : 0,
      xmax = xoffset > 0 ? vars.width.viz-xoffset : vars.width.viz,
      yoffset = (vars.height.viz-(vars.zoom.size.height*scale))/2,
      ymin = yoffset > 0 ? yoffset : 0,
      ymax = yoffset > 0 ? vars.height.viz-yoffset : vars.height.viz

  // Auto center visualization
  if (translate[0]+limits[0][0]*scale > xmin) {
    translate[0] = -limits[0][0]*scale+xmin
  }
  else if (translate[0]+limits[1][0]*scale < xmax) {
    translate[0] = xmax-(limits[1][0]*scale)
  }

  if (translate[1]+limits[0][1]*scale > ymin) {
    translate[1] = -limits[0][1]*scale+ymin
  }
  else if (translate[1]+limits[1][1]*scale < ymax) {
    translate[1] = ymax-(limits[1][1]*scale)
  }

  vars.zoom.behavior.translate(translate).scale(scale)

  vars.zoom.translate = translate
  vars.zoom.scale = scale

  if (d3.event.sourceEvent.type == "wheel") {
    var delay = vars.draw.timing ? 100 : 250
    clearTimeout(vars.zoom.wheel)
    vars.zoom.wheel = setTimeout(function(){
      d3plus.zoom.labels(vars)
    },delay)
  }
  else {
    d3plus.zoom.labels(vars)
  }

  if (d3.event.sourceEvent.type === "dblclick") {
    d3plus.zoom.transform(vars,vars.timing.transitions)
  }
  else {
    d3plus.zoom.transform(vars,0)
  }

}

},{}],235:[function(require,module,exports){
d3plus.zoom.transform = function(vars,timing) {

  if (typeof timing !== "number") {
    var timing = vars.timing.transitions
  }

  var translate = vars.zoom.translate
    , scale = vars.zoom.scale

  if (timing) {
    vars.g.viz.transition().duration(timing)
      .attr("transform","translate("+translate+")scale("+scale+")")

  }
  else {

    vars.g.viz
      .attr("transform","translate("+translate+")scale("+scale+")")

  }

}

},{}],236:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
var TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str.toString()
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.compare = function (a, b) {
  assert(Buffer.isBuffer(a) && Buffer.isBuffer(b), 'Arguments must be Buffers')
  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) {
    return -1
  }
  if (y < x) {
    return 1
  }
  return 0
}

// BUFFER INSTANCE METHODS
// =======================

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end === undefined) ? self.length : Number(end)

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = asciiSlice(self, start, end)
      break
    case 'binary':
      ret = binarySlice(self, start, end)
      break
    case 'base64':
      ret = base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

Buffer.prototype.equals = function (b) {
  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.compare = function (b) {
  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return readUInt16(this, offset, false, noAssert)
}

function readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return readInt16(this, offset, false, noAssert)
}

function readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return readInt32(this, offset, false, noAssert)
}

function readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return readFloat(this, offset, false, noAssert)
}

function readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
  return offset + 1
}

function writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
  return offset + 2
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  return writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  return writeUInt16(this, value, offset, false, noAssert)
}

function writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
  return offset + 4
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  return writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  return writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
  return offset + 1
}

function writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
  return offset + 2
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  return writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  return writeInt16(this, value, offset, false, noAssert)
}

function writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
  return offset + 4
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  return writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  return writeInt32(this, value, offset, false, noAssert)
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":237,"ieee754":238}],237:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],238:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],239:[function(require,module,exports){
module.exports = require('./lib/heap');

},{"./lib/heap":240}],240:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

  floor = Math.floor, min = Math.min;

  /* 
  Default comparison function to be used
  */


  defaultCmp = function(x, y) {
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  };

  /* 
  Insert item x in list a, and keep it sorted assuming a is sorted.
  
  If x is already in a, insert it to the right of the rightmost x.
  
  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
  */


  insort = function(a, x, lo, hi, cmp) {
    var mid;
    if (lo == null) {
      lo = 0;
    }
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (lo < 0) {
      throw new Error('lo must be non-negative');
    }
    if (hi == null) {
      hi = a.length;
    }
    while (lo < hi) {
      mid = floor((lo + hi) / 2);
      if (cmp(x, a[mid]) < 0) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
  };

  /*
  Push item onto heap, maintaining the heap invariant.
  */


  heappush = function(array, item, cmp) {
    if (cmp == null) {
      cmp = defaultCmp;
    }
    array.push(item);
    return _siftdown(array, 0, array.length - 1, cmp);
  };

  /*
  Pop the smallest item off the heap, maintaining the heap invariant.
  */


  heappop = function(array, cmp) {
    var lastelt, returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    lastelt = array.pop();
    if (array.length) {
      returnitem = array[0];
      array[0] = lastelt;
      _siftup(array, 0, cmp);
    } else {
      returnitem = lastelt;
    }
    return returnitem;
  };

  /*
  Pop and return the current smallest value, and add the new item.
  
  This is more efficient than heappop() followed by heappush(), and can be 
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
  */


  heapreplace = function(array, item, cmp) {
    var returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    returnitem = array[0];
    array[0] = item;
    _siftup(array, 0, cmp);
    return returnitem;
  };

  /*
  Fast version of a heappush followed by a heappop.
  */


  heappushpop = function(array, item, cmp) {
    var _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (array.length && cmp(array[0], item) < 0) {
      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
      _siftup(array, 0, cmp);
    }
    return item;
  };

  /*
  Transform list into a heap, in-place, in O(array.length) time.
  */


  heapify = function(array, cmp) {
    var i, _i, _j, _len, _ref, _ref1, _results, _results1;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    _ref1 = (function() {
      _results1 = [];
      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this).reverse();
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      _results.push(_siftup(array, i, cmp));
    }
    return _results;
  };

  /*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
  */


  updateItem = function(array, item, cmp) {
    var pos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    pos = array.indexOf(item);
    if (pos === -1) {
      return;
    }
    _siftdown(array, 0, pos, cmp);
    return _siftup(array, pos, cmp);
  };

  /*
  Find the n largest elements in a dataset.
  */


  nlargest = function(array, n, cmp) {
    var elem, result, _i, _len, _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    result = array.slice(0, n);
    if (!result.length) {
      return result;
    }
    heapify(result, cmp);
    _ref = array.slice(n);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elem = _ref[_i];
      heappushpop(result, elem, cmp);
    }
    return result.sort(cmp).reverse();
  };

  /*
  Find the n smallest elements in a dataset.
  */


  nsmallest = function(array, n, cmp) {
    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (n * 10 <= array.length) {
      result = array.slice(0, n).sort(cmp);
      if (!result.length) {
        return result;
      }
      los = result[result.length - 1];
      _ref = array.slice(n);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        if (cmp(elem, los) < 0) {
          insort(result, elem, 0, null, cmp);
          result.pop();
          los = result[result.length - 1];
        }
      }
      return result;
    }
    heapify(array, cmp);
    _results = [];
    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      _results.push(heappop(array, cmp));
    }
    return _results;
  };

  _siftdown = function(array, startpos, pos, cmp) {
    var newitem, parent, parentpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    newitem = array[pos];
    while (pos > startpos) {
      parentpos = (pos - 1) >> 1;
      parent = array[parentpos];
      if (cmp(newitem, parent) < 0) {
        array[pos] = parent;
        pos = parentpos;
        continue;
      }
      break;
    }
    return array[pos] = newitem;
  };

  _siftup = function(array, pos, cmp) {
    var childpos, endpos, newitem, rightpos, startpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    endpos = array.length;
    startpos = pos;
    newitem = array[pos];
    childpos = 2 * pos + 1;
    while (childpos < endpos) {
      rightpos = childpos + 1;
      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
        childpos = rightpos;
      }
      array[pos] = array[childpos];
      pos = childpos;
      childpos = 2 * pos + 1;
    }
    array[pos] = newitem;
    return _siftdown(array, startpos, pos, cmp);
  };

  Heap = (function() {
    Heap.push = heappush;

    Heap.pop = heappop;

    Heap.replace = heapreplace;

    Heap.pushpop = heappushpop;

    Heap.heapify = heapify;

    Heap.nlargest = nlargest;

    Heap.nsmallest = nsmallest;

    function Heap(cmp) {
      this.cmp = cmp != null ? cmp : defaultCmp;
      this.nodes = [];
    }

    Heap.prototype.push = function(x) {
      return heappush(this.nodes, x, this.cmp);
    };

    Heap.prototype.pop = function() {
      return heappop(this.nodes, this.cmp);
    };

    Heap.prototype.peek = function() {
      return this.nodes[0];
    };

    Heap.prototype.contains = function(x) {
      return this.nodes.indexOf(x) !== -1;
    };

    Heap.prototype.replace = function(x) {
      return heapreplace(this.nodes, x, this.cmp);
    };

    Heap.prototype.pushpop = function(x) {
      return heappushpop(this.nodes, x, this.cmp);
    };

    Heap.prototype.heapify = function() {
      return heapify(this.nodes, this.cmp);
    };

    Heap.prototype.updateItem = function(x) {
      return updateItem(this.nodes, x, this.cmp);
    };

    Heap.prototype.clear = function() {
      return this.nodes = [];
    };

    Heap.prototype.empty = function() {
      return this.nodes.length === 0;
    };

    Heap.prototype.size = function() {
      return this.nodes.length;
    };

    Heap.prototype.clone = function() {
      var heap;
      heap = new Heap();
      heap.nodes = this.nodes.slice(0);
      return heap;
    };

    Heap.prototype.toArray = function() {
      return this.nodes.slice(0);
    };

    Heap.prototype.insert = Heap.prototype.push;

    Heap.prototype.top = Heap.prototype.peek;

    Heap.prototype.front = Heap.prototype.peek;

    Heap.prototype.has = Heap.prototype.contains;

    Heap.prototype.copy = Heap.prototype.clone;

    return Heap;

  })();

  if (typeof module !== "undefined" && module !== null ? module.exports : void 0) {
    module.exports = Heap;
  } else {
    window.Heap = Heap;
  }

}).call(this);

},{}],241:[function(require,module,exports){
(function (global){
"use strict";

var numeric = (typeof exports === "undefined")?(function numeric() {}):(exports);
if(typeof global !== "undefined") { global.numeric = numeric; }

numeric.version = "1.2.6";

// 1. Utility functions
numeric.bench = function bench (f,interval) {
    var t1,t2,n,i;
    if(typeof interval === "undefined") { interval = 15; }
    n = 0.5;
    t1 = new Date();
    while(1) {
        n*=2;
        for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
        while(i>0) { f(); i--; }
        t2 = new Date();
        if(t2-t1 > interval) break;
    }
    for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
    while(i>0) { f(); i--; }
    t2 = new Date();
    return 1000*(3*n-1)/(t2-t1);
}

numeric._myIndexOf = (function _myIndexOf(w) {
    var n = this.length,k;
    for(k=0;k<n;++k) if(this[k]===w) return k;
    return -1;
});
numeric.myIndexOf = (Array.prototype.indexOf)?Array.prototype.indexOf:numeric._myIndexOf;

numeric.Function = Function;
numeric.precision = 4;
numeric.largeArray = 50;

numeric.prettyPrint = function prettyPrint(x) {
    function fmtnum(x) {
        if(x === 0) { return '0'; }
        if(isNaN(x)) { return 'NaN'; }
        if(x<0) { return '-'+fmtnum(-x); }
        if(isFinite(x)) {
            var scale = Math.floor(Math.log(x) / Math.log(10));
            var normalized = x / Math.pow(10,scale);
            var basic = normalized.toPrecision(numeric.precision);
            if(parseFloat(basic) === 10) { scale++; normalized = 1; basic = normalized.toPrecision(numeric.precision); }
            return parseFloat(basic).toString()+'e'+scale.toString();
        }
        return 'Infinity';
    }
    var ret = [];
    function foo(x) {
        var k;
        if(typeof x === "undefined") { ret.push(Array(numeric.precision+8).join(' ')); return false; }
        if(typeof x === "string") { ret.push('"'+x+'"'); return false; }
        if(typeof x === "boolean") { ret.push(x.toString()); return false; }
        if(typeof x === "number") {
            var a = fmtnum(x);
            var b = x.toPrecision(numeric.precision);
            var c = parseFloat(x.toString()).toString();
            var d = [a,b,c,parseFloat(b).toString(),parseFloat(c).toString()];
            for(k=1;k<d.length;k++) { if(d[k].length < a.length) a = d[k]; }
            ret.push(Array(numeric.precision+8-a.length).join(' ')+a);
            return false;
        }
        if(x === null) { ret.push("null"); return false; }
        if(typeof x === "function") { 
            ret.push(x.toString());
            var flag = false;
            for(k in x) { if(x.hasOwnProperty(k)) { 
                if(flag) ret.push(',\n');
                else ret.push('\n{');
                flag = true; 
                ret.push(k); 
                ret.push(': \n'); 
                foo(x[k]); 
            } }
            if(flag) ret.push('}\n');
            return true;
        }
        if(x instanceof Array) {
            if(x.length > numeric.largeArray) { ret.push('...Large Array...'); return true; }
            var flag = false;
            ret.push('[');
            for(k=0;k<x.length;k++) { if(k>0) { ret.push(','); if(flag) ret.push('\n '); } flag = foo(x[k]); }
            ret.push(']');
            return true;
        }
        ret.push('{');
        var flag = false;
        for(k in x) { if(x.hasOwnProperty(k)) { if(flag) ret.push(',\n'); flag = true; ret.push(k); ret.push(': \n'); foo(x[k]); } }
        ret.push('}');
        return true;
    }
    foo(x);
    return ret.join('');
}

numeric.parseDate = function parseDate(d) {
    function foo(d) {
        if(typeof d === 'string') { return Date.parse(d.replace(/-/g,'/')); }
        if(!(d instanceof Array)) { throw new Error("parseDate: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseFloat = function parseFloat_(d) {
    function foo(d) {
        if(typeof d === 'string') { return parseFloat(d); }
        if(!(d instanceof Array)) { throw new Error("parseFloat: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseCSV = function parseCSV(t) {
    var foo = t.split('\n');
    var j,k;
    var ret = [];
    var pat = /(([^'",]*)|('[^']*')|("[^"]*")),/g;
    var patnum = /^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/;
    var stripper = function(n) { return n.substr(0,n.length-1); }
    var count = 0;
    for(k=0;k<foo.length;k++) {
      var bar = (foo[k]+",").match(pat),baz;
      if(bar.length>0) {
          ret[count] = [];
          for(j=0;j<bar.length;j++) {
              baz = stripper(bar[j]);
              if(patnum.test(baz)) { ret[count][j] = parseFloat(baz); }
              else ret[count][j] = baz;
          }
          count++;
      }
    }
    return ret;
}

numeric.toCSV = function toCSV(A) {
    var s = numeric.dim(A);
    var i,j,m,n,row,ret;
    m = s[0];
    n = s[1];
    ret = [];
    for(i=0;i<m;i++) {
        row = [];
        for(j=0;j<m;j++) { row[j] = A[i][j].toString(); }
        ret[i] = row.join(', ');
    }
    return ret.join('\n')+'\n';
}

numeric.getURL = function getURL(url) {
    var client = new XMLHttpRequest();
    client.open("GET",url,false);
    client.send();
    return client;
}

numeric.imageURL = function imageURL(img) {
    function base64(A) {
        var n = A.length, i,x,y,z,p,q,r,s;
        var key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var ret = "";
        for(i=0;i<n;i+=3) {
            x = A[i];
            y = A[i+1];
            z = A[i+2];
            p = x >> 2;
            q = ((x & 3) << 4) + (y >> 4);
            r = ((y & 15) << 2) + (z >> 6);
            s = z & 63;
            if(i+1>=n) { r = s = 64; }
            else if(i+2>=n) { s = 64; }
            ret += key.charAt(p) + key.charAt(q) + key.charAt(r) + key.charAt(s);
            }
        return ret;
    }
    function crc32Array (a,from,to) {
        if(typeof from === "undefined") { from = 0; }
        if(typeof to === "undefined") { to = a.length; }
        var table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
                     0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 
                     0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
                     0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 
                     0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 
                     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 
                     0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
                     0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
                     0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
                     0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 
                     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 
                     0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 
                     0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 
                     0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 
                     0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 
                     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 
                     0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 
                     0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 
                     0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 
                     0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 
                     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 
                     0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 
                     0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 
                     0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 
                     0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 
                     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 
                     0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 
                     0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 
                     0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 
                     0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 
                     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 
                     0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];
     
        var crc = -1, y = 0, n = a.length,i;

        for (i = from; i < to; i++) {
            y = (crc ^ a[i]) & 0xFF;
            crc = (crc >>> 8) ^ table[y];
        }
     
        return crc ^ (-1);
    }

    var h = img[0].length, w = img[0][0].length, s1, s2, next,k,length,a,b,i,j,adler32,crc32;
    var stream = [
                  137, 80, 78, 71, 13, 10, 26, 10,                           //  0: PNG signature
                  0,0,0,13,                                                  //  8: IHDR Chunk length
                  73, 72, 68, 82,                                            // 12: "IHDR" 
                  (w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w&255,   // 16: Width
                  (h >> 24) & 255, (h >> 16) & 255, (h >> 8) & 255, h&255,   // 20: Height
                  8,                                                         // 24: bit depth
                  2,                                                         // 25: RGB
                  0,                                                         // 26: deflate
                  0,                                                         // 27: no filter
                  0,                                                         // 28: no interlace
                  -1,-2,-3,-4,                                               // 29: CRC
                  -5,-6,-7,-8,                                               // 33: IDAT Chunk length
                  73, 68, 65, 84,                                            // 37: "IDAT"
                  // RFC 1950 header starts here
                  8,                                                         // 41: RFC1950 CMF
                  29                                                         // 42: RFC1950 FLG
                  ];
    crc32 = crc32Array(stream,12,29);
    stream[29] = (crc32>>24)&255;
    stream[30] = (crc32>>16)&255;
    stream[31] = (crc32>>8)&255;
    stream[32] = (crc32)&255;
    s1 = 1;
    s2 = 0;
    for(i=0;i<h;i++) {
        if(i<h-1) { stream.push(0); }
        else { stream.push(1); }
        a = (3*w+1+(i===0))&255; b = ((3*w+1+(i===0))>>8)&255;
        stream.push(a); stream.push(b);
        stream.push((~a)&255); stream.push((~b)&255);
        if(i===0) stream.push(0);
        for(j=0;j<w;j++) {
            for(k=0;k<3;k++) {
                a = img[k][i][j];
                if(a>255) a = 255;
                else if(a<0) a=0;
                else a = Math.round(a);
                s1 = (s1 + a )%65521;
                s2 = (s2 + s1)%65521;
                stream.push(a);
            }
        }
        stream.push(0);
    }
    adler32 = (s2<<16)+s1;
    stream.push((adler32>>24)&255);
    stream.push((adler32>>16)&255);
    stream.push((adler32>>8)&255);
    stream.push((adler32)&255);
    length = stream.length - 41;
    stream[33] = (length>>24)&255;
    stream[34] = (length>>16)&255;
    stream[35] = (length>>8)&255;
    stream[36] = (length)&255;
    crc32 = crc32Array(stream,37);
    stream.push((crc32>>24)&255);
    stream.push((crc32>>16)&255);
    stream.push((crc32>>8)&255);
    stream.push((crc32)&255);
    stream.push(0);
    stream.push(0);
    stream.push(0);
    stream.push(0);
//    a = stream.length;
    stream.push(73);  // I
    stream.push(69);  // E
    stream.push(78);  // N
    stream.push(68);  // D
    stream.push(174); // CRC1
    stream.push(66);  // CRC2
    stream.push(96);  // CRC3
    stream.push(130); // CRC4
    return 'data:image/png;base64,'+base64(stream);
}

// 2. Linear algebra with Arrays.
numeric._dim = function _dim(x) {
    var ret = [];
    while(typeof x === "object") { ret.push(x.length); x = x[0]; }
    return ret;
}

numeric.dim = function dim(x) {
    var y,z;
    if(typeof x === "object") {
        y = x[0];
        if(typeof y === "object") {
            z = y[0];
            if(typeof z === "object") {
                return numeric._dim(x);
            }
            return [x.length,y.length];
        }
        return [x.length];
    }
    return [];
}

numeric.mapreduce = function mapreduce(body,init) {
    return Function('x','accum','_s','_k',
            'if(typeof accum === "undefined") accum = '+init+';\n'+
            'if(typeof x === "number") { var xi = x; '+body+'; return accum; }\n'+
            'if(typeof _s === "undefined") _s = numeric.dim(x);\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i,xi;\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) {\n'+
            '        accum = arguments.callee(x[i],accum,_s,_k+1);\n'+
            '    }'+
            '    return accum;\n'+
            '}\n'+
            'for(i=_n-1;i>=1;i-=2) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '    xi = x[i-1];\n'+
            '    '+body+';\n'+
            '}\n'+
            'if(i === 0) {\n'+
            '    xi = x[i];\n'+
            '    '+body+'\n'+
            '}\n'+
            'return accum;'
            );
}
numeric.mapreduce2 = function mapreduce2(body,setup) {
    return Function('x',
            'var n = x.length;\n'+
            'var i,xi;\n'+setup+';\n'+
            'for(i=n-1;i!==-1;--i) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '}\n'+
            'return accum;'
            );
}


numeric.same = function same(x,y) {
    var i,n;
    if(!(x instanceof Array) || !(y instanceof Array)) { return false; }
    n = x.length;
    if(n !== y.length) { return false; }
    for(i=0;i<n;i++) {
        if(x[i] === y[i]) { continue; }
        if(typeof x[i] === "object") { if(!same(x[i],y[i])) return false; }
        else { return false; }
    }
    return true;
}

numeric.rep = function rep(s,v,k) {
    if(typeof k === "undefined") { k=0; }
    var n = s[k], ret = Array(n), i;
    if(k === s.length-1) {
        for(i=n-2;i>=0;i-=2) { ret[i+1] = v; ret[i] = v; }
        if(i===-1) { ret[0] = v; }
        return ret;
    }
    for(i=n-1;i>=0;i--) { ret[i] = numeric.rep(s,v,k+1); }
    return ret;
}


numeric.dotMMsmall = function dotMMsmall(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0;
    p = x.length; q = y.length; r = y[0].length;
    ret = Array(p);
    for(i=p-1;i>=0;i--) {
        foo = Array(r);
        bar = x[i];
        for(k=r-1;k>=0;k--) {
            woo = bar[q-1]*y[q-1][k];
            for(j=q-2;j>=1;j-=2) {
                i0 = j-1;
                woo += bar[j]*y[j][k] + bar[i0]*y[i0][k];
            }
            if(j===0) { woo += bar[0]*y[0][k]; }
            foo[k] = woo;
        }
        ret[i] = foo;
    }
    return ret;
}
numeric._getCol = function _getCol(A,j,x) {
    var n = A.length, i;
    for(i=n-1;i>0;--i) {
        x[i] = A[i][j];
        --i;
        x[i] = A[i][j];
    }
    if(i===0) x[0] = A[0][j];
}
numeric.dotMMbig = function dotMMbig(x,y){
    var gc = numeric._getCol, p = y.length, v = Array(p);
    var m = x.length, n = y[0].length, A = new Array(m), xj;
    var VV = numeric.dotVV;
    var i,j,k,z;
    --p;
    --m;
    for(i=m;i!==-1;--i) A[i] = Array(n);
    --n;
    for(i=n;i!==-1;--i) {
        gc(y,i,v);
        for(j=m;j!==-1;--j) {
            z=0;
            xj = x[j];
            A[j][i] = VV(xj,v);
        }
    }
    return A;
}

numeric.dotMV = function dotMV(x,y) {
    var p = x.length, q = y.length,i;
    var ret = Array(p), dotVV = numeric.dotVV;
    for(i=p-1;i>=0;i--) { ret[i] = dotVV(x[i],y); }
    return ret;
}

numeric.dotVM = function dotVM(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0,s1,s2,s3,baz,accum;
    p = x.length; q = y[0].length;
    ret = Array(q);
    for(k=q-1;k>=0;k--) {
        woo = x[p-1]*y[p-1][k];
        for(j=p-2;j>=1;j-=2) {
            i0 = j-1;
            woo += x[j]*y[j][k] + x[i0]*y[i0][k];
        }
        if(j===0) { woo += x[0]*y[0][k]; }
        ret[k] = woo;
    }
    return ret;
}

numeric.dotVV = function dotVV(x,y) {
    var i,n=x.length,i1,ret = x[n-1]*y[n-1];
    for(i=n-2;i>=1;i-=2) {
        i1 = i-1;
        ret += x[i]*y[i] + x[i1]*y[i1];
    }
    if(i===0) { ret += x[0]*y[0]; }
    return ret;
}

numeric.dot = function dot(x,y) {
    var d = numeric.dim;
    switch(d(x).length*1000+d(y).length) {
    case 2002:
        if(y.length < 10) return numeric.dotMMsmall(x,y);
        else return numeric.dotMMbig(x,y);
    case 2001: return numeric.dotMV(x,y);
    case 1002: return numeric.dotVM(x,y);
    case 1001: return numeric.dotVV(x,y);
    case 1000: return numeric.mulVS(x,y);
    case 1: return numeric.mulSV(x,y);
    case 0: return x*y;
    default: throw new Error('numeric.dot only works on vectors and matrices');
    }
}

numeric.diag = function diag(d) {
    var i,i1,j,n = d.length, A = Array(n), Ai;
    for(i=n-1;i>=0;i--) {
        Ai = Array(n);
        i1 = i+2;
        for(j=n-1;j>=i1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j>i) { Ai[j] = 0; }
        Ai[i] = d[i];
        for(j=i-1;j>=1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j===0) { Ai[0] = 0; }
        A[i] = Ai;
    }
    return A;
}
numeric.getDiag = function(A) {
    var n = Math.min(A.length,A[0].length),i,ret = Array(n);
    for(i=n-1;i>=1;--i) {
        ret[i] = A[i][i];
        --i;
        ret[i] = A[i][i];
    }
    if(i===0) {
        ret[0] = A[0][0];
    }
    return ret;
}

numeric.identity = function identity(n) { return numeric.diag(numeric.rep([n],1)); }
numeric.pointwise = function pointwise(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = '_s';
    fun[params.length+1] = '_k';
    fun[params.length+2] = (
            'if(typeof _s === "undefined") _s = numeric.dim('+thevec+');\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee('+params.join(',')+',_s,_k+1);\n'+
            '    return ret;\n'+
            '}\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            '    '+body+'\n'+
            '}\n'+
            'return ret;'
            );
    return Function.apply(null,fun);
}
numeric.pointwise2 = function pointwise2(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = (
            'var _n = '+thevec+'.length;\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            body+'\n'+
            '}\n'+
            'return ret;'
            );
    return Function.apply(null,fun);
}
numeric._biforeach = (function _biforeach(x,y,s,k,f) {
    if(k === s.length-1) { f(x,y); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _biforeach(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
});
numeric._biforeach2 = (function _biforeach2(x,y,s,k,f) {
    if(k === s.length-1) { return f(x,y); }
    var i,n=s[k],ret = Array(n);
    for(i=n-1;i>=0;--i) { ret[i] = _biforeach2(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
    return ret;
});
numeric._foreach = (function _foreach(x,s,k,f) {
    if(k === s.length-1) { f(x); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _foreach(x[i],s,k+1,f); }
});
numeric._foreach2 = (function _foreach2(x,s,k,f) {
    if(k === s.length-1) { return f(x); }
    var i,n=s[k], ret = Array(n);
    for(i=n-1;i>=0;i--) { ret[i] = _foreach2(x[i],s,k+1,f); }
    return ret;
});

/*numeric.anyV = numeric.mapreduce('if(xi) return true;','false');
numeric.allV = numeric.mapreduce('if(!xi) return false;','true');
numeric.any = function(x) { if(typeof x.length === "undefined") return x; return numeric.anyV(x); }
numeric.all = function(x) { if(typeof x.length === "undefined") return x; return numeric.allV(x); }*/

numeric.ops2 = {
        add: '+',
        sub: '-',
        mul: '*',
        div: '/',
        mod: '%',
        and: '&&',
        or:  '||',
        eq:  '===',
        neq: '!==',
        lt:  '<',
        gt:  '>',
        leq: '<=',
        geq: '>=',
        band: '&',
        bor: '|',
        bxor: '^',
        lshift: '<<',
        rshift: '>>',
        rrshift: '>>>'
};
numeric.opseq = {
        addeq: '+=',
        subeq: '-=',
        muleq: '*=',
        diveq: '/=',
        modeq: '%=',
        lshifteq: '<<=',
        rshifteq: '>>=',
        rrshifteq: '>>>=',
        bandeq: '&=',
        boreq: '|=',
        bxoreq: '^='
};
numeric.mathfuns = ['abs','acos','asin','atan','ceil','cos',
                    'exp','floor','log','round','sin','sqrt','tan',
                    'isNaN','isFinite'];
numeric.mathfuns2 = ['atan2','pow','max','min'];
numeric.ops1 = {
        neg: '-',
        not: '!',
        bnot: '~',
        clone: ''
};
numeric.mapreducers = {
        any: ['if(xi) return true;','var accum = false;'],
        all: ['if(!xi) return false;','var accum = true;'],
        sum: ['accum += xi;','var accum = 0;'],
        prod: ['accum *= xi;','var accum = 1;'],
        norm2Squared: ['accum += xi*xi;','var accum = 0;'],
        norminf: ['accum = max(accum,abs(xi));','var accum = 0, max = Math.max, abs = Math.abs;'],
        norm1: ['accum += abs(xi)','var accum = 0, abs = Math.abs;'],
        sup: ['accum = max(accum,xi);','var accum = -Infinity, max = Math.max;'],
        inf: ['accum = min(accum,xi);','var accum = Infinity, min = Math.min;']
};

(function () {
    var i,o;
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        numeric.ops2[o] = o;
    }
    for(i in numeric.ops2) {
        if(numeric.ops2.hasOwnProperty(i)) {
            o = numeric.ops2[i];
            var code, codeeq, setup = '';
            if(numeric.myIndexOf.call(numeric.mathfuns2,i)!==-1) {
                setup = 'var '+o+' = Math.'+o+';\n';
                code = function(r,x,y) { return r+' = '+o+'('+x+','+y+')'; };
                codeeq = function(x,y) { return x+' = '+o+'('+x+','+y+')'; };
            } else {
                code = function(r,x,y) { return r+' = '+x+' '+o+' '+y; };
                if(numeric.opseq.hasOwnProperty(i+'eq')) {
                    codeeq = function(x,y) { return x+' '+o+'= '+y; };
                } else {
                    codeeq = function(x,y) { return x+' = '+x+' '+o+' '+y; };                    
                }
            }
            numeric[i+'VV'] = numeric.pointwise2(['x[i]','y[i]'],code('ret[i]','x[i]','y[i]'),setup);
            numeric[i+'SV'] = numeric.pointwise2(['x','y[i]'],code('ret[i]','x','y[i]'),setup);
            numeric[i+'VS'] = numeric.pointwise2(['x[i]','y'],code('ret[i]','x[i]','y'),setup);
            numeric[i] = Function(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var VV = numeric.'+i+'VV, VS = numeric.'+i+'VS, SV = numeric.'+i+'SV;\n'+
                    'var dim = numeric.dim;\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof x === "object") {\n'+
                    '      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);\n'+
                    '      else x = numeric._biforeach2(x,y,dim(x),0,VS);\n'+
                    '  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);\n'+
                    '  else '+codeeq('x','y')+'\n'+
                    '}\nreturn x;\n');
            numeric[o] = numeric[i];
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]','x[i]'], codeeq('ret[i]','x[i]'),setup);
            numeric[i+'eqS'] = numeric.pointwise2(['ret[i]','x'], codeeq('ret[i]','x'),setup);
            numeric[i+'eq'] = Function(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var V = numeric.'+i+'eqV, S = numeric.'+i+'eqS\n'+
                    'var s = numeric.dim(x);\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);\n'+
                    '  else numeric._biforeach(x,y,s,0,S);\n'+
                    '}\nreturn x;\n');
        }
    }
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        delete numeric.ops2[o];
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        numeric.ops1[o] = o;
    }
    for(i in numeric.ops1) {
        if(numeric.ops1.hasOwnProperty(i)) {
            setup = '';
            o = numeric.ops1[i];
            if(numeric.myIndexOf.call(numeric.mathfuns,i)!==-1) {
                if(Math.hasOwnProperty(o)) setup = 'var '+o+' = Math.'+o+';\n';
            }
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]'],'ret[i] = '+o+'(ret[i]);',setup);
            numeric[i+'eq'] = Function('x',
                    'if(typeof x !== "object") return '+o+'x\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'eqV;\n'+
                    'var s = numeric.dim(x);\n'+
                    'numeric._foreach(x,s,0,V);\n'+
                    'return x;\n');
            numeric[i+'V'] = numeric.pointwise2(['x[i]'],'ret[i] = '+o+'(x[i]);',setup);
            numeric[i] = Function('x',
                    'if(typeof x !== "object") return '+o+'(x)\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'V;\n'+
                    'var s = numeric.dim(x);\n'+
                    'return numeric._foreach2(x,s,0,V);\n');
        }
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        delete numeric.ops1[o];
    }
    for(i in numeric.mapreducers) {
        if(numeric.mapreducers.hasOwnProperty(i)) {
            o = numeric.mapreducers[i];
            numeric[i+'V'] = numeric.mapreduce2(o[0],o[1]);
            numeric[i] = Function('x','s','k',
                    o[1]+
                    'if(typeof x !== "object") {'+
                    '    xi = x;\n'+
                    o[0]+';\n'+
                    '    return accum;\n'+
                    '}'+
                    'if(typeof s === "undefined") s = numeric.dim(x);\n'+
                    'if(typeof k === "undefined") k = 0;\n'+
                    'if(k === s.length-1) return numeric.'+i+'V(x);\n'+
                    'var xi;\n'+
                    'var n = x.length, i;\n'+
                    'for(i=n-1;i!==-1;--i) {\n'+
                    '   xi = arguments.callee(x[i]);\n'+
                    o[0]+';\n'+
                    '}\n'+
                    'return accum;\n');
        }
    }
}());

numeric.truncVV = numeric.pointwise(['x[i]','y[i]'],'ret[i] = round(x[i]/y[i])*y[i];','var round = Math.round;');
numeric.truncVS = numeric.pointwise(['x[i]','y'],'ret[i] = round(x[i]/y)*y;','var round = Math.round;');
numeric.truncSV = numeric.pointwise(['x','y[i]'],'ret[i] = round(x/y[i])*y[i];','var round = Math.round;');
numeric.trunc = function trunc(x,y) {
    if(typeof x === "object") {
        if(typeof y === "object") return numeric.truncVV(x,y);
        return numeric.truncVS(x,y);
    }
    if (typeof y === "object") return numeric.truncSV(x,y);
    return Math.round(x/y)*y;
}

numeric.inv = function inv(x) {
    var s = numeric.dim(x), abs = Math.abs, m = s[0], n = s[1];
    var A = numeric.clone(x), Ai, Aj;
    var I = numeric.identity(m), Ii, Ij;
    var i,j,k,x;
    for(j=0;j<n;++j) {
        var i0 = -1;
        var v0 = -1;
        for(i=j;i!==m;++i) { k = abs(A[i][j]); if(k>v0) { i0 = i; v0 = k; } }
        Aj = A[i0]; A[i0] = A[j]; A[j] = Aj;
        Ij = I[i0]; I[i0] = I[j]; I[j] = Ij;
        x = Aj[j];
        for(k=j;k!==n;++k)    Aj[k] /= x; 
        for(k=n-1;k!==-1;--k) Ij[k] /= x;
        for(i=m-1;i!==-1;--i) {
            if(i!==j) {
                Ai = A[i];
                Ii = I[i];
                x = Ai[j];
                for(k=j+1;k!==n;++k)  Ai[k] -= Aj[k]*x;
                for(k=n-1;k>0;--k) { Ii[k] -= Ij[k]*x; --k; Ii[k] -= Ij[k]*x; }
                if(k===0) Ii[0] -= Ij[0]*x;
            }
        }
    }
    return I;
}

numeric.det = function det(x) {
    var s = numeric.dim(x);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: det() only works on square matrices'); }
    var n = s[0], ret = 1,i,j,k,A = numeric.clone(x),Aj,Ai,alpha,temp,k1,k2,k3;
    for(j=0;j<n-1;j++) {
        k=j;
        for(i=j+1;i<n;i++) { if(Math.abs(A[i][j]) > Math.abs(A[k][j])) { k = i; } }
        if(k !== j) {
            temp = A[k]; A[k] = A[j]; A[j] = temp;
            ret *= -1;
        }
        Aj = A[j];
        for(i=j+1;i<n;i++) {
            Ai = A[i];
            alpha = Ai[j]/Aj[j];
            for(k=j+1;k<n-1;k+=2) {
                k1 = k+1;
                Ai[k] -= Aj[k]*alpha;
                Ai[k1] -= Aj[k1]*alpha;
            }
            if(k!==n) { Ai[k] -= Aj[k]*alpha; }
        }
        if(Aj[j] === 0) { return 0; }
        ret *= Aj[j];
    }
    return ret*A[j][j];
}

numeric.transpose = function transpose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
            --j;
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = A1[0]; Bj[i-1] = A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = A0[j];
            --j;
            ret[j][0] = A0[j];
        }
        if(j===0) { ret[0][0] = A0[0]; }
    }
    return ret;
}
numeric.negtranspose = function negtranspose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
            --j;
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = -A1[0]; Bj[i-1] = -A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = -A0[j];
            --j;
            ret[j][0] = -A0[j];
        }
        if(j===0) { ret[0][0] = -A0[0]; }
    }
    return ret;
}

numeric._random = function _random(s,k) {
    var i,n=s[k],ret=Array(n), rnd;
    if(k === s.length-1) {
        rnd = Math.random;
        for(i=n-1;i>=1;i-=2) {
            ret[i] = rnd();
            ret[i-1] = rnd();
        }
        if(i===0) { ret[0] = rnd(); }
        return ret;
    }
    for(i=n-1;i>=0;i--) ret[i] = _random(s,k+1);
    return ret;
}
numeric.random = function random(s) { return numeric._random(s,0); }

numeric.norm2 = function norm2(x) { return Math.sqrt(numeric.norm2Squared(x)); }

numeric.linspace = function linspace(a,b,n) {
    if(typeof n === "undefined") n = Math.max(Math.round(b-a)+1,1);
    if(n<2) { return n===1?[a]:[]; }
    var i,ret = Array(n);
    n--;
    for(i=n;i>=0;i--) { ret[i] = (i*b+(n-i)*a)/n; }
    return ret;
}

numeric.getBlock = function getBlock(x,from,to) {
    var s = numeric.dim(x);
    function foo(x,k) {
        var i,a = from[k], n = to[k]-a, ret = Array(n);
        if(k === s.length-1) {
            for(i=n;i>=0;i--) { ret[i] = x[i+a]; }
            return ret;
        }
        for(i=n;i>=0;i--) { ret[i] = foo(x[i+a],k+1); }
        return ret;
    }
    return foo(x,0);
}

numeric.setBlock = function setBlock(x,from,to,B) {
    var s = numeric.dim(x);
    function foo(x,y,k) {
        var i,a = from[k], n = to[k]-a;
        if(k === s.length-1) { for(i=n;i>=0;i--) { x[i+a] = y[i]; } }
        for(i=n;i>=0;i--) { foo(x[i+a],y[i],k+1); }
    }
    foo(x,B,0);
    return x;
}

numeric.getRange = function getRange(A,I,J) {
    var m = I.length, n = J.length;
    var i,j;
    var B = Array(m), Bi, AI;
    for(i=m-1;i!==-1;--i) {
        B[i] = Array(n);
        Bi = B[i];
        AI = A[I[i]];
        for(j=n-1;j!==-1;--j) Bi[j] = AI[J[j]];
    }
    return B;
}

numeric.blockMatrix = function blockMatrix(X) {
    var s = numeric.dim(X);
    if(s.length<4) return numeric.blockMatrix([X]);
    var m=s[0],n=s[1],M,N,i,j,Xij;
    M = 0; N = 0;
    for(i=0;i<m;++i) M+=X[i][0].length;
    for(j=0;j<n;++j) N+=X[0][j][0].length;
    var Z = Array(M);
    for(i=0;i<M;++i) Z[i] = Array(N);
    var I=0,J,ZI,k,l,Xijk;
    for(i=0;i<m;++i) {
        J=N;
        for(j=n-1;j!==-1;--j) {
            Xij = X[i][j];
            J -= Xij[0].length;
            for(k=Xij.length-1;k!==-1;--k) {
                Xijk = Xij[k];
                ZI = Z[I+k];
                for(l = Xijk.length-1;l!==-1;--l) ZI[J+l] = Xijk[l];
            }
        }
        I += X[i][0].length;
    }
    return Z;
}

numeric.tensor = function tensor(x,y) {
    if(typeof x === "number" || typeof y === "number") return numeric.mul(x,y);
    var s1 = numeric.dim(x), s2 = numeric.dim(y);
    if(s1.length !== 1 || s2.length !== 1) {
        throw new Error('numeric: tensor product is only defined for vectors');
    }
    var m = s1[0], n = s2[0], A = Array(m), Ai, i,j,xi;
    for(i=m-1;i>=0;i--) {
        Ai = Array(n);
        xi = x[i];
        for(j=n-1;j>=3;--j) {
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
        }
        while(j>=0) { Ai[j] = xi * y[j]; --j; }
        A[i] = Ai;
    }
    return A;
}

// 3. The Tensor type T
numeric.T = function T(x,y) { this.x = x; this.y = y; }
numeric.t = function t(x,y) { return new numeric.T(x,y); }

numeric.Tbinop = function Tbinop(rr,rc,cr,cc,setup) {
    var io = numeric.indexOf;
    if(typeof setup !== "string") {
        var k;
        setup = '';
        for(k in numeric) {
            if(numeric.hasOwnProperty(k) && (rr.indexOf(k)>=0 || rc.indexOf(k)>=0 || cr.indexOf(k)>=0 || cc.indexOf(k)>=0) && k.length>1) {
                setup += 'var '+k+' = numeric.'+k+';\n';
            }
        }
    }
    return Function(['y'],
            'var x = this;\n'+
            'if(!(y instanceof numeric.T)) { y = new numeric.T(y); }\n'+
            setup+'\n'+
            'if(x.y) {'+
            '  if(y.y) {'+
            '    return new numeric.T('+cc+');\n'+
            '  }\n'+
            '  return new numeric.T('+cr+');\n'+
            '}\n'+
            'if(y.y) {\n'+
            '  return new numeric.T('+rc+');\n'+
            '}\n'+
            'return new numeric.T('+rr+');\n'
    );
}

numeric.T.prototype.add = numeric.Tbinop(
        'add(x.x,y.x)',
        'add(x.x,y.x),y.y',
        'add(x.x,y.x),x.y',
        'add(x.x,y.x),add(x.y,y.y)');
numeric.T.prototype.sub = numeric.Tbinop(
        'sub(x.x,y.x)',
        'sub(x.x,y.x),neg(y.y)',
        'sub(x.x,y.x),x.y',
        'sub(x.x,y.x),sub(x.y,y.y)');
numeric.T.prototype.mul = numeric.Tbinop(
        'mul(x.x,y.x)',
        'mul(x.x,y.x),mul(x.x,y.y)',
        'mul(x.x,y.x),mul(x.y,y.x)',
        'sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))');

numeric.T.prototype.reciprocal = function reciprocal() {
    var mul = numeric.mul, div = numeric.div;
    if(this.y) {
        var d = numeric.add(mul(this.x,this.x),mul(this.y,this.y));
        return new numeric.T(div(this.x,d),div(numeric.neg(this.y),d));
    }
    return new T(div(1,this.x));
}
numeric.T.prototype.div = function div(y) {
    if(!(y instanceof numeric.T)) y = new numeric.T(y);
    if(y.y) { return this.mul(y.reciprocal()); }
    var div = numeric.div;
    if(this.y) { return new numeric.T(div(this.x,y.x),div(this.y,y.x)); }
    return new numeric.T(div(this.x,y.x));
}
numeric.T.prototype.dot = numeric.Tbinop(
        'dot(x.x,y.x)',
        'dot(x.x,y.x),dot(x.x,y.y)',
        'dot(x.x,y.x),dot(x.y,y.x)',
        'sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))'
        );
numeric.T.prototype.transpose = function transpose() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),t(y)); }
    return new numeric.T(t(x));
}
numeric.T.prototype.transjugate = function transjugate() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),numeric.negtranspose(y)); }
    return new numeric.T(t(x));
}
numeric.Tunop = function Tunop(r,c,s) {
    if(typeof s !== "string") { s = ''; }
    return Function(
            'var x = this;\n'+
            s+'\n'+
            'if(x.y) {'+
            '  '+c+';\n'+
            '}\n'+
            r+';\n'
    );
}

numeric.T.prototype.exp = numeric.Tunop(
        'return new numeric.T(ex)',
        'return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))',
        'var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;');
numeric.T.prototype.conj = numeric.Tunop(
        'return new numeric.T(x.x);',
        'return new numeric.T(x.x,numeric.neg(x.y));');
numeric.T.prototype.neg = numeric.Tunop(
        'return new numeric.T(neg(x.x));',
        'return new numeric.T(neg(x.x),neg(x.y));',
        'var neg = numeric.neg;');
numeric.T.prototype.sin = numeric.Tunop(
        'return new numeric.T(numeric.sin(x.x))',
        'return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));');
numeric.T.prototype.cos = numeric.Tunop(
        'return new numeric.T(numeric.cos(x.x))',
        'return x.exp().add(x.neg().exp()).div(2);');
numeric.T.prototype.abs = numeric.Tunop(
        'return new numeric.T(numeric.abs(x.x));',
        'return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));',
        'var mul = numeric.mul;');
numeric.T.prototype.log = numeric.Tunop(
        'return new numeric.T(numeric.log(x.x));',
        'var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\n'+
        'return new numeric.T(numeric.log(r.x),theta.x);');
numeric.T.prototype.norm2 = numeric.Tunop(
        'return numeric.norm2(x.x);',
        'var f = numeric.norm2Squared;\n'+
        'return Math.sqrt(f(x.x)+f(x.y));');
numeric.T.prototype.inv = function inv() {
    var A = this;
    if(typeof A.y === "undefined") { return new numeric.T(numeric.inv(A.x)); }
    var n = A.x.length, i, j, k;
    var Rx = numeric.identity(n),Ry = numeric.rep([n,n],0);
    var Ax = numeric.clone(A.x), Ay = numeric.clone(A.y);
    var Aix, Aiy, Ajx, Ajy, Rix, Riy, Rjx, Rjy;
    var i,j,k,d,d1,ax,ay,bx,by,temp;
    for(i=0;i<n;i++) {
        ax = Ax[i][i]; ay = Ay[i][i];
        d = ax*ax+ay*ay;
        k = i;
        for(j=i+1;j<n;j++) {
            ax = Ax[j][i]; ay = Ay[j][i];
            d1 = ax*ax+ay*ay;
            if(d1 > d) { k=j; d = d1; }
        }
        if(k!==i) {
            temp = Ax[i]; Ax[i] = Ax[k]; Ax[k] = temp;
            temp = Ay[i]; Ay[i] = Ay[k]; Ay[k] = temp;
            temp = Rx[i]; Rx[i] = Rx[k]; Rx[k] = temp;
            temp = Ry[i]; Ry[i] = Ry[k]; Ry[k] = temp;
        }
        Aix = Ax[i]; Aiy = Ay[i];
        Rix = Rx[i]; Riy = Ry[i];
        ax = Aix[i]; ay = Aiy[i];
        for(j=i+1;j<n;j++) {
            bx = Aix[j]; by = Aiy[j];
            Aix[j] = (bx*ax+by*ay)/d;
            Aiy[j] = (by*ax-bx*ay)/d;
        }
        for(j=0;j<n;j++) {
            bx = Rix[j]; by = Riy[j];
            Rix[j] = (bx*ax+by*ay)/d;
            Riy[j] = (by*ax-bx*ay)/d;
        }
        for(j=i+1;j<n;j++) {
            Ajx = Ax[j]; Ajy = Ay[j];
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ajx[i]; ay = Ajy[i];
            for(k=i+1;k<n;k++) {
                bx = Aix[k]; by = Aiy[k];
                Ajx[k] -= bx*ax-by*ay;
                Ajy[k] -= by*ax+bx*ay;
            }
            for(k=0;k<n;k++) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= bx*ax-by*ay;
                Rjy[k] -= by*ax+bx*ay;
            }
        }
    }
    for(i=n-1;i>0;i--) {
        Rix = Rx[i]; Riy = Ry[i];
        for(j=i-1;j>=0;j--) {
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ax[j][i]; ay = Ay[j][i];
            for(k=n-1;k>=0;k--) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= ax*bx - ay*by;
                Rjy[k] -= ax*by + ay*bx;
            }
        }
    }
    return new numeric.T(Rx,Ry);
}
numeric.T.prototype.get = function get(i) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length;
    if(y) {
        while(k<n) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        return new numeric.T(x,y);
    }
    while(k<n) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    return new numeric.T(x);
}
numeric.T.prototype.set = function set(i,v) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length, vx = v.x, vy = v.y;
    if(n===0) {
        if(vy) { this.y = vy; }
        else if(y) { this.y = undefined; }
        this.x = x;
        return this;
    }
    if(vy) {
        if(y) { /* ok */ }
        else {
            y = numeric.rep(numeric.dim(x),0);
            this.y = y;
        }
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        y[ik] = vy;
        return this;
    }
    if(y) {
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        if(vx instanceof Array) y[ik] = numeric.rep(numeric.dim(vx),0);
        else y[ik] = 0;
        return this;
    }
    while(k<n-1) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    ik = i[k];
    x[ik] = vx;
    return this;
}
numeric.T.prototype.getRows = function getRows(i0,i1) {
    var n = i1-i0+1, j;
    var rx = Array(n), ry, x = this.x, y = this.y;
    for(j=i0;j<=i1;j++) { rx[j-i0] = x[j]; }
    if(y) {
        ry = Array(n);
        for(j=i0;j<=i1;j++) { ry[j-i0] = y[j]; }
        return new numeric.T(rx,ry);
    }
    return new numeric.T(rx);
}
numeric.T.prototype.setRows = function setRows(i0,i1,A) {
    var j;
    var rx = this.x, ry = this.y, x = A.x, y = A.y;
    for(j=i0;j<=i1;j++) { rx[j] = x[j-i0]; }
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        for(j=i0;j<=i1;j++) { ry[j] = y[j-i0]; }
    } else if(ry) {
        for(j=i0;j<=i1;j++) { ry[j] = numeric.rep([x[j-i0].length],0); }
    }
    return this;
}
numeric.T.prototype.getRow = function getRow(k) {
    var x = this.x, y = this.y;
    if(y) { return new numeric.T(x[k],y[k]); }
    return new numeric.T(x[k]);
}
numeric.T.prototype.setRow = function setRow(i,v) {
    var rx = this.x, ry = this.y, x = v.x, y = v.y;
    rx[i] = x;
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        ry[i] = y;
    } else if(ry) {
        ry = numeric.rep([x.length],0);
    }
    return this;
}

numeric.T.prototype.getBlock = function getBlock(from,to) {
    var x = this.x, y = this.y, b = numeric.getBlock;
    if(y) { return new numeric.T(b(x,from,to),b(y,from,to)); }
    return new numeric.T(b(x,from,to));
}
numeric.T.prototype.setBlock = function setBlock(from,to,A) {
    if(!(A instanceof numeric.T)) A = new numeric.T(A);
    var x = this.x, y = this.y, b = numeric.setBlock, Ax = A.x, Ay = A.y;
    if(Ay) {
        if(!y) { this.y = numeric.rep(numeric.dim(this),0); y = this.y; }
        b(x,from,to,Ax);
        b(y,from,to,Ay);
        return this;
    }
    b(x,from,to,Ax);
    if(y) b(y,from,to,numeric.rep(numeric.dim(Ax),0));
}
numeric.T.rep = function rep(s,v) {
    var T = numeric.T;
    if(!(v instanceof T)) v = new T(v);
    var x = v.x, y = v.y, r = numeric.rep;
    if(y) return new T(r(s,x),r(s,y));
    return new T(r(s,x));
}
numeric.T.diag = function diag(d) {
    if(!(d instanceof numeric.T)) d = new numeric.T(d);
    var x = d.x, y = d.y, diag = numeric.diag;
    if(y) return new numeric.T(diag(x),diag(y));
    return new numeric.T(diag(x));
}
numeric.T.eig = function eig() {
    if(this.y) { throw new Error('eig: not implemented for complex matrices.'); }
    return numeric.eig(this.x);
}
numeric.T.identity = function identity(n) { return new numeric.T(numeric.identity(n)); }
numeric.T.prototype.getDiag = function getDiag() {
    var n = numeric;
    var x = this.x, y = this.y;
    if(y) { return new n.T(n.getDiag(x),n.getDiag(y)); }
    return new n.T(n.getDiag(x));
}

// 4. Eigenvalues of real matrices

numeric.house = function house(x) {
    var v = numeric.clone(x);
    var s = x[0] >= 0 ? 1 : -1;
    var alpha = s*numeric.norm2(x);
    v[0] += alpha;
    var foo = numeric.norm2(v);
    if(foo === 0) { /* this should not happen */ throw new Error('eig: internal error'); }
    return numeric.div(v,foo);
}

numeric.toUpperHessenberg = function toUpperHessenberg(me) {
    var s = numeric.dim(me);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: toUpperHessenberg() only works on square matrices'); }
    var m = s[0], i,j,k,x,v,A = numeric.clone(me),B,C,Ai,Ci,Q = numeric.identity(m),Qi;
    for(j=0;j<m-2;j++) {
        x = Array(m-j-1);
        for(i=j+1;i<m;i++) { x[i-j-1] = A[i][j]; }
        if(numeric.norm2(x)>0) {
            v = numeric.house(x);
            B = numeric.getBlock(A,[j+1,j],[m-1,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Ai = A[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Ai[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(A,[0,j+1],[m-1,m-1]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Ai = A[i]; Ci = C[i]; for(k=j+1;k<m;k++) Ai[k] -= 2*Ci[k-j-1]; }
            B = Array(m-j-1);
            for(i=j+1;i<m;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    return {H:A, Q:Q};
}

numeric.epsilon = 2.220446049250313e-16;

numeric.QRFrancis = function(H,maxiter) {
    if(typeof maxiter === "undefined") { maxiter = 10000; }
    H = numeric.clone(H);
    var H0 = numeric.clone(H);
    var s = numeric.dim(H),m=s[0],x,v,a,b,c,d,det,tr, Hloc, Q = numeric.identity(m), Qi, Hi, B, C, Ci,i,j,k,iter;
    if(m<3) { return {Q:Q, B:[ [0,m-1] ]}; }
    var epsilon = numeric.epsilon;
    for(iter=0;iter<maxiter;iter++) {
        for(j=0;j<m-1;j++) {
            if(Math.abs(H[j+1][j]) < epsilon*(Math.abs(H[j][j])+Math.abs(H[j+1][j+1]))) {
                var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[j,j]),maxiter);
                var QH2 = numeric.QRFrancis(numeric.getBlock(H,[j+1,j+1],[m-1,m-1]),maxiter);
                B = Array(j+1);
                for(i=0;i<=j;i++) { B[i] = Q[i]; }
                C = numeric.dot(QH1.Q,B);
                for(i=0;i<=j;i++) { Q[i] = C[i]; }
                B = Array(m-j-1);
                for(i=j+1;i<m;i++) { B[i-j-1] = Q[i]; }
                C = numeric.dot(QH2.Q,B);
                for(i=j+1;i<m;i++) { Q[i] = C[i-j-1]; }
                return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,j+1))};
            }
        }
        a = H[m-2][m-2]; b = H[m-2][m-1];
        c = H[m-1][m-2]; d = H[m-1][m-1];
        tr = a+d;
        det = (a*d-b*c);
        Hloc = numeric.getBlock(H, [0,0], [2,2]);
        if(tr*tr>=4*det) {
            var s1,s2;
            s1 = 0.5*(tr+Math.sqrt(tr*tr-4*det));
            s2 = 0.5*(tr-Math.sqrt(tr*tr-4*det));
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,s1+s2)),
                               numeric.diag(numeric.rep([3],s1*s2)));
        } else {
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,tr)),
                               numeric.diag(numeric.rep([3],det)));
        }
        x = [Hloc[0][0],Hloc[1][0],Hloc[2][0]];
        v = numeric.house(x);
        B = [H[0],H[1],H[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<m;k++) Hi[k] -= 2*Ci[k]; }
        B = numeric.getBlock(H, [0,0],[m-1,2]);
        C = numeric.tensor(numeric.dot(B,v),v);
        for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<3;k++) Hi[k] -= 2*Ci[k]; }
        B = [Q[0],Q[1],Q[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Qi = Q[i]; Ci = C[i]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        var J;
        for(j=0;j<m-2;j++) {
            for(k=j;k<=j+1;k++) {
                if(Math.abs(H[k+1][k]) < epsilon*(Math.abs(H[k][k])+Math.abs(H[k+1][k+1]))) {
                    var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[k,k]),maxiter);
                    var QH2 = numeric.QRFrancis(numeric.getBlock(H,[k+1,k+1],[m-1,m-1]),maxiter);
                    B = Array(k+1);
                    for(i=0;i<=k;i++) { B[i] = Q[i]; }
                    C = numeric.dot(QH1.Q,B);
                    for(i=0;i<=k;i++) { Q[i] = C[i]; }
                    B = Array(m-k-1);
                    for(i=k+1;i<m;i++) { B[i-k-1] = Q[i]; }
                    C = numeric.dot(QH2.Q,B);
                    for(i=k+1;i<m;i++) { Q[i] = C[i-k-1]; }
                    return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,k+1))};
                }
            }
            J = Math.min(m-1,j+3);
            x = Array(J-j);
            for(i=j+1;i<=J;i++) { x[i-j-1] = H[i][j]; }
            v = numeric.house(x);
            B = numeric.getBlock(H, [j+1,j],[J,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Hi = H[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Hi[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(H, [0,j+1],[m-1,J]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=j+1;k<=J;k++) Hi[k] -= 2*Ci[k-j-1]; }
            B = Array(J-j);
            for(i=j+1;i<=J;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    throw new Error('numeric: eigenvalue iteration does not converge -- increase maxiter?');
}

numeric.eig = function eig(A,maxiter) {
    var QH = numeric.toUpperHessenberg(A);
    var QB = numeric.QRFrancis(QH.H,maxiter);
    var T = numeric.T;
    var n = A.length,i,k,flag = false,B = QB.B,H = numeric.dot(QB.Q,numeric.dot(QH.H,numeric.transpose(QB.Q)));
    var Q = new T(numeric.dot(QB.Q,QH.Q)),Q0;
    var m = B.length,j;
    var a,b,c,d,p1,p2,disc,x,y,p,q,n1,n2;
    var sqrt = Math.sqrt;
    for(k=0;k<m;k++) {
        i = B[k][0];
        if(i === B[k][1]) {
            // nothing
        } else {
            j = i+1;
            a = H[i][i];
            b = H[i][j];
            c = H[j][i];
            d = H[j][j];
            if(b === 0 && c === 0) continue;
            p1 = -a-d;
            p2 = a*d-b*c;
            disc = p1*p1-4*p2;
            if(disc>=0) {
                if(p1<0) x = -0.5*(p1-sqrt(disc));
                else     x = -0.5*(p1+sqrt(disc));
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1);
                    p = (a-x)/n1;
                    q = b/n1;
                } else {
                    n2 = sqrt(n2);
                    p = c/n2;
                    q = (d-x)/n2;
                }
                Q0 = new T([[q,-p],[p,q]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            } else {
                x = -0.5*p1;
                y = 0.5*sqrt(-disc);
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1+y*y);
                    p = (a-x)/n1;
                    q = b/n1;
                    x = 0;
                    y /= n1;
                } else {
                    n2 = sqrt(n2+y*y);
                    p = c/n2;
                    q = (d-x)/n2;
                    x = y/n2;
                    y = 0;
                }
                Q0 = new T([[q,-p],[p,q]],[[x,y],[y,-x]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            }
        }
    }
    var R = Q.dot(A).dot(Q.transjugate()), n = A.length, E = numeric.T.identity(n);
    for(j=0;j<n;j++) {
        if(j>0) {
            for(k=j-1;k>=0;k--) {
                var Rk = R.get([k,k]), Rj = R.get([j,j]);
                if(numeric.neq(Rk.x,Rj.x) || numeric.neq(Rk.y,Rj.y)) {
                    x = R.getRow(k).getBlock([k],[j-1]);
                    y = E.getRow(j).getBlock([k],[j-1]);
                    E.set([j,k],(R.get([k,j]).neg().sub(x.dot(y))).div(Rk.sub(Rj)));
                } else {
                    E.setRow(j,E.getRow(k));
                    continue;
                }
            }
        }
    }
    for(j=0;j<n;j++) {
        x = E.getRow(j);
        E.setRow(j,x.div(x.norm2()));
    }
    E = E.transpose();
    E = Q.transjugate().dot(E);
    return { lambda:R.getDiag(), E:E };
};

// 5. Compressed Column Storage matrices
numeric.ccsSparse = function ccsSparse(A) {
    var m = A.length,n,foo, i,j, counts = [];
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            j = parseInt(j);
            while(j>=counts.length) counts[counts.length] = 0;
            if(foo[j]!==0) counts[j]++;
        }
    }
    var n = counts.length;
    var Ai = Array(n+1);
    Ai[0] = 0;
    for(i=0;i<n;++i) Ai[i+1] = Ai[i] + counts[i];
    var Aj = Array(Ai[n]), Av = Array(Ai[n]);
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            if(foo[j]!==0) {
                counts[j]--;
                Aj[Ai[j]+counts[j]] = i;
                Av[Ai[j]+counts[j]] = foo[j];
            }
        }
    }
    return [Ai,Aj,Av];
}
numeric.ccsFull = function ccsFull(A) {
    var Ai = A[0], Aj = A[1], Av = A[2], s = numeric.ccsDim(A), m = s[0], n = s[1], i,j,j0,j1,k;
    var B = numeric.rep([m,n],0);
    for(i=0;i<n;i++) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j<j1;++j) { B[Aj[j]][i] = Av[j]; }
    }
    return B;
}
numeric.ccsTSolve = function ccsTSolve(A,b,x,bj,xj) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, max = Math.max,n=0;
    if(typeof bj === "undefined") x = numeric.rep([m],0);
    if(typeof bj === "undefined") bj = numeric.linspace(0,x.length-1);
    if(typeof xj === "undefined") xj = [];
    function dfs(j) {
        var k;
        if(x[j] !== 0) return;
        x[j] = 1;
        for(k=Ai[j];k<Ai[j+1];++k) dfs(Aj[k]);
        xj[n] = j;
        ++n;
    }
    var i,j,j0,j1,k,l,l0,l1,a;
    for(i=bj.length-1;i!==-1;--i) { dfs(bj[i]); }
    xj.length = n;
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=bj.length-1;i!==-1;--i) { j = bj[i]; x[j] = b[j]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = max(Ai[j+1],j0);
        for(k=j0;k!==j1;++k) { if(Aj[k] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k!==j1;++k) {
            l = Aj[k];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsDFS = function ccsDFS(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[J];
    k1[0] = k11 = Ai[J+1];
    while(1) {
        if(km >= k11) {
            xj[n] = j[m];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Pinv[Aj[km]];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve = function ccsLPSolve(A,B,x,xj,I,Pinv,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Pinv[Bj[i]],Ai,Aj,x,xj,Pinv); }
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=i0;i!==i1;++i) { j = Pinv[Bj[i]]; x[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Pinv[Aj[k]] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k<j1;++k) {
            l = Pinv[Aj[k]];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsLUP1 = function ccsLUP1(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var x = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,x,xj,i,Pinv,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(x[k]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(x[i])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
            a = x[i]; x[i] = x[e]; x[e] = a;
        }
        a = Li[i];
        e = Ui[i];
        d = x[i];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = x[k];
            xj[j] = 0;
            x[k] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsDFS0 = function ccsDFS0(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS0.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv,P) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[Pinv[J]];
    k1[0] = k11 = Ai[Pinv[J]+1];
    while(1) {
        if(isNaN(km)) throw new Error("Ow!");
        if(km >= k11) {
            xj[n] = Pinv[j[m]];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Aj[km];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                foo = Pinv[foo];
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve0 = function ccsLPSolve0(A,B,y,xj,I,Pinv,P,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Bj[i],Ai,Aj,y,xj,Pinv,P); }
    for(i=xj.length-1;i!==-1;--i) { j = xj[i]; y[P[j]] = 0; }
    for(i=i0;i!==i1;++i) { j = Bj[i]; y[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        l = P[j];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Aj[k] === l) { y[l] /= Av[k]; break; } }
        a = y[l];
        for(k=j0;k<j1;++k) y[Aj[k]] -= a*Av[k];
        y[l] = a;
    }
}
numeric.ccsLUP0 = function ccsLUP0(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var y = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve0, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS0(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,y,xj,i,Pinv,P,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(y[P[k]]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(y[P[i]])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
        }
        a = Li[i];
        e = Ui[i];
        d = y[P[i]];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = y[P[k]];
            xj[j] = 0;
            y[P[k]] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsLUP = numeric.ccsLUP0;

numeric.ccsDim = function ccsDim(A) { return [numeric.sup(A[1])+1,A[0].length-1]; }
numeric.ccsGetBlock = function ccsGetBlock(A,i,j) {
    var s = numeric.ccsDim(A),m=s[0],n=s[1];
    if(typeof i === "undefined") { i = numeric.linspace(0,m-1); }
    else if(typeof i === "number") { i = [i]; }
    if(typeof j === "undefined") { j = numeric.linspace(0,n-1); }
    else if(typeof j === "number") { j = [j]; }
    var p,p0,p1,P = i.length,q,Q = j.length,r,jq,ip;
    var Bi = numeric.rep([n],0), Bj=[], Bv=[], B = [Bi,Bj,Bv];
    var Ai = A[0], Aj = A[1], Av = A[2];
    var x = numeric.rep([m],0),count=0,flags = numeric.rep([m],0);
    for(q=0;q<Q;++q) {
        jq = j[q];
        var q0 = Ai[jq];
        var q1 = Ai[jq+1];
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 1;
            x[r] = Av[p];
        }
        for(p=0;p<P;++p) {
            ip = i[p];
            if(flags[ip]) {
                Bj[count] = p;
                Bv[count] = x[i[p]];
                ++count;
            }
        }
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 0;
        }
        Bi[q+1] = count;
    }
    return B;
}

numeric.ccsDot = function ccsDot(A,B) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var Bi = B[0], Bj = B[1], Bv = B[2];
    var sA = numeric.ccsDim(A), sB = numeric.ccsDim(B);
    var m = sA[0], n = sA[1], o = sB[1];
    var x = numeric.rep([m],0), flags = numeric.rep([m],0), xj = Array(m);
    var Ci = numeric.rep([o],0), Cj = [], Cv = [], C = [Ci,Cj,Cv];
    var i,j,k,j0,j1,i0,i1,l,p,a,b;
    for(k=0;k!==o;++k) {
        j0 = Bi[k];
        j1 = Bi[k+1];
        p = 0;
        for(j=j0;j<j1;++j) {
            a = Bj[j];
            b = Bv[j];
            i0 = Ai[a];
            i1 = Ai[a+1];
            for(i=i0;i<i1;++i) {
                l = Aj[i];
                if(flags[l]===0) {
                    xj[p] = l;
                    flags[l] = 1;
                    p = p+1;
                }
                x[l] = x[l] + Av[i]*b;
            }
        }
        j0 = Ci[k];
        j1 = j0+p;
        Ci[k+1] = j1;
        for(j=p-1;j!==-1;--j) {
            b = j0+j;
            i = xj[j];
            Cj[b] = i;
            Cv[b] = x[i];
            flags[i] = 0;
            x[i] = 0;
        }
        Ci[k+1] = Ci[k]+p;
    }
    return C;
}

numeric.ccsLUPSolve = function ccsLUPSolve(LUP,B) {
    var L = LUP.L, U = LUP.U, P = LUP.P;
    var Bi = B[0];
    var flag = false;
    if(typeof Bi !== "object") { B = [[0,B.length],numeric.linspace(0,B.length-1),B]; Bi = B[0]; flag = true; }
    var Bj = B[1], Bv = B[2];
    var n = L[0].length-1, m = Bi.length-1;
    var x = numeric.rep([n],0), xj = Array(n);
    var b = numeric.rep([n],0), bj = Array(n);
    var Xi = numeric.rep([m+1],0), Xj = [], Xv = [];
    var sol = numeric.ccsTSolve;
    var i,j,j0,j1,k,J,N=0;
    for(i=0;i<m;++i) {
        k = 0;
        j0 = Bi[i];
        j1 = Bi[i+1];
        for(j=j0;j<j1;++j) { 
            J = LUP.Pinv[Bj[j]];
            bj[k] = J;
            b[J] = Bv[j];
            ++k;
        }
        bj.length = k;
        sol(L,b,x,bj,xj);
        for(j=bj.length-1;j!==-1;--j) b[bj[j]] = 0;
        sol(U,x,b,xj,bj);
        if(flag) return b;
        for(j=xj.length-1;j!==-1;--j) x[xj[j]] = 0;
        for(j=bj.length-1;j!==-1;--j) {
            J = bj[j];
            Xj[N] = J;
            Xv[N] = b[J];
            b[J] = 0;
            ++N;
        }
        Xi[i+1] = N;
    }
    return [Xi,Xj,Xv];
}

numeric.ccsbinop = function ccsbinop(body,setup) {
    if(typeof setup === "undefined") setup='';
    return Function('X','Y',
            'var Xi = X[0], Xj = X[1], Xv = X[2];\n'+
            'var Yi = Y[0], Yj = Y[1], Yv = Y[2];\n'+
            'var n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;\n'+
            'var Zi = numeric.rep([n+1],0), Zj = [], Zv = [];\n'+
            'var x = numeric.rep([m],0),y = numeric.rep([m],0);\n'+
            'var xk,yk,zk;\n'+
            'var i,j,j0,j1,k,p=0;\n'+
            setup+
            'for(i=0;i<n;++i) {\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Xj[j];\n'+
            '    x[k] = 1;\n'+
            '    Zj[p] = k;\n'+
            '    ++p;\n'+
            '  }\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Yj[j];\n'+
            '    y[k] = Yv[j];\n'+
            '    if(x[k] === 0) {\n'+
            '      Zj[p] = k;\n'+
            '      ++p;\n'+
            '    }\n'+
            '  }\n'+
            '  Zi[i+1] = p;\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];\n'+
            '  j0 = Zi[i]; j1 = Zi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Zj[j];\n'+
            '    xk = x[k];\n'+
            '    yk = y[k];\n'+
            body+'\n'+
            '    Zv[j] = zk;\n'+
            '  }\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;\n'+
            '}\n'+
            'return [Zi,Zj,Zv];'
            );
};

(function() {
    var k,A,B,C;
    for(k in numeric.ops2) {
        if(isFinite(eval('1'+numeric.ops2[k]+'0'))) A = '[Y[0],Y[1],numeric.'+k+'(X,Y[2])]';
        else A = 'NaN';
        if(isFinite(eval('0'+numeric.ops2[k]+'1'))) B = '[X[0],X[1],numeric.'+k+'(X[2],Y)]';
        else B = 'NaN';
        if(isFinite(eval('1'+numeric.ops2[k]+'0')) && isFinite(eval('0'+numeric.ops2[k]+'1'))) C = 'numeric.ccs'+k+'MM(X,Y)';
        else C = 'NaN';
        numeric['ccs'+k+'MM'] = numeric.ccsbinop('zk = xk '+numeric.ops2[k]+'yk;');
        numeric['ccs'+k] = Function('X','Y',
                'if(typeof X === "number") return '+A+';\n'+
                'if(typeof Y === "number") return '+B+';\n'+
                'return '+C+';\n'
                );
    }
}());

numeric.ccsScatter = function ccsScatter(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = numeric.sup(Aj)+1,m=Ai.length;
    var Ri = numeric.rep([n],0),Rj=Array(m), Rv = Array(m);
    var counts = numeric.rep([n],0),i;
    for(i=0;i<m;++i) counts[Aj[i]]++;
    for(i=0;i<n;++i) Ri[i+1] = Ri[i] + counts[i];
    var ptr = Ri.slice(0),k,Aii;
    for(i=0;i<m;++i) {
        Aii = Aj[i];
        k = ptr[Aii];
        Rj[k] = Ai[i];
        Rv[k] = Av[i];
        ptr[Aii]=ptr[Aii]+1;
    }
    return [Ri,Rj,Rv];
}

numeric.ccsGather = function ccsGather(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = Ai.length-1,m = Aj.length;
    var Ri = Array(m), Rj = Array(m), Rv = Array(m);
    var i,j,j0,j1,p;
    p=0;
    for(i=0;i<n;++i) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j!==j1;++j) {
            Rj[p] = i;
            Ri[p] = Aj[j];
            Rv[p] = Av[j];
            ++p;
        }
    }
    return [Ri,Rj,Rv];
}

// The following sparse linear algebra routines are deprecated.

numeric.sdim = function dim(A,ret,k) {
    if(typeof ret === "undefined") { ret = []; }
    if(typeof A !== "object") return ret;
    if(typeof k === "undefined") { k=0; }
    if(!(k in ret)) { ret[k] = 0; }
    if(A.length > ret[k]) ret[k] = A.length;
    var i;
    for(i in A) {
        if(A.hasOwnProperty(i)) dim(A[i],ret,k+1);
    }
    return ret;
};

numeric.sclone = function clone(A,k,n) {
    if(typeof k === "undefined") { k=0; }
    if(typeof n === "undefined") { n = numeric.sdim(A).length; }
    var i,ret = Array(A.length);
    if(k === n-1) {
        for(i in A) { if(A.hasOwnProperty(i)) ret[i] = A[i]; }
        return ret;
    }
    for(i in A) {
        if(A.hasOwnProperty(i)) ret[i] = clone(A[i],k+1,n);
    }
    return ret;
}

numeric.sdiag = function diag(d) {
    var n = d.length,i,ret = Array(n),i1,i2,i3;
    for(i=n-1;i>=1;i-=2) {
        i1 = i-1;
        ret[i] = []; ret[i][i] = d[i];
        ret[i1] = []; ret[i1][i1] = d[i1];
    }
    if(i===0) { ret[0] = []; ret[0][0] = d[i]; }
    return ret;
}

numeric.sidentity = function identity(n) { return numeric.sdiag(numeric.rep([n],1)); }

numeric.stranspose = function transpose(A) {
    var ret = [], n = A.length, i,j,Ai;
    for(i in A) {
        if(!(A.hasOwnProperty(i))) continue;
        Ai = A[i];
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(typeof ret[j] !== "object") { ret[j] = []; }
            ret[j][i] = Ai[j];
        }
    }
    return ret;
}

numeric.sLUP = function LUP(A,tol) {
    throw new Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.");
};

numeric.sdotMM = function dotMM(A,B) {
    var p = A.length, q = B.length, BT = numeric.stranspose(B), r = BT.length, Ai, BTk;
    var i,j,k,accum;
    var ret = Array(p),reti;
    for(i=p-1;i>=0;i--) {
        reti = [];
        Ai = A[i];
        for(k=r-1;k>=0;k--) {
            accum = 0;
            BTk = BT[k];
            for(j in Ai) {
                if(!(Ai.hasOwnProperty(j))) continue;
                if(j in BTk) { accum += Ai[j]*BTk[j]; }
            }
            if(accum) reti[k] = accum;
        }
        ret[i] = reti;
    }
    return ret;
}

numeric.sdotMV = function dotMV(A,x) {
    var p = A.length, Ai, i,j;
    var ret = Array(p), accum;
    for(i=p-1;i>=0;i--) {
        Ai = A[i];
        accum = 0;
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(x[j]) accum += Ai[j]*x[j];
        }
        if(accum) ret[i] = accum;
    }
    return ret;
}

numeric.sdotVM = function dotMV(x,A) {
    var i,j,Ai,alpha;
    var ret = [], accum;
    for(i in x) {
        if(!x.hasOwnProperty(i)) continue;
        Ai = A[i];
        alpha = x[i];
        for(j in Ai) {
            if(!Ai.hasOwnProperty(j)) continue;
            if(!ret[j]) { ret[j] = 0; }
            ret[j] += alpha*Ai[j];
        }
    }
    return ret;
}

numeric.sdotVV = function dotVV(x,y) {
    var i,ret=0;
    for(i in x) { if(x[i] && y[i]) ret+= x[i]*y[i]; }
    return ret;
}

numeric.sdot = function dot(A,B) {
    var m = numeric.sdim(A).length, n = numeric.sdim(B).length;
    var k = m*1000+n;
    switch(k) {
    case 0: return A*B;
    case 1001: return numeric.sdotVV(A,B);
    case 2001: return numeric.sdotMV(A,B);
    case 1002: return numeric.sdotVM(A,B);
    case 2002: return numeric.sdotMM(A,B);
    default: throw new Error('numeric.sdot not implemented for tensors of order '+m+' and '+n);
    }
}

numeric.sscatter = function scatter(V) {
    var n = V[0].length, Vij, i, j, m = V.length, A = [], Aj;
    for(i=n-1;i>=0;--i) {
        if(!V[m-1][i]) continue;
        Aj = A;
        for(j=0;j<m-2;j++) {
            Vij = V[j][i];
            if(!Aj[Vij]) Aj[Vij] = [];
            Aj = Aj[Vij];
        }
        Aj[V[j][i]] = V[j+1][i];
    }
    return A;
}

numeric.sgather = function gather(A,ret,k) {
    if(typeof ret === "undefined") ret = [];
    if(typeof k === "undefined") k = [];
    var n,i,Ai;
    n = k.length;
    for(i in A) {
        if(A.hasOwnProperty(i)) {
            k[n] = parseInt(i);
            Ai = A[i];
            if(typeof Ai === "number") {
                if(Ai) {
                    if(ret.length === 0) {
                        for(i=n+1;i>=0;--i) ret[i] = [];
                    }
                    for(i=n;i>=0;--i) ret[i].push(k[i]);
                    ret[n+1].push(Ai);
                }
            } else gather(Ai,ret,k);
        }
    }
    if(k.length>n) k.pop();
    return ret;
}

// 6. Coordinate matrices
numeric.cLU = function LU(A) {
    var I = A[0], J = A[1], V = A[2];
    var p = I.length, m=0, i,j,k,a,b,c;
    for(i=0;i<p;i++) if(I[i]>m) m=I[i];
    m++;
    var L = Array(m), U = Array(m), left = numeric.rep([m],Infinity), right = numeric.rep([m],-Infinity);
    var Ui, Uj,alpha;
    for(k=0;k<p;k++) {
        i = I[k];
        j = J[k];
        if(j<left[i]) left[i] = j;
        if(j>right[i]) right[i] = j;
    }
    for(i=0;i<m-1;i++) { if(right[i] > right[i+1]) right[i+1] = right[i]; }
    for(i=m-1;i>=1;i--) { if(left[i]<left[i-1]) left[i-1] = left[i]; }
    var countL = 0, countU = 0;
    for(i=0;i<m;i++) {
        U[i] = numeric.rep([right[i]-left[i]+1],0);
        L[i] = numeric.rep([i-left[i]],0);
        countL += i-left[i]+1;
        countU += right[i]-i+1;
    }
    for(k=0;k<p;k++) { i = I[k]; U[i][J[k]-left[i]] = V[k]; }
    for(i=0;i<m-1;i++) {
        a = i-left[i];
        Ui = U[i];
        for(j=i+1;left[j]<=i && j<m;j++) {
            b = i-left[j];
            c = right[i]-i;
            Uj = U[j];
            alpha = Uj[b]/Ui[a];
            if(alpha) {
                for(k=1;k<=c;k++) { Uj[k+b] -= alpha*Ui[k+a]; }
                L[j][i-left[j]] = alpha;
            }
        }
    }
    var Ui = [], Uj = [], Uv = [], Li = [], Lj = [], Lv = [];
    var p,q,foo;
    p=0; q=0;
    for(i=0;i<m;i++) {
        a = left[i];
        b = right[i];
        foo = U[i];
        for(j=i;j<=b;j++) {
            if(foo[j-a]) {
                Ui[p] = i;
                Uj[p] = j;
                Uv[p] = foo[j-a];
                p++;
            }
        }
        foo = L[i];
        for(j=a;j<i;j++) {
            if(foo[j-a]) {
                Li[q] = i;
                Lj[q] = j;
                Lv[q] = foo[j-a];
                q++;
            }
        }
        Li[q] = i;
        Lj[q] = i;
        Lv[q] = 1;
        q++;
    }
    return {U:[Ui,Uj,Uv], L:[Li,Lj,Lv]};
};

numeric.cLUsolve = function LUsolve(lu,b) {
    var L = lu.L, U = lu.U, ret = numeric.clone(b);
    var Li = L[0], Lj = L[1], Lv = L[2];
    var Ui = U[0], Uj = U[1], Uv = U[2];
    var p = Ui.length, q = Li.length;
    var m = ret.length,i,j,k;
    k = 0;
    for(i=0;i<m;i++) {
        while(Lj[k] < i) {
            ret[i] -= Lv[k]*ret[Lj[k]];
            k++;
        }
        k++;
    }
    k = p-1;
    for(i=m-1;i>=0;i--) {
        while(Uj[k] > i) {
            ret[i] -= Uv[k]*ret[Uj[k]];
            k--;
        }
        ret[i] /= Uv[k];
        k--;
    }
    return ret;
};

numeric.cgrid = function grid(n,shape) {
    if(typeof n === "number") n = [n,n];
    var ret = numeric.rep(n,-1);
    var i,j,count;
    if(typeof shape !== "function") {
        switch(shape) {
        case 'L':
            shape = function(i,j) { return (i>=n[0]/2 || j<n[1]/2); }
            break;
        default:
            shape = function(i,j) { return true; };
            break;
        }
    }
    count=0;
    for(i=1;i<n[0]-1;i++) for(j=1;j<n[1]-1;j++) 
        if(shape(i,j)) {
            ret[i][j] = count;
            count++;
        }
    return ret;
}

numeric.cdelsq = function delsq(g) {
    var dir = [[-1,0],[0,-1],[0,1],[1,0]];
    var s = numeric.dim(g), m = s[0], n = s[1], i,j,k,p,q;
    var Li = [], Lj = [], Lv = [];
    for(i=1;i<m-1;i++) for(j=1;j<n-1;j++) {
        if(g[i][j]<0) continue;
        for(k=0;k<4;k++) {
            p = i+dir[k][0];
            q = j+dir[k][1];
            if(g[p][q]<0) continue;
            Li.push(g[i][j]);
            Lj.push(g[p][q]);
            Lv.push(-1);
        }
        Li.push(g[i][j]);
        Lj.push(g[i][j]);
        Lv.push(4);
    }
    return [Li,Lj,Lv];
}

numeric.cdotMV = function dotMV(A,x) {
    var ret, Ai = A[0], Aj = A[1], Av = A[2],k,p=Ai.length,N;
    N=0;
    for(k=0;k<p;k++) { if(Ai[k]>N) N = Ai[k]; }
    N++;
    ret = numeric.rep([N],0);
    for(k=0;k<p;k++) { ret[Ai[k]]+=Av[k]*x[Aj[k]]; }
    return ret;
}

// 7. Splines

numeric.Spline = function Spline(x,yl,yr,kl,kr) { this.x = x; this.yl = yl; this.yr = yr; this.kl = kl; this.kr = kr; }
numeric.Spline.prototype._at = function _at(x1,p) {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var x1,a,b,t;
    var add = numeric.add, sub = numeric.sub, mul = numeric.mul;
    a = sub(mul(kl[p],x[p+1]-x[p]),sub(yr[p+1],yl[p]));
    b = add(mul(kr[p+1],x[p]-x[p+1]),sub(yr[p+1],yl[p]));
    t = (x1-x[p])/(x[p+1]-x[p]);
    var s = t*(1-t);
    return add(add(add(mul(1-t,yl[p]),mul(t,yr[p+1])),mul(a,s*(1-t))),mul(b,s*t));
}
numeric.Spline.prototype.at = function at(x0) {
    if(typeof x0 === "number") {
        var x = this.x;
        var n = x.length;
        var p,q,mid,floor = Math.floor,a,b,t;
        p = 0;
        q = n-1;
        while(q-p>1) {
            mid = floor((p+q)/2);
            if(x[mid] <= x0) p = mid;
            else q = mid;
        }
        return this._at(x0,p);
    }
    var n = x0.length, i, ret = Array(n);
    for(i=n-1;i!==-1;--i) ret[i] = this.at(x0[i]);
    return ret;
}
numeric.Spline.prototype.diff = function diff() {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var n = yl.length;
    var i,dx,dy;
    var zl = kl, zr = kr, pl = Array(n), pr = Array(n);
    var add = numeric.add, mul = numeric.mul, div = numeric.div, sub = numeric.sub;
    for(i=n-1;i!==-1;--i) {
        dx = x[i+1]-x[i];
        dy = sub(yr[i+1],yl[i]);
        pl[i] = div(add(mul(dy, 6),mul(kl[i],-4*dx),mul(kr[i+1],-2*dx)),dx*dx);
        pr[i+1] = div(add(mul(dy,-6),mul(kl[i], 2*dx),mul(kr[i+1], 4*dx)),dx*dx);
    }
    return new numeric.Spline(x,zl,zr,pl,pr);
}
numeric.Spline.prototype.roots = function roots() {
    function sqr(x) { return x*x; }
    function heval(y0,y1,k0,k1,x) {
        var A = k0*2-(y1-y0);
        var B = -k1*2+(y1-y0);
        var t = (x+1)*0.5;
        var s = t*(1-t);
        return (1-t)*y0+t*y1+A*s*(1-t)+B*s*t;
    }
    var ret = [];
    var x = this.x, yl = this.yl, yr = this.yr, kl = this.kl, kr = this.kr;
    if(typeof yl[0] === "number") {
        yl = [yl];
        yr = [yr];
        kl = [kl];
        kr = [kr];
    }
    var m = yl.length,n=x.length-1,i,j,k,y,s,t;
    var ai,bi,ci,di, ret = Array(m),ri,k0,k1,y0,y1,A,B,D,dx,cx,stops,z0,z1,zm,t0,t1,tm;
    var sqrt = Math.sqrt;
    for(i=0;i!==m;++i) {
        ai = yl[i];
        bi = yr[i];
        ci = kl[i];
        di = kr[i];
        ri = [];
        for(j=0;j!==n;j++) {
            if(j>0 && bi[j]*ai[j]<0) ri.push(x[j]);
            dx = (x[j+1]-x[j]);
            cx = x[j];
            y0 = ai[j];
            y1 = bi[j+1];
            k0 = ci[j]/dx;
            k1 = di[j+1]/dx;
            D = sqr(k0-k1+3*(y0-y1)) + 12*k1*y0;
            A = k1+3*y0+2*k0-3*y1;
            B = 3*(k1+k0+2*(y0-y1));
            if(D<=0) {
                z0 = A/B;
                if(z0>x[j] && z0<x[j+1]) stops = [x[j],z0,x[j+1]];
                else stops = [x[j],x[j+1]];
            } else {
                z0 = (A-sqrt(D))/B;
                z1 = (A+sqrt(D))/B;
                stops = [x[j]];
                if(z0>x[j] && z0<x[j+1]) stops.push(z0);
                if(z1>x[j] && z1<x[j+1]) stops.push(z1);
                stops.push(x[j+1]);
            }
            t0 = stops[0];
            z0 = this._at(t0,j);
            for(k=0;k<stops.length-1;k++) {
                t1 = stops[k+1];
                z1 = this._at(t1,j);
                if(z0 === 0) {
                    ri.push(t0); 
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                if(z1 === 0 || z0*z1>0) {
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                var side = 0;
                while(1) {
                    tm = (z0*t1-z1*t0)/(z0-z1);
                    if(tm <= t0 || tm >= t1) { break; }
                    zm = this._at(tm,j);
                    if(zm*z1>0) {
                        t1 = tm;
                        z1 = zm;
                        if(side === -1) z0*=0.5;
                        side = -1;
                    } else if(zm*z0>0) {
                        t0 = tm;
                        z0 = zm;
                        if(side === 1) z1*=0.5;
                        side = 1;
                    } else break;
                }
                ri.push(tm);
                t0 = stops[k+1];
                z0 = this._at(t0, j);
            }
            if(z1 === 0) ri.push(t1);
        }
        ret[i] = ri;
    }
    if(typeof this.yl[0] === "number") return ret[0];
    return ret;
}
numeric.spline = function spline(x,y,k1,kn) {
    var n = x.length, b = [], dx = [], dy = [];
    var i;
    var sub = numeric.sub,mul = numeric.mul,add = numeric.add;
    for(i=n-2;i>=0;i--) { dx[i] = x[i+1]-x[i]; dy[i] = sub(y[i+1],y[i]); }
    if(typeof k1 === "string" || typeof kn === "string") { 
        k1 = kn = "periodic";
    }
    // Build sparse tridiagonal system
    var T = [[],[],[]];
    switch(typeof k1) {
    case "undefined":
        b[0] = mul(3/(dx[0]*dx[0]),dy[0]);
        T[0].push(0,0);
        T[1].push(0,1);
        T[2].push(2/dx[0],1/dx[0]);
        break;
    case "string":
        b[0] = add(mul(3/(dx[n-2]*dx[n-2]),dy[n-2]),mul(3/(dx[0]*dx[0]),dy[0]));
        T[0].push(0,0,0);
        T[1].push(n-2,0,1);
        T[2].push(1/dx[n-2],2/dx[n-2]+2/dx[0],1/dx[0]);
        break;
    default:
        b[0] = k1;
        T[0].push(0);
        T[1].push(0);
        T[2].push(1);
        break;
    }
    for(i=1;i<n-1;i++) {
        b[i] = add(mul(3/(dx[i-1]*dx[i-1]),dy[i-1]),mul(3/(dx[i]*dx[i]),dy[i]));
        T[0].push(i,i,i);
        T[1].push(i-1,i,i+1);
        T[2].push(1/dx[i-1],2/dx[i-1]+2/dx[i],1/dx[i]);
    }
    switch(typeof kn) {
    case "undefined":
        b[n-1] = mul(3/(dx[n-2]*dx[n-2]),dy[n-2]);
        T[0].push(n-1,n-1);
        T[1].push(n-2,n-1);
        T[2].push(1/dx[n-2],2/dx[n-2]);
        break;
    case "string":
        T[1][T[1].length-1] = 0;
        break;
    default:
        b[n-1] = kn;
        T[0].push(n-1);
        T[1].push(n-1);
        T[2].push(1);
        break;
    }
    if(typeof b[0] !== "number") b = numeric.transpose(b);
    else b = [b];
    var k = Array(b.length);
    if(typeof k1 === "string") {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.ccsLUPSolve(numeric.ccsLUP(numeric.ccsScatter(T)),b[i]);
            k[i][n-1] = k[i][0];
        }
    } else {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.cLUsolve(numeric.cLU(T),b[i]);
        }
    }
    if(typeof y[0] === "number") k = k[0];
    else k = numeric.transpose(k);
    return new numeric.Spline(x,y,y,k,k);
}

// 8. FFT
numeric.fftpow2 = function fftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    fftpow2(xe,ye);
    fftpow2(xo,yo);
    j = n/2;
    var t,k = (-6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric._ifftpow2 = function _ifftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    _ifftpow2(xe,ye);
    _ifftpow2(xo,yo);
    j = n/2;
    var t,k = (6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric.ifftpow2 = function ifftpow2(x,y) {
    numeric._ifftpow2(x,y);
    numeric.diveq(x,x.length);
    numeric.diveq(y,y.length);
}
numeric.convpow2 = function convpow2(ax,ay,bx,by) {
    numeric.fftpow2(ax,ay);
    numeric.fftpow2(bx,by);
    var i,n = ax.length,axi,bxi,ayi,byi;
    for(i=n-1;i!==-1;--i) {
        axi = ax[i]; ayi = ay[i]; bxi = bx[i]; byi = by[i];
        ax[i] = axi*bxi-ayi*byi;
        ay[i] = axi*byi+ayi*bxi;
    }
    numeric.ifftpow2(ax,ay);
}
numeric.T.prototype.fft = function fft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (-3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X;
}
numeric.T.prototype.ifft = function ifft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X.div(n);
}

//9. Unconstrained optimization
numeric.gradient = function gradient(f,x) {
    var n = x.length;
    var f0 = f(x);
    if(isNaN(f0)) throw new Error('gradient: f(x) is a NaN!');
    var max = Math.max;
    var i,x0 = numeric.clone(x),f1,f2, J = Array(n);
    var div = numeric.div, sub = numeric.sub,errest,roundoff,max = Math.max,eps = 1e-3,abs = Math.abs, min = Math.min;
    var t0,t1,t2,it=0,d1,d2,N;
    for(i=0;i<n;i++) {
        var h = max(1e-6*f0,1e-8);
        while(1) {
            ++it;
            if(it>20) { throw new Error("Numerical gradient fails"); }
            x0[i] = x[i]+h;
            f1 = f(x0);
            x0[i] = x[i]-h;
            f2 = f(x0);
            x0[i] = x[i];
            if(isNaN(f1) || isNaN(f2)) { h/=16; continue; }
            J[i] = (f1-f2)/(2*h);
            t0 = x[i]-h;
            t1 = x[i];
            t2 = x[i]+h;
            d1 = (f1-f0)/h;
            d2 = (f0-f2)/h;
            N = max(abs(J[i]),abs(f0),abs(f1),abs(f2),abs(t0),abs(t1),abs(t2),1e-8);
            errest = min(max(abs(d1-J[i]),abs(d2-J[i]),abs(d1-d2))/N,h/N);
            if(errest>eps) { h/=16; }
            else break;
            }
    }
    return J;
}

numeric.uncmin = function uncmin(f,x0,tol,gradient,maxit,callback,options) {
    var grad = numeric.gradient;
    if(typeof options === "undefined") { options = {}; }
    if(typeof tol === "undefined") { tol = 1e-8; }
    if(typeof gradient === "undefined") { gradient = function(x) { return grad(f,x); }; }
    if(typeof maxit === "undefined") maxit = 1000;
    x0 = numeric.clone(x0);
    var n = x0.length;
    var f0 = f(x0),f1,df0;
    if(isNaN(f0)) throw new Error('uncmin: f(x0) is a NaN!');
    var max = Math.max, norm2 = numeric.norm2;
    tol = max(tol,numeric.epsilon);
    var step,g0,g1,H1 = options.Hinv || numeric.identity(n);
    var dot = numeric.dot, inv = numeric.inv, sub = numeric.sub, add = numeric.add, ten = numeric.tensor, div = numeric.div, mul = numeric.mul;
    var all = numeric.all, isfinite = numeric.isFinite, neg = numeric.neg;
    var it=0,i,s,x1,y,Hy,Hs,ys,i0,t,nstep,t1,t2;
    var msg = "";
    g0 = gradient(x0);
    while(it<maxit) {
        if(typeof callback === "function") { if(callback(it,x0,f0,g0,H1)) { msg = "Callback returned true"; break; } }
        if(!all(isfinite(g0))) { msg = "Gradient has Infinity or NaN"; break; }
        step = neg(dot(H1,g0));
        if(!all(isfinite(step))) { msg = "Search direction has Infinity or NaN"; break; }
        nstep = norm2(step);
        if(nstep < tol) { msg="Newton step smaller than tol"; break; }
        t = 1;
        df0 = dot(g0,step);
        // line search
        x1 = x0;
        while(it < maxit) {
            if(t*nstep < tol) { break; }
            s = mul(step,t);
            x1 = add(x0,s);
            f1 = f(x1);
            if(f1-f0 >= 0.1*t*df0 || isNaN(f1)) {
                t *= 0.5;
                ++it;
                continue;
            }
            break;
        }
        if(t*nstep < tol) { msg = "Line search step size smaller than tol"; break; }
        if(it === maxit) { msg = "maxit reached during line search"; break; }
        g1 = gradient(x1);
        y = sub(g1,g0);
        ys = dot(y,s);
        Hy = dot(H1,y);
        H1 = sub(add(H1,
                mul(
                        (ys+dot(y,Hy))/(ys*ys),
                        ten(s,s)    )),
                div(add(ten(Hy,s),ten(s,Hy)),ys));
        x0 = x1;
        f0 = f1;
        g0 = g1;
        ++it;
    }
    return {solution: x0, f: f0, gradient: g0, invHessian: H1, iterations:it, message: msg};
}

// 10. Ode solver (Dormand-Prince)
numeric.Dopri = function Dopri(x,y,f,ymid,iterations,msg,events) {
    this.x = x;
    this.y = y;
    this.f = f;
    this.ymid = ymid;
    this.iterations = iterations;
    this.events = events;
    this.message = msg;
}
numeric.Dopri.prototype._at = function _at(xi,j) {
    function sqr(x) { return x*x; }
    var sol = this;
    var xs = sol.x;
    var ys = sol.y;
    var k1 = sol.f;
    var ymid = sol.ymid;
    var n = xs.length;
    var x0,x1,xh,y0,y1,yh,xi;
    var floor = Math.floor,h;
    var c = 0.5;
    var add = numeric.add, mul = numeric.mul,sub = numeric.sub, p,q,w;
    x0 = xs[j];
    x1 = xs[j+1];
    y0 = ys[j];
    y1 = ys[j+1];
    h  = x1-x0;
    xh = x0+c*h;
    yh = ymid[j];
    p = sub(k1[j  ],mul(y0,1/(x0-xh)+2/(x0-x1)));
    q = sub(k1[j+1],mul(y1,1/(x1-xh)+2/(x1-x0)));
    w = [sqr(xi - x1) * (xi - xh) / sqr(x0 - x1) / (x0 - xh),
         sqr(xi - x0) * sqr(xi - x1) / sqr(x0 - xh) / sqr(x1 - xh),
         sqr(xi - x0) * (xi - xh) / sqr(x1 - x0) / (x1 - xh),
         (xi - x0) * sqr(xi - x1) * (xi - xh) / sqr(x0-x1) / (x0 - xh),
         (xi - x1) * sqr(xi - x0) * (xi - xh) / sqr(x0-x1) / (x1 - xh)];
    return add(add(add(add(mul(y0,w[0]),
                           mul(yh,w[1])),
                           mul(y1,w[2])),
                           mul( p,w[3])),
                           mul( q,w[4]));
}
numeric.Dopri.prototype.at = function at(x) {
    var i,j,k,floor = Math.floor;
    if(typeof x !== "number") {
        var n = x.length, ret = Array(n);
        for(i=n-1;i!==-1;--i) {
            ret[i] = this.at(x[i]);
        }
        return ret;
    }
    var x0 = this.x;
    i = 0; j = x0.length-1;
    while(j-i>1) {
        k = floor(0.5*(i+j));
        if(x0[k] <= x) i = k;
        else j = k;
    }
    return this._at(x,i);
}

numeric.dopri = function dopri(x0,x1,y0,f,tol,maxit,event) {
    if(typeof tol === "undefined") { tol = 1e-6; }
    if(typeof maxit === "undefined") { maxit = 1000; }
    var xs = [x0], ys = [y0], k1 = [f(x0,y0)], k2,k3,k4,k5,k6,k7, ymid = [];
    var A2 = 1/5;
    var A3 = [3/40,9/40];
    var A4 = [44/45,-56/15,32/9];
    var A5 = [19372/6561,-25360/2187,64448/6561,-212/729];
    var A6 = [9017/3168,-355/33,46732/5247,49/176,-5103/18656];
    var b = [35/384,0,500/1113,125/192,-2187/6784,11/84];
    var bm = [0.5*6025192743/30085553152,
              0,
              0.5*51252292925/65400821598,
              0.5*-2691868925/45128329728,
              0.5*187940372067/1594534317056,
              0.5*-1776094331/19743644256,
              0.5*11237099/235043384];
    var c = [1/5,3/10,4/5,8/9,1,1];
    var e = [-71/57600,0,71/16695,-71/1920,17253/339200,-22/525,1/40];
    var i = 0,er,j;
    var h = (x1-x0)/10;
    var it = 0;
    var add = numeric.add, mul = numeric.mul, y1,erinf;
    var max = Math.max, min = Math.min, abs = Math.abs, norminf = numeric.norminf,pow = Math.pow;
    var any = numeric.any, lt = numeric.lt, and = numeric.and, sub = numeric.sub;
    var e0, e1, ev;
    var ret = new numeric.Dopri(xs,ys,k1,ymid,-1,"");
    if(typeof event === "function") e0 = event(x0,y0);
    while(x0<x1 && it<maxit) {
        ++it;
        if(x0+h>x1) h = x1-x0;
        k2 = f(x0+c[0]*h,                add(y0,mul(   A2*h,k1[i])));
        k3 = f(x0+c[1]*h,            add(add(y0,mul(A3[0]*h,k1[i])),mul(A3[1]*h,k2)));
        k4 = f(x0+c[2]*h,        add(add(add(y0,mul(A4[0]*h,k1[i])),mul(A4[1]*h,k2)),mul(A4[2]*h,k3)));
        k5 = f(x0+c[3]*h,    add(add(add(add(y0,mul(A5[0]*h,k1[i])),mul(A5[1]*h,k2)),mul(A5[2]*h,k3)),mul(A5[3]*h,k4)));
        k6 = f(x0+c[4]*h,add(add(add(add(add(y0,mul(A6[0]*h,k1[i])),mul(A6[1]*h,k2)),mul(A6[2]*h,k3)),mul(A6[3]*h,k4)),mul(A6[4]*h,k5)));
        y1 = add(add(add(add(add(y0,mul(k1[i],h*b[0])),mul(k3,h*b[2])),mul(k4,h*b[3])),mul(k5,h*b[4])),mul(k6,h*b[5]));
        k7 = f(x0+h,y1);
        er = add(add(add(add(add(mul(k1[i],h*e[0]),mul(k3,h*e[2])),mul(k4,h*e[3])),mul(k5,h*e[4])),mul(k6,h*e[5])),mul(k7,h*e[6]));
        if(typeof er === "number") erinf = abs(er);
        else erinf = norminf(er);
        if(erinf > tol) { // reject
            h = 0.2*h*pow(tol/erinf,0.25);
            if(x0+h === x0) {
                ret.msg = "Step size became too small";
                break;
            }
            continue;
        }
        ymid[i] = add(add(add(add(add(add(y0,
                mul(k1[i],h*bm[0])),
                mul(k3   ,h*bm[2])),
                mul(k4   ,h*bm[3])),
                mul(k5   ,h*bm[4])),
                mul(k6   ,h*bm[5])),
                mul(k7   ,h*bm[6]));
        ++i;
        xs[i] = x0+h;
        ys[i] = y1;
        k1[i] = k7;
        if(typeof event === "function") {
            var yi,xl = x0,xr = x0+0.5*h,xi;
            e1 = event(xr,ymid[i-1]);
            ev = and(lt(e0,0),lt(0,e1));
            if(!any(ev)) { xl = xr; xr = x0+h; e0 = e1; e1 = event(xr,y1); ev = and(lt(e0,0),lt(0,e1)); }
            if(any(ev)) {
                var xc, yc, en,ei;
                var side=0, sl = 1.0, sr = 1.0;
                while(1) {
                    if(typeof e0 === "number") xi = (sr*e1*xl-sl*e0*xr)/(sr*e1-sl*e0);
                    else {
                        xi = xr;
                        for(j=e0.length-1;j!==-1;--j) {
                            if(e0[j]<0 && e1[j]>0) xi = min(xi,(sr*e1[j]*xl-sl*e0[j]*xr)/(sr*e1[j]-sl*e0[j]));
                        }
                    }
                    if(xi <= xl || xi >= xr) break;
                    yi = ret._at(xi, i-1);
                    ei = event(xi,yi);
                    en = and(lt(e0,0),lt(0,ei));
                    if(any(en)) {
                        xr = xi;
                        e1 = ei;
                        ev = en;
                        sr = 1.0;
                        if(side === -1) sl *= 0.5;
                        else sl = 1.0;
                        side = -1;
                    } else {
                        xl = xi;
                        e0 = ei;
                        sl = 1.0;
                        if(side === 1) sr *= 0.5;
                        else sr = 1.0;
                        side = 1;
                    }
                }
                y1 = ret._at(0.5*(x0+xi),i-1);
                ret.f[i] = f(xi,yi);
                ret.x[i] = xi;
                ret.y[i] = yi;
                ret.ymid[i-1] = y1;
                ret.events = ev;
                ret.iterations = it;
                return ret;
            }
        }
        x0 += h;
        y0 = y1;
        e0 = e1;
        h = min(0.8*h*pow(tol/erinf,0.25),4*h);
    }
    ret.iterations = it;
    return ret;
}

// 11. Ax = b
numeric.LU = function(A, fast) {
  fast = fast || false;

  var abs = Math.abs;
  var i, j, k, absAjk, Akk, Ak, Pk, Ai;
  var max;
  var n = A.length, n1 = n-1;
  var P = new Array(n);
  if(!fast) A = numeric.clone(A);

  for (k = 0; k < n; ++k) {
    Pk = k;
    Ak = A[k];
    max = abs(Ak[k]);
    for (j = k + 1; j < n; ++j) {
      absAjk = abs(A[j][k]);
      if (max < absAjk) {
        max = absAjk;
        Pk = j;
      }
    }
    P[k] = Pk;

    if (Pk != k) {
      A[k] = A[Pk];
      A[Pk] = Ak;
      Ak = A[k];
    }

    Akk = Ak[k];

    for (i = k + 1; i < n; ++i) {
      A[i][k] /= Akk;
    }

    for (i = k + 1; i < n; ++i) {
      Ai = A[i];
      for (j = k + 1; j < n1; ++j) {
        Ai[j] -= Ai[k] * Ak[j];
        ++j;
        Ai[j] -= Ai[k] * Ak[j];
      }
      if(j===n1) Ai[j] -= Ai[k] * Ak[j];
    }
  }

  return {
    LU: A,
    P:  P
  };
}

numeric.LUsolve = function LUsolve(LUP, b) {
  var i, j;
  var LU = LUP.LU;
  var n   = LU.length;
  var x = numeric.clone(b);
  var P   = LUP.P;
  var Pi, LUi, LUii, tmp;

  for (i=n-1;i!==-1;--i) x[i] = b[i];
  for (i = 0; i < n; ++i) {
    Pi = P[i];
    if (P[i] !== i) {
      tmp = x[i];
      x[i] = x[Pi];
      x[Pi] = tmp;
    }

    LUi = LU[i];
    for (j = 0; j < i; ++j) {
      x[i] -= x[j] * LUi[j];
    }
  }

  for (i = n - 1; i >= 0; --i) {
    LUi = LU[i];
    for (j = i + 1; j < n; ++j) {
      x[i] -= x[j] * LUi[j];
    }

    x[i] /= LUi[i];
  }

  return x;
}

numeric.solve = function solve(A,b,fast) { return numeric.LUsolve(numeric.LU(A,fast), b); }

// 12. Linear programming
numeric.echelonize = function echelonize(A) {
    var s = numeric.dim(A), m = s[0], n = s[1];
    var I = numeric.identity(m);
    var P = Array(m);
    var i,j,k,l,Ai,Ii,Z,a;
    var abs = Math.abs;
    var diveq = numeric.diveq;
    A = numeric.clone(A);
    for(i=0;i<m;++i) {
        k = 0;
        Ai = A[i];
        Ii = I[i];
        for(j=1;j<n;++j) if(abs(Ai[k])<abs(Ai[j])) k=j;
        P[i] = k;
        diveq(Ii,Ai[k]);
        diveq(Ai,Ai[k]);
        for(j=0;j<m;++j) if(j!==i) {
            Z = A[j]; a = Z[k];
            for(l=n-1;l!==-1;--l) Z[l] -= Ai[l]*a;
            Z = I[j];
            for(l=m-1;l!==-1;--l) Z[l] -= Ii[l]*a;
        }
    }
    return {I:I, A:A, P:P};
}

numeric.__solveLP = function __solveLP(c,A,b,tol,maxit,x,flag) {
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var m = c.length, n = b.length,y;
    var unbounded = false, cb,i0=0;
    var alpha = 1.0;
    var f0,df0,AT = numeric.transpose(A), svd = numeric.svd,transpose = numeric.transpose,leq = numeric.leq, sqrt = Math.sqrt, abs = Math.abs;
    var muleq = numeric.muleq;
    var norm = numeric.norminf, any = numeric.any,min = Math.min;
    var all = numeric.all, gt = numeric.gt;
    var p = Array(m), A0 = Array(n),e=numeric.rep([n],1), H;
    var solve = numeric.solve, z = sub(b,dot(A,x)),count;
    var dotcc = dot(c,c);
    var g;
    for(count=i0;count<maxit;++count) {
        var i,j,d;
        for(i=n-1;i!==-1;--i) A0[i] = div(A[i],z[i]);
        var A1 = transpose(A0);
        for(i=m-1;i!==-1;--i) p[i] = (/*x[i]+*/sum(A1[i]));
        alpha = 0.25*abs(dotcc/dot(c,p));
        var a1 = 100*sqrt(dotcc/dot(p,p));
        if(!isFinite(alpha) || alpha>a1) alpha = a1;
        g = add(c,mul(alpha,p));
        H = dot(A1,A0);
        for(i=m-1;i!==-1;--i) H[i][i] += 1;
        d = solve(H,div(g,alpha),true);
        var t0 = div(z,dot(A,d));
        var t = 1.0;
        for(i=n-1;i!==-1;--i) if(t0[i]<0) t = min(t,-0.999*t0[i]);
        y = sub(x,mul(d,t));
        z = sub(b,dot(A,y));
        if(!all(gt(z,0))) return { solution: x, message: "", iterations: count };
        x = y;
        if(alpha<tol) return { solution: y, message: "", iterations: count };
        if(flag) {
            var s = dot(c,g), Ag = dot(A,g);
            unbounded = true;
            for(i=n-1;i!==-1;--i) if(s*Ag[i]<0) { unbounded = false; break; }
        } else {
            if(x[m-1]>=0) unbounded = false;
            else unbounded = true;
        }
        if(unbounded) return { solution: y, message: "Unbounded", iterations: count };
    }
    return { solution: x, message: "maximum iteration count exceeded", iterations:count };
}

numeric._solveLP = function _solveLP(c,A,b,tol,maxit) {
    var m = c.length, n = b.length,y;
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var c0 = numeric.rep([m],0).concat([1]);
    var J = numeric.rep([n,1],-1);
    var A0 = numeric.blockMatrix([[A                   ,   J  ]]);
    var b0 = b;
    var y = numeric.rep([m],0).concat(Math.max(0,numeric.sup(numeric.neg(b)))+1);
    var x0 = numeric.__solveLP(c0,A0,b0,tol,maxit,y,false);
    var x = numeric.clone(x0.solution);
    x.length = m;
    var foo = numeric.inf(sub(b,dot(A,x)));
    if(foo<0) { return { solution: NaN, message: "Infeasible", iterations: x0.iterations }; }
    var ret = numeric.__solveLP(c, A, b, tol, maxit-x0.iterations, x, true);
    ret.iterations += x0.iterations;
    return ret;
};

numeric.solveLP = function solveLP(c,A,b,Aeq,beq,tol,maxit) {
    if(typeof maxit === "undefined") maxit = 1000;
    if(typeof tol === "undefined") tol = numeric.epsilon;
    if(typeof Aeq === "undefined") return numeric._solveLP(c,A,b,tol,maxit);
    var m = Aeq.length, n = Aeq[0].length, o = A.length;
    var B = numeric.echelonize(Aeq);
    var flags = numeric.rep([n],0);
    var P = B.P;
    var Q = [];
    var i;
    for(i=P.length-1;i!==-1;--i) flags[P[i]] = 1;
    for(i=n-1;i!==-1;--i) if(flags[i]===0) Q.push(i);
    var g = numeric.getRange;
    var I = numeric.linspace(0,m-1), J = numeric.linspace(0,o-1);
    var Aeq2 = g(Aeq,I,Q), A1 = g(A,J,P), A2 = g(A,J,Q), dot = numeric.dot, sub = numeric.sub;
    var A3 = dot(A1,B.I);
    var A4 = sub(A2,dot(A3,Aeq2)), b4 = sub(b,dot(A3,beq));
    var c1 = Array(P.length), c2 = Array(Q.length);
    for(i=P.length-1;i!==-1;--i) c1[i] = c[P[i]];
    for(i=Q.length-1;i!==-1;--i) c2[i] = c[Q[i]];
    var c4 = sub(c2,dot(c1,dot(B.I,Aeq2)));
    var S = numeric._solveLP(c4,A4,b4,tol,maxit);
    var x2 = S.solution;
    if(x2!==x2) return S;
    var x1 = dot(B.I,sub(beq,dot(Aeq2,x2)));
    var x = Array(c.length);
    for(i=P.length-1;i!==-1;--i) x[P[i]] = x1[i];
    for(i=Q.length-1;i!==-1;--i) x[Q[i]] = x2[i];
    return { solution: x, message:S.message, iterations: S.iterations };
}

numeric.MPStoLP = function MPStoLP(MPS) {
    if(MPS instanceof String) { MPS.split('\n'); }
    var state = 0;
    var states = ['Initial state','NAME','ROWS','COLUMNS','RHS','BOUNDS','ENDATA'];
    var n = MPS.length;
    var i,j,z,N=0,rows = {}, sign = [], rl = 0, vars = {}, nv = 0;
    var name;
    var c = [], A = [], b = [];
    function err(e) { throw new Error('MPStoLP: '+e+'\nLine '+i+': '+MPS[i]+'\nCurrent state: '+states[state]+'\n'); }
    for(i=0;i<n;++i) {
        z = MPS[i];
        var w0 = z.match(/\S*/g);
        var w = [];
        for(j=0;j<w0.length;++j) if(w0[j]!=="") w.push(w0[j]);
        if(w.length === 0) continue;
        for(j=0;j<states.length;++j) if(z.substr(0,states[j].length) === states[j]) break;
        if(j<states.length) {
            state = j;
            if(j===1) { name = w[1]; }
            if(j===6) return { name:name, c:c, A:numeric.transpose(A), b:b, rows:rows, vars:vars };
            continue;
        }
        switch(state) {
        case 0: case 1: err('Unexpected line');
        case 2: 
            switch(w[0]) {
            case 'N': if(N===0) N = w[1]; else err('Two or more N rows'); break;
            case 'L': rows[w[1]] = rl; sign[rl] = 1; b[rl] = 0; ++rl; break;
            case 'G': rows[w[1]] = rl; sign[rl] = -1;b[rl] = 0; ++rl; break;
            case 'E': rows[w[1]] = rl; sign[rl] = 0;b[rl] = 0; ++rl; break;
            default: err('Parse error '+numeric.prettyPrint(w));
            }
            break;
        case 3:
            if(!vars.hasOwnProperty(w[0])) { vars[w[0]] = nv; c[nv] = 0; A[nv] = numeric.rep([rl],0); ++nv; }
            var p = vars[w[0]];
            for(j=1;j<w.length;j+=2) {
                if(w[j] === N) { c[p] = parseFloat(w[j+1]); continue; }
                var q = rows[w[j]];
                A[p][q] = (sign[q]<0?-1:1)*parseFloat(w[j+1]);
            }
            break;
        case 4:
            for(j=1;j<w.length;j+=2) b[rows[w[j]]] = (sign[rows[w[j]]]<0?-1:1)*parseFloat(w[j+1]);
            break;
        case 5: /*FIXME*/ break;
        case 6: err('Internal error');
        }
    }
    err('Reached end of file without ENDATA');
}
// seedrandom.js version 2.0.
// Author: David Bau 4/2/2011
//
// Defines a method Math.seedrandom() that, when called, substitutes
// an explicitly seeded RC4-based algorithm for Math.random().  Also
// supports automatic seeding from local or network sources of entropy.
//
// Usage:
//
//   <script src=http://davidbau.com/encode/seedrandom-min.js></script>
//
//   Math.seedrandom('yipee'); Sets Math.random to a function that is
//                             initialized using the given explicit seed.
//
//   Math.seedrandom();        Sets Math.random to a function that is
//                             seeded using the current time, dom state,
//                             and other accumulated local entropy.
//                             The generated seed string is returned.
//
//   Math.seedrandom('yowza', true);
//                             Seeds using the given explicit seed mixed
//                             together with accumulated entropy.
//
//   <script src="http://bit.ly/srandom-512"></script>
//                             Seeds using physical random bits downloaded
//                             from random.org.
//
//   <script src="https://jsonlib.appspot.com/urandom?callback=Math.seedrandom">
//   </script>                 Seeds using urandom bits from call.jsonlib.com,
//                             which is faster than random.org.
//
// Examples:
//
//   Math.seedrandom("hello");            // Use "hello" as the seed.
//   document.write(Math.random());       // Always 0.5463663768140734
//   document.write(Math.random());       // Always 0.43973793770592234
//   var rng1 = Math.random;              // Remember the current prng.
//
//   var autoseed = Math.seedrandom();    // New prng with an automatic seed.
//   document.write(Math.random());       // Pretty much unpredictable.
//
//   Math.random = rng1;                  // Continue "hello" prng sequence.
//   document.write(Math.random());       // Always 0.554769432473455
//
//   Math.seedrandom(autoseed);           // Restart at the previous seed.
//   document.write(Math.random());       // Repeat the 'unpredictable' value.
//
// Notes:
//
// Each time seedrandom('arg') is called, entropy from the passed seed
// is accumulated in a pool to help generate future seeds for the
// zero-argument form of Math.seedrandom, so entropy can be injected over
// time by calling seedrandom with explicit data repeatedly.
//
// On speed - This javascript implementation of Math.random() is about
// 3-10x slower than the built-in Math.random() because it is not native
// code, but this is typically fast enough anyway.  Seeding is more expensive,
// especially if you use auto-seeding.  Some details (timings on Chrome 4):
//
// Our Math.random()            - avg less than 0.002 milliseconds per call
// seedrandom('explicit')       - avg less than 0.5 milliseconds per call
// seedrandom('explicit', true) - avg less than 2 milliseconds per call
// seedrandom()                 - avg about 38 milliseconds per call
//
// LICENSE (BSD):
//
// Copyright 2010 David Bau, all rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
//   1. Redistributions of source code must retain the above copyright
//      notice, this list of conditions and the following disclaimer.
//
//   2. Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
// 
//   3. Neither the name of this module nor the names of its contributors may
//      be used to endorse or promote products derived from this software
//      without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
/**
 * All code is in an anonymous closure to keep the global namespace clean.
 *
 * @param {number=} overflow 
 * @param {number=} startdenom
 */

// Patched by Seb so that seedrandom.js does not pollute the Math object.
// My tests suggest that doing Math.trouble = 1 makes Math lookups about 5%
// slower.
numeric.seedrandom = { pow:Math.pow, random:Math.random };

(function (pool, math, width, chunks, significance, overflow, startdenom) {


//
// seedrandom()
// This is the seedrandom function described above.
//
math['seedrandom'] = function seedrandom(seed, use_entropy) {
  var key = [];
  var arc4;

  // Flatten the seed string or build one from local entropy if needed.
  seed = mixkey(flatten(
    use_entropy ? [seed, pool] :
    arguments.length ? seed :
    [new Date().getTime(), pool, window], 3), key);

  // Use the seed to initialize an ARC4 generator.
  arc4 = new ARC4(key);

  // Mix the randomness into accumulated entropy.
  mixkey(arc4.S, pool);

  // Override Math.random

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.

  math['random'] = function random() {  // Closure to return a random double:
    var n = arc4.g(chunks);             // Start with a numerator n < 2 ^ 48
    var d = startdenom;                 //   and denominator d = 2 ^ 48.
    var x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  // Return the seed that was used
  return seed;
};

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
/** @constructor */
function ARC4(key) {
  var t, u, me = this, keylen = key.length;
  var i = 0, j = me.i = me.j = me.m = 0;
  me.S = [];
  me.c = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) { me.S[i] = i++; }
  for (i = 0; i < width; i++) {
    t = me.S[i];
    j = lowbits(j + t + key[i % keylen]);
    u = me.S[j];
    me.S[i] = u;
    me.S[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  me.g = function getnext(count) {
    var s = me.S;
    var i = lowbits(me.i + 1); var t = s[i];
    var j = lowbits(me.j + t); var u = s[j];
    s[i] = u;
    s[j] = t;
    var r = s[lowbits(t + u)];
    while (--count) {
      i = lowbits(i + 1); t = s[i];
      j = lowbits(j + t); u = s[j];
      s[i] = u;
      s[j] = t;
      r = r * width + s[lowbits(t + u)];
    }
    me.i = i;
    me.j = j;
    return r;
  };
  // For robust unpredictability discard an initial batch of values.
  // See http://www.rsa.com/rsalabs/node.asp?id=2009
  me.g(width);
}

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
/** @param {Object=} result 
  * @param {string=} prop
  * @param {string=} typ */
function flatten(obj, depth, result, prop, typ) {
  result = [];
  typ = typeof(obj);
  if (depth && typ == 'object') {
    for (prop in obj) {
      if (prop.indexOf('S') < 5) {    // Avoid FF3 bug (local/sessionStorage)
        try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
      }
    }
  }
  return (result.length ? result : obj + (typ != 'string' ? '\0' : ''));
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
/** @param {number=} smear 
  * @param {number=} j */
function mixkey(seed, key, smear, j) {
  seed += '';                         // Ensure the seed is a string
  smear = 0;
  for (j = 0; j < seed.length; j++) {
    key[lowbits(j)] =
      lowbits((smear ^= key[lowbits(j)] * 19) + seed.charCodeAt(j));
  }
  seed = '';
  for (j in key) { seed += String.fromCharCode(key[j]); }
  return seed;
}

//
// lowbits()
// A quick "n mod width" for width a power of 2.
//
function lowbits(n) { return n & (width - 1); }

//
// The following constants are related to IEEE 754 limits.
//
startdenom = math.pow(width, chunks);
significance = math.pow(2, significance);
overflow = significance * 2;

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to intefere with determinstic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

// End anonymous scope, and pass initial values.
}(
  [],   // pool: entropy pool starts empty
  numeric.seedrandom, // math: package containing random, pow, and seedrandom
  256,  // width: each RC4 output is 0 <= x < 256
  6,    // chunks: at least six RC4 outputs for each double
  52    // significance: there are 52 significant digits in a double
  ));
/* This file is a slightly modified version of quadprog.js from Alberto Santini.
 * It has been slightly modified by Sbastien Loisel to make sure that it handles
 * 0-based Arrays instead of 1-based Arrays.
 * License is in resources/LICENSE.quadprog */
(function(exports) {

function base0to1(A) {
    if(typeof A !== "object") { return A; }
    var ret = [], i,n=A.length;
    for(i=0;i<n;i++) ret[i+1] = base0to1(A[i]);
    return ret;
}
function base1to0(A) {
    if(typeof A !== "object") { return A; }
    var ret = [], i,n=A.length;
    for(i=1;i<n;i++) ret[i-1] = base1to0(A[i]);
    return ret;
}

function dpori(a, lda, n) {
    var i, j, k, kp1, t;

    for (k = 1; k <= n; k = k + 1) {
        a[k][k] = 1 / a[k][k];
        t = -a[k][k];
        //~ dscal(k - 1, t, a[1][k], 1);
        for (i = 1; i < k; i = i + 1) {
            a[i][k] = t * a[i][k];
        }

        kp1 = k + 1;
        if (n < kp1) {
            break;
        }
        for (j = kp1; j <= n; j = j + 1) {
            t = a[k][j];
            a[k][j] = 0;
            //~ daxpy(k, t, a[1][k], 1, a[1][j], 1);
            for (i = 1; i <= k; i = i + 1) {
                a[i][j] = a[i][j] + (t * a[i][k]);
            }
        }
    }

}

function dposl(a, lda, n, b) {
    var i, k, kb, t;

    for (k = 1; k <= n; k = k + 1) {
        //~ t = ddot(k - 1, a[1][k], 1, b[1], 1);
        t = 0;
        for (i = 1; i < k; i = i + 1) {
            t = t + (a[i][k] * b[i]);
        }

        b[k] = (b[k] - t) / a[k][k];
    }

    for (kb = 1; kb <= n; kb = kb + 1) {
        k = n + 1 - kb;
        b[k] = b[k] / a[k][k];
        t = -b[k];
        //~ daxpy(k - 1, t, a[1][k], 1, b[1], 1);
        for (i = 1; i < k; i = i + 1) {
            b[i] = b[i] + (t * a[i][k]);
        }
    }
}

function dpofa(a, lda, n, info) {
    var i, j, jm1, k, t, s;

    for (j = 1; j <= n; j = j + 1) {
        info[1] = j;
        s = 0;
        jm1 = j - 1;
        if (jm1 < 1) {
            s = a[j][j] - s;
            if (s <= 0) {
                break;
            }
            a[j][j] = Math.sqrt(s);
        } else {
            for (k = 1; k <= jm1; k = k + 1) {
                //~ t = a[k][j] - ddot(k - 1, a[1][k], 1, a[1][j], 1);
                t = a[k][j];
                for (i = 1; i < k; i = i + 1) {
                    t = t - (a[i][j] * a[i][k]);
                }
                t = t / a[k][k];
                a[k][j] = t;
                s = s + t * t;
            }
            s = a[j][j] - s;
            if (s <= 0) {
                break;
            }
            a[j][j] = Math.sqrt(s);
        }
        info[1] = 0;
    }
}

function qpgen2(dmat, dvec, fddmat, n, sol, crval, amat,
    bvec, fdamat, q, meq, iact, nact, iter, work, ierr) {

    var i, j, l, l1, info, it1, iwzv, iwrv, iwrm, iwsv, iwuv, nvl, r, iwnbv,
        temp, sum, t1, tt, gc, gs, nu,
        t1inf, t2min,
        vsmall, tmpa, tmpb,
        go;

    r = Math.min(n, q);
    l = 2 * n + (r * (r + 5)) / 2 + 2 * q + 1;

    vsmall = 1.0e-60;
    do {
        vsmall = vsmall + vsmall;
        tmpa = 1 + 0.1 * vsmall;
        tmpb = 1 + 0.2 * vsmall;
    } while (tmpa <= 1 || tmpb <= 1);

    for (i = 1; i <= n; i = i + 1) {
        work[i] = dvec[i];
    }
    for (i = n + 1; i <= l; i = i + 1) {
        work[i] = 0;
    }
    for (i = 1; i <= q; i = i + 1) {
        iact[i] = 0;
    }

    info = [];

    if (ierr[1] === 0) {
        dpofa(dmat, fddmat, n, info);
        if (info[1] !== 0) {
            ierr[1] = 2;
            return;
        }
        dposl(dmat, fddmat, n, dvec);
        dpori(dmat, fddmat, n);
    } else {
        for (j = 1; j <= n; j = j + 1) {
            sol[j] = 0;
            for (i = 1; i <= j; i = i + 1) {
                sol[j] = sol[j] + dmat[i][j] * dvec[i];
            }
        }
        for (j = 1; j <= n; j = j + 1) {
            dvec[j] = 0;
            for (i = j; i <= n; i = i + 1) {
                dvec[j] = dvec[j] + dmat[j][i] * sol[i];
            }
        }
    }

    crval[1] = 0;
    for (j = 1; j <= n; j = j + 1) {
        sol[j] = dvec[j];
        crval[1] = crval[1] + work[j] * sol[j];
        work[j] = 0;
        for (i = j + 1; i <= n; i = i + 1) {
            dmat[i][j] = 0;
        }
    }
    crval[1] = -crval[1] / 2;
    ierr[1] = 0;

    iwzv = n;
    iwrv = iwzv + n;
    iwuv = iwrv + r;
    iwrm = iwuv + r + 1;
    iwsv = iwrm + (r * (r + 1)) / 2;
    iwnbv = iwsv + q;

    for (i = 1; i <= q; i = i + 1) {
        sum = 0;
        for (j = 1; j <= n; j = j + 1) {
            sum = sum + amat[j][i] * amat[j][i];
        }
        work[iwnbv + i] = Math.sqrt(sum);
    }
    nact = 0;
    iter[1] = 0;
    iter[2] = 0;

    function fn_goto_50() {
        iter[1] = iter[1] + 1;

        l = iwsv;
        for (i = 1; i <= q; i = i + 1) {
            l = l + 1;
            sum = -bvec[i];
            for (j = 1; j <= n; j = j + 1) {
                sum = sum + amat[j][i] * sol[j];
            }
            if (Math.abs(sum) < vsmall) {
                sum = 0;
            }
            if (i > meq) {
                work[l] = sum;
            } else {
                work[l] = -Math.abs(sum);
                if (sum > 0) {
                    for (j = 1; j <= n; j = j + 1) {
                        amat[j][i] = -amat[j][i];
                    }
                    bvec[i] = -bvec[i];
                }
            }
        }

        for (i = 1; i <= nact; i = i + 1) {
            work[iwsv + iact[i]] = 0;
        }

        nvl = 0;
        temp = 0;
        for (i = 1; i <= q; i = i + 1) {
            if (work[iwsv + i] < temp * work[iwnbv + i]) {
                nvl = i;
                temp = work[iwsv + i] / work[iwnbv + i];
            }
        }
        if (nvl === 0) {
            return 999;
        }

        return 0;
    }

    function fn_goto_55() {
        for (i = 1; i <= n; i = i + 1) {
            sum = 0;
            for (j = 1; j <= n; j = j + 1) {
                sum = sum + dmat[j][i] * amat[j][nvl];
            }
            work[i] = sum;
        }

        l1 = iwzv;
        for (i = 1; i <= n; i = i + 1) {
            work[l1 + i] = 0;
        }
        for (j = nact + 1; j <= n; j = j + 1) {
            for (i = 1; i <= n; i = i + 1) {
                work[l1 + i] = work[l1 + i] + dmat[i][j] * work[j];
            }
        }

        t1inf = true;
        for (i = nact; i >= 1; i = i - 1) {
            sum = work[i];
            l = iwrm + (i * (i + 3)) / 2;
            l1 = l - i;
            for (j = i + 1; j <= nact; j = j + 1) {
                sum = sum - work[l] * work[iwrv + j];
                l = l + j;
            }
            sum = sum / work[l1];
            work[iwrv + i] = sum;
            if (iact[i] < meq) {
                // continue;
                break;
            }
            if (sum < 0) {
                // continue;
                break;
            }
            t1inf = false;
            it1 = i;
        }

        if (!t1inf) {
            t1 = work[iwuv + it1] / work[iwrv + it1];
            for (i = 1; i <= nact; i = i + 1) {
                if (iact[i] < meq) {
                    // continue;
                    break;
                }
                if (work[iwrv + i] < 0) {
                    // continue;
                    break;
                }
                temp = work[iwuv + i] / work[iwrv + i];
                if (temp < t1) {
                    t1 = temp;
                    it1 = i;
                }
            }
        }

        sum = 0;
        for (i = iwzv + 1; i <= iwzv + n; i = i + 1) {
            sum = sum + work[i] * work[i];
        }
        if (Math.abs(sum) <= vsmall) {
            if (t1inf) {
                ierr[1] = 1;
                // GOTO 999
                return 999;
            } else {
                for (i = 1; i <= nact; i = i + 1) {
                    work[iwuv + i] = work[iwuv + i] - t1 * work[iwrv + i];
                }
                work[iwuv + nact + 1] = work[iwuv + nact + 1] + t1;
                // GOTO 700
                return 700;
            }
        } else {
            sum = 0;
            for (i = 1; i <= n; i = i + 1) {
                sum = sum + work[iwzv + i] * amat[i][nvl];
            }
            tt = -work[iwsv + nvl] / sum;
            t2min = true;
            if (!t1inf) {
                if (t1 < tt) {
                    tt = t1;
                    t2min = false;
                }
            }

            for (i = 1; i <= n; i = i + 1) {
                sol[i] = sol[i] + tt * work[iwzv + i];
                if (Math.abs(sol[i]) < vsmall) {
                    sol[i] = 0;
                }
            }

            crval[1] = crval[1] + tt * sum * (tt / 2 + work[iwuv + nact + 1]);
            for (i = 1; i <= nact; i = i + 1) {
                work[iwuv + i] = work[iwuv + i] - tt * work[iwrv + i];
            }
            work[iwuv + nact + 1] = work[iwuv + nact + 1] + tt;

            if (t2min) {
                nact = nact + 1;
                iact[nact] = nvl;

                l = iwrm + ((nact - 1) * nact) / 2 + 1;
                for (i = 1; i <= nact - 1; i = i + 1) {
                    work[l] = work[i];
                    l = l + 1;
                }

                if (nact === n) {
                    work[l] = work[n];
                } else {
                    for (i = n; i >= nact + 1; i = i - 1) {
                        if (work[i] === 0) {
                            // continue;
                            break;
                        }
                        gc = Math.max(Math.abs(work[i - 1]), Math.abs(work[i]));
                        gs = Math.min(Math.abs(work[i - 1]), Math.abs(work[i]));
                        if (work[i - 1] >= 0) {
                            temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                        } else {
                            temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                        }
                        gc = work[i - 1] / temp;
                        gs = work[i] / temp;

                        if (gc === 1) {
                            // continue;
                            break;
                        }
                        if (gc === 0) {
                            work[i - 1] = gs * temp;
                            for (j = 1; j <= n; j = j + 1) {
                                temp = dmat[j][i - 1];
                                dmat[j][i - 1] = dmat[j][i];
                                dmat[j][i] = temp;
                            }
                        } else {
                            work[i - 1] = temp;
                            nu = gs / (1 + gc);
                            for (j = 1; j <= n; j = j + 1) {
                                temp = gc * dmat[j][i - 1] + gs * dmat[j][i];
                                dmat[j][i] = nu * (dmat[j][i - 1] + temp) - dmat[j][i];
                                dmat[j][i - 1] = temp;

                            }
                        }
                    }
                    work[l] = work[nact];
                }
            } else {
                sum = -bvec[nvl];
                for (j = 1; j <= n; j = j + 1) {
                    sum = sum + sol[j] * amat[j][nvl];
                }
                if (nvl > meq) {
                    work[iwsv + nvl] = sum;
                } else {
                    work[iwsv + nvl] = -Math.abs(sum);
                    if (sum > 0) {
                        for (j = 1; j <= n; j = j + 1) {
                            amat[j][nvl] = -amat[j][nvl];
                        }
                        bvec[nvl] = -bvec[nvl];
                    }
                }
                // GOTO 700
                return 700;
            }
        }

        return 0;
    }

    function fn_goto_797() {
        l = iwrm + (it1 * (it1 + 1)) / 2 + 1;
        l1 = l + it1;
        if (work[l1] === 0) {
            // GOTO 798
            return 798;
        }
        gc = Math.max(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
        gs = Math.min(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
        if (work[l1 - 1] >= 0) {
            temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
        } else {
            temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
        }
        gc = work[l1 - 1] / temp;
        gs = work[l1] / temp;

        if (gc === 1) {
            // GOTO 798
            return 798;
        }
        if (gc === 0) {
            for (i = it1 + 1; i <= nact; i = i + 1) {
                temp = work[l1 - 1];
                work[l1 - 1] = work[l1];
                work[l1] = temp;
                l1 = l1 + i;
            }
            for (i = 1; i <= n; i = i + 1) {
                temp = dmat[i][it1];
                dmat[i][it1] = dmat[i][it1 + 1];
                dmat[i][it1 + 1] = temp;
            }
        } else {
            nu = gs / (1 + gc);
            for (i = it1 + 1; i <= nact; i = i + 1) {
                temp = gc * work[l1 - 1] + gs * work[l1];
                work[l1] = nu * (work[l1 - 1] + temp) - work[l1];
                work[l1 - 1] = temp;
                l1 = l1 + i;
            }
            for (i = 1; i <= n; i = i + 1) {
                temp = gc * dmat[i][it1] + gs * dmat[i][it1 + 1];
                dmat[i][it1 + 1] = nu * (dmat[i][it1] + temp) - dmat[i][it1 + 1];
                dmat[i][it1] = temp;
            }
        }

        return 0;
    }

    function fn_goto_798() {
        l1 = l - it1;
        for (i = 1; i <= it1; i = i + 1) {
            work[l1] = work[l];
            l = l + 1;
            l1 = l1 + 1;
        }

        work[iwuv + it1] = work[iwuv + it1 + 1];
        iact[it1] = iact[it1 + 1];
        it1 = it1 + 1;
        if (it1 < nact) {
            // GOTO 797
            return 797;
        }

        return 0;
    }

    function fn_goto_799() {
        work[iwuv + nact] = work[iwuv + nact + 1];
        work[iwuv + nact + 1] = 0;
        iact[nact] = 0;
        nact = nact - 1;
        iter[2] = iter[2] + 1;

        return 0;
    }

    go = 0;
    while (true) {
        go = fn_goto_50();
        if (go === 999) {
            return;
        }
        while (true) {
            go = fn_goto_55();
            if (go === 0) {
                break;
            }
            if (go === 999) {
                return;
            }
            if (go === 700) {
                if (it1 === nact) {
                    fn_goto_799();
                } else {
                    while (true) {
                        fn_goto_797();
                        go = fn_goto_798();
                        if (go !== 797) {
                            break;
                        }
                    }
                    fn_goto_799();
                }
            }
        }
    }

}

function solveQP(Dmat, dvec, Amat, bvec, meq, factorized) {
    Dmat = base0to1(Dmat);
    dvec = base0to1(dvec);
    Amat = base0to1(Amat);
    var i, n, q,
        nact, r,
        crval = [], iact = [], sol = [], work = [], iter = [],
        message;

    meq = meq || 0;
    factorized = factorized ? base0to1(factorized) : [undefined, 0];
    bvec = bvec ? base0to1(bvec) : [];

    // In Fortran the array index starts from 1
    n = Dmat.length - 1;
    q = Amat[1].length - 1;

    if (!bvec) {
        for (i = 1; i <= q; i = i + 1) {
            bvec[i] = 0;
        }
    }
    for (i = 1; i <= q; i = i + 1) {
        iact[i] = 0;
    }
    nact = 0;
    r = Math.min(n, q);
    for (i = 1; i <= n; i = i + 1) {
        sol[i] = 0;
    }
    crval[1] = 0;
    for (i = 1; i <= (2 * n + (r * (r + 5)) / 2 + 2 * q + 1); i = i + 1) {
        work[i] = 0;
    }
    for (i = 1; i <= 2; i = i + 1) {
        iter[i] = 0;
    }

    qpgen2(Dmat, dvec, n, n, sol, crval, Amat,
        bvec, n, q, meq, iact, nact, iter, work, factorized);

    message = "";
    if (factorized[1] === 1) {
        message = "constraints are inconsistent, no solution!";
    }
    if (factorized[1] === 2) {
        message = "matrix D in quadratic function is not positive definite!";
    }

    return {
        solution: base1to0(sol),
        value: base1to0(crval),
        unconstrained_solution: base1to0(dvec),
        iterations: base1to0(iter),
        iact: base1to0(iact),
        message: message
    };
}
exports.solveQP = solveQP;
}(numeric));
/*
Shanti Rao sent me this routine by private email. I had to modify it
slightly to work on Arrays instead of using a Matrix object.
It is apparently translated from http://stitchpanorama.sourceforge.net/Python/svd.py
*/

numeric.svd= function svd(A) {
    var temp;
//Compute the thin SVD from G. H. Golub and C. Reinsch, Numer. Math. 14, 403-420 (1970)
	var prec= numeric.epsilon; //Math.pow(2,-52) // assumes double prec
	var tolerance= 1.e-64/prec;
	var itmax= 50;
	var c=0;
	var i=0;
	var j=0;
	var k=0;
	var l=0;
	
	var u= numeric.clone(A);
	var m= u.length;
	
	var n= u[0].length;
	
	if (m < n) throw "Need more rows than columns"
	
	var e = new Array(n);
	var q = new Array(n);
	for (i=0; i<n; i++) e[i] = q[i] = 0.0;
	var v = numeric.rep([n,n],0);
//	v.zero();
	
 	function pythag(a,b)
 	{
		a = Math.abs(a)
		b = Math.abs(b)
		if (a > b)
			return a*Math.sqrt(1.0+(b*b/a/a))
		else if (b == 0.0) 
			return a
		return b*Math.sqrt(1.0+(a*a/b/b))
	}

	//Householder's reduction to bidiagonal form

	var f= 0.0;
	var g= 0.0;
	var h= 0.0;
	var x= 0.0;
	var y= 0.0;
	var z= 0.0;
	var s= 0.0;
	
	for (i=0; i < n; i++)
	{	
		e[i]= g;
		s= 0.0;
		l= i+1;
		for (j=i; j < m; j++) 
			s += (u[j][i]*u[j][i]);
		if (s <= tolerance)
			g= 0.0;
		else
		{	
			f= u[i][i];
			g= Math.sqrt(s);
			if (f >= 0.0) g= -g;
			h= f*g-s
			u[i][i]=f-g;
			for (j=l; j < n; j++)
			{
				s= 0.0
				for (k=i; k < m; k++) 
					s += u[k][i]*u[k][j]
				f= s/h
				for (k=i; k < m; k++) 
					u[k][j]+=f*u[k][i]
			}
		}
		q[i]= g
		s= 0.0
		for (j=l; j < n; j++) 
			s= s + u[i][j]*u[i][j]
		if (s <= tolerance)
			g= 0.0
		else
		{	
			f= u[i][i+1]
			g= Math.sqrt(s)
			if (f >= 0.0) g= -g
			h= f*g - s
			u[i][i+1] = f-g;
			for (j=l; j < n; j++) e[j]= u[i][j]/h
			for (j=l; j < m; j++)
			{	
				s=0.0
				for (k=l; k < n; k++) 
					s += (u[j][k]*u[i][k])
				for (k=l; k < n; k++) 
					u[j][k]+=s*e[k]
			}	
		}
		y= Math.abs(q[i])+Math.abs(e[i])
		if (y>x) 
			x=y
	}
	
	// accumulation of right hand gtransformations
	for (i=n-1; i != -1; i+= -1)
	{	
		if (g != 0.0)
		{
		 	h= g*u[i][i+1]
			for (j=l; j < n; j++) 
				v[j][i]=u[i][j]/h
			for (j=l; j < n; j++)
			{	
				s=0.0
				for (k=l; k < n; k++) 
					s += u[i][k]*v[k][j]
				for (k=l; k < n; k++) 
					v[k][j]+=(s*v[k][i])
			}	
		}
		for (j=l; j < n; j++)
		{
			v[i][j] = 0;
			v[j][i] = 0;
		}
		v[i][i] = 1;
		g= e[i]
		l= i
	}
	
	// accumulation of left hand transformations
	for (i=n-1; i != -1; i+= -1)
	{	
		l= i+1
		g= q[i]
		for (j=l; j < n; j++) 
			u[i][j] = 0;
		if (g != 0.0)
		{
			h= u[i][i]*g
			for (j=l; j < n; j++)
			{
				s=0.0
				for (k=l; k < m; k++) s += u[k][i]*u[k][j];
				f= s/h
				for (k=i; k < m; k++) u[k][j]+=f*u[k][i];
			}
			for (j=i; j < m; j++) u[j][i] = u[j][i]/g;
		}
		else
			for (j=i; j < m; j++) u[j][i] = 0;
		u[i][i] += 1;
	}
	
	// diagonalization of the bidiagonal form
	prec= prec*x
	for (k=n-1; k != -1; k+= -1)
	{
		for (var iteration=0; iteration < itmax; iteration++)
		{	// test f splitting
			var test_convergence = false
			for (l=k; l != -1; l+= -1)
			{	
				if (Math.abs(e[l]) <= prec)
				{	test_convergence= true
					break 
				}
				if (Math.abs(q[l-1]) <= prec)
					break 
			}
			if (!test_convergence)
			{	// cancellation of e[l] if l>0
				c= 0.0
				s= 1.0
				var l1= l-1
				for (i =l; i<k+1; i++)
				{	
					f= s*e[i]
					e[i]= c*e[i]
					if (Math.abs(f) <= prec)
						break
					g= q[i]
					h= pythag(f,g)
					q[i]= h
					c= g/h
					s= -f/h
					for (j=0; j < m; j++)
					{	
						y= u[j][l1]
						z= u[j][i]
						u[j][l1] =  y*c+(z*s)
						u[j][i] = -y*s+(z*c)
					} 
				}	
			}
			// test f convergence
			z= q[k]
			if (l== k)
			{	//convergence
				if (z<0.0)
				{	//q[k] is made non-negative
					q[k]= -z
					for (j=0; j < n; j++)
						v[j][k] = -v[j][k]
				}
				break  //break out of iteration loop and move on to next k value
			}
			if (iteration >= itmax-1)
				throw 'Error: no convergence.'
			// shift from bottom 2x2 minor
			x= q[l]
			y= q[k-1]
			g= e[k-1]
			h= e[k]
			f= ((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y)
			g= pythag(f,1.0)
			if (f < 0.0)
				f= ((x-z)*(x+z)+h*(y/(f-g)-h))/x
			else
				f= ((x-z)*(x+z)+h*(y/(f+g)-h))/x
			// next QR transformation
			c= 1.0
			s= 1.0
			for (i=l+1; i< k+1; i++)
			{	
				g= e[i]
				y= q[i]
				h= s*g
				g= c*g
				z= pythag(f,h)
				e[i-1]= z
				c= f/z
				s= h/z
				f= x*c+g*s
				g= -x*s+g*c
				h= y*s
				y= y*c
				for (j=0; j < n; j++)
				{	
					x= v[j][i-1]
					z= v[j][i]
					v[j][i-1] = x*c+z*s
					v[j][i] = -x*s+z*c
				}
				z= pythag(f,h)
				q[i-1]= z
				c= f/z
				s= h/z
				f= c*g+s*y
				x= -s*g+c*y
				for (j=0; j < m; j++)
				{
					y= u[j][i-1]
					z= u[j][i]
					u[j][i-1] = y*c+z*s
					u[j][i] = -y*s+z*c
				}
			}
			e[l]= 0.0
			e[k]= f
			q[k]= x
		} 
	}
		
	//vt= transpose(v)
	//return (u,q,vt)
	for (i=0;i<q.length; i++) 
	  if (q[i] < prec) q[i] = 0
	  
	//sort eigenvalues	
	for (i=0; i< n; i++)
	{	 
	//writeln(q)
	 for (j=i-1; j >= 0; j--)
	 {
	  if (q[j] < q[i])
	  {
	//  writeln(i,'-',j)
	   c = q[j]
	   q[j] = q[i]
	   q[i] = c
	   for(k=0;k<u.length;k++) { temp = u[k][i]; u[k][i] = u[k][j]; u[k][j] = temp; }
	   for(k=0;k<v.length;k++) { temp = v[k][i]; v[k][i] = v[k][j]; v[k][j] = temp; }
//	   u.swapCols(i,j)
//	   v.swapCols(i,j)
	   i = j	   
	  }
	 }	
	}
	
	return {U:u,S:q,V:v}
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],242:[function(require,module,exports){
/*
 (c) 2013, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

(function () { 'use strict';

// to suit your point format, run search/replace for '.x' and '.y';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)

// square distance between 2 points
function getSqDist(p1, p2) {

    var dx = p1.x - p2.x,
        dy = p1.y - p2.y;

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2) {

    var x = p1.x,
        y = p1.y,
        dx = p2.x - x,
        dy = p2.y - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2.x;
            y = p2.y;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p.x - x;
    dy = p.y - y;

    return dx * dx + dy * dy;
}
// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance) {

    var prevPoint = points[0],
        newPoints = [prevPoint],
        point;

    for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

// simplification using optimized Douglas-Peucker algorithm with recursion elimination
function simplifyDouglasPeucker(points, sqTolerance) {

    var len = points.length,
        MarkerArray = typeof Uint8Array !== 'undefined' ? Uint8Array : Array,
        markers = new MarkerArray(len),
        first = 0,
        last = len - 1,
        stack = [],
        newPoints = [],
        i, maxSqDist, sqDist, index;

    markers[first] = markers[last] = 1;

    while (last) {

        maxSqDist = 0;

        for (i = first + 1; i < last; i++) {
            sqDist = getSqSegDist(points[i], points[first], points[last]);

            if (sqDist > maxSqDist) {
                index = i;
                maxSqDist = sqDist;
            }
        }

        if (maxSqDist > sqTolerance) {
            markers[index] = 1;
            stack.push(first, index, index, last);
        }

        last = stack.pop();
        first = stack.pop();
    }

    for (i = 0; i < len; i++) {
        if (markers[i]) newPoints.push(points[i]);
    }

    return newPoints;
}

// both algorithms combined for awesome performance
function simplify(points, tolerance, highestQuality) {

    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}

// export as AMD module / Node module / browser or worker variable
if (typeof define === 'function' && define.amd) define(function() { return simplify; });
else if (typeof module !== 'undefined') module.exports = simplify;
else if (typeof self !== 'undefined') self.simplify = simplify;
else window.simplify = simplify;

})();

},{}],243:[function(require,module,exports){
"use strict"

module.exports = createKDTree
module.exports.deserialize = deserializeKDTree

var ndarray = require("ndarray")
var ndselect = require("ndarray-select")
var pack = require("ndarray-pack")
var ops = require("ndarray-ops")
var ndscratch = require("ndarray-scratch")
var pool = require("typedarray-pool")
var inorderTree = require("inorder-tree-layout")
var bits = require("bit-twiddle")
var KDTHeap = require("./lib/heap.js")

function KDTree(points, ids, n, d) {
  this.points = points
  this.ids = ids
  this.dimension = d
  this.length = n
}

var proto = KDTree.prototype

proto.serialize = function() {
  if(this.length > 0) {
    return {
      p: Array.prototype.slice.call(this.points.data, 0, this.length*this.dimension),
      i: Array.prototype.slice.call(this.ids, 0, this.length)
    }
  } else {
    return { d: this.dimension }
  }
}

//Range query
proto.range = function kdtRangeQuery(lo, hi, visit) {
  var n = this.length
  if(n < 1) {
    return
  }

  //Check degenerate case
  var d = this.dimension
  for(var i=0; i<d; ++i) {
    if(hi[i] < lo[i]) {
      return
    }
  }

  var points = this.points
  var ids = this.ids

  //Walk tree in level order, skipping subtrees which do not intersect range
  var visitRange = ndscratch.malloc([n, 2, d])
  var visitIndex = pool.mallocInt32(n)
  var rangeData = visitRange.data
  var pointData = points.data
  var visitCount = 1
  var visitTop = 0
  var retval

  visitIndex[0] = 0
  pack(lo, visitRange.pick(0,0))
  pack(hi, visitRange.pick(0,1))
  
  while(visitTop < visitCount) {
    var idx = visitIndex[visitTop]
    var k = bits.log2(idx+1)%d
    var loidx = visitRange.index(visitTop, 0, 0)
    var hiidx = visitRange.index(visitTop, 1, 0)
    var pidx = points.index(idx, 0)

    var visitPoint = true
    for(var i=0; i<d; ++i) {
      var pc = pointData[pidx+i]
      if((pc < rangeData[loidx + i]) || 
         (rangeData[hiidx + i] < pc)) {
        visitPoint = false
        break
      }
    }
    if(visitPoint) {
      retval = visit(ids[idx])
      if(retval !== undefined) {
        break
      }
    }

    //Visit children
    var pk = pointData[pidx+k]
    var hk = rangeData[hiidx+k]
    var lk = rangeData[loidx+k]
    if(lk <= pk) {
      var left = 2 * idx + 1
      if(left < n) {
        visitIndex[visitCount] = left
        var y = visitRange.index(visitCount, 0, 0)
        for(var i=0; i<d; ++i) {
          rangeData[y+i] = rangeData[loidx+i]
        }
        var z = visitRange.index(visitCount, 1, 0)
        for(var i=0; i<d; ++i) {
          rangeData[z+i] = rangeData[hiidx+i]
        }
        rangeData[z+k] = Math.min(hk, pk)
        visitCount += 1
      }
    }
    if(pk <= hk) {
      var right = 2 * (idx + 1)
      if(right < n) {
        visitIndex[visitCount] = right
        var y = visitRange.index(visitCount, 0, 0)
        for(var i=0; i<d; ++i) {
          rangeData[y+i] = rangeData[loidx+i]
        }
        var z = visitRange.index(visitCount, 1, 0)
        for(var i=0; i<d; ++i) {
          rangeData[z+i] = rangeData[hiidx+i]
        }
        rangeData[y+k] = Math.max(lk, pk)
        visitCount += 1
      }
    }

    //Increment pointer
    visitTop += 1
  }
  ndscratch.free(visitRange)
  pool.free(visitIndex)
  return retval
}

proto.rnn = function(point, radius, visit) {
  if(radius < 0) {
    return
  }
  var n = this.length
  if(n < 1) {
    return
  }
  var d = this.dimension
  var points = this.points
  var ids = this.ids

  //Walk tree in level order, skipping subtrees which do not intersect sphere
  var visitDistance = ndscratch.malloc([n, d])
  var visitIndex = pool.mallocInt32(n)
  var distanceData = visitDistance.data
  var pointData = points.data
  var visitCount = 1
  var visitTop = 0
  var r2 = radius*radius
  var retval

  //Initialize top of queue
  visitIndex[0] = 0
  for(var i=0; i<d; ++i) {
    visitDistance.set(0, i, 0)
  }

  //Walk over queue
  while(visitTop < visitCount) {
    var idx = visitIndex[visitTop]
    var pidx = points.index(idx, 0)

    //Check if point in sphere
    var d2 = 0.0
    for(var i=0; i<d; ++i) {
      d2 += Math.pow(point[i] - pointData[pidx+i], 2)
    }
    if(d2 <= r2) {
      retval = visit(ids[idx])
      if(retval !== undefined) {
        break
      }
    }

    //Visit children
    var k = bits.log2(idx+1)%d
    var ds = 0.0
    var didx = visitDistance.index(visitTop, 0)
    for(var i=0; i<d; ++i) {
      if(i !== k) {
        ds += distanceData[didx + i]
      }
    }

    //Handle split axis
    var qk = point[k]
    var pk = pointData[pidx+k]
    var dk = distanceData[didx+k]
    var lk = dk
    var hk = dk
    if(qk < pk) {
      hk = Math.max(dk, Math.pow(pk - qk, 2))
    } else {
      lk = Math.max(dk, Math.pow(pk - qk, 2))
    }

    var d2l = lk + ds
    var d2h = hk + ds

    if(d2l <= r2) {
      var left = 2 * idx + 1
      if(left < n) {
        visitIndex[visitCount] = left
        var y = visitDistance.index(visitCount, 0)
        for(var i=0; i<d; ++i) {
          distanceData[y+i] = distanceData[didx+i]
        }
        distanceData[y+k] = lk
        visitCount += 1
      }
    }
    if(d2h <= r2) {
      var right = 2 * (idx + 1)
      if(right < n) {
        visitIndex[visitCount] = right
        var y = visitDistance.index(visitCount, 0)
        for(var i=0; i<d; ++i) {
          distanceData[y+i] = distanceData[didx+i]
        }
        distanceData[y+k] = hk
        visitCount += 1
      }
    }

    //Increment pointer
    visitTop += 1
  }

  ndscratch.free(visitDistance)
  pool.free(visitIndex)
  return retval
}

proto.nn = function(point, maxDistance) {
  var n = this.length
  if(n < 1) {
    return -1
  }
  if(typeof maxDistance === "number") {
    if(maxDistance < 0) {
      return -1
    } 
  } else {
    maxDistance = Infinity
  }
  var d = this.dimension
  var points = this.points
  var pointData = points.data
  var dataVector = pool.mallocFloat64(d)

  var toVisit = new KDTHeap(n, d+1)
  var index = toVisit.index
  var data = toVisit.data
  index[0] = 0
  for(var i=0; i<=d; ++i) {
    data[i] = 0
  }
  toVisit.count += 1

  var nearest = -1
  var nearestD = maxDistance

  while(toVisit.count > 0) {
    if(data[0] >= nearestD) {
      break
    }

    var idx = index[0]
    var pidx = points.index(idx, 0)
    var d2 = 0.0
    for(var i=0; i<d; ++i) {
      d2 += Math.pow(point[i]-pointData[pidx+i], 2)
    }
    if(d2 < nearestD) {
      nearestD = d2
      nearest = idx
    }

    //Compute distance bounds for children
    var k = bits.log2(idx+1)%d
    var ds = 0
    for(var i=0; i<d; ++i) {
      var dd = data[i+1]
      if(i !== k) {
        ds += dd
      }
      dataVector[i] = dd
    }
    var qk = point[k]
    var pk = pointData[pidx+k]
    var dk = dataVector[k]
    var lk = dk
    var hk = dk
    if(qk < pk) {
      hk = Math.max(dk, Math.pow(pk - qk, 2))
    } else {
      lk = Math.max(dk, Math.pow(pk - qk, 2))
    }
    var d2l = lk + ds
    var d2h = hk + ds

    toVisit.pop()
    
    if(d2l < nearestD) {
      var left = 2 * idx + 1
      if(left < n) {
        var vcount = toVisit.count
        index[vcount] = left
        var vptr = vcount * (d+1)
        data[vptr] = d2l
        for(var i=1; i<=d; ++i) {
          data[vptr+i] = dataVector[i-1]
        }
        data[vptr+k+1] = lk
        toVisit.push()
      }
    }
    if(d2h < nearestD) {
      var right = 2 * (idx + 1)
      if(right < n) {
        var vcount = toVisit.count
        index[vcount] = right
        var vptr = vcount * (d+1)
        data[vptr] = d2h
        for(var i=1; i<=d; ++i) {
          data[vptr+i] = dataVector[i-1]
        }
        data[vptr+k+1] = hk
        toVisit.push()
      }
    }
  }

  pool.freeFloat64(dataVector)
  toVisit.dispose()
  
  if(nearest < 0) {
    return -1
  }
  return this.ids[nearest]
}

proto.knn = function(point, maxPoints, maxDistance) {
  //Check degenerate cases
  if(typeof maxDistance === "number") {
    if(maxDistance < 0) {
      return []
    }
  } else {
    maxDistance = Infinity
  }
  var n = this.length
  if(n < 1) {
    return []
  }
  if(typeof maxPoints === "number") {
    if(maxPoints <= 0) {
      return []
    }
    maxPoints = Math.min(maxPoints, n)|0
  } else {
    maxPoints = n
  }
  var ids = this.ids

  var d = this.dimension
  var points = this.points
  var pointData = points.data
  var dataVector = pool.mallocFloat64(d)
  
  //List of closest points
  var closestPoints = new KDTHeap(maxPoints, 1)
  var cl_index = closestPoints.index
  var cl_data = closestPoints.data

  var toVisit = new KDTHeap(n, d+1)
  var index = toVisit.index
  var data = toVisit.data
  index[0] = 0
  for(var i=0; i<=d; ++i) {
    data[i] = 0
  }
  toVisit.count += 1

  var nearest = -1
  var nearestD = maxDistance

  while(toVisit.count > 0) {
    if(data[0] >= nearestD) {
      break
    }

    var idx = index[0]
    var pidx = points.index(idx, 0)
    var d2 = 0.0
    for(var i=0; i<d; ++i) {
      d2 += Math.pow(point[i]-pointData[pidx+i], 2)
    }
    if(d2 < nearestD) {
      if(closestPoints.count >= maxPoints) {
        closestPoints.pop()
      }
      var pcount = closestPoints.count
      cl_index[pcount] = idx
      cl_data[pcount] = -d2
      closestPoints.push()
      if(closestPoints.count >= maxPoints) {
        nearestD = -cl_data[0]
      }
    }

    //Compute distance bounds for children
    var k = bits.log2(idx+1)%d
    var ds = 0
    for(var i=0; i<d; ++i) {
      var dd = data[i+1]
      if(i !== k) {
        ds += dd
      }
      dataVector[i] = dd
    }
    var qk = point[k]
    var pk = pointData[pidx+k]
    var dk = dataVector[k]
    var lk = dk
    var hk = dk
    if(qk < pk) {
      hk = Math.max(dk, Math.pow(pk - qk, 2))
    } else {
      lk = Math.max(dk, Math.pow(pk - qk, 2))
    }
    var d2l = lk + ds
    var d2h = hk + ds

    toVisit.pop()
    if(d2l < nearestD) {
      var left = 2 * idx + 1
      if(left < n) {
        var vcount = toVisit.count
        index[vcount] = left
        var vptr = vcount * (d+1)
        data[vptr] = d2l
        for(var i=1; i<=d; ++i) {
          data[vptr+i] = dataVector[i-1]
        }
        data[vptr+k+1] = lk
        toVisit.push()
      }
    }
    if(d2h < nearestD) {
      var right = 2 * (idx + 1)
      if(right < n) {
        var vcount = toVisit.count
        index[vcount] = right
        var vptr = vcount * (d+1)
        data[vptr] = d2h
        for(var i=1; i<=d; ++i) {
          data[vptr+i] = dataVector[i-1]
        }
        data[vptr+k+1] = hk
        toVisit.push()
      }
    }
  }

  pool.freeFloat64(dataVector)
  toVisit.dispose()

  //Sort result
  var result = new Array(closestPoints.count)
  var ids = this.ids
  for(var i=closestPoints.count-1; i>=0; --i) {
    result[i] = ids[cl_index[0]]
    closestPoints.pop()
  }
  closestPoints.dispose()

  return result
}

proto.dispose = function kdtDispose() {
  pool.free(this.points.data)
  pool.freeInt32(this.ids)
  this.points = null
  this.ids = null
  this.length = 0
}

function createKDTree(points) {
  var n, d, indexed
  if(Array.isArray(points)) {
    n = points.length
    if(n === 0) {
      return new KDTree(null, null, 0, 0)
    }
    d = points[0].length
    indexed = ndarray(pool.mallocDouble(n*(d+1)), [n, d+1])
    pack(points, indexed.hi(n, d))
  } else {
    n = points.shape[0]
    d = points.shape[1]

    //Round up data type size
    var type = points.dtype
    if(type === "int8" ||
       type === "int16" ||
       type === "int32" ) {
      type = "int32"
    } else if(type === "uint8" ||
      type === "uint8_clamped" ||
      type === "buffer" ||
      type === "uint16" ||
      type === "uint32") {
      type = "uint32"
    } else if(type === "float32") {
      type = "float32"
    } else {
      type = "float64"
    }
    indexed = ndarray(pool.malloc(n*(d+1)), [n, d+1])
    ops.assign(indexed.hi(n,d), points)
  }
  for(var i=0; i<n; ++i) {
    indexed.set(i, d, i)
  }

  var pointArray = ndscratch.malloc([n, d], points.dtype)
  var indexArray = pool.mallocInt32(n)
  var pointer = 0
  var pointData = pointArray.data
  var arrayData = indexed.data
  var l2_n = bits.log2(bits.nextPow2(n))

  var sel_cmp = ndselect.compile(indexed.order, true, indexed.dtype)

  //Walk tree in level order
  var toVisit = [indexed]
  while(pointer < n) {
    var head = toVisit.shift()
    var array = head
    var nn = array.shape[0]|0
    
    //Find median
    if(nn > 1) {
      var k = bits.log2(pointer+1)%d
      var median
      var n_2 = inorderTree.root(nn)
      median = sel_cmp(array, n_2, function(a,b) {
        return a.get(k) - b.get(k)
      })

      //Copy into new array
      var pptr = pointArray.index(pointer, 0)
      var mptr = median.offset
      for(var i=0; i<d; ++i) {
        pointData[pptr++] = arrayData[mptr++]
      }
      indexArray[pointer] = arrayData[mptr]
      pointer += 1

      //Queue new items
      toVisit.push(array.hi(n_2))
      if(nn > 2) {
        toVisit.push(array.lo(n_2+1))
      }
    } else {
      //Copy into new array
      var mptr = array.offset
      var pptr = pointArray.index(pointer, 0)
      for(var i=0; i<d; ++i) {
        pointData[pptr+i] = arrayData[mptr++]
      }
      indexArray[pointer] = arrayData[mptr]
      pointer += 1
    }
  }

  //Release indexed
  pool.free(indexed.data)

  return new KDTree(pointArray, indexArray, n, d)
}

function deserializeKDTree(data) {
  var points = data.p
  var ids = data.i
  if(points) {
    var nd = points.length
    var pointArray = pool.mallocFloat64(nd)
    for(var i=0; i<nd; ++i) {
      pointArray[i] = points[i]
    }
    var n = ids.length
    var idArray = pool.mallocInt32(n)
    for(var i=0; i<n; ++i) {
      idArray[i] = ids[i]
    }
    var d = (nd/n)|0
    return new KDTree(
      ndarray(pointArray, [n,d]),
      idArray,
      n,
      d)
  } else {
    return new KDTree(null, null, 0, data.d)
  }
}
},{"./lib/heap.js":244,"bit-twiddle":245,"inorder-tree-layout":246,"ndarray":261,"ndarray-ops":248,"ndarray-pack":253,"ndarray-scratch":259,"ndarray-select":260,"typedarray-pool":264}],244:[function(require,module,exports){
"use strict"

module.exports = KDTHeap

var pool = require("typedarray-pool")

function heapParent(i) {
  if(i & 1) {
    return (i - 1) >> 1
  }
  return (i >> 1) - 1
}

function KDTHeap(n, d) {
  this.count = 0
  this.dataSize = d
  this.index = pool.mallocInt32(n)
  this.data = pool.mallocFloat64(n*d)
}

var proto = KDTHeap.prototype

proto.heapSwap = function(_i,_j) {
  var data = this.data
  var index = this.index
  var d = this.dataSize
  var tmp = index[_i]
  index[_i] = index[_j]
  index[_j] = tmp
  var aptr = d*_i
  var bptr = d*_j
  for(var _k=0; _k<d; ++_k) {
    var t2 = data[aptr]
    data[aptr] = data[bptr]
    data[bptr] = t2
    aptr += 1
    bptr += 1
  }
}

proto.heapUp = function(i) {
  var d = this.dataSize
  var index = this.index
  var data = this.data
  var w = data[d*i]
  while(i>0) {
    var parent = heapParent(i)
    if(parent >= 0) {
      var pw = data[d*parent]
      if(w < pw) {
        this.heapSwap(i, parent)
        i = parent
        continue
      }
    }
    break
  }
}

proto.heapDown = function(i) {
  var d = this.dataSize
  var index = this.index
  var data = this.data
  var count = this.count
  var w = data[d*i]
  while(true) {
    var tw = w
    var left  = 2*i + 1
    var right = 2*(i + 1)
    var next = i
    if(left < count) {
      var lw = data[d*left]
      if(lw < tw) {
        next = left
        tw = lw
      }
    }
    if(right < count) {
      var rw = data[d*right]
      if(rw < tw) {
        next = right
      }
    }
    if(next === i) {
      break
    }
    this.heapSwap(i, next)
    i = next      
  }
}

//Clear item from top of heap
proto.pop = function() {
  this.count -= 1
  this.heapSwap(0, this.count)
  this.heapDown(0)
}

//Assume object already written to data
proto.push = function() {
  this.heapUp(this.count)
  this.count += 1
}

proto.dispose = function() {
  pool.freeInt32(this.index)
  pool.freeFloat64(this.data)
}
},{"typedarray-pool":264}],245:[function(require,module,exports){
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

"use strict"; "use restrict";

//Number of bits in an integer
var INT_BITS = 32;

//Constants
exports.INT_BITS  = INT_BITS;
exports.INT_MAX   =  0x7fffffff;
exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
  return (v > 0) - (v < 0);
}

//Computes absolute value of integer
exports.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

//Computes minimum of integers x and y
exports.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

//Computes maximum of integers x and y
exports.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

//Checks if a number is a power of two
exports.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
}

//Computes log base 2 of v
exports.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

//Computes log base 10 of v
exports.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

//Counts number of bits
exports.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

//Computes parity of word
exports.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
}

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
}

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}


},{}],246:[function(require,module,exports){
"use strict"

var bits = require("bit-twiddle")

function rootInorder(n) {
  var ptree = (bits.nextPow2(n+1)>>>1) - 1
  var f     = n - ptree
  if(bits.nextPow2(f)-1 >= ptree) {
    return ptree
  }
  return (ptree>>>1)+f
}
exports.root = rootInorder

function beginInorder(n) {
  return 0
}
exports.begin = beginInorder

function endInorder(n) {
  return n-1
}
exports.end = endInorder


//This is really horrible because n is not necessarily a power of 2
// If it was, we could just do:
//
//    height = bits.countTrailingZeros(~x)
//
// Instead, we just binary search because doing the right thing here is way too complicated.
function heightInorder(n, x) {
  if(n <= 0) {
    return 0
  }
  var r = rootInorder(n)
  if(x > r) {
    return heightInorder(n-r-1, x-r-1)
  } else if(x === r) {
    return bits.log2(n)
  }
  return heightInorder(r, x)
}
exports.height = heightInorder

function prevInorder(n, x) {
  return Math.max(x-1,0)
}
exports.prev = prevInorder

function nextInorder(n, x) {
  return Math.min(x+1,n-1)
}
exports.next = nextInorder


//The version for n = (1<<k)-1:
//
//  parent = (x & ~(1<<(h+1))) + (1<<h)
//
function parentInorder(n, x) {
  if(n <= 0) {
    return -1
  }
  var r = rootInorder(n)
  if(x > r) {
    var q = parentInorder(n-r-1, x-r-1)
    if(q < 0) {
      return r
    } else {
      return q + r + 1
    }
  } else if(x === r) {
    return -1
  }
  var q =  parentInorder(r, x)
  if(q < 0) {
    return r
  }
  return q
}
exports.parent = parentInorder


//Again, we get screwed because n is not a power of two -1.  If it was, we could do:
//
//    left = x - (1 << (h-1) )
//
// Where h is the height of the node
//
function leftInorder(n, x) {
  if(n <= 0) {
    return 0
  }
  var r = rootInorder(n)
  if(x > r) {
    return leftInorder(n-r-1, x-r-1) + r + 1
  } else if(x === r) {
    return rootInorder(x)
  }
  return leftInorder(r, x)

}
exports.left = leftInorder

//for power of two minus one:
//
//    right = x + (1<<(h-1))
//
function rightInorder(n, x) {
  if(n <= 0) {
    return 0
  }
  var r = rootInorder(n)
  if(x > r) {
    return rightInorder(n-r-1, x-r-1) + r + 1
  } else if(x === r) {
    return rootInorder(n-r-1) + r + 1
  }
  return rightInorder(r, x)
}
exports.right = rightInorder


function leafInorder(n, x) {
  return heightInorder(n, x) === 0
}
exports.leaf = leafInorder


function loInorder(n, x) {
  n |= 0
  x |= 0
  var l = 0
  while(n > 1) {
    var r = rootInorder(n)
    if(x > r) {
      l += r + 1
      n -= r + 1
      x -= r + 1
    } else if(x === r) {
      break
    } else {
      n = r
    }
  }
  return l
}
exports.lo = loInorder

function hiInorder(n, x) {
  n |= 0
  x |= 0
  var l = 0
  while(n > 1) {
    var r = rootInorder(n)
    if(x > r) {
      l += r + 1
      n -= r + 1
      x -= r + 1
    } else if(x === r) {
      l += n-1
      break
    } else {
      n = r
    }
  }
  return l
}
exports.hi = hiInorder

},{"bit-twiddle":247}],247:[function(require,module,exports){
module.exports=require(245)
},{}],248:[function(require,module,exports){
"use strict"

var compile = require("cwise-compiler")

var EmptyProc = {
  body: "",
  args: [],
  thisVars: [],
  localVars: []
}

function fixup(x) {
  if(!x) {
    return EmptyProc
  }
  for(var i=0; i<x.args.length; ++i) {
    var a = x.args[i]
    if(i === 0) {
      x.args[i] = {name: a, lvalue:true, rvalue: !!x.rvalue, count:x.count||1 }
    } else {
      x.args[i] = {name: a, lvalue:false, rvalue:true, count: 1}
    }
  }
  if(!x.thisVars) {
    x.thisVars = []
  }
  if(!x.localVars) {
    x.localVars = []
  }
  return x
}

function pcompile(user_args) {
  return compile({
    args:     user_args.args,
    pre:      fixup(user_args.pre),
    body:     fixup(user_args.body),
    post:     fixup(user_args.proc),
    funcName: user_args.funcName
  })
}

function makeOp(user_args) {
  var args = []
  for(var i=0; i<user_args.args.length; ++i) {
    args.push("a"+i)
  }
  var wrapper = new Function("P", [
    "return function ", user_args.funcName, "_ndarrayops(", args.join(","), ") {P(", args.join(","), ");return a0}"
  ].join(""))
  return wrapper(pcompile(user_args))
}

var assign_ops = {
  add:  "+",
  sub:  "-",
  mul:  "*",
  div:  "/",
  mod:  "%",
  band: "&",
  bor:  "|",
  bxor: "^",
  lshift: "<<",
  rshift: ">>",
  rrshift: ">>>"
}
;(function(){
  for(var id in assign_ops) {
    var op = assign_ops[id]
    exports[id] = makeOp({
      args: ["array","array","array"],
      body: {args:["a","b","c"],
             body: "a=b"+op+"c"},
      funcName: id
    })
    exports[id+"eq"] = makeOp({
      args: ["array","array"],
      body: {args:["a","b"],
             body:"a"+op+"=b"},
      rvalue: true,
      funcName: id+"eq"
    })
    exports[id+"s"] = makeOp({
      args: ["array", "array", "scalar"],
      body: {args:["a","b","s"],
             body:"a=b"+op+"s"},
      funcName: id+"s"
    })
    exports[id+"seq"] = makeOp({
      args: ["array","scalar"],
      body: {args:["a","s"],
             body:"a"+op+"=s"},
      rvalue: true,
      funcName: id+"seq"
    })
  }
})();

var unary_ops = {
  not: "!",
  bnot: "~",
  neg: "-",
  recip: "1.0/"
}
;(function(){
  for(var id in unary_ops) {
    var op = unary_ops[id]
    exports[id] = makeOp({
      args: ["array", "array"],
      body: {args:["a","b"],
             body:"a="+op+"b"},
      funcName: id
    })
    exports[id+"eq"] = makeOp({
      args: ["array"],
      body: {args:["a"],
             body:"a="+op+"a"},
      rvalue: true,
      count: 2,
      funcName: id+"eq"
    })
  }
})();

var binary_ops = {
  and: "&&",
  or: "||",
  eq: "===",
  neq: "!==",
  lt: "<",
  gt: ">",
  leq: "<=",
  geq: ">="
}
;(function() {
  for(var id in binary_ops) {
    var op = binary_ops[id]
    exports[id] = makeOp({
      args: ["array","array","array"],
      body: {args:["a", "b", "c"],
             body:"a=b"+op+"c"},
      funcName: id
    })
    exports[id+"s"] = makeOp({
      args: ["array","array","scalar"],
      body: {args:["a", "b", "s"],
             body:"a=b"+op+"s"},
      funcName: id+"s"
    })
    exports[id+"eq"] = makeOp({
      args: ["array", "array"],
      body: {args:["a", "b"],
             body:"a=a"+op+"b"},
      rvalue:true,
      count:2,
      funcName: id+"eq"
    })
    exports[id+"seq"] = makeOp({
      args: ["array", "scalar"],
      body: {args:["a","s"],
             body:"a=a"+op+"s"},
      rvalue:true,
      count:2,
      funcName: id+"seq"
    })
  }
})();

var math_unary = [
  "abs",
  "acos",
  "asin",
  "atan",
  "ceil",
  "cos",
  "exp",
  "floor",
  "log",
  "round",
  "sin",
  "sqrt",
  "tan"
]
;(function() {
  for(var i=0; i<math_unary.length; ++i) {
    var f = math_unary[i]
    exports[f] = makeOp({
                    args: ["array", "array"],
                    pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                    body: {args:["a","b"], body:"a=this_f(b)", thisVars:["this_f"]},
                    funcName: f
                  })
    exports[f+"eq"] = makeOp({
                      args: ["array"],
                      pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                      body: {args: ["a"], body:"a=this_f(a)", thisVars:["this_f"]},
                      rvalue: true,
                      count: 2,
                      funcName: f+"eq"
                    })
  }
})();

var math_comm = [
  "max",
  "min",
  "atan2",
  "pow"
]
;(function(){
  for(var i=0; i<math_comm.length; ++i) {
    var f= math_comm[i]
    exports[f] = makeOp({
                  args:["array", "array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(b,c)", thisVars:["this_f"]},
                  funcName: f
                })
    exports[f+"s"] = makeOp({
                  args:["array", "array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(b,c)", thisVars:["this_f"]},
                  funcName: f+"s"
                  })
    exports[f+"eq"] = makeOp({ args:["array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(a,b)", thisVars:["this_f"]},
                  rvalue: true,
                  count: 2,
                  funcName: f+"eq"
                  })
    exports[f+"seq"] = makeOp({ args:["array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(a,b)", thisVars:["this_f"]},
                  rvalue:true,
                  count:2,
                  funcName: f+"seq"
                  })
  }
})();

var math_noncomm = [
  "atan2",
  "pow"
]
;(function(){
  for(var i=0; i<math_noncomm.length; ++i) {
    var f= math_noncomm[i]
    exports[f+"op"] = makeOp({
                  args:["array", "array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(c,b)", thisVars:["this_f"]},
                  funcName: f+"op"
                })
    exports[f+"ops"] = makeOp({
                  args:["array", "array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(c,b)", thisVars:["this_f"]},
                  funcName: f+"ops"
                  })
    exports[f+"opeq"] = makeOp({ args:["array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(b,a)", thisVars:["this_f"]},
                  rvalue: true,
                  count: 2,
                  funcName: f+"opeq"
                  })
    exports[f+"opseq"] = makeOp({ args:["array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(b,a)", thisVars:["this_f"]},
                  rvalue:true,
                  count:2,
                  funcName: f+"opseq"
                  })
  }
})();

exports.any = compile({
  args:["array"],
  pre: EmptyProc,
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "if(a){return true}", localVars: [], thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return false"},
  funcName: "any"
})

exports.all = compile({
  args:["array"],
  pre: EmptyProc,
  body: {args:[{name:"x", lvalue:false, rvalue:true, count:1}], body: "if(!x){return false}", localVars: [], thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return true"},
  funcName: "all"
})

exports.sum = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "this_s+=a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "sum"
})

exports.prod = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=1"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "this_s*=a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "prod"
})

exports.norm2squared = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:2}], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norm2squared"
})
  
exports.norm2 = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:2}], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return Math.sqrt(this_s)"},
  funcName: "norm2"
})
  

exports.norminf = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:4}], body:"if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norminf"
})

exports.norm1 = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:3}], body: "this_s+=a<0?-a:a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norm1"
})

exports.sup = compile({
  args: [ "array" ],
  pre:
   { body: "this_h=-Infinity",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] },
  body:
   { body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
     args: [{"name":"_inline_1_arg0_","lvalue":false,"rvalue":true,"count":2} ],
     thisVars: [ "this_h" ],
     localVars: [] },
  post:
   { body: "return this_h",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] }
 })

exports.inf = compile({
  args: [ "array" ],
  pre:
   { body: "this_h=Infinity",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] },
  body:
   { body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
     args: [{"name":"_inline_1_arg0_","lvalue":false,"rvalue":true,"count":2} ],
     thisVars: [ "this_h" ],
     localVars: [] },
  post:
   { body: "return this_h",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] }
 })

exports.argmin = compile({
  args:["index","array","shape"],
  pre:{
    body:"{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
    args:[
      {name:"_inline_0_arg0_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg1_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg2_",lvalue:false,rvalue:true,count:1}
      ],
    thisVars:["this_i","this_v"],
    localVars:[]},
  body:{
    body:"{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
    args:[
      {name:"_inline_1_arg0_",lvalue:false,rvalue:true,count:2},
      {name:"_inline_1_arg1_",lvalue:false,rvalue:true,count:2}],
    thisVars:["this_i","this_v"],
    localVars:["_inline_1_k"]},
  post:{
    body:"{return this_i}",
    args:[],
    thisVars:["this_i"],
    localVars:[]}
})

exports.argmax = compile({
  args:["index","array","shape"],
  pre:{
    body:"{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
    args:[
      {name:"_inline_0_arg0_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg1_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg2_",lvalue:false,rvalue:true,count:1}
      ],
    thisVars:["this_i","this_v"],
    localVars:[]},
  body:{
    body:"{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
    args:[
      {name:"_inline_1_arg0_",lvalue:false,rvalue:true,count:2},
      {name:"_inline_1_arg1_",lvalue:false,rvalue:true,count:2}],
    thisVars:["this_i","this_v"],
    localVars:["_inline_1_k"]},
  post:{
    body:"{return this_i}",
    args:[],
    thisVars:["this_i"],
    localVars:[]}
})  

exports.random = makeOp({
  args: ["array"],
  pre: {args:[], body:"this_f=Math.random", thisVars:["this_f"]},
  body: {args: ["a"], body:"a=this_f()", thisVars:["this_f"]},
  funcName: "random"
})

exports.assign = makeOp({
  args:["array", "array"],
  body: {args:["a", "b"], body:"a=b"},
  funcName: "assign" })

exports.assigns = makeOp({
  args:["array", "scalar"],
  body: {args:["a", "b"], body:"a=b"},
  funcName: "assigns" })


exports.equals = compile({
  args:["array", "array"],
  pre: EmptyProc,
  body: {args:[{name:"x", lvalue:false, rvalue:true, count:1},
               {name:"y", lvalue:false, rvalue:true, count:1}], 
        body: "if(x!==y){return false}", 
        localVars: [], 
        thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return true"},
  funcName: "equals"
})



},{"cwise-compiler":249}],249:[function(require,module,exports){
"use strict"

var createThunk = require("./lib/thunk.js")

function Procedure() {
  this.argTypes = []
  this.shimArgs = []
  this.arrayArgs = []
  this.scalarArgs = []
  this.offsetArgs = []
  this.offsetArgIndex = []
  this.indexArgs = []
  this.shapeArgs = []
  this.funcName = ""
  this.pre = null
  this.body = null
  this.post = null
  this.debug = false
}

function compileCwise(user_args) {
  //Create procedure
  var proc = new Procedure()
  
  //Parse blocks
  proc.pre    = user_args.pre
  proc.body   = user_args.body
  proc.post   = user_args.post

  //Parse arguments
  var proc_args = user_args.args.slice(0)
  proc.argTypes = proc_args
  for(var i=0; i<proc_args.length; ++i) {
    var arg_type = proc_args[i]
    if(arg_type === "array") {
      proc.arrayArgs.push(i)
      proc.shimArgs.push("array" + i)
      if(i < proc.pre.args.length && proc.pre.args[i].count>0) {
        throw new Error("cwise: pre() block may not reference array args")
      }
      if(i < proc.post.args.length && proc.post.args[i].count>0) {
        throw new Error("cwise: post() block may not reference array args")
      }
    } else if(arg_type === "scalar") {
      proc.scalarArgs.push(i)
      proc.shimArgs.push("scalar" + i)
    } else if(arg_type === "index") {
      proc.indexArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {
        throw new Error("cwise: pre() block may not reference array index")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array index")
      }
      if(i < proc.post.args.length && proc.post.args[i].count > 0) {
        throw new Error("cwise: post() block may not reference array index")
      }
    } else if(arg_type === "shape") {
      proc.shapeArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {
        throw new Error("cwise: pre() block may not write to array shape")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array shape")
      }
      if(i < proc.post.args.length && proc.post.args[i].lvalue) {
        throw new Error("cwise: post() block may not write to array shape")
      }
    } else if(typeof arg_type === "object" && arg_type.offset) {
      proc.argTypes[i] = "offset"
      proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset })
      proc.offsetArgIndex.push(i)
    } else {
      throw new Error("cwise: Unknown argument type " + proc_args[i])
    }
  }
  
  //Make sure at least one array argument was specified
  if(proc.arrayArgs.length <= 0) {
    throw new Error("cwise: No array arguments specified")
  }
  
  //Make sure arguments are correct
  if(proc.pre.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in pre() block")
  }
  if(proc.body.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in body() block")
  }
  if(proc.post.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in post() block")
  }

  //Check debug flag
  proc.debug = !!user_args.printCode || !!user_args.debug
  
  //Retrieve name
  proc.funcName = user_args.funcName || "cwise"
  
  //Read in block size
  proc.blockSize = user_args.blockSize || 64

  return createThunk(proc)
}

module.exports = compileCwise

},{"./lib/thunk.js":251}],250:[function(require,module,exports){
"use strict"

var uniq = require("uniq")

function innerFill(order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , has_index = proc.indexArgs.length>0
    , code = []
    , vars = []
    , idx=0, pidx=0, i, j
  for(i=0; i<dimension; ++i) {
    vars.push(["i",i,"=0"].join(""))
  }
  //Compute scan deltas
  for(j=0; j<nargs; ++j) {
    for(i=0; i<dimension; ++i) {
      pidx = idx
      idx = order[i]
      if(i === 0) {
        vars.push(["d",j,"s",i,"=t",j,"p",idx].join(""))
      } else {
        vars.push(["d",j,"s",i,"=(t",j,"p",idx,"-s",pidx,"*t",j,"p",pidx,")"].join(""))
      }
    }
  }
  code.push("var " + vars.join(","))
  //Scan loop
  for(i=dimension-1; i>=0; --i) {
    idx = order[i]
    code.push(["for(i",i,"=0;i",i,"<s",idx,";++i",i,"){"].join(""))
  }
  //Push body of inner loop
  code.push(body)
  //Advance scan pointers
  for(i=0; i<dimension; ++i) {
    pidx = idx
    idx = order[i]
    for(j=0; j<nargs; ++j) {
      code.push(["p",j,"+=d",j,"s",i].join(""))
    }
    if(has_index) {
      if(i > 0) {
        code.push(["index[",pidx,"]-=s",pidx].join(""))
      }
      code.push(["++index[",idx,"]"].join(""))
    }
    code.push("}")
  }
  return code.join("\n")
}

function outerFill(matched, order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , blockSize = proc.blockSize
    , has_index = proc.indexArgs.length > 0
    , code = []
  for(var i=0; i<nargs; ++i) {
    code.push(["var offset",i,"=p",i].join(""))
  }
  //Generate matched loops
  for(var i=matched; i<dimension; ++i) {
    code.push(["for(var j"+i+"=SS[", order[i], "]|0;j", i, ">0;){"].join(""))
    code.push(["if(j",i,"<",blockSize,"){"].join(""))
    code.push(["s",order[i],"=j",i].join(""))
    code.push(["j",i,"=0"].join(""))
    code.push(["}else{s",order[i],"=",blockSize].join(""))
    code.push(["j",i,"-=",blockSize,"}"].join(""))
    if(has_index) {
      code.push(["index[",order[i],"]=j",i].join(""))
    }
  }
  for(var i=0; i<nargs; ++i) {
    var indexStr = ["offset"+i]
    for(var j=matched; j<dimension; ++j) {
      indexStr.push(["j",j,"*t",i,"p",order[j]].join(""))
    }
    code.push(["p",i,"=(",indexStr.join("+"),")"].join(""))
  }
  code.push(innerFill(order, proc, body))
  for(var i=matched; i<dimension; ++i) {
    code.push("}")
  }
  return code.join("\n")
}

//Count the number of compatible inner orders
function countMatches(orders) {
  var matched = 0, dimension = orders[0].length
  while(matched < dimension) {
    for(var j=1; j<orders.length; ++j) {
      if(orders[j][matched] !== orders[0][matched]) {
        return matched
      }
    }
    ++matched
  }
  return matched
}

//Processes a block according to the given data types
function processBlock(block, proc, dtypes) {
  var code = block.body
  var pre = []
  var post = []
  for(var i=0; i<block.args.length; ++i) {
    var carg = block.args[i]
    if(carg.count <= 0) {
      continue
    }
    var re = new RegExp(carg.name, "g")
    var ptrStr = ""
    var arrNum = proc.arrayArgs.indexOf(i)
    switch(proc.argTypes[i]) {
      case "offset":
        var offArgIndex = proc.offsetArgIndex.indexOf(i)
        var offArg = proc.offsetArgs[offArgIndex]
        arrNum = offArg.array
        ptrStr = "+q" + offArgIndex
      case "array":
        ptrStr = "p" + arrNum + ptrStr
        var localStr = "l" + i
        var arrStr = "a" + arrNum
        if(carg.count === 1) {
          if(dtypes[arrNum] === "generic") {
            if(carg.lvalue) {
              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join(""))
              code = code.replace(re, localStr)
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            } else {
              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
            }
          } else {
            code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
          }
        } else if(dtypes[arrNum] === "generic") {
          pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join(""))
          code = code.replace(re, localStr)
          if(carg.lvalue) {
            post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
          }
        } else {
          pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join(""))
          code = code.replace(re, localStr)
          if(carg.lvalue) {
            post.push([arrStr, "[", ptrStr, "]=", localStr].join(""))
          }
        }
      break
      case "scalar":
        code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i))
      break
      case "index":
        code = code.replace(re, "index")
      break
      case "shape":
        code = code.replace(re, "shape")
      break
    }
  }
  return [pre.join("\n"), code, post.join("\n")].join("\n").trim()
}

function typeSummary(dtypes) {
  var summary = new Array(dtypes.length)
  var allEqual = true
  for(var i=0; i<dtypes.length; ++i) {
    var t = dtypes[i]
    var digits = t.match(/\d+/)
    if(!digits) {
      digits = ""
    } else {
      digits = digits[0]
    }
    if(t.charAt(0) === 0) {
      summary[i] = "u" + t.charAt(1) + digits
    } else {
      summary[i] = t.charAt(0) + digits
    }
    if(i > 0) {
      allEqual = allEqual && summary[i] === summary[i-1]
    }
  }
  if(allEqual) {
    return summary[0]
  }
  return summary.join("")
}

//Generates a cwise operator
function generateCWiseOp(proc, typesig) {

  //Compute dimension
  var dimension = typesig[1].length|0
  var orders = new Array(proc.arrayArgs.length)
  var dtypes = new Array(proc.arrayArgs.length)

  //First create arguments for procedure
  var arglist = ["SS"]
  var code = ["'use strict'"]
  var vars = []
  
  for(var j=0; j<dimension; ++j) {
    vars.push(["s", j, "=SS[", j, "]"].join(""))
  }
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    arglist.push("a"+i)
    arglist.push("t"+i)
    arglist.push("p"+i)
    dtypes[i] = typesig[2*i]
    orders[i] = typesig[2*i+1]
    
    for(var j=0; j<dimension; ++j) {
      vars.push(["t",i,"p",j,"=t",i,"[",j,"]"].join(""))
    }
  }
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    arglist.push("Y" + i)
  }
  if(proc.shapeArgs.length > 0) {
    vars.push("shape=SS.slice(0)")
  }
  if(proc.indexArgs.length > 0) {
    var zeros = new Array(dimension)
    for(var i=0; i<dimension; ++i) {
      zeros[i] = "0"
    }
    vars.push(["index=[", zeros.join(","), "]"].join(""))
  }
  for(var i=0; i<proc.offsetArgs.length; ++i) {
    var off_arg = proc.offsetArgs[i]
    var init_string = []
    for(var j=0; j<off_arg.offset.length; ++j) {
      if(off_arg.offset[j] === 0) {
        continue
      } else if(off_arg.offset[j] === 1) {
        init_string.push(["t", off_arg.array, "p", j].join(""))      
      } else {
        init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""))
      }
    }
    if(init_string.length === 0) {
      vars.push("q" + i + "=0")
    } else {
      vars.push(["q", i, "=", init_string.join("+")].join(""))
    }
  }

  //Prepare this variables
  var thisVars = uniq([].concat(proc.pre.thisVars)
                      .concat(proc.body.thisVars)
                      .concat(proc.post.thisVars))
  vars = vars.concat(thisVars)
  code.push("var " + vars.join(","))
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    code.push("p"+i+"|=0")
  }
  
  //Inline prelude
  if(proc.pre.body.length > 3) {
    code.push(processBlock(proc.pre, proc, dtypes))
  }

  //Process body
  var body = processBlock(proc.body, proc, dtypes)
  var matched = countMatches(orders)
  if(matched < dimension) {
    code.push(outerFill(matched, orders[0], proc, body))
  } else {
    code.push(innerFill(orders[0], proc, body))
  }

  //Inline epilog
  if(proc.post.body.length > 3) {
    code.push(processBlock(proc.post, proc, dtypes))
  }
  
  if(proc.debug) {
    console.log("Generated cwise routine for ", typesig, ":\n\n", code.join("\n"))
  }
  
  var loopName = [(proc.funcName||"unnamed"), "_cwise_loop_", orders[0].join("s"),"m",matched,typeSummary(dtypes)].join("")
  var f = new Function(["function ",loopName,"(", arglist.join(","),"){", code.join("\n"),"} return ", loopName].join(""))
  return f()
}
module.exports = generateCWiseOp
},{"uniq":252}],251:[function(require,module,exports){
"use strict"

var compile = require("./compile.js")

function createThunk(proc) {
  var code = ["'use strict'", "var CACHED={}"]
  var vars = []
  var thunkName = proc.funcName + "_cwise_thunk"
  
  //Build thunk
  code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""))
  var typesig = []
  var string_typesig = []
  var proc_args = [["array",proc.arrayArgs[0],".shape"].join("")]
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    var j = proc.arrayArgs[i]
    vars.push(["t", j, "=array", j, ".dtype,",
               "r", j, "=array", j, ".order"].join(""))
    typesig.push("t" + j)
    typesig.push("r" + j)
    string_typesig.push("t"+j)
    string_typesig.push("r"+j+".join()")
    proc_args.push("array" + j + ".data")
    proc_args.push("array" + j + ".stride")
    proc_args.push("array" + j + ".offset|0")
  }
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    proc_args.push("scalar" + proc.scalarArgs[i])
  }
  vars.push(["type=[", string_typesig.join(","), "].join()"].join(""))
  vars.push("proc=CACHED[type]")
  code.push("var " + vars.join(","))
  
  code.push(["if(!proc){",
             "CACHED[type]=proc=compile([", typesig.join(","), "])}",
             "return proc(", proc_args.join(","), ")}"].join(""))

  if(proc.debug) {
    console.log("Generated thunk:", code.join("\n"))
  }
  
  //Compile thunk
  var thunk = new Function("compile", code.join("\n"))
  return thunk(compile.bind(undefined, proc))
}

module.exports = createThunk

},{"./compile.js":250}],252:[function(require,module,exports){
"use strict"

function unique_pred(list, compare) {
  var ptr = 1
    , len = list.length
    , a=list[0], b=list[0]
  for(var i=1; i<len; ++i) {
    b = a
    a = list[i]
    if(compare(a, b)) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique_eq(list) {
  var ptr = 1
    , len = list.length
    , a=list[0], b = list[0]
  for(var i=1; i<len; ++i, b=a) {
    b = a
    a = list[i]
    if(a !== b) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique(list, compare, sorted) {
  if(list.length === 0) {
    return list
  }
  if(compare) {
    if(!sorted) {
      list.sort(compare)
    }
    return unique_pred(list, compare)
  }
  if(!sorted) {
    list.sort()
  }
  return unique_eq(list)
}

module.exports = unique

},{}],253:[function(require,module,exports){
"use strict"

var ndarray = require("ndarray")
var do_convert = require("./doConvert.js")

module.exports = function convert(arr, result) {
  var shape = [], c = arr, sz = 1
  while(c instanceof Array) {
    shape.push(c.length)
    sz *= c.length
    c = c[0]
  }
  if(shape.length === 0) {
    return ndarray()
  }
  if(!result) {
    result = ndarray(new Float64Array(sz), shape)
  }
  do_convert(result, arr)
  return result
}

},{"./doConvert.js":254,"ndarray":261}],254:[function(require,module,exports){
module.exports=require('cwise-compiler')({"args":["array","scalar","index"],"pre":{"body":"{}","args":[],"thisVars":[],"localVars":[]},"body":{"body":"{\nvar _inline_1_v=_inline_1_arg1_,_inline_1_i\nfor(_inline_1_i=0;_inline_1_i<_inline_1_arg2_.length-1;++_inline_1_i) {\n_inline_1_v=_inline_1_v[_inline_1_arg2_[_inline_1_i]]\n}\n_inline_1_arg0_=_inline_1_v[_inline_1_arg2_[_inline_1_arg2_.length-1]]\n}","args":[{"name":"_inline_1_arg0_","lvalue":true,"rvalue":false,"count":1},{"name":"_inline_1_arg1_","lvalue":false,"rvalue":true,"count":1},{"name":"_inline_1_arg2_","lvalue":false,"rvalue":true,"count":4}],"thisVars":[],"localVars":["_inline_1_i","_inline_1_v"]},"post":{"body":"{}","args":[],"thisVars":[],"localVars":[]},"funcName":"convert","blockSize":64})

},{"cwise-compiler":255}],255:[function(require,module,exports){
"use strict"

var createThunk = require("./lib/thunk.js")

function Procedure() {
  this.argTypes = []
  this.shimArgs = []
  this.arrayArgs = []
  this.scalarArgs = []
  this.offsetArgs = []
  this.offsetArgIndex = []
  this.indexArgs = []
  this.shapeArgs = []
  this.funcName = ""
  this.pre = null
  this.body = null
  this.post = null
  this.debug = false
}

function compileCwise(user_args) {
  //Create procedure
  var proc = new Procedure()
  
  //Parse blocks
  proc.pre    = user_args.pre
  proc.body   = user_args.body
  proc.post   = user_args.post

  //Parse arguments
  var proc_args = user_args.args.slice(0)
  proc.argTypes = proc_args.slice(0)
  for(var i=0; i<proc_args.length; ++i) {
    var arg_type = proc_args[i]
    if(arg_type === "array") {
      proc.arrayArgs.push(i)
      proc.shimArgs.push("array" + i)
      if(i < proc.pre.args.length && proc.pre.args[i].count>0) {
        throw new Error("cwise: pre() block may not reference array args")
      }
      if(i < proc.post.args.length && proc.post.args[i].count>0) {
        throw new Error("cwise: post() block may not reference array args")
      }
    } else if(arg_type === "scalar") {
      proc.scalarArgs.push(i)
      proc.shimArgs.push("scalar" + i)
    } else if(arg_type === "index") {
      proc.indexArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {
        throw new Error("cwise: pre() block may not reference array index")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array index")
      }
      if(i < proc.post.args.length && proc.post.args[i].count > 0) {
        throw new Error("cwise: post() block may not reference array index")
      }
    } else if(arg_type === "shape") {
      proc.shapeArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {
        throw new Error("cwise: pre() block may not write to array shape")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array shape")
      }
      if(i < proc.post.args.length && proc.post.args[i].lvalue) {
        throw new Error("cwise: post() block may not write to array shape")
      }
    } else if(typeof arg_type === "object" && arg_type.offset) {
      proc.argTypes[i] = "offset"
      proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset })
      proc.offsetArgIndex.push(i)
    } else {
      throw new Error("cwise: Unknown argument type " + proc_args[i])
    }
  }
  
  //Make sure at least one array argument was specified
  if(proc.arrayArgs.length <= 0) {
    throw new Error("cwise: No array arguments specified")
  }
  
  //Make sure arguments are correct
  if(proc.pre.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in pre() block")
  }
  if(proc.body.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in body() block")
  }
  if(proc.post.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in post() block")
  }

  //Check debug flag
  proc.debug = !!user_args.printCode || !!user_args.debug
  
  //Retrieve name
  proc.funcName = user_args.funcName || "cwise"
  
  //Read in block size
  proc.blockSize = user_args.blockSize || 64

  return createThunk(proc)
}

module.exports = compileCwise

},{"./lib/thunk.js":257}],256:[function(require,module,exports){
"use strict"

var uniq = require("uniq")

function innerFill(order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , has_index = proc.indexArgs.length>0
    , code = []
    , vars = []
    , idx=0, pidx=0, i, j
  for(i=0; i<dimension; ++i) {
    vars.push(["i",i,"=0"].join(""))
  }
  //Compute scan deltas
  for(j=0; j<nargs; ++j) {
    for(i=0; i<dimension; ++i) {
      pidx = idx
      idx = order[i]
      if(i === 0) {
        vars.push(["d",j,"s",i,"=t",j,"[",idx,"]"].join(""))
      } else {
        vars.push(["d",j,"s",i,"=(t",j,"[",idx,"]-s",pidx,"*t",j,"[",pidx,"])"].join(""))
      }
    }
  }
  code.push("var " + vars.join(","))
  //Scan loop
  for(i=dimension-1; i>=0; --i) {
    idx = order[i]
    code.push(["for(i",i,"=0;i",i,"<s",idx,";++i",i,"){"].join(""))
  }
  //Push body of inner loop
  code.push(body)
  //Advance scan pointers
  for(i=0; i<dimension; ++i) {
    pidx = idx
    idx = order[i]
    for(j=0; j<nargs; ++j) {
      code.push(["p",j,"+=d",j,"s",i].join(""))
    }
    if(has_index) {
      if(i > 0) {
        code.push(["index[",pidx,"]-=s",pidx].join(""))
      }
      code.push(["++index[",idx,"]"].join(""))
    }
    code.push("}")
  }
  return code.join("\n")
}

function outerFill(matched, order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , blockSize = proc.blockSize
    , has_index = proc.indexArgs.length > 0
    , code = []
  for(var i=0; i<nargs; ++i) {
    code.push(["var offset",i,"=p",i].join(""))
  }
  //Generate matched loops
  for(var i=matched; i<dimension; ++i) {
    code.push(["for(var j"+i+"=SS[", order[i], "]|0;j", i, ">0;){"].join(""))
    code.push(["if(j",i,"<",blockSize,"){"].join(""))
    code.push(["s",order[i],"=j",i].join(""))
    code.push(["j",i,"=0"].join(""))
    code.push(["}else{s",order[i],"=",blockSize].join(""))
    code.push(["j",i,"-=",blockSize,"}"].join(""))
    if(has_index) {
      code.push(["index[",order[i],"]=j",i].join(""))
    }
  }
  for(var i=0; i<nargs; ++i) {
    var indexStr = ["offset"+i]
    for(var j=matched; j<dimension; ++j) {
      indexStr.push(["j",j,"*t",i,"[",order[j],"]"].join(""))
    }
    code.push(["p",i,"=(",indexStr.join("+"),")"].join(""))
  }
  code.push(innerFill(order, proc, body))
  for(var i=matched; i<dimension; ++i) {
    code.push("}")
  }
  return code.join("\n")
}

//Count the number of compatible inner orders
function countMatches(orders) {
  var matched = 0, dimension = orders[0].length
  while(matched < dimension) {
    for(var j=1; j<orders.length; ++j) {
      if(orders[j][matched] !== orders[0][matched]) {
        return matched
      }
    }
    ++matched
  }
  return matched
}

//Processes a block according to the given data types
function processBlock(block, proc, dtypes) {
  var code = block.body
  var pre = []
  var post = []
  for(var i=0; i<block.args.length; ++i) {
    var carg = block.args[i]
    if(carg.count <= 0) {
      continue
    }
    var re = new RegExp(carg.name, "g")
    var ptrStr = ""
    var arrNum = proc.arrayArgs.indexOf(i)
    switch(proc.argTypes[i]) {
      case "offset":
        var offArgIndex = proc.offsetArgIndex.indexOf(i)
        var offArg = proc.offsetArgs[offArgIndex]
        arrNum = offArg.array
        ptrStr = "+q" + offArgIndex
      case "array":
        ptrStr = "p" + arrNum + ptrStr
        var localStr = "l" + i
        var arrStr = "a" + arrNum
        if(carg.count === 1) {
          if(dtypes[arrNum] === "generic") {
            if(carg.lvalue) {
              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join(""))
              code = code.replace(re, localStr)
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            } else {
              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
            }
          } else {
            code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
          }
        } else if(dtypes[arrNum] === "generic") {
          pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join(""))
          code = code.replace(re, localStr)
          if(carg.lvalue) {
            post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
          }
        } else {
          pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join(""))
          code = code.replace(re, localStr)
          if(carg.lvalue) {
            post.push([arrStr, "[", ptrStr, "]=", localStr].join(""))
          }
        }
      break
      case "scalar":
        code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i))
      break
      case "index":
        code = code.replace(re, "index")
      break
      case "shape":
        code = code.replace(re, "shape")
      break
    }
  }
  return [pre.join("\n"), code, post.join("\n")].join("\n").trim()
}

function typeSummary(dtypes) {
  var summary = new Array(dtypes.length)
  var allEqual = true
  for(var i=0; i<dtypes.length; ++i) {
    var t = dtypes[i]
    var digits = t.match(/\d+/)
    if(!digits) {
      digits = ""
    } else {
      digits = digits[0]
    }
    if(t.charAt(0) === 0) {
      summary[i] = "u" + t.charAt(1) + digits
    } else {
      summary[i] = t.charAt(0) + digits
    }
    if(i > 0) {
      allEqual = allEqual && summary[i] === summary[i-1]
    }
  }
  if(allEqual) {
    return summary[0]
  }
  return summary.join("")
}

//Generates a cwise operator
function generateCWiseOp(proc, typesig) {

  //Compute dimension
  var dimension = typesig[1].length|0
  var orders = new Array(proc.arrayArgs.length)
  var dtypes = new Array(proc.arrayArgs.length)

  //First create arguments for procedure
  var arglist = ["SS"]
  var code = ["'use strict'"]
  var vars = []
  
  for(var j=0; j<dimension; ++j) {
    vars.push(["s", j, "=SS[", j, "]"].join(""))
  }
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    arglist.push("a"+i)
    arglist.push("t"+i)
    arglist.push("p"+i)
    dtypes[i] = typesig[2*i]
    orders[i] = typesig[2*i+1]
  }
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    arglist.push("Y" + i)
  }
  if(proc.shapeArgs.length > 0) {
    vars.push("shape=SS.slice(0)")
  }
  if(proc.indexArgs.length > 0) {
    var zeros = new Array(dimension)
    for(var i=0; i<dimension; ++i) {
      zeros[i] = "0"
    }
    vars.push(["index=[", zeros.join(","), "]"].join(""))
  }
  for(var i=0; i<proc.offsetArgs.length; ++i) {
    var off_arg = proc.offsetArgs[i]
    var init_string = []
    for(var j=0; j<off_arg.offset.length; ++j) {
      if(off_arg.offset[j] === 0) {
        continue
      } else if(off_arg.offset[j] === 1) {
        init_string.push(["t", off_arg.array, "[", j, "]"].join(""))      
      } else {
        init_string.push([off_arg.offset[j], "*t", off_arg.array, "[", j, "]"].join(""))
      }
    }
    if(init_string.length === 0) {
      vars.push("q" + i + "=0")
    } else {
      vars.push(["q", i, "=(", init_string.join("+"),")|0"].join(""))
    }
  }

  //Prepare this variables
  var thisVars = uniq([].concat(proc.pre.thisVars)
                      .concat(proc.body.thisVars)
                      .concat(proc.post.thisVars))
  vars = vars.concat(thisVars)
  code.push("var " + vars.join(","))
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    code.push("p"+i+"|=0")
  }
  
  //Inline prelude
  if(proc.pre.body.length > 3) {
    code.push(processBlock(proc.pre, proc, dtypes))
  }

  //Process body
  var body = processBlock(proc.body, proc, dtypes)
  var matched = countMatches(orders)
  if(matched < dimension) {
    code.push(outerFill(matched, orders[0], proc, body))
  } else {
    code.push(innerFill(orders[0], proc, body))
  }

  //Inline epilog
  if(proc.post.body.length > 3) {
    code.push(processBlock(proc.post, proc, dtypes))
  }
  
  if(proc.debug) {
    console.log("Generated cwise routine for ", typesig, ":\n\n", code.join("\n"))
  }
  
  var loopName = [(proc.funcName||"unnamed"), "_cwise_loop_", orders[0].join("s"),"m",matched,typeSummary(dtypes)].join("")
  var f = new Function(["function ",loopName,"(", arglist.join(","),"){", code.join("\n"),"} return ", loopName].join(""))
  return f()
}
module.exports = generateCWiseOp
},{"uniq":258}],257:[function(require,module,exports){
arguments[4][251][0].apply(exports,arguments)
},{"./compile.js":256}],258:[function(require,module,exports){
"use strict"

function unique_pred(list, compare) {
  var ptr = 1
    , len = list.length
    , a=list[0], b=list[0]
  for(var i=1; i<len; ++i) {
    b = a
    a = list[i]
    if(compare(a, b)) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique_eq(list) {
  var ptr = 1
    , len = list.length
    , a=list[0], b = list[0]
  for(var i=1; i<len; ++i, b=a) {
    b = a
    a = list[i]
    if(a !== b) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique(list, compare, sorted) {
  if(list.length === 0) {
    return []
  }
  if(compare) {
    if(!sorted) {
      list.sort(compare)
    }
    return unique_pred(list, compare)
  }
  if(!sorted) {
    list.sort()
  }
  return unique_eq(list)
}

module.exports = unique
},{}],259:[function(require,module,exports){
"use strict"

var ndarray = require("ndarray")
var ops = require("ndarray-ops")
var pool = require("typedarray-pool")

function clone(array) {
  var dtype = array.dtype
  if(dtype === "generic" || dtype === "array") {
    dtype = "double"
  }
  var data = pool.malloc(array.size, dtype)
  var result = ndarray(data, array.shape)
  ops.assign(result, array)
  return result
}
exports.clone = clone

function malloc(shape, dtype) {
  if(!dtype) {
    dtype = "double"
  }
  var sz = 1
  var stride = new Array(shape.length)
  for(var i=shape.length-1; i>=0; --i) {
    stride[i] = sz
    sz *= shape[i]
  }
  return ndarray(pool.malloc(sz, dtype), shape, stride, 0)
}
exports.malloc = malloc

function free(array) {
  if(array.dtype === "generic" || array.dtype === "array") {
    return
  }
  pool.free(array.data)
}
exports.free = free

function zeros(shape, dtype) {
  if(!dtype) {
    dtype = "double"
  }

  var sz = 1
  var stride = new Array(shape.length)
  for(var i=shape.length-1; i>=0; --i) {
    stride[i] = sz
    sz *= shape[i]
  }
  var buf = pool.malloc(sz, dtype)
  for(var i=0; i<sz; ++i) {
    buf[i] = 0
  }
  return ndarray(buf, shape, stride, 0)
}
exports.zeros = zeros
},{"ndarray":261,"ndarray-ops":248,"typedarray-pool":264}],260:[function(require,module,exports){
"use strict"

module.exports = ndSelect
module.exports.compile = lookupCache

//Macros
var ARRAY = "a"
var RANK = "K"
var CMP = "C"
var DATA = "d"
var OFFSET = "o"
var RND = "R"
var TMP = "T"
var LO = "L"
var HI = "H"
var PIVOT = "X"
function SHAPE(i) {
  return "s" + i
}
function STRIDE(i) {
  return "t" + i
}
function STEP(i) {
  return "u" + i
}
function STEP_CMP(i) {
  return "v" + i
}
function INDEX(i) {
  return "i" + i
}
function PICK(i) {
  return "p" + i
}
function PTR(i) {
  return "x" + i
}

//Create new order where index 0 is slowest index
function permuteOrder(order) {
  var norder = order.slice()
  norder.splice(order.indexOf(0), 1)
  norder.unshift(0)
  return norder
}

//Generate quick select procedure
function compileQuickSelect(order, useCompare, dtype) {
  order = permuteOrder(order)

  var dimension = order.length
  var useGetter = (dtype === "generic")
  var funcName = "ndSelect" + dtype + order.join("_") + "_" + (useCompare ? "cmp" : "lex")

  var code = []

  //Get arguments for code
  var args = [ARRAY, RANK]
  if(useCompare) {
    args.push(CMP)
  }

  //Unpack ndarray variables
  var vars = [
    DATA + "=" + ARRAY + ".data",
    OFFSET + "=" + ARRAY + ".offset|0",
    RND + "=Math.random",
    TMP]
  for(var i=0; i<2; ++i) {
    vars.push(PTR(i) + "=0")
  }
  for(var i=0; i<dimension; ++i) {
    vars.push(
      SHAPE(i) + "=" + ARRAY + ".shape[" + i + "]|0",
      STRIDE(i) + "=" + ARRAY + ".stride[" + i + "]|0",
      INDEX(i) + "=0")
  }
  for(var i=1; i<dimension; ++i) {
    if(i < dimension-1) {
      vars.push(STEP_CMP(i) + "=(" + STRIDE(i) + "-" + SHAPE(i+1) + "*" + STRIDE(i+1) + ")|0",
                STEP(order[i]) + "=(" + STRIDE(order[i]) + "-" + SHAPE(order[i+1]) + "*" + STRIDE(order[i+1]) + ")|0")
    } else {
      vars.push(STEP_CMP(i) + "=" + STRIDE(i),
                STEP(order[i]) + "=" + STRIDE(order[i]))
    }
  }
  if(useCompare) {
    for(var i=0; i<2; ++i) {
      vars.push(PICK(i) + "=" + ARRAY + ".pick(0)")
    }
  }
  vars.push(
    PIVOT + "=0",
    LO + "=0",
    HI + "=" + SHAPE(order[0]) + "-1")

  function compare(out, i0, i1) {
    if(useCompare) {
      code.push(
        PICK(0), ".offset=", OFFSET, "+", STRIDE(order[0]), "*(", i0, ");",
        PICK(1), ".offset=", OFFSET, "+", STRIDE(order[0]), "*(", i1, ");",
        out, "=", CMP, "(", PICK(0), ",", PICK(1), ");")
    } else {
      code.push(
        PTR(0), "=", OFFSET, "+", STRIDE(0), "*(", i0, ");",
        PTR(1), "=", OFFSET, "+", STRIDE(0), "*(", i1, ");")
      if(dimension > 1) {
        code.push("_cmp:")
      }
      for(var i=dimension-1; i>0; --i) {
        code.push("for(", INDEX(i), "=0;", 
          INDEX(i), "<", SHAPE(i), ";",
          INDEX(i), "++){")
      }
      if(useGetter) {
        code.push(out, "=", DATA, ".get(", PTR(0), ")-", 
                            DATA, ".get(", PTR(1), ");")
      } else {
        code.push(out, "=", DATA, "[", PTR(0), "]-", 
                            DATA, "[", PTR(1), "];")
      }
      if(dimension > 1) {
        code.push("if(", out, ")break _cmp;")
      }
      for(var i=1; i<dimension; ++i) {
        code.push(
          PTR(0), "+=", STEP_CMP(i), ";",
          PTR(1), "+=", STEP_CMP(i),
          "}")
      }
    }
  }

  function swap(i0, i1) {
    code.push(
      PTR(0), "=", OFFSET, "+", STRIDE(order[0]), "*(", i0, ");",
      PTR(1), "=", OFFSET, "+", STRIDE(order[0]), "*(", i1, ");")
    for(var i=dimension-1; i>0; --i) {
      code.push("for(", INDEX(order[i]), "=0;", 
        INDEX(order[i]), "<", SHAPE(order[i]), ";",
        INDEX(order[i]), "++){")
    }
    if(useGetter) {
      code.push(TMP, "=", DATA, ".get(", PTR(0), ");", 
                DATA, ".set(", PTR(0), ",", DATA, ".get(", PTR(1), "));",
                DATA, ".set(", PTR(1), ",", TMP, ");")
    } else {
      code.push(TMP, "=", DATA, "[", PTR(0), "];", 
                DATA, "[", PTR(0), "]=", DATA, "[", PTR(1), "];",
                DATA, "[", PTR(1), "]=", TMP, ";")
    }
    for(var i=1; i<dimension; ++i) {
      code.push(
        PTR(0), "+=", STEP(order[i]), ";",
        PTR(1), "+=", STEP(order[i]),
        "}")
    }
  }

  code.push(
    "while(", LO, "<", HI, "){",
      PIVOT, "=(", RND, "()*(", HI, "-", LO, "+1)+", LO, ")|0;")

  //Partition array by pivot
  swap(PIVOT, HI)

  code.push(
    PIVOT, "=", LO, ";",
    "for(", INDEX(0), "=", LO, ";",
      INDEX(0), "<", HI, ";",
      INDEX(0), "++){")
  compare(TMP, INDEX(0), HI)
  code.push("if(", TMP, "<0){")
    swap(PIVOT, INDEX(0))
    code.push(PIVOT, "++;")
  code.push("}}")
  swap(PIVOT, HI)

  //Check pivot bounds
  code.push(
    "if(", PIVOT, "===", RANK, "){",
      LO, "=", PIVOT, ";",
      "break;",
    "}else if(", RANK, "<", PIVOT, "){",
      HI, "=", PIVOT, "-1;",
    "}else{",
      LO, "=", PIVOT, "+1;",
    "}",
  "}")

  if(useCompare) {
    code.push(PICK(0), ".offset=", OFFSET, "+", LO, "*", STRIDE(0), ";",
      "return ", PICK(0), ";")
  } else {
    code.push("return ", ARRAY, ".pick(", LO, ");")
  }

  //Compile and link js together
  var procCode = [
    "'use strict';function ", funcName, "(", args, "){",
      "var ", vars.join(), ";",
      code.join(""),
    "};return ", funcName
  ].join("")

  var proc = new Function(procCode)
  return proc()
}

var CACHE = {}

function lookupCache(order, useCompare, dtype) {
  var typesig = order.join() + useCompare + dtype
  var proc = CACHE[typesig]
  if(proc) {
    return proc
  }
  return CACHE[typesig] = compileQuickSelect(order, useCompare, dtype)
}

function ndSelect(array, k, compare) {
  k |= 0
  if((array.dimension === 0) || 
    (array.shape[0] <= k) ||
    (k < 0)) {
    return null
  }
  var useCompare = !!compare
  var proc = lookupCache(array.order, useCompare, array.dtype)
  if(useCompare) {
    return proc(array, k, compare)
  } else {
    return proc(array, k)
  }
}
},{}],261:[function(require,module,exports){
(function (Buffer){
var iota = require("iota-array")

var arrayMethods = [
  "concat",
  "join",
  "slice",
  "toString",
  "indexOf",
  "lastIndexOf",
  "forEach",
  "every",
  "some",
  "filter",
  "map",
  "reduce",
  "reduceRight"
]

var hasTypedArrays  = ((typeof Float64Array) !== "undefined")
var hasBuffer       = ((typeof Buffer) !== "undefined")

function compare1st(a, b) {
  return a[0] - b[0]
}

function order() {
  var stride = this.stride
  var terms = new Array(stride.length)
  var i
  for(i=0; i<terms.length; ++i) {
    terms[i] = [Math.abs(stride[i]), i]
  }
  terms.sort(compare1st)
  var result = new Array(terms.length)
  for(i=0; i<result.length; ++i) {
    result[i] = terms[i][1]
  }
  return result
}

function compileConstructor(dtype, dimension) {
  var className = ["View", dimension, "d", dtype].join("")
  if(dimension < 0) {
    className = "View_Nil" + dtype
  }
  var useGetters = (dtype === "generic")
  
  if(dimension === -1) {
    //Special case for trivial arrays
    var code = 
      "function "+className+"(a){this.data=a;};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new "+className+"(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_"+className+"(a){return new "+className+"(a);}"
    var procedure = new Function(code)
    return procedure()
  } else if(dimension === 0) {
    //Special case for 0d arrays
    var code =
      "function "+className+"(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function "+className+"_copy() {\
return new "+className+"(this.data,this.offset)\
};\
proto.pick=function "+className+"_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function "+className+"_get(){\
return "+(useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]")+
"};\
proto.set=function "+className+"_set(v){\
return "+(useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v")+"\
};\
return function construct_"+className+"(a,b,c,d){return new "+className+"(a,d)}"
    var procedure = new Function("TrivialArray", code)
    return procedure(CACHED_CONSTRUCTORS[dtype][0])
  }

  var code = ["'use strict'"]
    
  //Create constructor for view
  var indices = iota(dimension)
  var args = indices.map(function(i) { return "i"+i })
  var index_str = "this.offset+" + indices.map(function(i) {
        return "this._stride" + i + "*i" + i
      }).join("+")
  code.push("function "+className+"(a,"+
    indices.map(function(i) {
      return "b"+i
    }).join(",") + "," +
    indices.map(function(i) {
      return "c"+i
    }).join(",") + ",d){this.data=a")
  for(var i=0; i<dimension; ++i) {
    code.push("this._shape"+i+"=b"+i+"|0")
  }
  for(var i=0; i<dimension; ++i) {
    code.push("this._stride"+i+"=c"+i+"|0")
  }
  code.push("this.offset=d|0}",
    "var proto="+className+".prototype",
    "proto.dtype='"+dtype+"'",
    "proto.dimension="+dimension)
  
  //view.stride and view.shape
  var strideClassName = "VStride" + dimension + "d" + dtype
  var shapeClassName = "VShape" + dimension + "d" + dtype
  var props = {"stride":strideClassName, "shape":shapeClassName}
  for(var prop in props) {
    var arrayName = props[prop]
    code.push(
      "function " + arrayName + "(v) {this._v=v} var aproto=" + arrayName + ".prototype",
      "aproto.length="+dimension)
    
    var array_elements = []
    for(var i=0; i<dimension; ++i) {
      array_elements.push(["this._v._", prop, i].join(""))
    }
    code.push(
      "aproto.toJSON=function " + arrayName + "_toJSON(){return [" + array_elements.join(",") + "]}",
      "aproto.valueOf=aproto.toString=function " + arrayName + "_toString(){return [" + array_elements.join(",") + "].join()}")
    
    for(var i=0; i<dimension; ++i) {
      code.push("Object.defineProperty(aproto,"+i+",{get:function(){return this._v._"+prop+i+"},set:function(v){return this._v._"+prop+i+"=v|0},enumerable:true})")
    }
    for(var i=0; i<arrayMethods.length; ++i) {
      if(arrayMethods[i] in Array.prototype) {
        code.push("aproto."+arrayMethods[i]+"=Array.prototype."+arrayMethods[i])
      }
    }
    code.push(["Object.defineProperty(proto,'",prop,"',{get:function ", arrayName, "_get(){return new ", arrayName, "(this)},set: function ", arrayName, "_set(v){"].join(""))
    for(var i=0; i<dimension; ++i) {
      code.push("this._"+prop+i+"=v["+i+"]|0")
    }
    code.push("return v}})")
  }
  
  //view.size:
  code.push("Object.defineProperty(proto,'size',{get:function "+className+"_size(){\
return "+indices.map(function(i) { return "this._shape"+i }).join("*"),
"}})")

  //view.order:
  if(dimension === 1) {
    code.push("proto.order=[0]")
  } else {
    code.push("Object.defineProperty(proto,'order',{get:")
    if(dimension < 4) {
      code.push("function "+className+"_order(){")
      if(dimension === 2) {
        code.push("return (Math.abs(this._stride0)>Math.abs(this._stride1))?[1,0]:[0,1]}})")
      } else if(dimension === 3) {
        code.push(
"var s0=Math.abs(this._stride0),s1=Math.abs(this._stride1),s2=Math.abs(this._stride2);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})")
      }
    } else {
      code.push("ORDER})")
    }
  }
  
  //view.set(i0, ..., v):
  code.push(
"proto.set=function "+className+"_set("+args.join(",")+",v){")
  if(useGetters) {
    code.push("return this.data.set("+index_str+",v)}")
  } else {
    code.push("return this.data["+index_str+"]=v}")
  }
  
  //view.get(i0, ...):
  code.push("proto.get=function "+className+"_get("+args.join(",")+"){")
  if(useGetters) {
    code.push("return this.data.get("+index_str+")}")
  } else {
    code.push("return this.data["+index_str+"]}")
  }
  
  //view.index:
  code.push(
    "proto.index=function "+className+"_index(", args.join(), "){return "+index_str+"}")

  //view.hi():
  code.push("proto.hi=function "+className+"_hi("+args.join(",")+"){return new "+className+"(this.data,"+
    indices.map(function(i) {
      return ["(typeof i",i,"!=='number'||i",i,"<0)?this._shape", i, ":i", i,"|0"].join("")
    }).join(",")+","+
    indices.map(function(i) {
      return "this._stride"+i
    }).join(",")+",this.offset)}")
  
  //view.lo():
  var a_vars = indices.map(function(i) { return "a"+i+"=this._shape"+i })
  var c_vars = indices.map(function(i) { return "c"+i+"=this._stride"+i })
  code.push("proto.lo=function "+className+"_lo("+args.join(",")+"){var b=this.offset,d=0,"+a_vars.join(",")+","+c_vars.join(","))
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'&&i"+i+">=0){\
d=i"+i+"|0;\
b+=c"+i+"*d;\
a"+i+"-=d}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a"+i
    }).join(",")+","+
    indices.map(function(i) {
      return "c"+i
    }).join(",")+",b)}")
  
  //view.step():
  code.push("proto.step=function "+className+"_step("+args.join(",")+"){var "+
    indices.map(function(i) {
      return "a"+i+"=this._shape"+i
    }).join(",")+","+
    indices.map(function(i) {
      return "b"+i+"=this._stride"+i
    }).join(",")+",c=this.offset,d=0,ceil=Math.ceil")
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'){\
d=i"+i+"|0;\
if(d<0){\
c+=b"+i+"*(a"+i+"-1);\
a"+i+"=ceil(-a"+i+"/d)\
}else{\
a"+i+"=ceil(a"+i+"/d)\
}\
b"+i+"*=d\
}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a" + i
    }).join(",")+","+
    indices.map(function(i) {
      return "b" + i
    }).join(",")+",c)}")
  
  //view.transpose():
  var tShape = new Array(dimension)
  var tStride = new Array(dimension)
  for(var i=0; i<dimension; ++i) {
    tShape[i] = "a[i"+i+"]"
    tStride[i] = "b[i"+i+"]"
  }
  code.push("proto.transpose=function "+className+"_transpose("+args+"){"+
    args.map(function(n,idx) { return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)"}).join(";"),
    "var a=this.shape,b=this.stride;return new "+className+"(this.data,"+tShape.join(",")+","+tStride.join(",")+",this.offset)}")
  
  //view.pick():
  code.push("proto.pick=function "+className+"_pick("+args+"){var a=[],b=[],c=this.offset")
  for(var i=0; i<dimension; ++i) {
    code.push("if(typeof i"+i+"==='number'&&i"+i+">=0){c=(c+this._stride"+i+"*i"+i+")|0}else{a.push(this._shape"+i+");b.push(this._stride"+i+")}")
  }
  code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}")
    
  //Add return statement
  code.push("return function construct_"+className+"(data,shape,stride,offset){return new "+className+"(data,"+
    indices.map(function(i) {
      return "shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "stride["+i+"]"
    }).join(",")+",offset)}")

  //Compile procedure
  var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"))
  return procedure(CACHED_CONSTRUCTORS[dtype], order)
}

function arrayDType(data) {
  if(hasBuffer) {
    if(Buffer.isBuffer(data)) {
      return "buffer"
    }
  }
  if(hasTypedArrays) {
    switch(Object.prototype.toString.call(data)) {
      case "[object Float64Array]":
        return "float64"
      case "[object Float32Array]":
        return "float32"
      case "[object Int8Array]":
        return "int8"
      case "[object Int16Array]":
        return "int16"
      case "[object Int32Array]":
        return "int32"
      case "[object Uint8Array]":
        return "uint8"
      case "[object Uint16Array]":
        return "uint16"
      case "[object Uint32Array]":
        return "uint32"
      case "[object Uint8ClampedArray]":
        return "uint8_clamped"
    }
  }
  if(Array.isArray(data)) {
    return "array"
  }
  return "generic"
}

var CACHED_CONSTRUCTORS = {
  "float32":[],
  "float64":[],
  "int8":[],
  "int16":[],
  "int32":[],
  "uint8":[],
  "uint16":[],
  "uint32":[],
  "array":[],
  "uint8_clamped":[],
  "buffer":[],
  "generic":[]
}

;(function() {
  for(var id in CACHED_CONSTRUCTORS) {
    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))
  }
});

function wrappedNDArrayCtor(data, shape, stride, offset) {
  if(data === undefined) {
    var ctor = CACHED_CONSTRUCTORS.array[0]
    return ctor([])
  } else if(typeof data === "number") {
    data = [data]
  }
  if(shape === undefined) {
    shape = [ data.length ]
  }
  var d = shape.length
  if(stride === undefined) {
    stride = new Array(d)
    for(var i=d-1, sz=1; i>=0; --i) {
      stride[i] = sz
      sz *= shape[i]
    }
  }
  if(offset === undefined) {
    offset = 0
    for(var i=0; i<d; ++i) {
      if(stride[i] < 0) {
        offset -= (shape[i]-1)*stride[i]
      }
    }
  }
  var dtype = arrayDType(data)
  var ctor_list = CACHED_CONSTRUCTORS[dtype]
  while(ctor_list.length <= d+1) {
    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))
  }
  var ctor = ctor_list[d+1]
  return ctor(data, shape, stride, offset)
}

module.exports = wrappedNDArrayCtor
}).call(this,require("buffer").Buffer)
},{"buffer":236,"iota-array":262}],262:[function(require,module,exports){
"use strict"

function iota(n) {
  var result = new Array(n)
  for(var i=0; i<n; ++i) {
    result[i] = i
  }
  return result
}

module.exports = iota
},{}],263:[function(require,module,exports){
"use strict"

function dupe_array(count, value, i) {
  var c = count[i]|0
  if(c <= 0) {
    return []
  }
  var result = new Array(c), j
  if(i === count.length-1) {
    for(j=0; j<c; ++j) {
      result[j] = value
    }
  } else {
    for(j=0; j<c; ++j) {
      result[j] = dupe_array(count, value, i+1)
    }
  }
  return result
}

function dupe_number(count, value) {
  var result, i
  result = new Array(count)
  for(i=0; i<count; ++i) {
    result[i] = value
  }
  return result
}

function dupe(count, value) {
  if(typeof value === "undefined") {
    value = 0
  }
  switch(typeof count) {
    case "number":
      if(count > 0) {
        return dupe_number(count|0, value)
      }
    break
    case "object":
      if(typeof (count.length) === "number") {
        return dupe_array(count, value, 0)
      }
    break
  }
  return []
}

module.exports = dupe
},{}],264:[function(require,module,exports){
(function (global,Buffer){
var bits = require("bit-twiddle")
var dup = require("dup")
if(!global.__TYPEDARRAY_POOL) {
  global.__TYPEDARRAY_POOL = {
      UINT8   : dup([32, 0])
    , UINT16  : dup([32, 0])
    , UINT32  : dup([32, 0])
    , INT8    : dup([32, 0])
    , INT16   : dup([32, 0])
    , INT32   : dup([32, 0])
    , FLOAT   : dup([32, 0])
    , DOUBLE  : dup([32, 0])
    , DATA    : dup([32, 0])
    , UINT8C  : dup([32, 0])
    , BUFFER  : dup([32, 0])
  }
}
var hasUint8C = (typeof Uint8ClampedArray) !== "undefined"
var POOL = global.__TYPEDARRAY_POOL
if(!POOL.UINT8C) {
  POOL.UINT8C = dup([32, 0])
}
if(!POOL.BUFFER) {
  POOL.BUFFER = dup([32, 0])
}
var UINT8   = POOL.UINT8
  , UINT16  = POOL.UINT16
  , UINT32  = POOL.UINT32
  , INT8    = POOL.INT8
  , INT16   = POOL.INT16
  , INT32   = POOL.INT32
  , FLOAT   = POOL.FLOAT
  , DOUBLE  = POOL.DOUBLE
  , DATA    = POOL.DATA
  , UINT8C  = POOL.UINT8C
  , BUFFER  = POOL.BUFFER

exports.free = function free(array) {
  var n = array.length|0
    , log_n = bits.log2(n)
  if(Buffer.isBuffer(array)) {
    BUFFER[log_n].push(array)
  } else {
    switch(Object.prototype.toString.call(array)) {
      case "[object Uint8Array]":
        UINT8[log_n].push(array)
      break
      case "[object Uint16Array]":
        UINT16[log_n].push(array)
      break
      case "[object Uint32Array]":
        UINT32[log_n].push(array)
      break
      case "[object Int8Array]":
        INT8[log_n].push(array)
      break
      case "[object Int16Array]":
        INT16[log_n].push(array)
      break
      case "[object Int32Array]":
        INT32[log_n].push(array)
      break
      case "[object Uint8ClampedArray]":
        UINT8C[log_n].push(array)
      break
      case "[object Float32Array]":
        FLOAT[log_n].push(array)
      break
      case "[object Float64Array]":
        DOUBLE[log_n].push(array)
      break
      case "[object ArrayBuffer]":
        DATA[log_n].push(array)
      break
      default:
        throw new Error("typedarray-pool: Unspecified array type")
    }
  }
}

exports.freeUint8 = function freeUint8(array) {
  UINT8[bits.log2(array.length)].push(array)
}

exports.freeUint16 = function freeUint16(array) {
  UINT16[bits.log2(array.length)].push(array)
}

exports.freeUint32 = function freeUint32(array) {
  UINT32[bits.log2(array.length)].push(array)
}

exports.freeInt8 = function freeInt8(array) {
  INT8[bits.log2(array.length)].push(array)
}

exports.freeInt16 = function freeInt16(array) {
  INT16[bits.log2(array.length)].push(array)
}

exports.freeInt32 = function freeInt32(array) {
  INT32[bits.log2(array.length)].push(array)
}

exports.freeFloat32 = exports.freeFloat = function freeFloat(array) {
  FLOAT[bits.log2(array.length)].push(array)
}

exports.freeFloat64 = exports.freeDouble = function freeDouble(array) {
  DOUBLE[bits.log2(array.length)].push(array)
}

exports.freeArrayBuffer = function freeArrayBuffer(array) {
  DATA[bits.log2(array.length)].push(array)
}

if(hasUint8C) {
  exports.freeUint8Clamped = function freeUint8Clamped(array) {
    UINT8C[bits.log2(array.length)].push(array)
  }
} else {
  exports.freeUint8Clamped = exports.freeUint8
}

exports.freeBuffer = function freeBuffer(array) {
  BUFFER[bits.log2(array.length)].push(array)
}

exports.malloc = function malloc(n, dtype) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  if(dtype === undefined || dtype === "arraybuffer") {
    var d = DATA[log_n]
    if(d.length > 0) {
      var r = d[d.length-1]
      d.pop()
      return r
    }
    return new ArrayBuffer(n)
  } else {
    switch(dtype) {
      case "uint8":
        var u8 = UINT8[log_n]
        if(u8.length > 0) {
          return u8.pop()
        }
        return new Uint8Array(n)
      break

      case "uint16":
        var u16 = UINT16[log_n]
        if(u16.length > 0) {
          return u16.pop()
        }
        return new Uint16Array(n)
      break

      case "uint32":
        var u32 = UINT32[log_n]
        if(u32.length > 0) {
          return u32.pop()
        }
        return new Uint32Array(n)
      break

      case "int8":
        var i8 = INT8[log_n]
        if(i8.length > 0) {
          return i8.pop()
        }
        return new Int8Array(n)
      break

      case "int16":
        var i16 = INT16[log_n]
        if(i16.length > 0) {
          return i16.pop()
        }
        return new Int16Array(n)
      break

      case "int32":
        var i32 = INT32[log_n]
        if(i32.length > 0) {
          return i32.pop()
        }
        return new Int32Array(n)
      break

      case "float":
      case "float32":
        var f = FLOAT[log_n]
        if(f.length > 0) {
          return f.pop()
        }
        return new Float32Array(n)
      break

      case "double":
      case "float64":
        var dd = DOUBLE[log_n]
        if(dd.length > 0) {
          return dd.pop()
        }
        return new Float64Array(n)
      break

      case "uint8_clamped":
        if(hasUint8C) {
          var u8c = UINT8C[log_n]
          if(u8c.length > 0) {
            return u8c.pop()
          }
          return new Uint8ClampedArray(n)
        } else {
          var u8 = UINT8[log_n]
          if(u8.length > 0) {
            return u8.pop()
          }
          return new Uint8Array(n)
        }
      break

      case "buffer":
        var buf = BUFFER[log_n]
        if(buf.length > 0) {
          return buf.pop()
        }
        return new Buffer(n)
      break

      default:
        return null
    }
  }
  return null
}

exports.mallocUint8 = function mallocUint8(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = UINT8[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Uint8Array(n)
}

exports.mallocUint16 = function mallocUint16(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = UINT16[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Uint16Array(n)
}

exports.mallocUint32 = function mallocUint32(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = UINT32[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Uint32Array(n)
}

exports.mallocInt8 = function mallocInt8(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = INT8[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Int8Array(n)
}

exports.mallocInt16 = function mallocInt16(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = INT16[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Int16Array(n)
}

exports.mallocInt32 = function mallocInt32(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = INT32[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Int32Array(n)
}

exports.mallocFloat32 = exports.mallocFloat = function mallocFloat(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = FLOAT[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Float32Array(n)
}

exports.mallocFloat64 = exports.mallocDouble = function mallocDouble(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = DOUBLE[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Float64Array(n)
}

exports.mallocArrayBuffer = function mallocArrayBuffer(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = DATA[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new ArrayBuffer(n)
}

if(hasUint8C) {
  exports.mallocUint8Clamped = function mallocUint8Clamped(n) {
    n = bits.nextPow2(n)
    var log_n = bits.log2(n)
    var cache = UINT8C[log_n]
    if(cache.length > 0) {
      return cache.pop()
    }
    return new Uint8ClampedArray(n)
  }
} else {
  exports.mallocUint8Clamped = exports.mallocUint8
}

exports.mallocBuffer = function mallocBuffer(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = BUFFER[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Buffer(n)
}

exports.clearCache = function clearCache() {
  for(var i=0; i<32; ++i) {
    UINT8[i].length = 0
    UINT16[i].length = 0
    UINT32[i].length = 0
    INT8[i].length = 0
    INT16[i].length = 0
    INT32[i].length = 0
    FLOAT[i].length = 0
    DOUBLE[i].length = 0
    DATA[i].length = 0
    UINT8C[i].length = 0
    BUFFER[i].length = 0
  }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"bit-twiddle":245,"buffer":236,"dup":263}]},{},[66,67,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,57,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,58,59,60,61,62,63,64,65,68,69,70,71,80,72,73,74,75,76,77,78,79,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,168,169,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,178,170,171,172,173,174,175,176,177,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,230,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,231,232,233,234,235])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9EYXZlL1NpdGVzL0QzcGx1cy9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiLi9zcmMvYXJyYXkvc29ydC5qcyIsIi9Vc2Vycy9EYXZlL1NpdGVzL0QzcGx1cy9zcmMvYXJyYXkvdXBkYXRlLmNvZmZlZSIsIi9Vc2Vycy9EYXZlL1NpdGVzL0QzcGx1cy9zcmMvY29sb3IvbGVnaWJsZS5jb2ZmZWUiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvc3JjL2NvbG9yL2xpZ2h0ZXIuY29mZmVlIiwiL1VzZXJzL0RhdmUvU2l0ZXMvRDNwbHVzL3NyYy9jb2xvci9taXguY29mZmVlIiwiL1VzZXJzL0RhdmUvU2l0ZXMvRDNwbHVzL3NyYy9jb2xvci9yYW5kb20uY29mZmVlIiwiL1VzZXJzL0RhdmUvU2l0ZXMvRDNwbHVzL3NyYy9jb2xvci9zY2FsZS5jb2ZmZWUiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvc3JjL2NvbG9yL3NvcnQuY29mZmVlIiwiL1VzZXJzL0RhdmUvU2l0ZXMvRDNwbHVzL3NyYy9jb2xvci90ZXh0LmNvZmZlZSIsIi9Vc2Vycy9EYXZlL1NpdGVzL0QzcGx1cy9zcmMvY29sb3IvdmFsaWRhdGUuY29mZmVlIiwiLi9zcmMvY29yZS9kYXRhL2NvbG9yLmpzIiwiLi9zcmMvY29yZS9kYXRhL2ZpbHRlci5qcyIsIi4vc3JjL2NvcmUvZGF0YS9mb3JtYXQuanMiLCIuL3NyYy9jb3JlL2RhdGEva2V5cy5qcyIsIi9Vc2Vycy9EYXZlL1NpdGVzL0QzcGx1cy9zcmMvY29yZS9kYXRhL2xvYWQuY29mZmVlIiwiLi9zcmMvY29yZS9kYXRhL25lc3QuanMiLCIuL3NyYy9jb3JlL2RhdGEvdGhyZXNob2xkLmpzIiwiLi9zcmMvY29yZS9mZXRjaC9jb2xvci5qcyIsIi4vc3JjL2NvcmUvZmV0Y2gvZGF0YS5qcyIsIi4vc3JjL2NvcmUvZmV0Y2gvdGV4dC5qcyIsIi4vc3JjL2NvcmUvZmV0Y2gvdmFsdWUuanMiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvc3JjL2NvcmUvZm9udC90ZXN0ZXIuY29mZmVlIiwiLi9zcmMvY29yZS9tZXRob2QvcmVzZXQuanMiLCIuL3NyYy9jb3JlL3BhcnNlL2VkZ2VzLmpzIiwiLi9zcmMvY29yZS9wYXJzZS9lbGVtZW50LmpzIiwiLi9zcmMvY29yZS9wYXJzZS9ub2Rlcy5qcyIsIi9Vc2Vycy9EYXZlL1NpdGVzL0QzcGx1cy9zcmMvZGF0YS9iZXN0UmVncmVzcy5jb2ZmZWUiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvc3JjL2RhdGEvbG9mLmNvZmZlZSIsIi9Vc2Vycy9EYXZlL1NpdGVzL0QzcGx1cy9zcmMvZGF0YS9tYWQuY29mZmVlIiwiL1VzZXJzL0RhdmUvU2l0ZXMvRDNwbHVzL3NyYy9mb250L2F3ZXNvbWUuY29mZmVlIiwiL1VzZXJzL0RhdmUvU2l0ZXMvRDNwbHVzL3NyYy9mb250L3NpemVzLmNvZmZlZSIsIi4vc3JjL2ZvbnQvdmFsaWRhdGUuanMiLCIuL3NyYy9mb3JtL2Zvcm0uanMiLCIuL3NyYy9mb3JtL3R5cGVzL2F1dG8uanMiLCIuL3NyYy9mb3JtL3R5cGVzL2J1dHRvbi9idXR0b24uanMiLCIuL3NyYy9mb3JtL3R5cGVzL2J1dHRvbi9mdW5jdGlvbnMvY29sb3IuanMiLCIuL3NyYy9mb3JtL3R5cGVzL2J1dHRvbi9mdW5jdGlvbnMvaWNvbnMuanMiLCIuL3NyYy9mb3JtL3R5cGVzL2J1dHRvbi9mdW5jdGlvbnMvbW91c2VldmVudHMuanMiLCIuL3NyYy9mb3JtL3R5cGVzL2J1dHRvbi9mdW5jdGlvbnMvc3R5bGUuanMiLCIuL3NyYy9mb3JtL3R5cGVzL2Ryb3AvZHJvcC5qcyIsIi4vc3JjL2Zvcm0vdHlwZXMvZHJvcC9mdW5jdGlvbnMvYWN0aXZlLmpzIiwiLi9zcmMvZm9ybS90eXBlcy9kcm9wL2Z1bmN0aW9ucy9hcnJvdy5qcyIsIi4vc3JjL2Zvcm0vdHlwZXMvZHJvcC9mdW5jdGlvbnMvYnV0dG9uLmpzIiwiLi9zcmMvZm9ybS90eXBlcy9kcm9wL2Z1bmN0aW9ucy9kYXRhLmpzIiwiLi9zcmMvZm9ybS90eXBlcy9kcm9wL2Z1bmN0aW9ucy9lbGVtZW50LmpzIiwiLi9zcmMvZm9ybS90eXBlcy9kcm9wL2Z1bmN0aW9ucy9oZWlnaHQuanMiLCIuL3NyYy9mb3JtL3R5cGVzL2Ryb3AvZnVuY3Rpb25zL2l0ZW1zLmpzIiwiLi9zcmMvZm9ybS90eXBlcy9kcm9wL2Z1bmN0aW9ucy9rZXlib2FyZC5qcyIsIi4vc3JjL2Zvcm0vdHlwZXMvZHJvcC9mdW5jdGlvbnMvbGlzdC5qcyIsIi4vc3JjL2Zvcm0vdHlwZXMvZHJvcC9mdW5jdGlvbnMvc2Nyb2xsLmpzIiwiLi9zcmMvZm9ybS90eXBlcy9kcm9wL2Z1bmN0aW9ucy9zZWFyY2guanMiLCIuL3NyYy9mb3JtL3R5cGVzL2Ryb3AvZnVuY3Rpb25zL3NlbGVjdG9yLmpzIiwiLi9zcmMvZm9ybS90eXBlcy9kcm9wL2Z1bmN0aW9ucy90aXRsZS5qcyIsIi4vc3JjL2Zvcm0vdHlwZXMvZHJvcC9mdW5jdGlvbnMvdXBkYXRlLmpzIiwiLi9zcmMvZm9ybS90eXBlcy9kcm9wL2Z1bmN0aW9ucy93aWR0aC5qcyIsIi4vc3JjL2Zvcm0vdHlwZXMvZHJvcC9mdW5jdGlvbnMvd2luZG93LmpzIiwiLi9zcmMvZm9ybS90eXBlcy90b2dnbGUuanMiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvc3JjL2dlbmVyYWwvY29uc29sZS5jb2ZmZWUiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvc3JjL2dlbmVyYWwvZXZlbnRzLmNvZmZlZSIsIi4vc3JjL2dlbmVyYWwvaWUuanMiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvc3JjL2dlbmVyYWwvcHJlZml4LmNvZmZlZSIsIi4vc3JjL2dlbmVyYWwvcnRsLmpzIiwiLi9zcmMvZ2VuZXJhbC9zY3JvbGxiYXIuanMiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvc3JjL2dlbmVyYWwvd2lraS5jb2ZmZWUiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvc3JjL2dlb20vbGFyZ2VzdFJlY3QuY29mZmVlIiwiL1VzZXJzL0RhdmUvU2l0ZXMvRDNwbHVzL3NyYy9pbml0LmNvZmZlZSIsIi4vc3JjL2xpYnMuanMiLCIuL3NyYy9sb2NhbGUvZW5fVVMuanMiLCIuL3NyYy9sb2NhbGUvbWtfTUsuanMiLCIuL3NyYy9sb2NhbGUvcHRfQlIuanMiLCIuL3NyYy9sb2NhbGUvemhfQ04uanMiLCIuL3NyYy9tZXRob2QvaGVscGVycy9heGlzLmpzIiwiLi9zcmMvbWV0aG9kL2hlbHBlcnMvZmlsdGVyLmpzIiwiLi9zcmMvbWV0aG9kL2hlbHBlcnMvZnVuY3Rpb24uanMiLCIuL3NyYy9tZXRob2QvaGVscGVycy9pbml0LmpzIiwiLi9zcmMvbWV0aG9kL2hlbHBlcnMvb2JqZWN0LmpzIiwiLi9zcmMvbWV0aG9kL2hlbHBlcnMvcHJvY2Vzcy5qcyIsIi4vc3JjL21ldGhvZC9oZWxwZXJzL3Byb2Nlc3NEYXRhLmpzIiwiLi9zcmMvbWV0aG9kL2hlbHBlcnMvc2V0LmpzIiwiLi9zcmMvbWV0aG9kL21ldGhvZC5qcyIsIi4vc3JjL21ldGhvZC90eXBlcy9hY3RpdmUuanMiLCIuL3NyYy9tZXRob2QvdHlwZXMvYWdncy5qcyIsIi4vc3JjL21ldGhvZC90eXBlcy9hbHQuanMiLCIuL3NyYy9tZXRob2QvdHlwZXMvYXR0cnMuanMiLCIuL3NyYy9tZXRob2QvdHlwZXMvYXhlcy5qcyIsIi4vc3JjL21ldGhvZC90eXBlcy9jb2xvci5qcyIsIi4vc3JjL21ldGhvZC90eXBlcy9jb250YWluZXIuanMiLCIuL3NyYy9tZXRob2QvdHlwZXMvY29vcmRzLmpzIiwiLi9zcmMvbWV0aG9kL3R5cGVzL2Nzdi5qcyIsIi4vc3JjL21ldGhvZC90eXBlcy9kYXRhLmpzIiwiLi9zcmMvbWV0aG9kL3R5cGVzL2RlcHRoLmpzIiwiLi9zcmMvbWV0aG9kL3R5cGVzL2Rlc2NzLmpzIiwiLi9zcmMvbWV0aG9kL3R5cGVzL2Rldi5qcyIsIi4vc3JjL21ldGhvZC90eXBlcy9kcmF3LmpzIiwiLi9zcmMvbWV0aG9kL3R5cGVzL2VkZ2VzLmpzIiwiLi9zcmMvbWV0aG9kL3R5cGVzL2Vycm9yLmpzIiwiLi9zcmMvbWV0aG9kL3R5cGVzL2ZvY3VzLmpzIiwiLi9zcmMvbWV0aG9kL3R5cGVzL2Zvb3Rlci5qcyIsIi4vc3JjL21ldGhvZC90eXBlcy9mb3JtYXQuanMiLCIuL3NyYy9tZXRob2QvdHlwZXMvaGVpZ2h0LmpzIiwiLi9zcmMvbWV0aG9kL3R5cGVzL2hpc3RvcnkuanMiLCIuL3NyYy9tZXRob2QvdHlwZXMvaG92ZXIuanMiLCIuL3NyYy9tZXRob2QvdHlwZXMvaWNvbi5qcyIsIi4vc3JjL21ldGhvZC90eXBlcy9pZC5qcyIsIi4vc3JjL21ldGhvZC90eXBlcy9rZXl3b3Jkcy5qcyIsIi4vc3JjL21ldGhvZC90eXBlcy9sYWJlbHMuanMiLCIuL3NyYy9tZXRob2QvdHlwZXMvbGVnZW5kLmpzIiwiLi9zcmMvbWV0aG9kL3R5cGVzL21hcmdpbi5qcyIsIi4vc3JjL21ldGhvZC90eXBlcy9tZXNzYWdlcy5qcyIsIi4vc3JjL21ldGhvZC90eXBlcy9ub2Rlcy5qcyIsIi4vc3JjL21ldGhvZC90eXBlcy9vcGVuLmpzIiwiLi9zcmMvbWV0aG9kL3R5cGVzL29yZGVyLmpzIiwiLi9zcmMvbWV0aG9kL3R5cGVzL3JlbW92ZS5qcyIsIi4vc3JjL21ldGhvZC90eXBlcy9yZXNpemUuanMiLCIuL3NyYy9tZXRob2QvdHlwZXMvc2VhcmNoLmpzIiwiLi9zcmMvbWV0aG9kL3R5cGVzL3NlbGVjdC5qcyIsIi4vc3JjL21ldGhvZC90eXBlcy9zZWxlY3RBbGwuanMiLCIuL3NyYy9tZXRob2QvdHlwZXMvc2hhcGUuanMiLCIuL3NyYy9tZXRob2QvdHlwZXMvc2l6ZS5qcyIsIi4vc3JjL21ldGhvZC90eXBlcy9zdHlsZS5qcyIsIi4vc3JjL21ldGhvZC90eXBlcy90ZW1wLmpzIiwiLi9zcmMvbWV0aG9kL3R5cGVzL3RleHQuanMiLCIuL3NyYy9tZXRob2QvdHlwZXMvdGltZS5qcyIsIi4vc3JjL21ldGhvZC90eXBlcy90aW1lbGluZS5qcyIsIi4vc3JjL21ldGhvZC90eXBlcy90aXRsZS5qcyIsIi4vc3JjL21ldGhvZC90eXBlcy90b29sdGlwLmpzIiwiLi9zcmMvbWV0aG9kL3R5cGVzL3RvdGFsLmpzIiwiLi9zcmMvbWV0aG9kL3R5cGVzL3R5cGUuanMiLCIuL3NyYy9tZXRob2QvdHlwZXMvdWkuanMiLCIuL3NyYy9tZXRob2QvdHlwZXMvd2lkdGguanMiLCIuL3NyYy9tZXRob2QvdHlwZXMveC5qcyIsIi4vc3JjL21ldGhvZC90eXBlcy95LmpzIiwiLi9zcmMvbWV0aG9kL3R5cGVzL3pvb20uanMiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvc3JjL25ldHdvcmsvY2x1c3Rlci5jb2ZmZWUiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvc3JjL25ldHdvcmsvbm9ybWFsaXplLmNvZmZlZSIsIi9Vc2Vycy9EYXZlL1NpdGVzL0QzcGx1cy9zcmMvbmV0d29yay9zaG9ydGVzdFBhdGguY29mZmVlIiwiL1VzZXJzL0RhdmUvU2l0ZXMvRDNwbHVzL3NyYy9uZXR3b3JrL3N1YmdyYXBoLmNvZmZlZSIsIi4vc3JjL251bWJlci9mb3JtYXQuanMiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvc3JjL29iamVjdC9tZXJnZS5jb2ZmZWUiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvc3JjL29iamVjdC92YWxpZGF0ZS5jb2ZmZWUiLCIuL3NyYy9zdHJpbmcvZm9ybWF0LmpzIiwiL1VzZXJzL0RhdmUvU2l0ZXMvRDNwbHVzL3NyYy9zdHJpbmcvbGlzdC5jb2ZmZWUiLCIuL3NyYy9zdHJpbmcvc3RyaXAuanMiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvc3JjL3N0cmluZy90aXRsZS5jb2ZmZWUiLCIuL3NyYy9zdHlsZS9kZWZhdWx0L2RlZmF1bHQuanMiLCIuL3NyYy9zdHlsZS9kZWZhdWx0L3BhcmFtcy9heGVzLmpzIiwiLi9zcmMvc3R5bGUvZGVmYXVsdC9wYXJhbXMvYmFja2dyb3VuZC5qcyIsIi4vc3JjL3N0eWxlL2RlZmF1bHQvcGFyYW1zL2NvbG9yLmpzIiwiLi9zcmMvc3R5bGUvZGVmYXVsdC9wYXJhbXMvY29vcmRzLmpzIiwiLi9zcmMvc3R5bGUvZGVmYXVsdC9wYXJhbXMvZGF0YS5qcyIsIi4vc3JjL3N0eWxlL2RlZmF1bHQvcGFyYW1zL2VkZ2VzLmpzIiwiLi9zcmMvc3R5bGUvZGVmYXVsdC9wYXJhbXMvZm9udC5qcyIsIi4vc3JjL3N0eWxlL2RlZmF1bHQvcGFyYW1zL2Zvb3Rlci5qcyIsIi4vc3JjL3N0eWxlL2RlZmF1bHQvcGFyYW1zL2hlaWdodC5qcyIsIi4vc3JjL3N0eWxlL2RlZmF1bHQvcGFyYW1zL2ljb24uanMiLCIuL3NyYy9zdHlsZS9kZWZhdWx0L3BhcmFtcy9sYWJlbHMuanMiLCIuL3NyYy9zdHlsZS9kZWZhdWx0L3BhcmFtcy9sZWdlbmQuanMiLCIuL3NyYy9zdHlsZS9kZWZhdWx0L3BhcmFtcy9saW5rcy5qcyIsIi4vc3JjL3N0eWxlL2RlZmF1bHQvcGFyYW1zL21lc3NhZ2VzLmpzIiwiLi9zcmMvc3R5bGUvZGVmYXVsdC9wYXJhbXMvbm9kZXMuanMiLCIuL3NyYy9zdHlsZS9kZWZhdWx0L3BhcmFtcy9zaGFwZS5qcyIsIi4vc3JjL3N0eWxlL2RlZmF1bHQvcGFyYW1zL3RpbWVsaW5lLmpzIiwiLi9zcmMvc3R5bGUvZGVmYXVsdC9wYXJhbXMvdGltaW5nLmpzIiwiLi9zcmMvc3R5bGUvZGVmYXVsdC9wYXJhbXMvdGl0bGUuanMiLCIuL3NyYy9zdHlsZS9kZWZhdWx0L3BhcmFtcy90b29sdGlwLmpzIiwiLi9zcmMvc3R5bGUvZGVmYXVsdC9wYXJhbXMvdWkuanMiLCIuL3NyYy9zdHlsZS9kZWZhdWx0L3BhcmFtcy93aWR0aC5qcyIsIi4vc3JjL3N0eWxlL2ZvbnRGYW1pbHkuanMiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvc3JjL3N0eWxlL3NoZWV0LmNvZmZlZSIsIi4vc3JjL3RleHR3cmFwL2hlbHBlcnMvZmxvdy5qcyIsIi4vc3JjL3RleHR3cmFwL2hlbHBlcnMvZm9yZWlnbi5qcyIsIi4vc3JjL3RleHR3cmFwL2hlbHBlcnMvZ2V0RGltZW5zaW9ucy5qcyIsIi4vc3JjL3RleHR3cmFwL2hlbHBlcnMvZ2V0U2l6ZS5qcyIsIi4vc3JjL3RleHR3cmFwL2hlbHBlcnMvZ2V0VGV4dC5qcyIsIi4vc3JjL3RleHR3cmFwL2hlbHBlcnMvcmVzaXplLmpzIiwiLi9zcmMvdGV4dHdyYXAvaGVscGVycy90c3Bhbi5qcyIsIi4vc3JjL3RleHR3cmFwL2hlbHBlcnMvd3JhcC5qcyIsIi4vc3JjL3RleHR3cmFwL3RleHR3cmFwLmpzIiwiLi9zcmMvdG9vbHRpcC9hcHAuanMiLCIuL3NyYy90b29sdGlwL2Fycm93LmpzIiwiLi9zcmMvdG9vbHRpcC9jcmVhdGUuanMiLCIuL3NyYy90b29sdGlwL2RhdGEuanMiLCIuL3NyYy90b29sdGlwL21vdmUuanMiLCIuL3NyYy90b29sdGlwL3JlbW92ZS5qcyIsIi4vc3JjL3V0aWwvYnVja2V0cy5qcyIsIi9Vc2Vycy9EYXZlL1NpdGVzL0QzcGx1cy9zcmMvdXRpbC9jaGlsZC5jb2ZmZWUiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvc3JjL3V0aWwvY2xvc2VzdC5jb2ZmZWUiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvc3JjL3V0aWwvY29weS5jb2ZmZWUiLCIuL3NyYy91dGlsL2Qzc2VsZWN0aW9uLmpzIiwiLi9zcmMvdXRpbC9kYXRhdXJsLmpzIiwiL1VzZXJzL0RhdmUvU2l0ZXMvRDNwbHVzL3NyYy91dGlsL2Rpc3RhbmNlcy5jb2ZmZWUiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvc3JjL3V0aWwvb2Zmc2V0LmNvZmZlZSIsIi9Vc2Vycy9EYXZlL1NpdGVzL0QzcGx1cy9zcmMvdXRpbC91bmlxdWVzLmNvZmZlZSIsIi4vc3JjL3Zpei9kcmF3L2FwcC5qcyIsIi4vc3JjL3Zpei9kcmF3L2NvbnRhaW5lci5qcyIsIi4vc3JjL3Zpei9kcmF3L2VudGVyLmpzIiwiLi9zcmMvdml6L2RyYXcvZXJyb3JzLmpzIiwiLi9zcmMvdml6L2RyYXcvZmluaXNoLmpzIiwiLi9zcmMvdml6L2RyYXcvZm9jdXMuanMiLCIuL3NyYy92aXovZHJhdy9zdGVwcy5qcyIsIi4vc3JjL3Zpei9kcmF3L3VwZGF0ZS5qcyIsIi4vc3JjL3Zpei9zaGFwZXMvYXJlYS5qcyIsIi4vc3JjL3Zpei9zaGFwZXMvY29sb3IuanMiLCIuL3NyYy92aXovc2hhcGVzL2Nvb3JkaW5hdGVzLmpzIiwiLi9zcmMvdml6L3NoYXBlcy9kb251dC5qcyIsIi4vc3JjL3Zpei9zaGFwZXMvZHJhdy5qcyIsIi4vc3JjL3Zpei9zaGFwZXMvZWRnZXMuanMiLCIuL3NyYy92aXovc2hhcGVzL2ZpbGwuanMiLCIuL3NyYy92aXovc2hhcGVzL2xhYmVscy5qcyIsIi4vc3JjL3Zpei9zaGFwZXMvbGluZS5qcyIsIi4vc3JjL3Zpei9zaGFwZXMvcmVjdC5qcyIsIi4vc3JjL3Zpei9zaGFwZXMvc3R5bGUuanMiLCIuL3NyYy92aXovdHlwZXMvYnViYmxlcy5qcyIsIi4vc3JjL3Zpei90eXBlcy9jaGFydC5qcyIsIi4vc3JjL3Zpei90eXBlcy9nZW9fbWFwLmpzIiwiLi9zcmMvdml6L3R5cGVzL2xpbmUuanMiLCIuL3NyYy92aXovdHlwZXMvbmV0d29yay5qcyIsIi9Vc2Vycy9EYXZlL1NpdGVzL0QzcGx1cy9zcmMvdml6L3R5cGVzL3BhdGhzLmNvZmZlZSIsIi4vc3JjL3Zpei90eXBlcy9yaW5ncy5qcyIsIi4vc3JjL3Zpei90eXBlcy9zY2F0dGVyLmpzIiwiLi9zcmMvdml6L3R5cGVzL3N0YWNrZWQuanMiLCIuL3NyYy92aXovdHlwZXMvdHJlZV9tYXAuanMiLCIuL3NyYy92aXovdWkvZHJhd2VyLmpzIiwiLi9zcmMvdml6L3VpL2ZvY3VzLmpzIiwiLi9zcmMvdml6L3VpL2hpc3RvcnkuanMiLCIuL3NyYy92aXovdWkvbGVnZW5kLmpzIiwiLi9zcmMvdml6L3VpL21lc3NhZ2UuanMiLCIuL3NyYy92aXovdWkvdGltZWxpbmUuanMiLCIuL3NyYy92aXovdWkvdGl0bGVzLmpzIiwiLi9zcmMvdml6L3Zpei5qcyIsIi4vc3JjL3pvb20vYm91bmRzLmpzIiwiLi9zcmMvem9vbS9jb250cm9scy5qcyIsIi4vc3JjL3pvb20vbGFiZWxzLmpzIiwiLi9zcmMvem9vbS9tb3VzZS5qcyIsIi4vc3JjL3pvb20vdHJhbnNmb3JtLmpzIiwiL1VzZXJzL0RhdmUvU2l0ZXMvRDNwbHVzL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIi9Vc2Vycy9EYXZlL1NpdGVzL0QzcGx1cy9ub2RlX21vZHVsZXMvaGVhcC9pbmRleC5qcyIsIi9Vc2Vycy9EYXZlL1NpdGVzL0QzcGx1cy9ub2RlX21vZHVsZXMvaGVhcC9saWIvaGVhcC5qcyIsIi9Vc2Vycy9EYXZlL1NpdGVzL0QzcGx1cy9ub2RlX21vZHVsZXMvbnVtZXJpYy9udW1lcmljLTEuMi42LmpzIiwiL1VzZXJzL0RhdmUvU2l0ZXMvRDNwbHVzL25vZGVfbW9kdWxlcy9zaW1wbGlmeS1qcy9zaW1wbGlmeS5qcyIsIi9Vc2Vycy9EYXZlL1NpdGVzL0QzcGx1cy9ub2RlX21vZHVsZXMvc3RhdGljLWtkdHJlZS9rZHRyZWUuanMiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvbm9kZV9tb2R1bGVzL3N0YXRpYy1rZHRyZWUvbGliL2hlYXAuanMiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvbm9kZV9tb2R1bGVzL3N0YXRpYy1rZHRyZWUvbm9kZV9tb2R1bGVzL2JpdC10d2lkZGxlL3R3aWRkbGUuanMiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvbm9kZV9tb2R1bGVzL3N0YXRpYy1rZHRyZWUvbm9kZV9tb2R1bGVzL2lub3JkZXItdHJlZS1sYXlvdXQvaW5vcmRlci5qcyIsIi9Vc2Vycy9EYXZlL1NpdGVzL0QzcGx1cy9ub2RlX21vZHVsZXMvc3RhdGljLWtkdHJlZS9ub2RlX21vZHVsZXMvbmRhcnJheS1vcHMvbmRhcnJheS1vcHMuanMiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvbm9kZV9tb2R1bGVzL3N0YXRpYy1rZHRyZWUvbm9kZV9tb2R1bGVzL25kYXJyYXktb3BzL25vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9jb21waWxlci5qcyIsIi9Vc2Vycy9EYXZlL1NpdGVzL0QzcGx1cy9ub2RlX21vZHVsZXMvc3RhdGljLWtkdHJlZS9ub2RlX21vZHVsZXMvbmRhcnJheS1vcHMvbm9kZV9tb2R1bGVzL2N3aXNlLWNvbXBpbGVyL2xpYi9jb21waWxlLmpzIiwiL1VzZXJzL0RhdmUvU2l0ZXMvRDNwbHVzL25vZGVfbW9kdWxlcy9zdGF0aWMta2R0cmVlL25vZGVfbW9kdWxlcy9uZGFycmF5LW9wcy9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbGliL3RodW5rLmpzIiwiL1VzZXJzL0RhdmUvU2l0ZXMvRDNwbHVzL25vZGVfbW9kdWxlcy9zdGF0aWMta2R0cmVlL25vZGVfbW9kdWxlcy9uZGFycmF5LW9wcy9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbm9kZV9tb2R1bGVzL3VuaXEvdW5pcS5qcyIsIi9Vc2Vycy9EYXZlL1NpdGVzL0QzcGx1cy9ub2RlX21vZHVsZXMvc3RhdGljLWtkdHJlZS9ub2RlX21vZHVsZXMvbmRhcnJheS1wYWNrL2NvbnZlcnQuanMiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvbm9kZV9tb2R1bGVzL3N0YXRpYy1rZHRyZWUvbm9kZV9tb2R1bGVzL25kYXJyYXktcGFjay9kb0NvbnZlcnQuanMiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvbm9kZV9tb2R1bGVzL3N0YXRpYy1rZHRyZWUvbm9kZV9tb2R1bGVzL25kYXJyYXktcGFjay9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvY29tcGlsZXIuanMiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvbm9kZV9tb2R1bGVzL3N0YXRpYy1rZHRyZWUvbm9kZV9tb2R1bGVzL25kYXJyYXktcGFjay9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbGliL2NvbXBpbGUuanMiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvbm9kZV9tb2R1bGVzL3N0YXRpYy1rZHRyZWUvbm9kZV9tb2R1bGVzL25kYXJyYXktcGFjay9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbm9kZV9tb2R1bGVzL3VuaXEvdW5pcS5qcyIsIi9Vc2Vycy9EYXZlL1NpdGVzL0QzcGx1cy9ub2RlX21vZHVsZXMvc3RhdGljLWtkdHJlZS9ub2RlX21vZHVsZXMvbmRhcnJheS1zY3JhdGNoL3NjcmF0Y2guanMiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvbm9kZV9tb2R1bGVzL3N0YXRpYy1rZHRyZWUvbm9kZV9tb2R1bGVzL25kYXJyYXktc2VsZWN0L3NlbGVjdC5qcyIsIi9Vc2Vycy9EYXZlL1NpdGVzL0QzcGx1cy9ub2RlX21vZHVsZXMvc3RhdGljLWtkdHJlZS9ub2RlX21vZHVsZXMvbmRhcnJheS9uZGFycmF5LmpzIiwiL1VzZXJzL0RhdmUvU2l0ZXMvRDNwbHVzL25vZGVfbW9kdWxlcy9zdGF0aWMta2R0cmVlL25vZGVfbW9kdWxlcy9uZGFycmF5L25vZGVfbW9kdWxlcy9pb3RhLWFycmF5L2lvdGEuanMiLCIvVXNlcnMvRGF2ZS9TaXRlcy9EM3BsdXMvbm9kZV9tb2R1bGVzL3N0YXRpYy1rZHRyZWUvbm9kZV9tb2R1bGVzL3R5cGVkYXJyYXktcG9vbC9ub2RlX21vZHVsZXMvZHVwL2R1cC5qcyIsIi9Vc2Vycy9EYXZlL1NpdGVzL0QzcGx1cy9ub2RlX21vZHVsZXMvc3RhdGljLWtkdHJlZS9ub2RlX21vZHVsZXMvdHlwZWRhcnJheS1wb29sL3Bvb2wuanMiXSwibmFtZXMi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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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SUFBaUIsSUFBQyxDQUFBLHFCQUFELENBQUEsQ0FBd0IsQ0FBQyxNQUFsRDtBQUFBLE1BQ0EsSUFBQSxFQUFNLENBRE47QUFBQSxNQUVBLEtBQUEsRUFBTyxJQUFDLENBQUEscUJBQUQsQ0FBQSxDQUZQO0tBREYsRUFENEc7RUFBQSxDQUE5RyxDQVRBLENBQUE7QUFBQSxFQWVBLE1BQU0sQ0FBQyxNQUFQLENBQUEsQ0FmQSxDQUFBO0FBZ0JBLEVBQUEsSUFBQSxDQUFBLE1BQUE7QUFBQSxJQUFBLE1BQU0sQ0FBQyxNQUFQLENBQUEsQ0FBQSxDQUFBO0dBaEJBO1NBaUJBLE1BbkJrQjtBQUFBLENBTHBCLENBQUE7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9VQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQSxNQUFNLENBQUMsT0FBTyxDQUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBYixHQUFxQixTQUFDLElBQUQsR0FBQTtBQUNuQixNQUFBLHVCQUFBO0FBQUEsRUFBQSxDQUFBLEdBQUksQ0FBSixDQUFBO0FBQUEsRUFDQSxhQUFBLEdBQWdCLEtBRGhCLENBQUE7QUFFQSxTQUFNLENBQUEsR0FBSSxRQUFRLENBQUMsV0FBVyxDQUFDLE1BQS9CLEdBQUE7QUFDRSxJQUFBLEtBQUEsR0FBUSxRQUFRLENBQUMsV0FBWSxDQUFBLENBQUEsQ0FBN0IsQ0FBQTtBQUNBLElBQUEsSUFBRyxLQUFLLENBQUMsSUFBTixJQUFlLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBWCxDQUFtQixJQUFuQixDQUFBLElBQTRCLENBQTlDO0FBQ0UsTUFBQSxhQUFBLEdBQWdCLElBQWhCLENBQUE7QUFDQSxZQUZGO0tBREE7QUFBQSxJQUlBLENBQUEsRUFKQSxDQURGO0VBQUEsQ0FGQTtTQVFBLGNBVG1CO0FBQUEsQ0FBckIsQ0FBQTs7QUFBQSxNQVdNLENBQUMsT0FBUCxHQUFpQixNQUFNLENBQUMsS0FBSyxDQUFDLEtBWDlCLENBQUE7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25SQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzltQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMTBJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNubUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ2YXIgZmV0Y2hWYWx1ZSA9IHJlcXVpcmUoXCIuLi9jb3JlL2ZldGNoL3ZhbHVlLmpzXCIpLFxuICAgIGZldGNoQ29sb3IgPSByZXF1aXJlKFwiLi4vY29yZS9mZXRjaC9jb2xvci5qc1wiKSxcbiAgICBmZXRjaFRleHQgID0gcmVxdWlyZShcIi4uL2NvcmUvZmV0Y2gvdGV4dC5qc1wiKVxuLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIFNvcnRzIGFuIGFycmF5IG9mIG9iamVjdHNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kM3BsdXMuYXJyYXkuc29ydCA9IGZ1bmN0aW9uKCBhcnIgLCBrZXlzICwgc29ydCAsIGNvbG9ycyAsIHZhcnMgKSB7XG5cbiAgaWYgKCAhYXJyIHx8IGFyci5sZW5ndGggPD0gMSB8fCAha2V5cyApIHtcbiAgICByZXR1cm4gYXJyIHx8IFtdXG4gIH1cblxuICBpZiAoICFzb3J0ICkge1xuICAgIHZhciBzb3J0ID0gXCJhc2NcIlxuICB9XG5cbiAgaWYgKCAhKGtleXMgaW5zdGFuY2VvZiBBcnJheSkgKSB7XG4gICAga2V5cyA9IFsga2V5cyBdXG4gIH1cblxuICBpZiAoICFjb2xvcnMgKSB7XG4gICAgdmFyIGNvbG9ycyA9IFsgXCJjb2xvclwiIF1cbiAgfVxuICBlbHNlIGlmICggIShjb2xvcnMgaW5zdGFuY2VvZiBBcnJheSkgKSB7XG4gICAgY29sb3JzID0gWyBjb2xvcnMgXVxuICB9XG5cbiAgZnVuY3Rpb24gY29tcGFyYXRvciggYSAsIGIgKSB7XG5cbiAgICB2YXIgcmV0VmFsID0gMFxuXG4gICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGtleXMubGVuZ3RoIDsgaSsrICkge1xuXG4gICAgICB2YXIgayA9IGtleXNbaV1cblxuICAgICAgaWYgKCB2YXJzICkge1xuXG4gICAgICAgIHZhciBkZXB0aEtleSA9IGEuZDNwbHVzID8gdmFycy5pZC5uZXN0aW5nW2EuZDNwbHVzLmRlcHRoXSA6IHVuZGVmaW5lZFxuICAgICAgICAgICwgZGVwdGhJbnQgPSBhLmQzcGx1cyA/IGEuZDNwbHVzLmRlcHRoIDogdW5kZWZpbmVkXG5cbiAgICAgICAgYSA9IGsgPT09IHZhcnMuY29sb3IudmFsdWVcbiAgICAgICAgICA/IGZldGNoQ29sb3IoIHZhcnMgLCBhICwgZGVwdGhLZXkgKVxuICAgICAgICAgIDogayA9PT0gdmFycy50ZXh0LnZhbHVlXG4gICAgICAgICAgPyBmZXRjaFRleHQoIHZhcnMgLCBhICwgZGVwdGhJbnQgKVxuICAgICAgICAgIDogZmV0Y2hWYWx1ZSggdmFycyAsIGEgLCBrICwgZGVwdGhLZXkgKVxuXG4gICAgICAgIHZhciBkZXB0aEtleSA9IGIuZDNwbHVzID8gdmFycy5pZC5uZXN0aW5nW2IuZDNwbHVzLmRlcHRoXSA6IHVuZGVmaW5lZFxuICAgICAgICAgICwgZGVwdGhJbnQgPSBiLmQzcGx1cyA/IGIuZDNwbHVzLmRlcHRoIDogdW5kZWZpbmVkXG4gICAgICAgIGIgPSBrID09PSB2YXJzLmNvbG9yLnZhbHVlXG4gICAgICAgICAgPyBmZXRjaENvbG9yKCB2YXJzICwgYiAsIGRlcHRoS2V5IClcbiAgICAgICAgICA6IGsgPT09IHZhcnMudGV4dC52YWx1ZVxuICAgICAgICAgID8gZmV0Y2hUZXh0KCB2YXJzICwgYiAsIGRlcHRoSW50IClcbiAgICAgICAgICA6IGZldGNoVmFsdWUoIHZhcnMgLCBiICwgayAsIGRlcHRoS2V5IClcblxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGEgPSBhW2tdXG4gICAgICAgIGIgPSBiW2tdXG4gICAgICB9XG5cbiAgICAgIGEgPSBhIGluc3RhbmNlb2YgQXJyYXkgPyBhID0gYVswXVxuICAgICAgICA6IHR5cGVvZiBhID09PSBcInN0cmluZ1wiID8gYSA9IGEudG9Mb3dlckNhc2UoKSA6IGFcbiAgICAgIGIgPSBiIGluc3RhbmNlb2YgQXJyYXkgPyBiID0gYlswXVxuICAgICAgICA6IHR5cGVvZiBiID09PSBcInN0cmluZ1wiID8gYiA9IGIudG9Mb3dlckNhc2UoKSA6IGJcblxuICAgICAgcmV0VmFsID0gY29sb3JzLmluZGV4T2YoaykgPj0gMCA/IGQzcGx1cy5jb2xvci5zb3J0KCBhICwgYiApXG4gICAgICAgICAgICAgOiBhIDwgYiA/IC0xIDogMVxuXG4gICAgICBpZiAoIHJldFZhbCAhPT0gMCB8fCBpID09PSBrZXlzLmxlbmd0aC0xICkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHNvcnQgPT09IFwiYXNjXCIgPyByZXRWYWwgOiAtcmV0VmFsXG5cbiAgfVxuXG4gIGlmICggYXJyLmxlbmd0aCA9PT0gMiApIHtcbiAgICByZXR1cm4gY29tcGFyYXRvcihhcnJbMF0sYXJyWzFdKVxuICB9XG5cbiAgcmV0dXJuIGFyci5zb3J0KGNvbXBhcmF0b3IpXG5cblxufVxuIiwiIyMjKlxuICogVXBkYXRlcyBhbiBhcnJheSwgZWl0aGVyIG92ZXJ3cml0aW5nIGl0IHdpdGggYSBuZXcgYXJyYXksIHJlbW92aW5nIGFuIGVudHJ5XG4gKiBpZiBpdCBpcyBwcmVzZW50LCBvciBhZGRpbmcgaXQgaWYgaXQgaXMgbm90LlxuICMjI1xuZDNwbHVzLmFycmF5LnVwZGF0ZSA9IChhcnIsIHgpIC0+XG4gIGFyciA9IFtdIHVubGVzcyBhcnIgaW5zdGFuY2VvZiBBcnJheVxuXG4gICMgSWYgdGhlIHVzZXIgaGFzIHBhc3NlZCBhbiBhcnJheSwganVzdCB1c2UgdGhhdC5cbiAgaWYgeCBpbnN0YW5jZW9mIEFycmF5XG4gICAgYXJyID0geFxuXG4gICMgT3RoZXJ3aXNlIHJlbW92ZSBpdCBpZiBpdCBpcyBwcmVzZW50LlxuICBlbHNlIGlmIGFyci5pbmRleE9mKHgpID49IDBcbiAgICBhcnIuc3BsaWNlIGFyci5pbmRleE9mKHgpLCAxXG5cbiAgIyBFbHNlLCBhZGQgaXQhXG4gIGVsc2VcbiAgICBhcnIucHVzaCB4XG4gIGFyclxuIiwiIyMjKlxuICogRGFya2VucyBhIGNvbG9yIGlmIGl0J3MgdG9vIGxpZ2h0IHRvIGFwcGVhciBvbiB3aGl0ZVxuICMjI1xuZDNwbHVzLmNvbG9yLmxlZ2libGUgPSAoY29sb3IpIC0+XG4gIGhzbCA9IGQzLmhzbCBjb2xvclxuICBpZiBoc2wubCA+IC40NVxuICAgIGhzbC5zID0gMC44IGlmIGhzbC5zID4gLjhcbiAgICBoc2wubCA9IDAuNDVcbiAgaHNsLnRvU3RyaW5nKClcbiIsIiMjIypcbiAqIExpZ2h0ZW5zIGEgY29sb3JcbiAjIyNcbmQzcGx1cy5jb2xvci5saWdodGVyID0gKGNvbG9yLCBpbmNyZW1lbnQpIC0+XG4gIGluY3JlbWVudCA9IDAuNSAgaWYgaW5jcmVtZW50IGlzIGB1bmRlZmluZWRgXG4gIGMgPSBkMy5oc2woY29sb3IpXG4gIGMubCArPSAoMSAtIGMubCkgKiBpbmNyZW1lbnRcbiAgYy50b1N0cmluZygpXG4iLCIjIyMqXG4gKiBNaXhlcyAyIGNvbG9ycyB3aXRoIG9wdGlvbmFsIG9wYWNpdGllc1xuICMjI1xuZDNwbHVzLmNvbG9yLm1peCA9IChjMSwgYzIsIG8xLCBvMikgLT5cbiAgbzEgPSAxICB1bmxlc3MgbzFcbiAgbzIgPSAxICB1bmxlc3MgbzJcbiAgYzEgPSBkMy5yZ2IoYzEpXG4gIGMyID0gZDMucmdiKGMyKVxuICByID0gKG8xICogYzEuciArIG8yICogYzIuciAtIG8xICogbzIgKiBjMi5yKSAvIChvMSArIG8yIC0gbzEgKiBvMilcbiAgZyA9IChvMSAqIGMxLmcgKyBvMiAqIGMyLmcgLSBvMSAqIG8yICogYzIuZykgLyAobzEgKyBvMiAtIG8xICogbzIpXG4gIGIgPSAobzEgKiBjMS5iICsgbzIgKiBjMi5iIC0gbzEgKiBvMiAqIGMyLmIpIC8gKG8xICsgbzIgLSBvMSAqIG8yKVxuICBkMy5yZ2IociwgZywgYikudG9TdHJpbmcoKVxuIiwiIyMjKlxuICogUmV0dXJucyBhIHJhbmRvbSBjb2xvclxuICMjI1xuZDNwbHVzLmNvbG9yLnJhbmRvbSA9ICh4LCBzY2FsZSkgLT5cbiAgcmFuZF9pbnQgPSB4IG9yIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIwKVxuICBzY2FsZSA9IHNjYWxlIG9yIGQzcGx1cy5jb2xvci5zY2FsZVxuICBzY2FsZSByYW5kX2ludFxuIiwiIyMjKlxuICogRGVmYXVsdCBEM3BsdXMgY29sb3Igc2NhbGVcbiAjIyNcbmQzcGx1cy5jb2xvci5zY2FsZSA9IGQzLnNjYWxlLm9yZGluYWwoKS5yYW5nZShbXG4gIFwiI2IyMjIwMFwiLFxuICBcIiNFQUNFM0ZcIixcbiAgXCIjMjgyRjZCXCIsXG5cbiAgXCIjQjM1QzFFXCIsXG4gIFwiIzIyNEYyMFwiLFxuICBcIiM1RjQ4N0NcIixcblxuICBcIiM3NTkxNDNcIixcbiAgXCIjNDE5MzkxXCIsXG4gIFwiIzk5M0Y4OFwiLFxuXG4gIFwiI2U4OWM4OVwiLFxuICBcIiNmZmVlOGRcIixcbiAgXCIjYWZkNWU4XCIsXG5cbiAgXCIjZjdiYTc3XCIsXG4gIFwiI2E1YzY5N1wiLFxuICBcIiNjNWI1ZTVcIixcblxuICBcIiNkMWQzOTJcIixcbiAgXCIjYmJlZmQwXCIsXG4gIFwiI2UwOTljZlwiXG5dKVxuIiwiIyMjKlxuICogU29ydHMgMiBjb2xvcnMgYmFzZWQgb24gaHVlLlxuICMjI1xuZDNwbHVzLmNvbG9yLnNvcnQgPSAoYSwgYikgLT5cbiAgYUhTTCA9IGQzLmhzbCBhXG4gIGJIU0wgPSBkMy5oc2wgYlxuICBhID0gaWYgYUhTTC5zIGlzIDAgdGhlbiAzNjEgZWxzZSBhSFNMLmhcbiAgYiA9IGlmIGJIU0wucyBpcyAwIHRoZW4gMzYxIGVsc2UgYkhTTC5oXG4gIGlmIGEgaXMgYiB0aGVuIGFIU0wubCAtIGJIU0wubCBlbHNlIGEgLSBiXG4iLCIjIyMqXG4gKiBSZXR1cm5zIGFwcHJvcHJpYXRlIHRleHQgY29sb3IgYmFzZWQgb2ZmIG9mIGEgZ2l2ZW4gY29sb3JcbiAjIyNcbmQzcGx1cy5jb2xvci50ZXh0ID0gKGNvbG9yKSAtPlxuICByZ2JDb2xvciA9IGQzLnJnYihjb2xvcilcbiAgciA9IHJnYkNvbG9yLnJcbiAgZyA9IHJnYkNvbG9yLmdcbiAgYiA9IHJnYkNvbG9yLmJcbiAgeWlxID0gKHIgKiAyOTkgKyBnICogNTg3ICsgYiAqIDExNCkgLyAxMDAwXG4gIGlmIHlpcSA+PSAxMjggdGhlbiBcIiM0NDQ0NDRcIiBlbHNlIFwiI2Y3ZjdmN1wiXG4iLCIjIyMqXG4gKiBUZXN0cyBpZiBhIHN0cmluZyBpcyBhIHZhbGlkIGNvbG9yXG4gIyMjXG5kM3BsdXMuY29sb3IudmFsaWRhdGUgPSAoY29sb3IpIC0+XG4gIGNvbG9yID0gY29sb3IgKyBcIlwiXG4gIGNvbG9yID0gY29sb3IucmVwbGFjZShSZWdFeHAoXCIgXCIsIFwiZ1wiKSwgXCJcIilcbiAgY29sb3IgPSBjb2xvci5zcGxpdChcIihcIilbMV0uc3BsaXQoXCIpXCIpWzBdLnNwbGl0KFwiLFwiKS5zbGljZSgwLCAzKS5qb2luKFwiLFwiKSBpZiBjb2xvci5pbmRleE9mKFwicmdiXCIpIGlzIDBcbiAgY29sb3IgPSBjb2xvci5zcGxpdChcIixcIilbMl0uc3BsaXQoXCIpXCIpWzBdICBpZiBjb2xvci5pbmRleE9mKFwiaHNsXCIpIGlzIDBcbiAgdGVzdENvbG9yID0gZDMucmdiKGNvbG9yKS50b1N0cmluZygpXG4gIGJsYWNrQ29sb3JzID0gWyBcImJsYWNrXCIsIFwiIzAwMFwiLCBcIiMwMDAwMDBcIiwgXCIwJVwiLCBcIjAsMCwwXCIgXVxuICB1c2VyQmxhY2sgPSBibGFja0NvbG9ycy5pbmRleE9mKGNvbG9yKSA+PSAwXG4gIHRlc3RDb2xvciBpc250IFwiIzAwMDAwMFwiIG9yIHVzZXJCbGFja1xuIiwidmFyIGZldGNoVmFsdWUgPSByZXF1aXJlKFwiLi4vZmV0Y2gvdmFsdWUuanNcIilcbi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gU2V0cyBjb2xvciByYW5nZSBvZiBkYXRhLCBpZiBhcHBsaWNhYmxlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFycykge1xuXG4gIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lKFwiZ2V0dGluZyBjb2xvciBkYXRhIHJhbmdlXCIpXG5cbiAgdmFyIGRhdGFfcmFuZ2UgPSBbXVxuICB2YXJzLmRhdGEucG9vbC5mb3JFYWNoKGZ1bmN0aW9uKGQpe1xuICAgIHZhciB2YWwgPSBwYXJzZUZsb2F0KGZldGNoVmFsdWUodmFycyxkLHZhcnMuY29sb3IudmFsdWUpKVxuICAgIGlmICh0eXBlb2YgdmFsID09IFwibnVtYmVyXCIgJiYgIWlzTmFOKHZhbCkgJiYgZGF0YV9yYW5nZS5pbmRleE9mKHZhbCkgPCAwKSBkYXRhX3JhbmdlLnB1c2godmFsKVxuICB9KVxuXG4gIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lRW5kKFwiZ2V0dGluZyBjb2xvciBkYXRhIHJhbmdlXCIpXG5cbiAgaWYgKGRhdGFfcmFuZ2UubGVuZ3RoID4gMSkge1xuXG4gICAgdmFyIGRhdGFfZG9tYWluID0gbnVsbFxuXG4gICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWUoXCJjYWxjdWxhdGluZyBjb2xvciBzY2FsZVwiKVxuXG4gICAgZGF0YV9yYW5nZSA9IGQzLmV4dGVudChkYXRhX3JhbmdlKVxuXG4gICAgaWYgKGRhdGFfcmFuZ2VbMF0gPCAwICYmIGRhdGFfcmFuZ2VbMV0gPiAwKSB7XG4gICAgICB2YXIgY29sb3JfcmFuZ2UgPSB2YXJzLmNvbG9yLnJhbmdlXG4gICAgICBpZiAoY29sb3JfcmFuZ2UubGVuZ3RoID09IDMpIHtcbiAgICAgICAgZGF0YV9yYW5nZS5wdXNoKGRhdGFfcmFuZ2VbMV0pXG4gICAgICAgIGRhdGFfcmFuZ2VbMV0gPSAwXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFfcmFuZ2VbMV0gPiAwICYmIGRhdGFfcmFuZ2VbMF0gPj0gMCkge1xuICAgICAgdmFyIGNvbG9yX3JhbmdlID0gdmFycy5jb2xvci5oZWF0bWFwXG4gICAgICBkYXRhX3JhbmdlID0gZDNwbHVzLnV0aWwuYnVja2V0cyhkYXRhX3JhbmdlLGNvbG9yX3JhbmdlLmxlbmd0aClcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgY29sb3JfcmFuZ2UgPSB2YXJzLmNvbG9yLnJhbmdlLnNsaWNlKDApXG4gICAgICBpZiAoZGF0YV9yYW5nZVswXSA8IDApIHtcbiAgICAgICAgY29sb3JfcmFuZ2UucG9wKClcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjb2xvcl9yYW5nZS5zaGlmdCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFycy5jb2xvci52YWx1ZVNjYWxlID0gZDMuc2NhbGUuc3FydCgpXG4gICAgICAuZG9tYWluKGRhdGFfcmFuZ2UpXG4gICAgICAucmFuZ2UoY29sb3JfcmFuZ2UpXG4gICAgICAuaW50ZXJwb2xhdGUoZDMuaW50ZXJwb2xhdGVSZ2IpXG5cbiAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZUVuZChcImNhbGN1bGF0aW5nIGNvbG9yIHNjYWxlXCIpXG5cbiAgfVxuICBlbHNlIHtcbiAgICB2YXJzLmNvbG9yLnZhbHVlU2NhbGUgPSBudWxsXG4gIH1cblxufVxuIiwidmFyIGZldGNoVmFsdWUgPSByZXF1aXJlKFwiLi4vZmV0Y2gvdmFsdWUuanNcIilcbi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBSZXN0cmljdHMgZGF0YSBiYXNlZCBvbiBTb2xvL011dGUgZmlsdGVyc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIHZhcnMgLCBkYXRhICkge1xuXG4gIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lKFwiZmlsdGVyaW5nIGRhdGFcIilcblxuICB2YXIgYXZhaWxhYmxlS2V5cyA9IGQzLmtleXModmFycy5kYXRhLmtleXMgfHwge30pXG5cbiAgaWYgKCBcImF0dHJzXCIgaW4gdmFycyApIHtcbiAgICBhdmFpbGFibGVLZXlzID0gYXZhaWxhYmxlS2V5cy5jb25jYXQoZDMua2V5cyh2YXJzLmF0dHJzLmtleXMgfHwge30pKVxuICB9XG5cbiAgZGF0YSA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpe1xuICAgIHJldHVybiB2YXJzLmlkLnZhbHVlIGluIGRcbiAgfSlcblxuICB2YXJzLmRhdGEuZmlsdGVycy5mb3JFYWNoKCBmdW5jdGlvbigga2V5ICkge1xuXG4gICAgaWYgKCBhdmFpbGFibGVLZXlzLmluZGV4T2YodmFyc1trZXldLnZhbHVlKSA+PSAwICkge1xuXG4gICAgICBkYXRhID0gZGF0YS5maWx0ZXIoIGZ1bmN0aW9uKCBkICkge1xuXG4gICAgICAgIHZhciB2YWwgPSBmZXRjaFZhbHVlKHZhcnMsZCx2YXJzW2tleV0udmFsdWUpXG4gICAgICAgIGlmICgga2V5ID09PSBcInNpemVcIiApIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIlxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiB2YWwgIT09IG51bGxcbiAgICAgICAgfVxuXG4gICAgICB9KVxuXG4gICAgfVxuXG4gIH0pXG5cbiAgLy8gaWYgXCJzb2xvXCIsIG9ubHkgY2hlY2sgYWdhaW5zdCBcInNvbG9cIiAoZGlzcmVnYXJkIFwibXV0ZVwiKVxuICB2YXIga2V5ID0gdmFycy5kYXRhLnNvbG8ubGVuZ3RoID8gXCJzb2xvXCIgOiBcIm11dGVcIlxuXG4gIHZhcnMuZGF0YVtrZXldLmZvckVhY2goIGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgZnVuY3Rpb24gdGVzdF92YWx1ZSggdmFsICkge1xuXG4gICAgICB2YXIgYXJyID0gdmFyc1t2XVtrZXldLnZhbHVlXG5cbiAgICAgIHZhciBtYXRjaCA9IGZhbHNlXG4gICAgICBhcnIuZm9yRWFjaChmdW5jdGlvbihmKXtcbiAgICAgICAgaWYgKHR5cGVvZiBmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBtYXRjaCA9IGYodmFsKVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBmID09PSB2YWwgKSB7XG4gICAgICAgICAgbWF0Y2ggPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIG1hdGNoXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmVzdF9jaGVjayggZCApIHtcblxuICAgICAgLy8gaWYgdGhlIHZhcmlhYmxlIGhhcyBuZXN0aW5nLCBjaGVjayBhbGwgbGV2ZWxzXG4gICAgICB2YXIgbWF0Y2ggPSBmYWxzZVxuICAgICAgaWYgKHZhcnNbdl0ubmVzdGluZykge1xuICAgICAgICB2YXIgbmVzdGluZyA9IHZhcnNbdl0ubmVzdGluZ1xuICAgICAgICBpZiAoZDNwbHVzLm9iamVjdC52YWxpZGF0ZShuZXN0aW5nKSkge1xuICAgICAgICAgIG5lc3RpbmcgPSBkMy5rZXlzKG5lc3RpbmcpXG4gICAgICAgIH1cbiAgICAgICAgbmVzdGluZy5mb3JFYWNoKGZ1bmN0aW9uKG4pe1xuICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIG1hdGNoID0gdGVzdF92YWx1ZShmZXRjaFZhbHVlKHZhcnMsZCxuKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbWF0Y2ggPSB0ZXN0X3ZhbHVlKGZldGNoVmFsdWUodmFycyxkLHZhcnNbdl0udmFsdWUpKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ga2V5ID09PSBcInNvbG9cIiA/IG1hdGNoIDogIW1hdGNoXG5cbiAgICB9XG5cbiAgICBkYXRhID0gZGF0YS5maWx0ZXIobmVzdF9jaGVjaylcblxuICAgIGlmICggdiA9PT0gXCJpZFwiICkge1xuXG4gICAgICBpZiAoXCJub2Rlc1wiIGluIHZhcnMgJiYgdmFycy5ub2Rlcy52YWx1ZSkge1xuICAgICAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUubG9nKFwiRmlsdGVyaW5nIE5vZGVzXCIpXG4gICAgICAgIHZhcnMubm9kZXMucmVzdHJpY3RlZCA9IHZhcnMubm9kZXMudmFsdWUuZmlsdGVyKG5lc3RfY2hlY2spXG4gICAgICB9XG5cbiAgICAgIGlmIChcImVkZ2VzXCIgaW4gdmFycyAmJiB2YXJzLmVkZ2VzLnZhbHVlKSB7XG4gICAgICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS5sb2coXCJGaWx0ZXJpbmcgQ29ubmVjdGlvbnNcIilcbiAgICAgICAgdmFycy5lZGdlcy5yZXN0cmljdGVkID0gdmFycy5lZGdlcy52YWx1ZS5maWx0ZXIoZnVuY3Rpb24oZCl7XG4gICAgICAgICAgdmFyIGZpcnN0X21hdGNoID0gbmVzdF9jaGVjayhkW3ZhcnMuZWRnZXMuc291cmNlXSksXG4gICAgICAgICAgICAgIHNlY29uZF9tYXRjaCA9IG5lc3RfY2hlY2soZFt2YXJzLmVkZ2VzLnRhcmdldF0pXG4gICAgICAgICAgcmV0dXJuIGZpcnN0X21hdGNoICYmIHNlY29uZF9tYXRjaFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgfVxuXG4gIH0pXG5cbiAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWVFbmQoXCJmaWx0ZXJpbmcgZGF0YVwiKVxuXG4gIHJldHVybiBkYXRhXG5cbn1cbiIsInZhciBkYXRhTmVzdCAgID0gcmVxdWlyZShcIi4vbmVzdC5qc1wiKSxcbiAgICBmZXRjaFZhbHVlID0gcmVxdWlyZShcIi4uL2ZldGNoL3ZhbHVlLmpzXCIpXG4vL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gRm9ybWF0cyByYXcgZGF0YSBieSB0aW1lIGFuZCBuZXN0aW5nXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggdmFycyApIHtcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gR2V0cyBhbGwgdW5pcXVlIHRpbWUgdmFsdWVzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXJzLmRhdGEudGltZSA9IHtcInZhbHVlc1wiOiBbXX1cbiAgaWYgKCB2YXJzLnRpbWUgJiYgdmFycy50aW1lLnZhbHVlICkge1xuXG4gICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIHtcbiAgICAgIHZhciB0aW1lclN0cmluZyA9IFwiYW5hbHl6aW5nIHRpbWUgcGVyaW9kc1wiXG4gICAgICBkM3BsdXMuY29uc29sZS50aW1lKCB0aW1lclN0cmluZyApXG4gICAgfVxuXG4gICAgdmFyIHVuaXF1ZVRpbWVzID0gZDNwbHVzLnV0aWwudW5pcXVlcyggdmFycy5kYXRhLnZhbHVlICwgdmFycy50aW1lLnZhbHVlIClcbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB1bmlxdWVUaW1lcy5sZW5ndGggOyBpKysgKSB7XG4gICAgICB2YXIgZCA9IG5ldyBEYXRlKHVuaXF1ZVRpbWVzW2ldLnRvU3RyaW5nKCkpXG4gICAgICBpZiAoZCAhPT0gXCJJbnZhbGlkIERhdGVcIikge1xuICAgICAgICBkLnNldFRpbWUoIGQuZ2V0VGltZSgpICsgZC5nZXRUaW1lem9uZU9mZnNldCgpICogNjAgKiAxMDAwIClcbiAgICAgICAgdmFycy5kYXRhLnRpbWUudmFsdWVzLnB1c2goZClcbiAgICAgIH1cbiAgICB9XG4gICAgdmFycy5kYXRhLnRpbWUudmFsdWVzLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS1ifSlcblxuICAgIHZhciBzdGVwID0gW11cbiAgICB2YXJzLmRhdGEudGltZS52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbih5LGkpe1xuICAgICAgaWYgKGkgIT0gMCkge1xuICAgICAgICB2YXIgcHJldiA9IHZhcnMuZGF0YS50aW1lLnZhbHVlc1tpLTFdXG4gICAgICAgIHN0ZXAucHVzaCh5LXByZXYpXG4gICAgICAgIGlmIChpID09PSB2YXJzLmRhdGEudGltZS52YWx1ZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHZhcnMuZGF0YS50aW1lLnRvdGFsID0geSAtIHZhcnMuZGF0YS50aW1lLnZhbHVlc1swXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIHZhcnMuZGF0YS50aW1lLnN0ZXAgPSBkMy5taW4oc3RlcClcblxuICAgIHZhciBwZXJpb2RzID0gW1wiTWlsbGlzZWNvbmRzXCIsXCJTZWNvbmRzXCIsXCJNaW51dGVzXCIsXCJIb3Vyc1wiLFwiRGF0ZVwiLFwiTW9udGhcIixcIkZ1bGxZZWFyXCJdXG4gICAgICAsIGNvbnZlcnNpb25zID0gWzEwMDAsNjAsNjAsMjQsMzAsMTIsMV1cblxuICAgIHZhciBnZXREaWZmID0gZnVuY3Rpb24oc3RhcnQsZW5kLGkpIHtcblxuICAgICAgaWYgKCF2YXJzLmRhdGEudGltZS5zdGVwRGl2aWRlcikge1xuICAgICAgICB2YXJzLmRhdGEudGltZS5zdGVwRGl2aWRlciA9IGNvbnZlcnNpb25zLnNsaWNlKDAsaSkucmVkdWNlKGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEqYn0pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGguZmxvb3IoZW5kLXN0YXJ0KS92YXJzLmRhdGEudGltZS5zdGVwRGl2aWRlcilcblxuICAgIH1cblxuICAgIHZhciBzdGVwID0gdmFycy5kYXRhLnRpbWUuc3RlcCwgdG90YWwgPSB2YXJzLmRhdGEudGltZS50b3RhbFxuICAgIHBlcmlvZHMuZm9yRWFjaChmdW5jdGlvbihwLGkpe1xuXG4gICAgICBpZiAoIXZhcnMuZGF0YS50aW1lLnN0ZXBUeXBlICYmIChpID09PSBwZXJpb2RzLmxlbmd0aC0xIHx8IE1hdGgucm91bmQoc3RlcCkgPCBjb252ZXJzaW9uc1tpXSkpIHtcbiAgICAgICAgdmFycy5kYXRhLnRpbWUuc3RlcFR5cGUgPSBwXG4gICAgICAgIHZhciBzdGFydCA9IHZhcnMuZGF0YS50aW1lLnZhbHVlc1swXVxuICAgICAgICAgICwgZW5kID0gdmFycy5kYXRhLnRpbWUudmFsdWVzW3ZhcnMuZGF0YS50aW1lLnZhbHVlcy5sZW5ndGgtMV1cbiAgICAgICAgdmFycy5kYXRhLnRpbWUuc3RlcEludGVydmFscyA9IGdldERpZmYoc3RhcnQsZW5kLGkpXG4gICAgICB9XG5cbiAgICAgIGlmICghdmFycy5kYXRhLnRpbWUudG90YWxUeXBlICYmIChpID09PSBwZXJpb2RzLmxlbmd0aC0xIHx8IE1hdGgucm91bmQodG90YWwpIDwgY29udmVyc2lvbnNbaV0pKSB7XG4gICAgICAgIHZhcnMuZGF0YS50aW1lLnRvdGFsVHlwZSA9IHBcbiAgICAgIH1cblxuICAgICAgc3RlcCA9IHN0ZXAvY29udmVyc2lvbnNbaV1cbiAgICAgIHRvdGFsID0gdG90YWwvY29udmVyc2lvbnNbaV1cbiAgICB9KVxuXG4gICAgdmFycy5kYXRhLnRpbWUudmFsdWVzLmZvckVhY2goZnVuY3Rpb24oeSxpKXtcbiAgICAgIGlmIChpICE9IDApIHtcbiAgICAgICAgdmFyIHByZXYgPSB2YXJzLmRhdGEudGltZS52YWx1ZXNbMF1cbiAgICAgICAgLy8gY29uc29sZS5sb2cocGVyaW9kcy5pbmRleE9mKHZhcnMuZGF0YS50aW1lLnN0ZXBUeXBlKSlcbiAgICAgICAgdmFycy5kYXRhLnRpbWUuZGF0YVN0ZXBzLnB1c2goZ2V0RGlmZihwcmV2LHkscGVyaW9kcy5pbmRleE9mKHZhcnMuZGF0YS50aW1lLnN0ZXBUeXBlKSkpXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFycy5kYXRhLnRpbWUuZGF0YVN0ZXBzID0gWzBdXG4gICAgICB9XG4gICAgfSlcblxuICAgIHZhciBzdGVwVHlwZSA9IHZhcnMuZGF0YS50aW1lLnN0ZXBUeXBlXG4gICAgICAsIHRvdGFsVHlwZSA9IHZhcnMuZGF0YS50aW1lLnRvdGFsVHlwZVxuICAgICAgLCBsb2NhbGUgPSB2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWVcblxuICAgIHZhciBnZXRGb3JtYXQgPSBmdW5jdGlvbihzLHQsc21hbGwpIHtcblxuICAgICAgaWYgKHMgPT09IHQpIHtcbiAgICAgICAgcmV0dXJuIHNtYWxsICYmIGxvY2FsZS50aW1lRm9ybWF0W3MrXCJTbWFsbFwiXSA/IGxvY2FsZS50aW1lRm9ybWF0W3MrXCJTbWFsbFwiXSA6IGxvY2FsZS50aW1lRm9ybWF0W3NdXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHBlcmlvZHMuaW5kZXhPZihzKSA+PSA0IHx8IHBlcmlvZHMuaW5kZXhPZih0KSA8PSAzKSB7XG4gICAgICAgICAgcmV0dXJuIGxvY2FsZS50aW1lRm9ybWF0W3QrXCItXCIrc11cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgIGlmICh0ID09PSBcIkRhdGVcIikge1xuICAgICAgICAgICAgdmFyIGZvcm1hdCA9IGxvY2FsZS50aW1lRm9ybWF0W3RdXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZvcm1hdCA9IGxvY2FsZS50aW1lRm9ybWF0W3QrXCItRGF0ZVwiXVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzID09PSBcIkhvdXJzXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQgK1wiIFwiKyBsb2NhbGUudGltZUZvcm1hdFtzXVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQgK1wiIFwiKyBsb2NhbGUudGltZUZvcm1hdFtcIkhvdXJzLVwiK3NdXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciBtdWx0aSA9IFtdXG4gICAgICAsIGZ1bmN0aW9ucyA9IFtcbiAgICAgICAgLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLmdldE1pbGxpc2Vjb25kcygpOyB9XG4gICAgICAgICwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5nZXRTZWNvbmRzKCk7IH1cbiAgICAgICAgLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLmdldE1pbnV0ZXMoKTsgfVxuICAgICAgICAsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuZ2V0SG91cnMoKTsgfVxuICAgICAgICAsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuZ2V0RGF0ZSgpICE9IDE7IH1cbiAgICAgICAgLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLmdldE1vbnRoKCk7IH1cbiAgICAgICAgLCBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgIF1cblxuICAgIGZvciAodmFyIGkgPSBwZXJpb2RzLmluZGV4T2Yoc3RlcFR5cGUpOyBpIDw9IHBlcmlvZHMuaW5kZXhPZih0b3RhbFR5cGUpOyBpKyspIHtcbiAgICAgIHZhciBwcmV2ID0gaS0xIDwgcGVyaW9kcy5pbmRleE9mKHN0ZXBUeXBlKSA/IHBlcmlvZHNbaV0gOiBwZXJpb2RzW2ktMV1cbiAgICAgIHZhciBzbWFsbCA9IHBlcmlvZHNbaV0gPT09IHByZXYgJiYgc3RlcFR5cGUgIT09IHRvdGFsVHlwZVxuICAgICAgdmFyIGZvcm1hdCA9IGdldEZvcm1hdChwcmV2LHBlcmlvZHNbaV0sc21hbGwpXG4gICAgICBtdWx0aS5wdXNoKFtmb3JtYXQsZnVuY3Rpb25zW2krMV1dKVxuICAgIH1cblxuICAgIHZhcnMuZGF0YS50aW1lLmZvcm1hdCA9IGQzLmxvY2FsZShsb2NhbGUuZm9ybWF0KS50aW1lRm9ybWF0KGdldEZvcm1hdChzdGVwVHlwZSx0b3RhbFR5cGUpKVxuICAgIHZhcnMuZGF0YS50aW1lLm11bHRpRm9ybWF0ID0gZDMubG9jYWxlKGxvY2FsZS5mb3JtYXQpLnRpbWVGb3JtYXQubXVsdGkobXVsdGkpXG5cbiAgICB2YXJzLmRhdGEudGltZS50aWNrcyA9IFtdXG4gICAgdmFyIG1pbiA9IGQzLm1pbih2YXJzLmRhdGEudGltZS52YWx1ZXMpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdmFycy5kYXRhLnRpbWUuc3RlcEludGVydmFsczsgaSsrKSB7XG4gICAgICB2YXIgZCA9IG5ldyBEYXRlKG1pbilcbiAgICAgIGRbXCJzZXRcIit2YXJzLmRhdGEudGltZS5zdGVwVHlwZV0oZFtcImdldFwiK3ZhcnMuZGF0YS50aW1lLnN0ZXBUeXBlXSgpICsgaSlcbiAgICAgIHZhcnMuZGF0YS50aW1lLnRpY2tzLnB1c2goZClcbiAgICB9XG5cbiAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZUVuZCggdGltZXJTdHJpbmcgKVxuXG4gIH1cblxuICBpZiAoIHZhcnMuZGV2LnZhbHVlICkge1xuICAgIHZhciB0aW1lclN0cmluZyA9IFwibmVzdGluZyBkYXRhIGJ5IHRpbWUgYW5kIGRlcHRoc1wiXG4gICAgZDNwbHVzLmNvbnNvbGUudGltZSggdGltZXJTdHJpbmcgKVxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIEdldHMgYWxsIHVuaXF1ZSB0aW1lIHZhbHVlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgdmFycy5kYXRhLm5lc3RlZCA9IHt9XG4gIGlmICh2YXJzLmRhdGEudGltZS52YWx1ZXMubGVuZ3RoID09PSAwKSB7XG5cbiAgICB2YXJzLmRhdGEubmVzdGVkLmFsbCA9IHt9XG4gICAgdmFycy5pZC5uZXN0aW5nLmZvckVhY2goIGZ1bmN0aW9uKCBkZXB0aCAsIGkgKSB7XG5cbiAgICAgIHZhciBuZXN0aW5nRGVwdGggPSB2YXJzLmlkLm5lc3Rpbmcuc2xpY2UoIDAgLCBpICsgMSApXG5cbiAgICAgIHZhcnMuZGF0YS5uZXN0ZWQuYWxsWyBkZXB0aCBdID0gZGF0YU5lc3QoIHZhcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgdmFycy5kYXRhLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIG5lc3RpbmdEZXB0aCApXG5cbiAgICB9KVxuXG4gIH1cbiAgZWxzZSB7XG5cbiAgICB2YXJzLmRhdGEudGltZS52YWx1ZXMuZm9yRWFjaCggZnVuY3Rpb24oIHQgKSB7XG5cbiAgICAgIHZhciBtcyA9IHQuZ2V0VGltZSgpXG5cbiAgICAgIHZhcnMuZGF0YS5uZXN0ZWRbIG1zIF0gPSB7IH1cblxuICAgICAgdmFyIHRpbWVEYXRhID0gdmFycy5kYXRhLnZhbHVlLmZpbHRlciggZnVuY3Rpb24oZCkge1xuICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKGZldGNoVmFsdWUoIHZhcnMgLCBkICwgdmFycy50aW1lLnZhbHVlICkudG9TdHJpbmcoKSlcbiAgICAgICAgZC5zZXRUaW1lKCBkLmdldFRpbWUoKSArIGQuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwICogMTAwMCApXG4gICAgICAgIHJldHVybiBkLmdldFRpbWUoKSA9PT0gbXNcbiAgICAgIH0pXG5cbiAgICAgIHZhcnMuaWQubmVzdGluZy5mb3JFYWNoKCBmdW5jdGlvbiggZGVwdGggLCBpICkge1xuXG4gICAgICAgIHZhciBuZXN0aW5nRGVwdGggPSB2YXJzLmlkLm5lc3Rpbmcuc2xpY2UoIDAgLCBpICsgMSApXG5cbiAgICAgICAgdmFycy5kYXRhLm5lc3RlZFsgbXMgXVsgZGVwdGggXSA9IGRhdGFOZXN0KCB2YXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHRpbWVEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIG5lc3RpbmdEZXB0aCApXG5cbiAgICAgIH0pXG5cbiAgICB9KVxuXG4gIH1cblxuICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZUVuZCggdGltZXJTdHJpbmcgKVxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gR2V0IEtleSBUeXBlcyBmcm9tIERhdGFcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCB2YXJzICwgdHlwZSApIHtcblxuICBpZiAoIHZhcnMuZGV2LnZhbHVlICkge1xuICAgIHZhciB0aW1lclN0cmluZyA9IHR5cGUgKyBcIiBrZXkgYW5hbHlzaXNcIlxuICAgIGNvbnNvbGUudGltZSggdGltZXJTdHJpbmcgKVxuICB9XG5cbiAgdmFyc1t0eXBlXS5rZXlzID0ge31cblxuICBmdW5jdGlvbiBnZXRfa2V5cyggYXJyICkge1xuICAgIGlmIChhcnIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgYXJyLmZvckVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICBnZXRfa2V5cyggZCApXG4gICAgICB9KVxuICAgIH1cbiAgICBlbHNlIGlmICggZDNwbHVzLm9iamVjdC52YWxpZGF0ZShhcnIpICkge1xuICAgICAgZm9yICh2YXIgZCBpbiBhcnIpIHtcbiAgICAgICAgaWYgKCBkM3BsdXMub2JqZWN0LnZhbGlkYXRlKGFycltkXSkgKSB7XG4gICAgICAgICAgZ2V0X2tleXMoIGFycltkXSApXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShkIGluIHZhcnNbdHlwZV0ua2V5cykgJiYgZCBpbiBhcnIpIHtcbiAgICAgICAgICB2YXJzW3R5cGVdLmtleXNbZF0gPSB0eXBlb2YgYXJyW2RdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIGQzcGx1cy5vYmplY3QudmFsaWRhdGUodmFyc1t0eXBlXS52YWx1ZSkgKSB7XG4gICAgZm9yICggdmFyIGEgaW4gdmFyc1t0eXBlXS52YWx1ZSApIHtcbiAgICAgIGdldF9rZXlzKHZhcnNbdHlwZV0udmFsdWVbYV0pXG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGdldF9rZXlzKHZhcnNbdHlwZV0udmFsdWUpXG4gIH1cblxuICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgY29uc29sZS50aW1lKCB0aW1lclN0cmluZyApXG5cbn1cbiIsIiMjIypcbiAqIExvYWQgRGF0YSB1c2luZyBKU09OXG4gIyMjXG5tb2R1bGUuZXhwb3J0cyA9ICh2YXJzLCBrZXksIG5leHQpIC0+XG5cbiAgZDNwbHVzLmNvbnNvbGUudGltZSBcImxvYWRpbmcgXCIgKyBrZXkgaWYgdmFycy5kZXYudmFsdWVcblxuICB1cmwgPSB2YXJzW2tleV0udXJsXG5cbiAgdW5sZXNzIHZhcnNba2V5XS5maWxldHlwZS52YWx1ZVxuXG4gICAgZmlsZVR5cGUgPSB1cmwuc2xpY2UodXJsLmxlbmd0aCAtIDUpLnNwbGl0KFwiLlwiKVxuXG4gICAgaWYgZmlsZVR5cGUubGVuZ3RoID4gMVxuICAgICAgZmlsZVR5cGUgPSBmaWxlVHlwZVsxXVxuICAgIGVsc2VcbiAgICAgIGZpbGVUeXBlID0gZmFsc2VcblxuICAgIGlmIGZpbGVUeXBlXG4gICAgICBmaWxlVHlwZSA9IFwidGV4dFwiIGlmIGZpbGVUeXBlIGlzIFwidHh0XCJcbiAgICAgIGZpbGVUeXBlID0gXCJqc29uXCIgaWYgdmFyc1trZXldLmZpbGV0eXBlLmFjY2VwdGVkLmluZGV4T2YoZmlsZVR5cGUpIDwgMFxuICAgIGVsc2VcbiAgICAgIGZpbGVUeXBlID0gXCJqc29uXCJcblxuICBlbHNlXG4gICAgZmlsZVR5cGUgPSB2YXJzW2tleV0uZmlsZXR5cGUudmFsdWVcblxuICBpZiBmaWxlVHlwZSBpcyBcImRzdlwiXG4gICAgcGFyc2VyID0gZDMuZHN2KHZhcnNba2V5XS5kZWxpbWl0ZXIudmFsdWUsIFwidGV4dC9wbGFpblwiKVxuICBlbHNlXG4gICAgcGFyc2VyID0gZDNbZmlsZVR5cGVdXG5cbiAgcGFyc2VyIHVybCwgKGVycm9yLCBkYXRhKSAtPlxuXG4gICAgaWYgbm90IGVycm9yIGFuZCBkYXRhXG5cbiAgICAgIGlmIHR5cGVvZiB2YXJzW2tleV0uY2FsbGJhY2sgaXMgXCJmdW5jdGlvblwiXG4gICAgICAgIHJldCA9IHZhcnNba2V5XS5jYWxsYmFjayhkYXRhKVxuICAgICAgICBpZiByZXRcbiAgICAgICAgICBpZiBkM3BsdXMub2JqZWN0LnZhbGlkYXRlKHJldCkgYW5kIGtleSBvZiByZXRcbiAgICAgICAgICAgIGZvciBrIG9mIHJldFxuICAgICAgICAgICAgICB2YXJzW2tdLnZhbHVlID0gcmV0W2tdIGlmIGsgb2YgdmFyc1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZhcnNba2V5XS52YWx1ZSA9IHJldFxuICAgICAgZWxzZVxuICAgICAgICB2YXJzW2tleV0udmFsdWUgPSBkYXRhXG5cbiAgICAgIGlmIFsgXCJqc29uXCIgXS5pbmRleE9mKGZpbGVUeXBlKSA8IDBcbiAgICAgICAgdmFyc1trZXldLnZhbHVlLmZvckVhY2ggKGQpIC0+XG4gICAgICAgICAgZm9yIGsgb2YgZFxuICAgICAgICAgICAgdW5sZXNzIGlzTmFOKGRba10pXG4gICAgICAgICAgICAgIGRba10gPSBwYXJzZUZsb2F0KGRba10pXG4gICAgICAgICAgICBlbHNlIGlmIGRba10udG9Mb3dlckNhc2UoKSBpcyBcImZhbHNlXCJcbiAgICAgICAgICAgICAgZFtrXSA9IGZhbHNlXG4gICAgICAgICAgICBlbHNlIGlmIGRba10udG9Mb3dlckNhc2UoKSBpcyBcInRydWVcIlxuICAgICAgICAgICAgICBkW2tdID0gdHJ1ZVxuICAgICAgICAgICAgZWxzZSBpZiBkW2tdLnRvTG93ZXJDYXNlKCkgaXMgXCJudWxsXCJcbiAgICAgICAgICAgICAgZFtrXSA9IG51bGxcbiAgICAgICAgICAgIGVsc2UgZFtrXSA9IGB1bmRlZmluZWRgIGlmIGRba10udG9Mb3dlckNhc2UoKSBpcyBcInVuZGVmaW5lZFwiXG5cbiAgICAgIHZhcnNba2V5XS5jaGFuZ2VkID0gdHJ1ZVxuICAgICAgdmFyc1trZXldLmxvYWRlZCA9IHRydWVcblxuICAgIGVsc2VcbiAgICAgIHZhcnMuaW50ZXJuYWxfZXJyb3IgPSBcIkNvdWxkIG5vdCBsb2FkIGRhdGEgZnJvbTogXFxcIlwiICsgdXJsICsgXCJcXFwiXCJcblxuICAgIGQzcGx1cy5jb25zb2xlLnRpbWUgXCJsb2FkaW5nIFwiICsga2V5IGlmIHZhcnMuZGV2LnZhbHVlXG4gICAgbmV4dCgpXG4iLCJ2YXIgZmV0Y2hWYWx1ZSA9IHJlcXVpcmUoXCIuLi9mZXRjaC92YWx1ZS5qc1wiKVxuLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIE5lc3RzIGFuZCBncm91cHMgdGhlIGRhdGEuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIGRhdGFOZXN0ID0gZnVuY3Rpb24oIHZhcnMgLCBmbGF0RGF0YSAsIG5lc3RpbmdMZXZlbHMgLCByZXF1aXJlbWVudHMgKSB7XG5cbiAgdmFyIG5lc3RlZERhdGEgICA9IGQzLm5lc3QoKVxuICAgICwgZ3JvdXBlZERhdGEgID0gW11cbiAgICAsIHNlZ21lbnRzICAgICA9IHZhcnMuc2hlbGwgPT09IFwidml6XCJcbiAgICAgICAgICAgICAgICAgICAgPyBbIFwiYWN0aXZlXCIgLCBcInRlbXBcIiAsIFwidG90YWxcIiBdIDogW11cbiAgICAsIHJlcXVpcmVtZW50cyA9IHJlcXVpcmVtZW50cyB8fCB2YXJzLnR5cGVzW3ZhcnMudHlwZS52YWx1ZV0ucmVxdWlyZW1lbnRzIHx8IFtdXG4gICAgLCBleGNlcHRpb25zICAgPSB2YXJzLnNoZWxsID09PSBcInZpelwiXG4gICAgICAgICAgICAgICAgICAgPyBbIHZhcnMudGltZS52YWx1ZSAsIHZhcnMuaWNvbi52YWx1ZSBdIDogW11cbiAgICAsIGNoZWNrQXhlcyAgICA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAgICAgLy8gSWYgdGhlIHZpc3VhbGl6YXRpb24gaGFzIG1ldGhvZCByZXF1aXJlbWVudHMsIGNoZWNrIHRvIHNlZSBpZiB3ZSBuZWVkXG4gICAgICAvLyB0byBrZXkgdGhlIGRhdGEgYnkgYSBjb250aW51b3VzIHNjYWxlIHZhcmlhYmxlLlxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIGlmICggcmVxdWlyZW1lbnRzICYmIHJlcXVpcmVtZW50cy5sZW5ndGggKSB7XG5cbiAgICAgICAgdmFycy5heGVzLnZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKGF4aXMpe1xuXG4gICAgICAgICAgdmFyIGF4aXNLZXkgPSB2YXJzW2F4aXNdLnZhbHVlXG5cbiAgICAgICAgICBpZiAoIHJlcXVpcmVtZW50cy5pbmRleE9mKGF4aXMpID49IDAgJiYgYXhpc0tleVxuICAgICAgICAgICAgICAgJiYgdmFyc1theGlzXS5zY2FsZS52YWx1ZSA9PT0gXCJjb250aW51b3VzXCIpIHtcblxuICAgICAgICAgICAgZXhjZXB0aW9ucy5wdXNoKGF4aXNLZXkpXG5cbiAgICAgICAgICAgIG5lc3RlZERhdGEua2V5KGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hWYWx1ZSggdmFycyAsIGQgLCBheGlzS2V5IClcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSlcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIGlmICghKHJlcXVpcmVtZW50cyBpbnN0YW5jZW9mIEFycmF5KSkgcmVxdWlyZW1lbnRzID0gW3JlcXVpcmVtZW50c11cblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gTG9vcCB0aHJvdWdoIGVhY2ggbmVzdGluZyBsZXZlbC5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIG5lc3RpbmdMZXZlbHMuZm9yRWFjaChmdW5jdGlvbiggbGV2ZWwgLCBpICl7XG5cbiAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgLy8gQ3JlYXRlIGEgbmVzdCBrZXkgZm9yIHRoZSBjdXJyZW50IGxldmVsLlxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBuZXN0ZWREYXRhXG4gICAgICAua2V5KGZ1bmN0aW9uKGQpe1xuXG4gICAgICAgIGlmICggdHlwZW9mIGxldmVsID09PSBcImZ1bmN0aW9uXCIgKSB7XG4gICAgICAgICAgcmV0dXJuIGxldmVsKGQpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmV0Y2hWYWx1ZSggdmFycyAsIGQgLCBsZXZlbCApXG4gICAgICB9KVxuXG4gICAgY2hlY2tBeGVzKClcblxuICB9KVxuXG4gIGlmICggIW5lc3RpbmdMZXZlbHMubGVuZ3RoICkge1xuXG4gICAgbmVzdGVkRGF0YVxuICAgICAgLmtleShmdW5jdGlvbihkKXtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0pXG5cbiAgICBjaGVja0F4ZXMoKVxuICB9XG5cbiAgdmFyIGkgPSBuZXN0aW5nTGV2ZWxzLmxlbmd0aCA/IG5lc3RpbmdMZXZlbHMubGVuZ3RoIC0gMSA6IDBcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gSWYgd2UncmUgYXQgdGhlIGRlZXBlc3QgbGV2ZWwsIGNyZWF0ZSB0aGUgcm9sbHVwIGZ1bmN0aW9uLlxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgbmVzdGVkRGF0YS5yb2xsdXAoZnVuY3Rpb24oIGxlYXZlcyApIHtcblxuICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAvLyBJZiB0aGVyZSdzIG9ubHkgMSBsZWFmLCBhbmQgaXQncyBiZWVuIHByb2Nlc3NlZCwgcmV0dXJuIGl0IGFzLWlzLlxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBpZiAoIGxlYXZlcy5sZW5ndGggPT09IDEgJiYgKFwiZDNwbHVzXCIgaW4gbGVhdmVzWzBdKSApIHtcbiAgICAgIC8vIHZhciByZXR1cm5PYmogPSBsZWF2ZXNbMF1cbiAgICAgIC8vIHJldHVybk9iai5kM3BsdXMuZGVwdGggPSBpXG4gICAgICBncm91cGVkRGF0YS5wdXNoKGxlYXZlc1swXSlcbiAgICAgIHJldHVybiBsZWF2ZXNbMF1cbiAgICB9XG5cbiAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgLy8gQ3JlYXRlIHRoZSBcImQzcGx1c1wiIG9iamVjdCBmb3IgdGhlIHJldHVybiB2YXJpYWJsZSwgc3RhcnRpbmcgd2l0aFxuICAgIC8vIGp1c3QgdGhlIGN1cnJlbnQgZGVwdGguXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciByZXR1cm5PYmogPSB7XG4gICAgICBcImQzcGx1c1wiOiB7XG4gICAgICAgIFwiZGVwdGhcIjogaVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChcImQzcGx1c1wiIGluIGxlYXZlc1swXSkge1xuXG4gICAgICBsZWF2ZXMuZm9yRWFjaChmdW5jdGlvbihsKXtcbiAgICAgICAgaWYgKFwiZDNwbHVzXCIgaW4gbCkge1xuICAgICAgICAgIGlmIChsLmQzcGx1cy5tZXJnZWQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgaWYgKCFyZXR1cm5PYmouZDNwbHVzLm1lcmdlZCkgcmV0dXJuT2JqLmQzcGx1cy5tZXJnZWQgPSBbXVxuICAgICAgICAgICAgcmV0dXJuT2JqLmQzcGx1cy5tZXJnZWQgPSByZXR1cm5PYmouZDNwbHVzLm1lcmdlZC5jb25jYXQobC5kM3BsdXMubWVyZ2VkKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobC5kM3BsdXMudGV4dCkgcmV0dXJuT2JqLmQzcGx1cy50ZXh0ID0gbC5kM3BsdXMudGV4dFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAvLyBDcmVhdGUgYSByZWZlcmVuY2Ugc3VtIGZvciB0aGUgMyBkaWZmZXJlbnQgXCJzZWdtZW50XCIgdmFyaWFibGVzLlxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBzZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGMpe1xuXG4gICAgICB2YXIga2V5ID0gdmFyc1tjXS52YWx1ZSB8fCBjXG5cbiAgICAgIHJldHVybk9iai5kM3BsdXNba2V5XSA9IGQzLnN1bShsZWF2ZXMsIGZ1bmN0aW9uKCBkICkge1xuXG4gICAgICAgIGlmICggdmFyc1tjXS52YWx1ZSApIHtcblxuICAgICAgICAgIHZhciBhID0gZmV0Y2hWYWx1ZSh2YXJzLGQsdmFyc1tjXS52YWx1ZSlcblxuICAgICAgICAgIGlmICggdHlwZW9mIGEgIT09IFwibnVtYmVyXCIgKSB7XG4gICAgICAgICAgICBhID0gYSA/IDEgOiAwXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIGMgPT09IFwidG90YWxcIiApIHtcbiAgICAgICAgICB2YXIgYSA9IDFcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgYSA9IDBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhXG5cbiAgICAgIH0pXG5cbiAgICB9KVxuXG4gICAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAgIC8vIEFnZ3JlZ2F0ZSBhbGwgdmFsdWVzIGRldGVjdGVkIGluIHRoZSBkYXRhLlxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmb3IgKCB2YXIga2V5IGluIHZhcnMuZGF0YS5rZXlzICkge1xuXG4gICAgICB2YXIgYWdnICAgICA9IHZhcnMuYWdncy52YWx1ZVtrZXldIHx8IFwic3VtXCJcbiAgICAgICAgLCBhZ2dUeXBlID0gdHlwZW9mIGFnZ1xuICAgICAgICAsIGtleVR5cGUgPSB2YXJzLmRhdGEua2V5c1trZXldXG4gICAgICAgICwgaWRLZXkgICA9IHZhcnMuaWQubmVzdGluZy5pbmRleE9mKGtleSkgPj0gMFxuICAgICAgICAsIHRpbWVLZXkgPSBcInRpbWVcIiBpbiB2YXJzICYmIGtleSA9PT0gdmFycy50aW1lLnZhbHVlXG5cbiAgICAgIGlmICgga2V5IGluIHJldHVybk9iai5kM3BsdXMgKSB7XG5cbiAgICAgICAgcmV0dXJuT2JqW2tleV0gPSByZXR1cm5PYmouZDNwbHVzW2tleV1cblxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIGFnZ1R5cGUgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuICAgICAgICByZXR1cm5PYmpba2V5XSA9IHZhcnMuYWdncy52YWx1ZVtrZXldKGxlYXZlcylcblxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIHRpbWVLZXkgKSB7XG4gICAgICAgIHZhciB1bmlxdWVzID0gZDNwbHVzLnV0aWwudW5pcXVlcyhsZWF2ZXMsa2V5KSwgZGF0ZXMgPSBbXVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlRGF0ZXMoYXJyKSB7XG5cbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgICAgdmFyIGQgPSBhcnJbaV1cbiAgICAgICAgICAgIGlmIChkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGQuY29uc3RydWN0b3IgPT09IERhdGUpIGRhdGVzLnB1c2goZClcbiAgICAgICAgICAgICAgZWxzZSBpZiAoZC5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBwYXJzZURhdGVzKGQpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZCA9IG5ldyBEYXRlKGQudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICBpZiAoZCAhPT0gXCJJbnZhbGlkIERhdGVcIikge1xuICAgICAgICAgICAgICAgICAgZC5zZXRUaW1lKCBkLmdldFRpbWUoKSArIGQuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwICogMTAwMCApXG4gICAgICAgICAgICAgICAgICBkYXRlcy5wdXNoKGQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZURhdGVzKHVuaXF1ZXMpXG5cbiAgICAgICAgaWYgKGRhdGVzLmxlbmd0aCA9PT0gMSkgcmV0dXJuT2JqW2tleV0gPSBkYXRlc1swXVxuICAgICAgICBlbHNlIGlmICh1bmlxdWVzLmxlbmd0aCkgcmV0dXJuT2JqW2tleV0gPSBkYXRlc1xuICAgICAgICBlbHNlIHJldHVybk9ialtrZXldID0gbnVsbFxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIGtleVR5cGUgPT09IFwibnVtYmVyXCIgJiYgYWdnVHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAhaWRLZXkgKSB7XG4gICAgICAgIHZhciB1bmlxdWVzID0gZDNwbHVzLnV0aWwudW5pcXVlcyhsZWF2ZXMsa2V5KVxuICAgICAgICBpZiAodW5pcXVlcy5sZW5ndGgpIHJldHVybk9ialtrZXldID0gZDNbYWdnXSh1bmlxdWVzKVxuICAgICAgICBlbHNlIHJldHVybk9ialtrZXldID0gbnVsbFxuICAgICAgfVxuICAgICAgZWxzZSB7XG5cbiAgICAgICAgdmFyIHRlc3RWYWxzID0gW11cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tWYWwob2JqKSB7XG4gICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBvYmouZm9yRWFjaChjaGVja1ZhbClcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoZDNwbHVzLm9iamVjdC52YWxpZGF0ZShvYmopICYmIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmpba2V5XSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgIG9ialtrZXldLmZvckVhY2goY2hlY2tWYWwpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGVzdFZhbHMucHVzaChvYmopXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoZWNrVmFsKGxlYXZlcylcblxuICAgICAgICB2YXIga2V5VmFsdWVzID0gdGVzdFZhbHMubGVuZ3RoID09PSAxID8gdGVzdFZhbHNbMF1ba2V5XVxuICAgICAgICAgICAgICAgICAgICAgIDogZDNwbHVzLnV0aWwudW5pcXVlcyggdGVzdFZhbHMgLCBrZXkgKVxuXG4gICAgICAgIGlmICgga2V5VmFsdWVzICE9PSB1bmRlZmluZWQgJiYga2V5VmFsdWVzICE9PSBudWxsICkge1xuXG4gICAgICAgICAgaWYgKCAhKGtleVZhbHVlcyBpbnN0YW5jZW9mIEFycmF5KSApIHtcbiAgICAgICAgICAgIGtleVZhbHVlcyA9IFsga2V5VmFsdWVzIF1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIGtleVZhbHVlcy5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgIGlmICggaWRLZXkgJiYgdmFycy5pZC5uZXN0aW5nLmluZGV4T2Yoa2V5KSA+IGkgJiYgdGVzdFZhbHMubGVuZ3RoID4gMSApIHtcbiAgICAgICAgICAgICAgaWYgKGtleSA9PSBcImlkXCIgJiYgbmVzdGluZ0xldmVscy5sZW5ndGggPT0gMSAmJiB0ZXN0VmFscy5sZW5ndGggPiBsZWF2ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld05lc3RpbmcgPSBuZXN0aW5nTGV2ZWxzLmNvbmNhdChrZXkpXG4gICAgICAgICAgICAgICAgdGVzdFZhbHMgPSBkYXRhTmVzdCh2YXJzLHRlc3RWYWxzLG5ld05lc3RpbmcpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuT2JqW2tleV0gPSB0ZXN0VmFscy5sZW5ndGggPT09IDEgPyB0ZXN0VmFsc1swXSA6IHRlc3RWYWxzXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgIHJldHVybk9ialtrZXldID0ga2V5VmFsdWVzLmxlbmd0aCA9PT0gMSA/IGtleVZhbHVlc1swXSA6IGtleVZhbHVlc1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpZEtleSkge1xuICAgICAgICAgIHZhciBlbmRQb2ludCA9IHZhcnMuaWQubmVzdGluZy5pbmRleE9mKGtleSkgLSAxXG4gICAgICAgICAgaWYgKGVuZFBvaW50ID49IGkgJiYgKCEoXCJlbmRQb2ludFwiIGluIHJldHVybk9iai5kM3BsdXMpIHx8IHJldHVybk9iai5kM3BsdXMuZW5kUG9pbnQgPiBpKSkge1xuICAgICAgICAgICAgcmV0dXJuT2JqLmQzcGx1cy5lbmRQb2ludCA9IGlcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgZ3JvdXBlZERhdGEucHVzaChyZXR1cm5PYmopXG5cbiAgICByZXR1cm4gcmV0dXJuT2JqXG5cbiAgfSlcblxuICB2YXIgcmVuYW1lX2tleV92YWx1ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmoudmFsdWVzICYmIG9iai52YWx1ZXMubGVuZ3RoKSB7XG4gICAgICBvYmouY2hpbGRyZW4gPSBvYmoudmFsdWVzLm1hcChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIHJlbmFtZV9rZXlfdmFsdWUob2JqKTtcbiAgICAgIH0pXG4gICAgICBkZWxldGUgb2JqLnZhbHVlc1xuICAgICAgcmV0dXJuIG9ialxuICAgIH1cbiAgICBlbHNlIGlmKG9iai52YWx1ZXMpIHtcbiAgICAgIHJldHVybiBvYmoudmFsdWVzXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH1cblxuICB2YXIgZmluZF9rZXlzID0gZnVuY3Rpb24ob2JqLGRlcHRoLGtleXMpIHtcbiAgICBpZiAob2JqLmNoaWxkcmVuKSB7XG4gICAgICBpZiAodmFycy5kYXRhLmtleXNbbmVzdGluZ0xldmVsc1tkZXB0aF1dID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgb2JqLmtleSA9IHBhcnNlRmxvYXQob2JqLmtleSlcbiAgICAgIH1cbiAgICAgIGtleXNbbmVzdGluZ0xldmVsc1tkZXB0aF1dID0gb2JqLmtleVxuICAgICAgZGVsZXRlIG9iai5rZXlcbiAgICAgIGZvciAoIHZhciBrIGluIGtleXMgKSB7XG4gICAgICAgIG9ialtrXSA9IGtleXNba11cbiAgICAgIH1cbiAgICAgIGRlcHRoKytcbiAgICAgIG9iai5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGMpe1xuICAgICAgICBmaW5kX2tleXMoYyxkZXB0aCxrZXlzKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBuZXN0ZWREYXRhID0gbmVzdGVkRGF0YVxuICAgIC5lbnRyaWVzKGZsYXREYXRhKVxuICAgIC5tYXAocmVuYW1lX2tleV92YWx1ZSlcbiAgICAubWFwKGZ1bmN0aW9uKG9iail7XG4gICAgICBmaW5kX2tleXMob2JqLDAse30pXG4gICAgICByZXR1cm4gb2JqXG4gICAgfSlcblxuICByZXR1cm4gZ3JvdXBlZERhdGFcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRhdGFOZXN0XG4iLCJ2YXIgZGF0YU5lc3QgICA9IHJlcXVpcmUoXCIuL25lc3QuanNcIiksXG4gICAgZmV0Y2hWYWx1ZSA9IHJlcXVpcmUoXCIuLi9mZXRjaC92YWx1ZS5qc1wiKSxcbiAgICBmZXRjaENvbG9yID0gcmVxdWlyZShcIi4uL2ZldGNoL2NvbG9yLmpzXCIpLFxuICAgIGZldGNoVGV4dCAgPSByZXF1aXJlKFwiLi4vZmV0Y2gvdGV4dC5qc1wiKVxuLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBNZXJnZXMgZGF0YSB1bmRlcm5lYXRoIHRoZSBzaXplIHRocmVzaG9sZFxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCB2YXJzICwgcmF3RGF0YSAsIHNwbGl0ICkge1xuXG4gIGlmICggdmFycy5zaXplLnRocmVzaG9sZCA9PT0gZmFsc2UgKSB7XG4gICAgdmFyIHRocmVzaG9sZCA9IDBcbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgdmFycy5zaXplLnRocmVzaG9sZCA9PT0gXCJudW1iZXJcIikge1xuICAgIHZhciB0aHJlc2hvbGQgPSB2YXJzLnNpemUudGhyZXNob2xkXG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIHZhcnMudHlwZXNbdmFycy50eXBlLnZhbHVlXS50aHJlc2hvbGQgPT09IFwibnVtYmVyXCIpIHtcbiAgICB2YXIgdGhyZXNob2xkID0gdmFycy50eXBlc1t2YXJzLnR5cGUudmFsdWVdLnRocmVzaG9sZFxuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiB2YXJzLnR5cGVzW3ZhcnMudHlwZS52YWx1ZV0udGhyZXNob2xkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgdGhyZXNob2xkID0gdmFycy50eXBlc1t2YXJzLnR5cGUudmFsdWVdLnRocmVzaG9sZCh2YXJzKVxuICB9XG4gIGVsc2Uge1xuICAgIHZhciB0aHJlc2hvbGQgPSAwLjAyXG4gIH1cblxuICBpZiAodHlwZW9mIHRocmVzaG9sZCA9PSBcIm51bWJlclwiICYmIHRocmVzaG9sZCA+IDApIHtcblxuICAgIHZhciBhbGxvd2VkID0gW10sXG4gICAgICAgIGN1dG9mZiA9IHZhcnMuZGVwdGgudmFsdWUgPT0gMCA/IDAgOiB7fSxcbiAgICAgICAgcmVtb3ZlZCA9IFtdLFxuICAgICAgICBsYXJnZXN0ID0ge31cblxuICAgIHZhciBuZXN0ID0gZDMubmVzdCgpXG5cbiAgICBpZiAoc3BsaXQpIHtcbiAgICAgIG5lc3RcbiAgICAgICAgLmtleShmdW5jdGlvbihkKXtcbiAgICAgICAgICByZXR1cm4gZmV0Y2hWYWx1ZSh2YXJzLGQsc3BsaXQpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgbmVzdFxuICAgICAgLnJvbGx1cChmdW5jdGlvbihsZWF2ZXMpe1xuICAgICAgICB2YXIgdG90YWwgPSBsZWF2ZXMubGVuZ3RoXG4gICAgICAgIGlmICh2YXJzLmFnZ3NbdmFycy5zaXplLnZhbHVlXSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFycy5hZ2dzW3ZhcnMuc2l6ZS52YWx1ZV0gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0b3RhbCA9IHZhcnMuYWdnc1t2YXJzLnNpemUudmFsdWVdKGxlYXZlcylcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhcnMuYWdnc1t2YXJzLnNpemUudmFsdWVdID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRvdGFsID0gZDNbdmFycy5hZ2dzW3ZhcnMuc2l6ZS52YWx1ZV1dKGxlYXZlcyxmdW5jdGlvbihsKXtcbiAgICAgICAgICAgICAgcmV0dXJuIGZldGNoVmFsdWUodmFycyxsLHZhcnMuc2l6ZS52YWx1ZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRvdGFsID0gZDMuc3VtKGxlYXZlcyxmdW5jdGlvbihsKXtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaFZhbHVlKHZhcnMsbCx2YXJzLnNpemUudmFsdWUpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICB2YXIgeCA9IHNwbGl0ID8gZmV0Y2hWYWx1ZSh2YXJzLGxlYXZlc1swXSxzcGxpdCkgOiBcImFsbFwiXG4gICAgICAgIGxhcmdlc3RbeF0gPSB0b3RhbFxuICAgICAgICByZXR1cm4gdG90YWxcbiAgICAgIH0pXG4gICAgICAuZW50cmllcyhyYXdEYXRhKVxuXG4gICAgdmFyIGZpbHRlcmVkRGF0YSA9IHJhd0RhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpe1xuXG4gICAgICB2YXIgaWQgPSBmZXRjaFZhbHVlKHZhcnMsZCx2YXJzLmlkLnZhbHVlKSxcbiAgICAgICAgICB2YWwgPSBmZXRjaFZhbHVlKHZhcnMsZCx2YXJzLnNpemUudmFsdWUpLFxuICAgICAgICAgIHggPSBzcGxpdCA/IGZldGNoVmFsdWUodmFycyxkLHNwbGl0KSA6IFwiYWxsXCJcblxuICAgICAgaWYgKGFsbG93ZWQuaW5kZXhPZihpZCkgPCAwKSB7XG4gICAgICAgIGlmICh2YWwvbGFyZ2VzdFt4XSA+PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgICBhbGxvd2VkLnB1c2goaWQpXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBpZiAoYWxsb3dlZC5pbmRleE9mKGlkKSA8IDApIHtcbiAgICAgICAgaWYgKHZhcnMuZGVwdGgudmFsdWUgPT0gMCkge1xuICAgICAgICAgIGlmICh2YWwgPiBjdXRvZmYpIGN1dG9mZiA9IHZhbFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBkW3ZhcnMuaWQubmVzdGluZ1t2YXJzLmRlcHRoLnZhbHVlLTFdXVxuICAgICAgICAgIGlmICghKHBhcmVudCBpbiBjdXRvZmYpKSBjdXRvZmZbcGFyZW50XSA9IDBcbiAgICAgICAgICBpZiAodmFsID4gY3V0b2ZmW3BhcmVudF0pIGN1dG9mZltwYXJlbnRdID0gdmFsXG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlZC5wdXNoKGQpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICB9KVxuXG4gICAgaWYgKCByZW1vdmVkLmxlbmd0aCA+IDEgKSB7XG5cbiAgICAgIHJlbW92ZWQgPSBkM3BsdXMuYXJyYXkuc29ydCggcmVtb3ZlZCAsIHZhcnMuc2l6ZS52YWx1ZSAsIFwiZGVzY1wiICwgW10gLCB2YXJzIClcblxuICAgICAgdmFyIGxldmVscyA9IHZhcnMuaWQubmVzdGluZy5zbGljZSgwLHZhcnMuZGVwdGgudmFsdWUpXG4gICAgICB2YXIgbWVyZ2VkID0gZGF0YU5lc3QodmFycyxyZW1vdmVkLGxldmVscylcblxuICAgICAgbWVyZ2VkLmZvckVhY2goZnVuY3Rpb24obSl7XG5cbiAgICAgICAgdmFyIHBhcmVudCA9IHZhcnMuaWQubmVzdGluZ1t2YXJzLmRlcHRoLnZhbHVlLTFdXG5cbiAgICAgICAgdmFycy5pZC5uZXN0aW5nLmZvckVhY2goZnVuY3Rpb24oZCxpKXtcblxuICAgICAgICAgIGlmICh2YXJzLmRlcHRoLnZhbHVlID09IGkpIHtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gbVt2YXJzLmlkLm5lc3RpbmdbaS0xXV1cbiAgICAgICAgICAgIGlmICggdHlwZW9mIHByZXYgPT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgIG1bZF0gPSBcImQzcGx1c19vdGhlcl9cIitwcmV2XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgbVtkXSA9IFwiZDNwbHVzX290aGVyXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaSA+IHZhcnMuZGVwdGgudmFsdWUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBtW2RdXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICh2YXJzLmNvbG9yLnZhbHVlICYmIHZhcnMuY29sb3IudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlmICh2YXJzLmRlcHRoLnZhbHVlID09IDApIHtcbiAgICAgICAgICAgIG1bdmFycy5jb2xvci52YWx1ZV0gPSB2YXJzLmNvbG9yLm1pc3NpbmdcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtW3ZhcnMuY29sb3IudmFsdWVdID0gZmV0Y2hWYWx1ZSh2YXJzLG1bcGFyZW50XSx2YXJzLmNvbG9yLnZhbHVlLHBhcmVudClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFycy5pY29uLnZhbHVlKSB7XG4gICAgICAgICAgbVt2YXJzLmljb24udmFsdWVdID0gZmV0Y2hWYWx1ZSh2YXJzLG1bcGFyZW50XSx2YXJzLmljb24udmFsdWUscGFyZW50KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1bcGFyZW50XSkge1xuICAgICAgICAgIG0uZDNwbHVzLmRlcHRoID0gdmFycy5kZXB0aC52YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhcnMuZGVwdGgudmFsdWUgPT0gMCkge1xuICAgICAgICAgIHZhciB0ZXh0TGFiZWwgPSB2YXJzLmZvcm1hdC52YWx1ZSh2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUudWkudmFsdWVzKVxuICAgICAgICAgIHRleHRMYWJlbCArPSBcIiA8IFwiK3ZhcnMuZm9ybWF0LnZhbHVlKGN1dG9mZilcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgdGV4dExhYmVsID0gZmV0Y2hUZXh0KHZhcnMsbSx2YXJzLmRlcHRoLnZhbHVlLTEpXG4gICAgICAgICAgdGV4dExhYmVsID0gdGV4dExhYmVsLmxlbmd0aCA/IHRleHRMYWJlbFswXS5zcGxpdChcIiA8IFwiKVswXSA6IHZhcnMuZm9ybWF0LnZhbHVlKHZhcnMuZm9ybWF0LmxvY2FsZS52YWx1ZS51aS52YWx1ZXMpXG4gICAgICAgICAgdGV4dExhYmVsICs9IFwiIDwgXCIrdmFycy5mb3JtYXQudmFsdWUoY3V0b2ZmW21bcGFyZW50XV0sdmFycy5zaXplLnZhbHVlKVxuICAgICAgICB9XG4gICAgICAgIHRleHRMYWJlbCArPSBcIiAoXCIrdmFycy5mb3JtYXQudmFsdWUodGhyZXNob2xkKjEwMCkrXCIlKVwiXG5cbiAgICAgICAgbS5kM3BsdXMudGhyZXNob2xkID0gY3V0b2ZmXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBtLmQzcGx1cy5tZXJnZWQgPSBbXVxuICAgICAgICAgIHJlbW92ZWQuZm9yRWFjaChmdW5jdGlvbihyKXtcbiAgICAgICAgICAgIGlmIChtW3BhcmVudF0gPT0gcltwYXJlbnRdKSB7XG4gICAgICAgICAgICAgIG0uZDNwbHVzLm1lcmdlZC5wdXNoKHIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBtLmQzcGx1cy5tZXJnZWQgPSByZW1vdmVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFycy50ZXh0LnZhbHVlKSB7XG4gICAgICAgICAgbVt2YXJzLnRleHQudmFsdWVdID0gdGV4dExhYmVsXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbS5kM3BsdXMudGV4dCA9IHRleHRMYWJlbFxuICAgICAgICB9XG5cbiAgICAgIH0pXG5cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBtZXJnZWQgPSByZW1vdmVkXG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbHRlcmVkRGF0YS5jb25jYXQobWVyZ2VkKVxuXG4gIH1cblxuICByZXR1cm4gcmF3RGF0YVxuXG59XG4iLCJ2YXIgZmV0Y2hWYWx1ZSA9IHJlcXVpcmUoXCIuL3ZhbHVlLmpzXCIpXG4vL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gRmluZHMgYW4gb2JqZWN0J3MgY29sb3IgYW5kIHJldHVybnMgcmFuZG9tIGlmIGl0IGNhbm5vdCBiZSBmb3VuZFxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIHZhcnMgLCBpZCAsIGxldmVsICkge1xuXG4gIGlmICggIWxldmVsICkge1xuICAgIHZhciBsZXZlbCA9IHZhcnMuaWQudmFsdWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJhbmRvbSggYyApIHtcblxuICAgIGlmICggZDNwbHVzLm9iamVjdC52YWxpZGF0ZSggYyApICkge1xuICAgICAgYyA9IGNbIGxldmVsIF1cbiAgICB9XG5cbiAgICBpZiAoYyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBjID0gY1swXVxuICAgIH1cblxuICAgIHJldHVybiBkM3BsdXMuY29sb3IucmFuZG9tKCBjLCB2YXJzLmNvbG9yLnNjYWxlLnZhbHVlIClcblxuICB9XG5cbiAgaWYgKCAhdmFycy5jb2xvci52YWx1ZSApIHtcblxuICAgIHJldHVybiBnZXRSYW5kb20oIGlkIClcblxuICB9XG4gIGVsc2Uge1xuXG4gICAgZm9yICggdmFyIGkgPSB2YXJzLmlkLm5lc3RpbmcuaW5kZXhPZihsZXZlbCkgOyBpID49IDAgOyBpLS0gKSB7XG4gICAgICB2YXIgY29sb3JMZXZlbCA9IHZhcnMuaWQubmVzdGluZ1tpXVxuICAgICAgICAsIG8gPSBkM3BsdXMub2JqZWN0LnZhbGlkYXRlKGlkKSAmJiAhKHZhcnMuY29sb3IudmFsdWUgaW4gaWQpICYmIGlkW2xldmVsXSBpbnN0YW5jZW9mIEFycmF5ID8gaWRbbGV2ZWxdWzBdIDogZmV0Y2hWYWx1ZSh2YXJzLCBpZCwgY29sb3JMZXZlbClcbiAgICAgICAgLCBjb2xvciA9IGZldGNoVmFsdWUoIHZhcnMgLCBvICwgdmFycy5jb2xvci52YWx1ZSAsIGNvbG9yTGV2ZWwgKVxuICAgICAgaWYgKCBjb2xvciApIGJyZWFrXG4gICAgfVxuXG4gICAgaWYgKCAhY29sb3IgKSB7XG5cbiAgICAgIGlmICggdmFycy5jb2xvci52YWx1ZSB8fCB0eXBlb2YgdmFycy5jb2xvci52YWx1ZVNjYWxlID09PSBcImZ1bmN0aW9uXCIgKSB7XG4gICAgICAgIHJldHVybiB2YXJzLmNvbG9yLm1pc3NpbmdcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRSYW5kb20oIGlkIClcblxuICAgIH1cbiAgICBlbHNlIGlmICggIXZhcnMuY29sb3IudmFsdWVTY2FsZSApIHtcbiAgICAgIHJldHVybiBkM3BsdXMuY29sb3IudmFsaWRhdGUoIGNvbG9yICkgPyBjb2xvciA6IGdldFJhbmRvbSggY29sb3IgKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiB2YXJzLmNvbG9yLnZhbHVlU2NhbGUoIGNvbG9yIClcbiAgICB9XG5cbiAgfVxuXG59XG4iLCJ2YXIgZGF0YUZpbHRlciA9IHJlcXVpcmUoXCIuLi9kYXRhL2ZpbHRlci5qc1wiKSxcbiAgICBkYXRhTmVzdCA9IHJlcXVpcmUoXCIuLi9kYXRhL25lc3QuanNcIilcbi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gRmV0Y2hlcyBzcGVjaWZpYyB5ZWFycyBvZiBkYXRhXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIHZhcnMgLCB5ZWFycyApIHtcblxuICBpZiAoIXZhcnMuZGF0YS52YWx1ZSkgcmV0dXJuIFtdXG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIElmIFwieWVhcnNcIiBoYXZlIG5vdCBiZWVuIHJlcXVlc3RlZCwgZGV0ZXJtaW5lIHRoZSB5ZWFycyB1c2luZyAudGltZSgpXG4gIC8vIHNvbG8gYW5kIG11dGVcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGlmICggIXllYXJzICYmIFwidGltZVwiIGluIHZhcnMgKSB7XG5cbiAgICB2YXIga2V5ICAgPSB2YXJzLnRpbWUuc29sby52YWx1ZS5sZW5ndGggPyBcInNvbG9cIiA6IFwibXV0ZVwiXG4gICAgICAsIHllYXJzID0gW11cblxuICAgIGlmICggdmFycy50aW1lW2tleV0udmFsdWUubGVuZ3RoICkge1xuXG4gICAgICB2YXIgeWVhcnMgPSBbXVxuICAgICAgdmFycy50aW1lW2tleV0udmFsdWUuZm9yRWFjaChmdW5jdGlvbiggeSApe1xuICAgICAgICBpZiAoIHR5cGVvZiB5ID09PSBcImZ1bmN0aW9uXCIgKSB7XG4gICAgICAgICAgdmFycy5kYXRhLnRpbWUudmFsdWVzLmZvckVhY2goZnVuY3Rpb24oIHQgKXtcbiAgICAgICAgICAgIGlmICggeSh0LmdldFRpbWUoKSkgKSB5ZWFycy5wdXNoKCB0LmdldFRpbWUoKSApXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggeS5jb25zdHJ1Y3RvciA9PT0gRGF0ZSApIHtcbiAgICAgICAgICB5ZWFycy5wdXNoKG5ldyBEYXRlKHkpLmdldFRpbWUoKSlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKHkudG9TdHJpbmcoKSlcbiAgICAgICAgICBpZiAoZCAhPT0gXCJJbnZhbGlkIERhdGVcIikge1xuICAgICAgICAgICAgZC5zZXRUaW1lKCBkLmdldFRpbWUoKSArIGQuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwICogMTAwMCApXG4gICAgICAgICAgICB5ZWFycy5wdXNoKGQuZ2V0VGltZSgpKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9KVxuXG4gICAgICBpZiAoIGtleSA9PT0gXCJtdXRlXCIgKSB7XG4gICAgICAgIHllYXJzID0gdmFycy5kYXRhLnRpbWUudmFsdWVzLmZpbHRlcihmdW5jdGlvbiggdCApe1xuICAgICAgICAgIHJldHVybiB5ZWFycy5pbmRleE9mKCB0LmdldFRpbWUoKSApIDwgMFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgfVxuICAgIGVsc2UgeWVhcnMucHVzaChcImFsbFwiKVxuXG4gIH1cbiAgZWxzZSB7XG4gICAgeWVhcnMgPSBbIFwiYWxsXCIgXVxuICB9XG5cbiAgaWYgKHllYXJzLmluZGV4T2YoXCJhbGxcIikgPj0gMCAmJiB2YXJzLmRhdGEudGltZS52YWx1ZXMubGVuZ3RoKSB7XG4gICAgeWVhcnMgPSB2YXJzLmRhdGEudGltZS52YWx1ZXMuc2xpY2UoMClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHllYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB5ZWFyc1tpXSA9IHllYXJzW2ldLmdldFRpbWUoKVxuICAgIH1cbiAgfVxuXG4gIHZhciBjYWNoZUlEID0gWyB2YXJzLnR5cGUudmFsdWUgLCB2YXJzLmlkLnZhbHVlICwgdmFycy5kZXB0aC52YWx1ZSBdXG4gICAgICAgICAgICAgICAgICAuY29uY2F0KCB2YXJzLmRhdGEuZmlsdGVycyApXG4gICAgICAgICAgICAgICAgICAuY29uY2F0KCB5ZWFycyApXG4gICAgLCBmaWx0ZXIgID0gdmFycy5kYXRhLnNvbG8ubGVuZ3RoID8gXCJzb2xvXCIgOiBcIm11dGVcIlxuICAgICwgY2FjaGVLZXlzID0gZDMua2V5cyh2YXJzLmRhdGEuY2FjaGUpXG4gICAgLCB2aXpGaWx0ZXIgPSB2YXJzLnNoZWxsID09PSBcInZpelwiXG4gICAgICAgICAgICAgICAgID8gdmFycy50eXBlc1t2YXJzLnR5cGUudmFsdWVdLmZpbHRlciA6IG51bGxcblxuICBpZiAoIHZhcnMuZGF0YVtmaWx0ZXJdLmxlbmd0aCApIHtcbiAgICB2YXJzLmRhdGFbZmlsdGVyXS5mb3JFYWNoKGZ1bmN0aW9uKGYpe1xuICAgICAgdmFyIHZhbHMgPSB2YXJzW2ZdW2ZpbHRlcl0udmFsdWUuc2xpY2UoMClcbiAgICAgIHZhbHMudW5zaGlmdChmKVxuICAgICAgY2FjaGVJRCA9IGNhY2hlSUQuY29uY2F0KHZhbHMpXG4gICAgfSlcbiAgfVxuXG4gIGNhY2hlSUQgPSBjYWNoZUlELmpvaW4oXCJfXCIpXG5cbiAgdmFyIG1hdGNoID0gZmFsc2VcblxuICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgY2FjaGVLZXlzLmxlbmd0aCA7IGkrKyApIHtcblxuICAgIHZhciBtYXRjaEtleSA9IGNhY2hlS2V5c1tpXS5zcGxpdChcIl9cIikuc2xpY2UoMSkuam9pbihcIl9cIilcblxuICAgIGlmICggbWF0Y2hLZXkgPT09IGNhY2hlSUQgKSB7XG4gICAgICBjYWNoZUlEID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBcIl9cIiArIGNhY2hlSURcbiAgICAgIHZhcnMuZGF0YS5jYWNoZVtjYWNoZUlEXSA9IHZhcnMuZGF0YS5jYWNoZVtjYWNoZUtleXNbaV1dXG4gICAgICBkZWxldGUgdmFycy5kYXRhLmNhY2hlW2NhY2hlS2V5c1tpXV1cbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gIH1cblxuICBpZiAoIHZhcnMuZGF0YS5jYWNoZVtjYWNoZUlEXSApIHtcblxuICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS5jb21tZW50KFwiZGF0YSBhbHJlYWR5IGNhY2hlZFwiKVxuXG4gICAgdmFyIHJldHVybkRhdGEgPSB2YXJzLmRhdGEuY2FjaGVbY2FjaGVJRF1cblxuICAgIGlmICggdHlwZW9mIHZpekZpbHRlciA9PT0gXCJmdW5jdGlvblwiICkge1xuICAgICAgcmV0dXJuRGF0YSA9IHZpekZpbHRlciggdmFycyAsICByZXR1cm5EYXRhIClcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuRGF0YVxuXG4gIH1cbiAgZWxzZSB7XG5cbiAgICB2YXIgbWlzc2luZyA9IFtdXG4gICAgICAsIHJldHVybkRhdGEgPSBbXVxuXG4gICAgaWYgKCB2YXJzLmRhdGEudmFsdWUgJiYgdmFycy5kYXRhLnZhbHVlLmxlbmd0aCApIHtcblxuICAgICAgeWVhcnMuZm9yRWFjaChmdW5jdGlvbih5KXtcbiAgICAgICAgaWYgKCB2YXJzLmRhdGEubmVzdGVkW3ldICkge1xuICAgICAgICAgIHJldHVybkRhdGEgPSByZXR1cm5EYXRhLmNvbmNhdCggdmFycy5kYXRhLm5lc3RlZFt5XVt2YXJzLmlkLnZhbHVlXSApXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBtaXNzaW5nLnB1c2goIHkgKVxuICAgICAgfSlcblxuICAgIH1cblxuICAgIGlmICggcmV0dXJuRGF0YS5sZW5ndGggPT09IDAgJiYgbWlzc2luZy5sZW5ndGggJiYgIXZhcnMuaW50ZXJuYWxfZXJyb3IgKSB7XG5cbiAgICAgIHZhciBmb3JtYXQgPSB2YXJzLnRpbWUuZm9ybWF0LnZhbHVlIHx8IHZhcnMuZGF0YS50aW1lLmZvcm1hdFxuXG4gICAgICBpZiAobWlzc2luZy5sZW5ndGggPiAxKSB7XG4gICAgICAgIG1pc3NpbmcgPSBkMy5leHRlbnQobWlzc2luZylcbiAgICAgIH1cblxuICAgICAgbWlzc2luZyA9IG1pc3NpbmcubWFwKGZ1bmN0aW9uKG0pe1xuICAgICAgICByZXR1cm4gZm9ybWF0KG5ldyBEYXRlKG0pKVxuICAgICAgfSlcbiAgICAgIG1pc3NpbmcgPSBtaXNzaW5nLmpvaW4oXCIgLSBcIilcblxuICAgICAgdmFyIHN0ciA9IHZhcnMuZm9ybWF0LmxvY2FsZS52YWx1ZS5lcnJvci5kYXRhWWVhclxuICAgICAgICAsIGFuZCA9IHZhcnMuZm9ybWF0LmxvY2FsZS52YWx1ZS51aS5hbmRcbiAgICAgIG1pc3NpbmcgPSBkM3BsdXMuc3RyaW5nLmxpc3QobWlzc2luZyxhbmQpXG4gICAgICB2YXJzLmludGVybmFsX2Vycm9yID0gZDNwbHVzLnN0cmluZy5mb3JtYXQoc3RyLG1pc3NpbmcpXG4gICAgICB2YXJzLnRpbWUubWlzc2luZyA9IHRydWVcblxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgaWYgKHZhcnMudGltZSkgdmFycy50aW1lLm1pc3NpbmcgPSBmYWxzZVxuXG4gICAgICBpZiAoIHllYXJzLmxlbmd0aCA+IDEgKSB7XG5cbiAgICAgICAgdmFyIHNlcGFyYXRlZCA9IGZhbHNlXG4gICAgICAgIHZhcnMuYXhlcy52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbihhKXtcbiAgICAgICAgICBpZiAoIHZhcnNbYV0udmFsdWUgPT09IHZhcnMudGltZS52YWx1ZVxuICAgICAgICAgICYmIHZhcnNbYV0uc2NhbGUudmFsdWUgPT09IFwiY29udGludW91c1wiICkge1xuICAgICAgICAgICAgc2VwYXJhdGVkID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXNlcGFyYXRlZCkge1xuICAgICAgICAgIHZhciBuZXN0ZWQgPSB2YXJzLmlkLm5lc3Rpbmcuc2xpY2UoMCx2YXJzLmRlcHRoLnZhbHVlKzEpXG4gICAgICAgICAgcmV0dXJuRGF0YSA9IGRhdGFOZXN0KCB2YXJzICwgcmV0dXJuRGF0YSAsIG5lc3RlZCApXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBpZiAoICFyZXR1cm5EYXRhICkge1xuICAgICAgICByZXR1cm5EYXRhID0gW11cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuXG4gICAgICAgIHJldHVybkRhdGEgPSBkYXRhRmlsdGVyKCB2YXJzICwgcmV0dXJuRGF0YSApXG5cbiAgICAgIH1cblxuICAgICAgdmFyIGNhY2hlS2V5cyA9IGQzLmtleXModmFycy5kYXRhLmNhY2hlKVxuICAgICAgaWYgKCBjYWNoZUtleXMubGVuZ3RoID09PSAyMCApIHtcbiAgICAgICAgY2FjaGVLZXlzLnNvcnQoKVxuICAgICAgICBkZWxldGUgdmFycy5kYXRhLmNhY2hlKGNhY2hlS2V5c1swXSlcbiAgICAgIH1cblxuICAgICAgY2FjaGVJRCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgXCJfXCIgKyBjYWNoZUlEXG4gICAgICB2YXJzLmRhdGEuY2FjaGVbY2FjaGVJRF0gPSByZXR1cm5EYXRhXG5cbiAgICAgIGlmICggdHlwZW9mIHZpekZpbHRlciA9PT0gXCJmdW5jdGlvblwiICkge1xuICAgICAgICByZXR1cm5EYXRhID0gdml6RmlsdGVyKCB2YXJzICwgcmV0dXJuRGF0YSApXG4gICAgICB9XG5cbiAgICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS5jb21tZW50KFwic3RvcmluZyBkYXRhIGluIGNhY2hlXCIpXG5cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuRGF0YVxuXG4gIH1cblxufVxuIiwidmFyIGZldGNoVmFsdWUgPSByZXF1aXJlKFwiLi92YWx1ZS5qc1wiKVxuLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIEdldCBhcnJheSBvZiBhdmFpbGFibGUgdGV4dCB2YWx1ZXNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhcnMsb2JqLGRlcHRoKSB7XG5cbiAgaWYgKCB0eXBlb2YgZGVwdGggIT09IFwibnVtYmVyXCIgKSB2YXIgZGVwdGggPSB2YXJzLmRlcHRoLnZhbHVlXG5cbiAgdmFyIGtleSA9IHZhcnMuaWQubmVzdGluZ1tkZXB0aF1cblxuICBpZiAoIHZhcnMudGV4dC5uZXN0aW5nICYmIGQzcGx1cy5vYmplY3QudmFsaWRhdGUodmFycy50ZXh0Lm5lc3RpbmcpICkge1xuICAgIGlmICggdmFycy50ZXh0Lm5lc3Rpbmdba2V5XSApIHtcbiAgICAgIHZhciB0ZXh0S2V5cyA9IHZhcnMudGV4dC5uZXN0aW5nW2tleV1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgdGV4dEtleXMgPSB2YXJzLnRleHQudmFsdWVcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIHRleHRLZXlzID0gW11cbiAgICBpZiAodmFycy50ZXh0LnZhbHVlICYmIGRlcHRoID09PSB2YXJzLmRlcHRoLnZhbHVlKSB0ZXh0S2V5cy5wdXNoKHZhcnMudGV4dC52YWx1ZSlcbiAgICB0ZXh0S2V5cy5wdXNoKGtleSlcbiAgfVxuXG4gIGlmICggISh0ZXh0S2V5cyBpbnN0YW5jZW9mIEFycmF5KSApIHtcbiAgICB0ZXh0S2V5cyA9IFsgdGV4dEtleXMgXVxuICB9XG5cbiAgdmFyIG5hbWVzID0gW11cblxuICBpZiAoZDNwbHVzLm9iamVjdC52YWxpZGF0ZShvYmopICYmIFwiZDNwbHVzXCIgaW4gb2JqICYmIG9iai5kM3BsdXMudGV4dCkge1xuICAgIG5hbWVzLnB1c2gob2JqLmQzcGx1cy50ZXh0LnRvU3RyaW5nKCkpXG4gIH1cbiAgZWxzZSB7XG5cbiAgICB2YXIgaWRzID0gZDNwbHVzLm9iamVjdC52YWxpZGF0ZShvYmopICYmIGtleSBpbiBvYmogPyBvYmpba2V5XSA6IGZldGNoVmFsdWUodmFycywgb2JqLCBrZXkpXG4gICAgaWYgKCEoaWRzIGluc3RhbmNlb2YgQXJyYXkpKSBpZHMgPSBbaWRzXVxuICAgIGVsc2UgaWYgKGQzcGx1cy5vYmplY3QudmFsaWRhdGUoaWRzWzBdKSkge1xuICAgICAgaWRzID0gZDNwbHVzLnV0aWwudW5pcXVlcyhpZHMsa2V5KVxuICAgIH1cblxuICAgIHRleHRLZXlzLmZvckVhY2goZnVuY3Rpb24oIHQgKXtcblxuICAgICAgdmFyIG5hbWUgPSBbXVxuICAgICAgaWRzLmZvckVhY2goZnVuY3Rpb24oaSl7XG4gICAgICAgIHZhciBuID0gZmV0Y2hWYWx1ZSh2YXJzLGksdCxrZXkpXG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgaWYgKG4gaW5zdGFuY2VvZiBBcnJheSAmJiBkM3BsdXMub2JqZWN0LnZhbGlkYXRlKG5bMF0pKSB7XG4gICAgICAgICAgICBuID0gZDNwbHVzLnV0aWwudW5pcXVlcyhuLHQpXG4gICAgICAgICAgfVxuICAgICAgICAgIG5hbWUgPSBuYW1lLmNvbmNhdChuKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBpZiAoIG5hbWUubGVuZ3RoICkge1xuICAgICAgICBuYW1lID0gbmFtZS5tYXAoZnVuY3Rpb24obil7XG4gICAgICAgICAgaWYgKG4gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIG4ubWFwKGZ1bmN0aW9uKG5uKXtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhcnMuZm9ybWF0LnZhbHVlKG5uLnRvU3RyaW5nKCksdClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB2YXJzLmZvcm1hdC52YWx1ZShuLnRvU3RyaW5nKCksdClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIGlmIChuYW1lLmxlbmd0aCA9PT0gMSkgbmFtZSA9IG5hbWVbMF1cbiAgICAgICAgbmFtZXMucHVzaChuYW1lKVxuICAgICAgfVxuXG4gICAgfSlcblxuICB9XG5cbiAgcmV0dXJuIG5hbWVzXG5cbn1cbiIsIi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBGaW5kcyBhIGdpdmVuIHZhcmlhYmxlIGJ5IHNlYXJjaGluZyB0aHJvdWdoIHRoZSBkYXRhIGFuZCBhdHRyc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIHZhcnMgLCBpZCAsIHZhcmlhYmxlICwgaWRfdmFyICwgYWdnICkge1xuXG4gIGlmICggdmFyaWFibGUgJiYgdHlwZW9mIHZhcmlhYmxlID09PSBcImZ1bmN0aW9uXCIgKSB7XG4gICAgcmV0dXJuIHZhcmlhYmxlKCBpZCApXG4gIH1cbiAgZWxzZSBpZiAoICF2YXJpYWJsZSApIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgaWYgKCFpZF92YXIpIHtcbiAgICBpZiAoIGQzcGx1cy5vYmplY3QudmFsaWRhdGUodmFyaWFibGUpICkge1xuICAgICAgaWYgKHZhcmlhYmxlW3ZhcnMuaWQudmFsdWVdKSB7XG4gICAgICAgIHZhciBpZF92YXIgPSB2YXJzLmlkLnZhbHVlXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGlkX3ZhciA9IGQzLmtleXModmFyaWFibGUpWzBdXG4gICAgICB9XG4gICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlW2lkX3Zhcl1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgaWRfdmFyID0gdmFycy5pZC52YWx1ZVxuICAgIH1cbiAgfVxuXG4gIGlmICggdmFyaWFibGUgPT09IGlkX3ZhciApIHtcbiAgICBpZiAoIGQzcGx1cy5vYmplY3QudmFsaWRhdGUoaWQpICYmIHZhcmlhYmxlIGluIGlkICkge1xuICAgICAgcmV0dXJuIGlkW3ZhcmlhYmxlXVxuICAgIH1cbiAgICBlbHNlIGlmICggIShpZCBpbnN0YW5jZW9mIEFycmF5KSApIHtcbiAgICAgIHJldHVybiBpZFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbHRlckFycmF5KCBhcnIgKSB7XG5cbiAgICBpZiAoIGlkIGluc3RhbmNlb2YgQXJyYXkgKSB7XG4gICAgICB2YXIgdW5pcXVlcyA9IGQzcGx1cy51dGlsLnVuaXF1ZXMoIGlkICwgaWRfdmFyIClcbiAgICAgIHJldHVybiBhcnIuZmlsdGVyKGZ1bmN0aW9uKGQpe1xuICAgICAgICByZXR1cm4gdW5pcXVlcy5pbmRleE9mKGRbaWRfdmFyXSkgPj0gMFxuICAgICAgfSlcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gYXJyLmZpbHRlcihmdW5jdGlvbihkKXtcbiAgICAgICAgcmV0dXJuIGRbaWRfdmFyXSA9PT0gaWRcbiAgICAgIH0pXG4gICAgfVxuXG4gIH1cblxuICBpZiAoIGQzcGx1cy5vYmplY3QudmFsaWRhdGUoaWQpICYmIHZhcmlhYmxlIGluIGlkICkge1xuICAgIHJldHVybiBpZFt2YXJpYWJsZV1cbiAgfVxuICBlbHNlIHtcblxuICAgIGZ1bmN0aW9uIGNoZWNrRGF0YSggZGF0YSApIHtcbiAgICAgIHZhciB2YWxzID0gZDNwbHVzLnV0aWwudW5pcXVlcyggZGF0YSAsIHZhcmlhYmxlIClcbiAgICAgIGlmICggdmFscy5sZW5ndGggPT09IDEgKSByZXR1cm4gdmFsc1swXVxuICAgIH1cblxuICAgIGlmICggZDNwbHVzLm9iamVjdC52YWxpZGF0ZShpZCkgJiYgaWRfdmFyIGluIGlkICkge1xuICAgICAgdmFyIHZhbCA9IGNoZWNrRGF0YSggaWQgKVxuICAgICAgaWYgKCB2YWwgKSByZXR1cm4gdmFsXG4gICAgICBpZCA9IGlkW2lkX3Zhcl1cbiAgICB9XG5cbiAgICBpZiAoIGlkIGluc3RhbmNlb2YgQXJyYXkgKSB7XG4gICAgICB2YXIgdmFsID0gY2hlY2tEYXRhKCBpZCApXG4gICAgICBpZiAoIHZhbCApIHJldHVybiB2YWxcbiAgICB9XG5cbiAgICBpZiAoIHZhcnMuZGF0YS5hcHAgaW5zdGFuY2VvZiBBcnJheSApIHtcbiAgICAgIHZhciB2YWwgPSBjaGVja0RhdGEoIGZpbHRlckFycmF5KCB2YXJzLmRhdGEuYXBwICkgKVxuICAgICAgaWYgKCB2YWwgKSByZXR1cm4gdmFsXG4gICAgfVxuXG4gIH1cblxuICBpZiAoIFwiYXR0cnNcIiBpbiB2YXJzICYmIHZhcnMuYXR0cnMudmFsdWUgKSB7XG5cbiAgICBpZiAoIHZhcnMuYXR0cnMudmFsdWUgaW5zdGFuY2VvZiBBcnJheSApIHtcbiAgICAgIHZhciBhdHRyID0gZmlsdGVyQXJyYXkodmFycy5hdHRycy52YWx1ZSlcbiAgICB9XG4gICAgZWxzZSBpZiAoIGlkX3ZhciBpbiB2YXJzLmF0dHJzLnZhbHVlICkge1xuICAgICAgaWYgKCB2YXJzLmF0dHJzLnZhbHVlW2lkX3Zhcl0gaW5zdGFuY2VvZiBBcnJheSApIHtcbiAgICAgICAgdmFyIGF0dHIgPSBmaWx0ZXJBcnJheSh2YXJzLmF0dHJzLnZhbHVlW2lkX3Zhcl0pXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGF0dHIgPSB2YXJzLmF0dHJzLnZhbHVlW2lkX3Zhcl1cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgYXR0ciA9IHZhcnMuYXR0cnMudmFsdWVcbiAgICB9XG5cbiAgfVxuXG4gIGlmICggZDNwbHVzLm9iamVjdC52YWxpZGF0ZShhdHRyKSApIHtcblxuICAgIHZhciBuZXdBdHRyID0gW11cblxuICAgIGlmICggaWQgaW5zdGFuY2VvZiBBcnJheSApIHtcbiAgICAgIGlmIChkM3BsdXMub2JqZWN0LnZhbGlkYXRlKGlkWzBdKSkgaWQgPSBkM3BsdXMudXRpbC51bmlxdWVzKGlkLGlkX3ZhcilcbiAgICAgIGlkLmZvckVhY2goZnVuY3Rpb24oZCl7XG4gICAgICAgIG5ld0F0dHIucHVzaChhdHRyW2RdKVxuICAgICAgfSlcbiAgICB9XG4gICAgZWxzZSBuZXdBdHRyLnB1c2goYXR0cltpZF0pXG5cbiAgICBhdHRyID0gbmV3QXR0clxuXG4gIH1cblxuICBpZiAoIGF0dHIgJiYgYXR0ci5sZW5ndGggKSB7XG4gICAgdmFyIHZhbHMgPSBkM3BsdXMudXRpbC51bmlxdWVzKCBhdHRyICwgdmFyaWFibGUgKVxuICAgIGlmICggdmFscy5sZW5ndGggPT09IDEgKSByZXR1cm4gdmFsc1swXVxuICAgIGVsc2UgaWYgKHZhbHMubGVuZ3RoKSByZXR1cm4gdmFsc1xuXG4gIH1cblxuICByZXR1cm4gbnVsbFxuXG59XG4iLCIjIyMqXG4gKiBDcmVhdGVzIGFuIGludmlzaWJsZSB0ZXN0IGVsZW1lbnQgdG8gcG9wdWxhdGVcbiAjIyNcbm1vZHVsZS5leHBvcnRzID0gKHR5cGUpIC0+XG5cbiAgdHlwZSA9IFwiZGl2XCIgaWYgWyBcImRpdlwiLCBcInN2Z1wiIF0uaW5kZXhPZih0eXBlKSA8IDBcbiAgc3R5bGVzID1cbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXG4gICAgbGVmdDogXCItOTk5OXB4XCJcbiAgICB0b3A6IFwiLTk5OTlweFwiXG4gICAgdmlzaWJpbGl0eTogXCJoaWRkZW5cIlxuICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuXG4gIHRlc3RlciA9IGQzLnNlbGVjdChcImJvZHlcIikuc2VsZWN0QWxsKHR5cGUgKyBcIi5kM3BsdXNfdGVzdGVyXCIpLmRhdGEoWyBcImQzcGx1c190ZXN0ZXJcIiBdKVxuICB0ZXN0ZXIuZW50ZXIoKS5hcHBlbmQodHlwZSkuYXR0cihcImNsYXNzXCIsIFwiZDNwbHVzX3Rlc3RlclwiKS5zdHlsZSBzdHlsZXNcblxuICB0ZXN0ZXJcbiIsIi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gUmVzZXRzIGNlcnRhaW4ga2V5cyBpbiBnbG9iYWwgdmFyaWFibGVzLlxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgcmVzZXQgPSBmdW5jdGlvbiggb2JqICwgbWV0aG9kICkge1xuXG4gIGlmICggb2JqLmNoYW5nZWQgKSB7XG4gICAgb2JqLmNoYW5nZWQgPSBmYWxzZVxuICB9XG5cbiAgaWYgKCBtZXRob2QgPT09IFwiZHJhd1wiICkge1xuICAgIG9iai5mcm96ZW4gPSBmYWxzZVxuICAgIG9iai51cGRhdGUgPSB0cnVlXG4gICAgb2JqLmZpcnN0ID0gZmFsc2VcbiAgfVxuXG4gIGZvciAoIHZhciBvIGluIG9iaiApIHtcblxuICAgIGlmICggZDNwbHVzLm9iamVjdC52YWxpZGF0ZSggb2JqW29dICkgKSB7XG5cbiAgICAgIHJlc2V0KCBvYmpbb10gLCBvIClcblxuICAgIH1cblxuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXNldFxuIiwiLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBDbGVhbnMgZWRnZXMgbGlzdCBhbmQgcG9wdWxhdGVzIG5vZGVzIGxpc3QgaWYgbmVlZGVkXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIHZhcnMgKSB7XG5cbiAgaWYgKCB2YXJzLmRldi52YWx1ZSApIHtcbiAgICB2YXIgdGltZXJTdHJpbmcgPSBcImFuYWx5emluZyBlZGdlcyBsaXN0XCJcbiAgICBkM3BsdXMuY29uc29sZS50aW1lKCB0aW1lclN0cmluZyApXG4gIH1cblxuICB2YXIgYXBwUmVxcyAgICAgPSB2YXJzLnR5cGVzW3ZhcnMudHlwZS52YWx1ZV0ucmVxdWlyZW1lbnRzXG4gIGlmICghKGFwcFJlcXMgaW5zdGFuY2VvZiBBcnJheSkpIGFwcFJlcXMgPSBbYXBwUmVxc11cbiAgdmFyIGNyZWF0ZU5vZGVzID0gYXBwUmVxcy5pbmRleE9mKFwibm9kZXNcIikgPj0gMCAmJiAhdmFycy5ub2Rlcy52YWx1ZVxuXG4gIGlmICggY3JlYXRlTm9kZXMgKSB7XG4gICAgdmFycy5ub2Rlcy52YWx1ZSA9IFtdXG4gICAgdmFyIHBsYWNlZCA9IFtdXG4gICAgdmFycy5ub2Rlcy5jaGFuZ2VkID0gdHJ1ZVxuICB9XG5cbiAgdmFycy5lZGdlcy52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe1xuXG4gICAgaWYgKHR5cGVvZiBlW3ZhcnMuZWRnZXMuc291cmNlXSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdmFyIG9iaiA9IHt9XG4gICAgICBvYmpbdmFycy5pZC52YWx1ZV0gPSBlW3ZhcnMuZWRnZXMuc291cmNlXVxuICAgICAgZVt2YXJzLmVkZ2VzLnNvdXJjZV0gPSBvYmpcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlW3ZhcnMuZWRnZXMudGFyZ2V0XSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdmFyIG9iaiA9IHt9XG4gICAgICBvYmpbdmFycy5pZC52YWx1ZV0gPSBlW3ZhcnMuZWRnZXMudGFyZ2V0XVxuICAgICAgZVt2YXJzLmVkZ2VzLnRhcmdldF0gPSBvYmpcbiAgICB9XG5cbiAgICBpZiAoIShcImtleXNcIiBpbiB2YXJzLmRhdGEpKSB7XG4gICAgICB2YXJzLmRhdGEua2V5cyA9IHt9XG4gICAgfVxuXG4gICAgaWYgKCEodmFycy5pZC52YWx1ZSBpbiB2YXJzLmRhdGEua2V5cykpIHtcbiAgICAgIHZhcnMuZGF0YS5rZXlzW3ZhcnMuaWQudmFsdWVdID0gdHlwZW9mIGVbdmFycy5lZGdlcy5zb3VyY2VdW3ZhcnMuaWQudmFsdWVdXG4gICAgfVxuXG4gICAgaWYgKCBjcmVhdGVOb2RlcyApIHtcbiAgICAgIGlmIChwbGFjZWQuaW5kZXhPZihlW3ZhcnMuZWRnZXMuc291cmNlXVt2YXJzLmlkLnZhbHVlXSkgPCAwKSB7XG4gICAgICAgIHBsYWNlZC5wdXNoKGVbdmFycy5lZGdlcy5zb3VyY2VdW3ZhcnMuaWQudmFsdWVdKVxuICAgICAgICB2YXJzLm5vZGVzLnZhbHVlLnB1c2goZVt2YXJzLmVkZ2VzLnNvdXJjZV0pXG4gICAgICB9XG4gICAgICBpZiAocGxhY2VkLmluZGV4T2YoZVt2YXJzLmVkZ2VzLnRhcmdldF1bdmFycy5pZC52YWx1ZV0pIDwgMCkge1xuICAgICAgICBwbGFjZWQucHVzaChlW3ZhcnMuZWRnZXMudGFyZ2V0XVt2YXJzLmlkLnZhbHVlXSlcbiAgICAgICAgdmFycy5ub2Rlcy52YWx1ZS5wdXNoKGVbdmFycy5lZGdlcy50YXJnZXRdKVxuICAgICAgfVxuICAgIH1cblxuICB9KVxuXG4gIHZhcnMuZWRnZXMudmFsdWUgPSB2YXJzLmVkZ2VzLnZhbHVlLmZpbHRlcihmdW5jdGlvbihlKXtcblxuICAgIHZhciBzb3VyY2UgPSBlW3ZhcnMuZWRnZXMuc291cmNlXVt2YXJzLmlkLnZhbHVlXVxuICAgICAgLCB0YXJnZXQgPSBlW3ZhcnMuZWRnZXMudGFyZ2V0XVt2YXJzLmlkLnZhbHVlXVxuXG4gICAgaWYgKCBzb3VyY2UgPT09IHRhcmdldCApIHtcbiAgICAgIHZhciBzdHIgPSB2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUuZGV2LnNhbWVFZGdlXG4gICAgICBkM3BsdXMuY29uc29sZS53YXJuaW5nKGQzcGx1cy5zdHJpbmcuZm9ybWF0KHN0cixcIlxcXCJcIitzb3VyY2UrXCJcXFwiXCIpICwgXCJlZGdlc1wiIClcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gIH0pXG5cbiAgdmFycy5lZGdlcy5saW5rZWQgPSB0cnVlXG5cbiAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWVFbmQoIHRpbWVyU3RyaW5nIClcblxufVxuIiwiLy8gUGFyc2VzIGFuIEhUTUwgZWxlbWVudCBmb3IgZGF0YVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggdmFycyApIHtcblxuICB2YXIgYXR0cmlidXRlcyA9IFsgdmFycy5jb2xvci52YWx1ZVxuICAgICAgICAgICAgICAgICAgICwgdmFycy5pY29uLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgLCB2YXJzLmtleXdvcmRzLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgLCB2YXJzLmFsdC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICwgXCJzdHlsZVwiIF1cblxuICBpZiAoIXZhcnMudGV4dC52YWx1ZSkge1xuICAgIHZhcnMuc2VsZi50ZXh0KFwidGV4dFwiKVxuICB9XG5cbiAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMuY29uY2F0KHZhcnMuaWQubmVzdGluZylcblxuICBmdW5jdGlvbiBnZXRfYXR0cmlidXRlcyggb2JqICwgZWxlbSApIHtcbiAgICBbXS5mb3JFYWNoLmNhbGwoZWxlbS5hdHRyaWJ1dGVzLCBmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgIGlmICgvXmRhdGEtLy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgICAgICAgIHZhciBjYW1lbENhc2VOYW1lID0gYXR0ci5uYW1lLnN1YnN0cig1KS5yZXBsYWNlKC8tKC4pL2csIGZ1bmN0aW9uICgkMCwgJDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJDEudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb2JqW2NhbWVsQ2FzZU5hbWVdID0gYXR0ci52YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICBhdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24oYSl7XG5cbiAgICAgIGlmICggZWxlbS5nZXRBdHRyaWJ1dGUoYSkgIT09IG51bGwgKSB7XG4gICAgICAgIG9ialthXSA9IGVsZW0uZ2V0QXR0cmlidXRlKGEpXG4gICAgICB9XG5cbiAgICB9KVxuXG4gIH1cblxuICB2YXJzLnNlbGYuZGF0YSh7XCJlbGVtZW50XCI6IHZhcnMuZGF0YS52YWx1ZX0pXG5cbiAgdmFyIGVsZW1lbnRUYWcgID0gdmFycy5kYXRhLmVsZW1lbnQudmFsdWUubm9kZSgpLnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuICAgICwgZWxlbWVudFR5cGUgPSB2YXJzLmRhdGEuZWxlbWVudC52YWx1ZS5hdHRyKFwidHlwZVwiKVxuICAgICwgZWxlbWVudERhdGEgPSBbXVxuXG4gIGlmICggZWxlbWVudFRhZyA9PT0gXCJzZWxlY3RcIiApIHtcblxuICAgIHZhciBlbGVtZW50SUQgPSB2YXJzLmRhdGEuZWxlbWVudC52YWx1ZS5ub2RlKCkuaWRcbiAgICBpZiAoIGVsZW1lbnRJRCApIHtcbiAgICAgIHZhcnMuc2VsZi5jb250YWluZXIoe1wiaWRcIjogZWxlbWVudElEfSlcbiAgICB9XG5cbiAgICB2YXJzLmRhdGEuZWxlbWVudC52YWx1ZS5zZWxlY3RBbGwoXCJvcHRpb25cIilcbiAgICAgIC5lYWNoKGZ1bmN0aW9uKCBvICwgaSApe1xuXG4gICAgICAgIHZhciBkYXRhX29iaiA9IHt9XG5cbiAgICAgICAgZGF0YV9vYmoudGV4dCA9IHRoaXMuaW5uZXJIVE1MXG5cbiAgICAgICAgZ2V0X2F0dHJpYnV0ZXMoZGF0YV9vYmosdGhpcylcblxuICAgICAgICBlbGVtZW50RGF0YS5wdXNoKGRhdGFfb2JqKVxuXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHZhcnMuaWQubmVzdGluZy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IHZhcnMuaWQubmVzdGluZ1tpXVxuICAgICAgICAgICAgaWYgKGxldmVsIGluIGRhdGFfb2JqKSB7XG4gICAgICAgICAgICAgIHZhcnMuc2VsZi5mb2N1cyhkYXRhX29ialtsZXZlbF0pXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH0pXG5cbiAgfVxuICBlbHNlIGlmICggZWxlbWVudFRhZyA9PT0gXCJpbnB1dFwiICYmIGVsZW1lbnRUeXBlID09PSBcInJhZGlvXCIgKSB7XG5cbiAgICB2YXIgZWxlbWVudE5hbWUgPSB2YXJzLmRhdGEuZWxlbWVudC52YWx1ZS5ub2RlKCkuZ2V0QXR0cmlidXRlKFwibmFtZVwiKVxuICAgIGlmICggZWxlbWVudE5hbWUgKSB7XG4gICAgICB2YXJzLnNlbGYuY29udGFpbmVyKHtcImlkXCI6IGVsZW1lbnROYW1lfSlcbiAgICB9XG5cbiAgICB2YXJzLmRhdGEuZWxlbWVudC52YWx1ZVxuICAgICAgLmVhY2goZnVuY3Rpb24oIG8gLCBpICl7XG5cbiAgICAgICAgdmFyIGRhdGFfb2JqID0ge31cblxuICAgICAgICBnZXRfYXR0cmlidXRlcyhkYXRhX29iaix0aGlzKVxuXG4gICAgICAgIHZhciBpZCA9IGRhdGFfb2JqW3ZhcnMuaWQudmFsdWVdIHx8IHRoaXMuaWQgfHwgZmFsc2VcblxuICAgICAgICBpZiAoIGlkICYmIGlzTmFOKHBhcnNlRmxvYXQoaWQpKSApIHtcblxuICAgICAgICAgIHZhciBsYWJlbCA9IGQzLnNlbGVjdChcImxhYmVsW2Zvcj1cIitpZCtcIl1cIilcblxuICAgICAgICAgIGlmICggIWxhYmVsLmVtcHR5KCkgKSB7XG4gICAgICAgICAgICBkYXRhX29iai50ZXh0ID0gbGFiZWwuaHRtbCgpXG4gICAgICAgICAgICBsYWJlbC5jYWxsKGhpZGVFbGVtZW50KVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudERhdGEucHVzaChkYXRhX29iailcblxuICAgICAgICBpZiAodGhpcy5jaGVja2VkKSB7XG4gICAgICAgICAgdmFycy5mb2N1cy52YWx1ZVswXSA9IGRhdGFfb2JqW3ZhcnMuaWQudmFsdWVdXG4gICAgICAgIH1cblxuICAgICAgfSlcblxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIEdldCBmb2N1cyBmcm9tIGRhdGEsIGlmIGl0IGhhc24ndCBiZWVuIGZvdW5kIG9yIHNldC5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGlmICggIXZhcnMuZm9jdXMudmFsdWUubGVuZ3RoICYmIGVsZW1lbnREYXRhLmxlbmd0aCApIHtcblxuICAgIHZhcnMuZGF0YS5lbGVtZW50LnZhbHVlLm5vZGUoKS5zZWxlY3RlZEluZGV4ID0gMFxuICAgIHZhcnMuc2VsZi5mb2N1cyhlbGVtZW50RGF0YVswXVt2YXJzLmlkLnZhbHVlXSlcblxuICB9XG5cbiAgZnVuY3Rpb24gaGlkZUVsZW1lbnQoIGVsZW0gKSB7XG5cbiAgICBlbGVtXG4gICAgICAuc3R5bGUoXCJwb3NpdGlvblwiLFwiYWJzb2x1dGVcIixcImltcG9ydGFudFwiKVxuICAgICAgLnN0eWxlKFwiY2xpcFwiLFwicmVjdCgxcHggMXB4IDFweCAxcHgpXCIsXCJpbXBvcnRhbnRcIilcbiAgICAgIC5zdHlsZShcImNsaXBcIixcInJlY3QoMXB4LCAxcHgsIDFweCwgMXB4KVwiLFwiaW1wb3J0YW50XCIpXG4gICAgICAuc3R5bGUoXCJ3aWR0aFwiLFwiMXB4XCIsXCJpbXBvcnRhbnRcIilcbiAgICAgIC5zdHlsZShcImhlaWdodFwiLFwiMXB4XCIsXCJpbXBvcnRhbnRcIilcbiAgICAgIC5zdHlsZShcIm1hcmdpblwiLFwiLTFweFwiLFwiaW1wb3J0YW50XCIpXG4gICAgICAuc3R5bGUoXCJwYWRkaW5nXCIsXCIwXCIsXCJpbXBvcnRhbnRcIilcbiAgICAgIC5zdHlsZShcImJvcmRlclwiLFwiMFwiLFwiaW1wb3J0YW50XCIpXG4gICAgICAuc3R5bGUoXCJvdmVyZmxvd1wiLFwiaGlkZGVuXCIsXCJpbXBvcnRhbnRcIilcblxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIElmIGEgPGxlZ2VuZD4gZWxlbWVudCBleGlzdHMsIHVzZSBpdCBhcyB0aGUgdGl0bGUuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXIgZWxlbWVudExlZ2VuZCA9IGQzLnNlbGVjdChcImxlZ2VuZFtmb3I9XCIrdmFycy5jb250YWluZXIuaWQrXCJdXCIpXG4gIGlmICggIWVsZW1lbnRMZWdlbmQuZW1wdHkoKSApIHtcblxuICAgIHZhcnMuc2VsZi50aXRsZShlbGVtZW50TGVnZW5kLmh0bWwoKSlcbiAgICBlbGVtZW50TGVnZW5kLmNhbGwoaGlkZUVsZW1lbnQpXG5cbiAgfVxuXG4gIHZhciBjb250YWluZXJUYWcgPSB2YXJzLmNvbnRhaW5lci52YWx1ZVxuICAgICAgICAgICAgICAgICAgID8gdmFycy5jb250YWluZXIudmFsdWUubm9kZSgpLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA6IGZhbHNlXG5cbiAgaWYgKCB2YXJzLmNvbnRhaW5lci52YWx1ZSA9PT0gZmFsc2UgfHwgY29udGFpbmVyVGFnID09PSBcImJvZHlcIiApIHtcbiAgICB2YXJzLmNvbnRhaW5lci52YWx1ZSA9IGQzLnNlbGVjdCh2YXJzLmRhdGEuZWxlbWVudC52YWx1ZS5ub2RlKCkucGFyZW50Tm9kZSlcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50RGF0YVxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIENhbGN1bGF0ZXMgbm9kZSBwb3NpdGlvbnMsIGlmIG5lZWRlZCBmb3IgbmV0d29ya1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhcnMpIHtcblxuICBpZiAoIHZhcnMuZGV2LnZhbHVlICkge1xuICAgIHZhciB0aW1lclN0cmluZyA9IFwiYW5hbHl6aW5nIG5vZGUgcG9zaXRpb25zXCJcbiAgICBkM3BsdXMuY29uc29sZS50aW1lKCB0aW1lclN0cmluZyApXG4gIH1cblxuICB2YXIgc2V0ID0gdmFycy5ub2Rlcy52YWx1ZS5maWx0ZXIoZnVuY3Rpb24obil7XG4gICAgcmV0dXJuIHR5cGVvZiBuLnggPT0gXCJudW1iZXJcIiAmJiB0eXBlb2Ygbi55ID09IFwibnVtYmVyXCJcbiAgfSkubGVuZ3RoXG5cbiAgaWYgKHNldCA9PSB2YXJzLm5vZGVzLnZhbHVlLmxlbmd0aCkge1xuICAgIHZhcnMubm9kZXMucG9zaXRpb25zID0gdHJ1ZVxuICB9XG4gIGVsc2Uge1xuXG4gICAgdmFyIGZvcmNlID0gZDMubGF5b3V0LmZvcmNlKClcbiAgICAgIC5zaXplKFt2YXJzLndpZHRoLnZpeix2YXJzLmhlaWdodC52aXpdKVxuICAgICAgLm5vZGVzKHZhcnMubm9kZXMudmFsdWUpXG4gICAgICAubGlua3ModmFycy5lZGdlcy52YWx1ZSlcblxuICAgIHZhciBpdGVyYXRpb25zID0gNTAsXG4gICAgICAgIHRocmVzaG9sZCA9IDAuMDE7XG5cbiAgICBmb3JjZS5zdGFydCgpOyAvLyBEZWZhdWx0cyB0byBhbHBoYSA9IDAuMVxuICAgIGZvciAodmFyIGkgPSBpdGVyYXRpb25zOyBpID4gMDsgLS1pKSB7XG4gICAgICBmb3JjZS50aWNrKCk7XG4gICAgICBpZihmb3JjZS5hbHBoYSgpIDwgdGhyZXNob2xkKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3JjZS5zdG9wKCk7XG5cbiAgICB2YXJzLm5vZGVzLnBvc2l0aW9ucyA9IHRydWVcblxuICB9XG5cbiAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWVFbmQoIHRpbWVyU3RyaW5nIClcblxufVxuIiwiI15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuIyBGaW5kcyB0aGUgYmVzdCByZWdyZXNzaW9uIG1vZGVsIHRoYXQgZml0cyB0aGUgZGF0YSB1c2luZyBCYXllc2lhbiBJbmZvcm1hdGlvbiBDcml0ZXJpYVxuIy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4jIGRhdGEgaXMgYW4gYXJyYXkgb2YgdHdvLWRpbWVuc2lvbmFsIGFycmF5cyBpbiB0aGUgZm9ybWF0IG9mIFt4LCB5XVxuXG4jIG9wdGlvbnMgaXMgYSBkaWN0aW9uYXJ5IG9mIG9wdGlvbnMgd2l0aCBhdHRyaWJ1dGVzXG4gICMgbWF4RGVncmVlOyBtYXhpbXVtIHBvc3NpYmxlIGRlZ3JlZSBvZiB0aGUgcG9seW5vbWlhbC4gRGVmYXVsdCBpcyAxMC5cblxuIyBSZXR1cm5zIHRoZSBtb2RlbCB3aXRoIHRoZSBiZXN0IEJJQyBzY29yZSBhcyBhIHRyaXBsZSBbZGVncmVlcywgYmV0YUhhdCwgeUhhdF1cbiAgIyB3aGVyZSBkZWdyZWVzIGlzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGRlZ3JlZXMgb2YgZWFjaCB0ZXJtIGluIHRoZSBwb2x5bm9taWFsLlxuICAjIGFuZCBiZXRhSGF0IGNvbnRhaW5zIHRoZSBjb2VmZmljaWVudHMgZm9yIGVhY2ggdGVybVxuICAjIGFuZCB5SGF0IGNvbnRhaW5zIHRoZSByZWdyZXNzZWQgb3V0cHV0IGZvciBlYWNoIGlucHV0IHRlcm0uXG5cbm51bWVyaWMgPSByZXF1aXJlICdudW1lcmljJ1xuXG5kM3BsdXMuZGF0YS5iZXN0UmVncmVzcyA9IChkYXRhLCBvcHRpb25zKSAtPlxuICBpZiBub3Qgb3B0aW9ucz8gdGhlbiBvcHRpb25zID0ge31cbiAgaWYgbm90IG9wdGlvbnMubWF4RGVncmVlPyB0aGVuIG9wdGlvbnMubWF4RGVncmVlID0gNSAjIHRyeSB0byBmaXQgYSBwb2x5bm9taWFsIHVwIHRvIHRoaXMgZGVncmVlXG4gIE4gPSBkYXRhLmxlbmd0aFxuICAjIGNob29zZSB0aGUgbW9kZWwgdGhhdCBoYXMgbWluaW11bSBCSUMgKHBlbmFsdHkpXG4gIHByZXZCSUMgPSBOdW1iZXIuTUFYX1ZBTFVFXG4gIGJlc3RSZXN1bHQgPSBudWxsXG4gIFxuICAjIGNvbnN0cnVjdCB0aGUgbWF0cml4IFhcbiAgWGZ1bGx0ciA9ICgoTWF0aC5wb3cocG9pbnRbMF0sIGRlZ3JlZSkgZm9yIHBvaW50IGluIGRhdGEpIGZvciBkZWdyZWUgaW4gWzEuLi5vcHRpb25zLm1heERlZ3JlZSsxXSlcbiAgeSA9IChwb2ludFsxXSBmb3IgcG9pbnQgaW4gZGF0YSlcbiAgZm9yIGkgaW4gWzAuLi4xPDxvcHRpb25zLm1heERlZ3JlZV1cbiAgICBYdHIgPSBbMSBmb3IgcSBpbiBbMC4uLk5dXVxuICAgIGRlZ3JlZXMgPSBbMF1cbiAgICBmb3IgaiBpbiBbMC4uLm9wdGlvbnMubWF4RGVncmVlXVxuICAgICAgaWYgKGkgJiAxPDxqKSA+IDBcbiAgICAgICAgWHRyLnB1c2ggWGZ1bGx0cltqXVxuICAgICAgICBkZWdyZWVzLnB1c2ggaisxXG4gICAgI2NvbnNvbGUubG9nIFh0clxuICAgIFggPSBudW1lcmljLnRyYW5zcG9zZSBYdHJcbiAgICBrID0gZGVncmVlcy5sZW5ndGggIyBkZWdyZWVzIG9mIGZyZWVkb21cbiAgICBiZXRhX2hhdCA9IG51bWVyaWMuZG90KG51bWVyaWMuZG90KG51bWVyaWMuaW52KG51bWVyaWMuZG90KFh0ciwgWCkpLCBYdHIpLCB5KVxuICAgIHlfaGF0ID0gbnVtZXJpYy5kb3QoWCwgYmV0YV9oYXQpXG4gICAgcmVzaWR1YWwgPSBudW1lcmljLnN1YiB5LCB5X2hhdFxuICAgIHNzZSA9IG51bWVyaWMuZG90IHJlc2lkdWFsLCByZXNpZHVhbFxuICAgICMgY29tcHV0ZSBzaWdtYTJcbiAgICBzaWdtYTIgPSBzc2UgLyAoTiAtIGspXG4gICAgIyBjb21wdXRlIGxvZy1saWtlbGlob29kXG4gICAgbG9nbGlrZSA9IC0wLjUqTipNYXRoLmxvZygyKk1hdGguUEkpLTAuNSpOKk1hdGgubG9nKHNpZ21hMiktc3NlLygyKnNpZ21hMilcbiAgICBiaWMgPSAtMipsb2dsaWtlICsgayooTWF0aC5sb2coTiktTWF0aC5sb2coMipNYXRoLlBJKSlcbiAgICBpZiBiaWMgPCBwcmV2QklDXG4gICAgICBwcmV2QklDID0gYmljXG4gICAgICBiZXN0UmVzdWx0ID0gW2RlZ3JlZXMsIGJldGFfaGF0LCB5X2hhdF1cbiAgcmV0dXJuIGJlc3RSZXN1bHRcbiIsIiNeXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiMgRmluZHMgb3V0bGllcnMgaW4gbi1kaW0gZGF0YSB1c2luZyB0aGUgTG9jYWwgT3V0bGllciBGYWN0b3IgYWxnb3JpdGhtXG4jIFNlZTpcbiMgICBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xvY2FsX291dGxpZXJfZmFjdG9yXG4jLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmtkdHJlZSA9IHJlcXVpcmUgJ3N0YXRpYy1rZHRyZWUnXG5cbiMgcG9pbnRzIGlzIGFuIGFycmF5IG9mIG4tZGltZW5zaW9uYWwgcG9pbnRzLiBFYWNoIHBvaW50IGlzIGFuIGFycmF5IG9mIGxlbmd0aCBuXG5cbiMgSyBpcyB0aGUgbnVtYmVyIG9mIG5lYXJlc3QgbmVpZ2hib3JzIHRvIGxvb2sgZm9yIHdoZW4gY29tcGFyaW5nIGRlbnNpdGllcy4gRGVmYXVsdCB2YWx1ZSBpcyAxMFxuXG4jIFJldHVybnMgYW4gYXJyYXkgb2YgW2luZGV4LCBsb2ZdIHR1cGxlcywgd2hlcmUgaW5kZXggaXMgdGhlIGluZGV4IG9mIHRoZSBwb2ludCBpbiB0aGUgb3JpZ2luYWwgYXJyYXlcbiMgYW5kIGxvZiBpcyB0aGUgbG9jYWwgb3V0bGllciBmYWN0b3IgZm9yIHRoYXQgcG9pbnQuIFRoZSBhcnJheSBpcyBvcmRlcmVkIGJ5IGRlc2NyZWFzaW5nIG9yZGVyIG9mIExPRlxuIyBzbyB0aGUgb3V0bGllcnMgYXJlIGluIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5LlxuXG5kM3BsdXMuZGF0YS5sb2YgPSAocG9pbnRzLCBLPTEwKSAtPlxuICB0cmVlID0ga2R0cmVlIHBvaW50cyAjIGNvbnN0cnVjdCBhIGtkLXRyZWVcbiAgbmVpZ2hib3JzID0gKHRyZWUua25uKHAsIEsrMSlbMS4uLl0gZm9yIHAgaW4gcG9pbnRzKSAjIGdldCB0aGUgayBuZWFyZXN0IG5laWdoYm9ycyBmb3IgZWFjaCBwb2ludFxuXG4gICMgY2FsY3VsYXRlIHRoZSBzcXVhcmVkIGV1Y2xpZGVhbiBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50cyBwMSBhbmQgcDJcbiAgc3FEaXN0ID0gKGksIGopIC0+XG4gICAgQSA9IHBvaW50c1tpXVxuICAgIEIgPSBwb2ludHNbal1cbiAgICBkaXN0ID0gMFxuICAgIGZvciBpIGluIFswLi4uQS5sZW5ndGhdXG4gICAgICBkZWx0YSA9IEFbaV0gLSBCW2ldXG4gICAgICBkaXN0ICs9IGRlbHRhICogZGVsdGFcbiAgICByZXR1cm4gZGlzdFxuICBcbiAgIyBwcmUtY29tcHV0ZSBrZGlzdCBmb3IgYWxsIHBvaW50c1xuICBrZGlzdHMgPSAoc3FEaXN0IGksIG5laWdoYm9yc1tpXVtLLTFdIGZvciBpIGluIFswLi4ucG9pbnRzLmxlbmd0aF0pXG4gIFxuICAjIHJlYWNoYWJpbGl0eSBkaXN0YW5jZVxuICByZWFjaERpc3QgPSAoaSwgaikgLT4gTWF0aC5tYXggc3FEaXN0KGksIGopLCBrZGlzdHNbal1cblxuICAjIGxvY2FsIHJlYWNoYWJpbGl0eSBkZW5zaXR5XG4gIGxkciA9IChpKSAtPlxuICAgIHJEaXN0ID0gMFxuICAgIHJEaXN0ICs9IHJlYWNoRGlzdCBpLCBqIGZvciBqIGluIG5laWdoYm9yc1tpXVxuICAgIHJldHVybiBLIC8gckRpc3RcblxuICAjIHByZS1jb21wdXRlIGxyZCBmb3IgYWxsIHBvaW50c1xuICBsZHJzID0gKGxkciBpIGZvciBpIGluIFswLi4ucG9pbnRzLmxlbmd0aF0pXG5cbiAgcmVzdWx0ID0gZm9yIGkgaW4gWzAuLi5wb2ludHMubGVuZ3RoXVxuICAgIGF2Z19scmQgPSAwXG4gICAgYXZnX2xyZCArPSBsZHJzW2pdIGZvciBqIGluIG5laWdoYm9yc1tpXVxuICAgIGF2Z19scmQgLz0gS1xuICAgIFtpLCBhdmdfbHJkIC8gbGRyc1tpXV1cbiAgcmVzdWx0LnNvcnQgKGEsYikgLT4gYlsxXSAtIGFbMV1cbiAgcmV0dXJuIHJlc3VsdCIsIiNeXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiMgRmluZHMgb3V0bGllcnMgaW4gMS1kaW0gZGF0YSBieSBjb21wdXRpbmcgdGhlIG1lZGlhbiBhYnNvbHV0ZSBkZXZpYXRpb24gZm9yIGVhY2ggcG9pbnRcbiMgU2VlOlxuI1x0aHR0cDovL2V1cmVrYXN0YXRpc3RpY3MuY29tL3VzaW5nLXRoZS1tZWRpYW4tYWJzb2x1dGUtZGV2aWF0aW9uLXRvLWZpbmQtb3V0bGllcnNcbiNcdGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWVkaWFuX2Fic29sdXRlX2RldmlhdGlvblxuIy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4jIHBvaW50cyBpcyBhbiBhcnJheSBvZiBudW1iZXJzICgxLWRpbSBwb2ludHMpLlxuXG4jIFJldHVybnMgYW4gYXJyYXkgb2YgW2luZGV4LCBkZXZpYXRpb25dIHR1cGxlcywgd2hlcmUgaW5kZXggaXMgdGhlIGluZGV4IG9mIHRoZSBwb2ludCBpbiB0aGUgb3JpZ2luYWwgYXJyYXlcbiMgYW5kIGRldmlhdGlvbiBpcyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgbWVkaWFuIGluIE1BRCB1bml0cyBmb3IgdGhhdCBwb2ludC4gVGhlIGFycmF5IGlzIG9yZGVyZWQgYnlcbiMgZGVzY3JlYXNpbmcgb3JkZXIgb2YgZGV2aWF0aW9uIHNvIHRoZSBvdXRsaWVycyBhcmUgaW4gdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXkuXG5kM3BsdXMuZGF0YS5tYWQgPSAocG9pbnRzKSAtPlxuICBtZWRpYW4gPSBkMy5tZWRpYW4gcG9pbnRzXG4gIG1hZCA9IGQzLm1lZGlhbiBwb2ludHMubWFwIChwKSAtPiBNYXRoLmFicyhwLW1lZGlhbilcbiAgcmVzdWx0ID0gcG9pbnRzLm1hcCAocCwgaSkgLT4gW2ksIE1hdGguYWJzKHAtbWVkaWFuKS9tYWRdXG4gIHJlc3VsdC5zb3J0IChhLGIpIC0+IGJbMV0gLSBhWzFdXG4gIHJldHVybiByZXN1bHQiLCIjIyMqXG4gKiBEZXRlY3RzIGlmIHRoZSBGb250LUF3ZXNvbWUgbGlicmFyeSBpcyBsb2FkZWQgb24gdGhlIHBhZ2UuXG4gIyMjXG5zdHlsZXNoZWV0ID0gcmVxdWlyZSBcIi4uL3N0eWxlL3NoZWV0LmNvZmZlZVwiXG5kM3BsdXMuZm9udC5hd2Vzb21lID0gc3R5bGVzaGVldCBcImZvbnQtYXdlc29tZVwiXG4iLCJmb250VGVzdGVyID0gcmVxdWlyZSBcIi4uL2NvcmUvZm9udC90ZXN0ZXIuY29mZmVlXCJcblxuIyMjKlxuICogQ3JlYXRlcyB0ZXN0IGRpdiB0byBwb3B1bGF0ZSB3aXRoIHRlc3QgRElWc1xuICMjI1xuZDNwbHVzLmZvbnQuc2l6ZXMgPSAod29yZHMsIHN0eWxlLCBwYXJlbnQpIC0+XG5cbiAgdGVzdGVyID0gcGFyZW50IG9yIGZvbnRUZXN0ZXIoXCJzdmdcIikuYXBwZW5kKFwidGV4dFwiKVxuICBzdHlsZSA9IHN0eWxlIG9yIHt9XG4gIHNpemVzID0gW11cbiAgd29yZHMgPSBbIHdvcmRzIF0gdW5sZXNzIHdvcmRzIGluc3RhbmNlb2YgQXJyYXlcbiAgdHNwYW5zID0gdGVzdGVyLnNlbGVjdEFsbChcInRzcGFuLmQzcGx1c190ZXN0Rm9udFNpemVcIikuZGF0YSh3b3JkcylcbiAgYXR0ciA9XG4gICAgeDogMFxuICAgIHk6IDBcblxuICB0c3BhbnMuZW50ZXIoKS5hcHBlbmQoXCJ0c3BhblwiKS5hdHRyKFwiY2xhc3NcIiwgXCJkM3BsdXNfdGVzdEZvbnRTaXplXCIpLnRleHQoU3RyaW5nKS5zdHlsZShzdHlsZSkuYXR0cihhdHRyKS5lYWNoIChkKSAtPlxuICAgIHNpemVzLnB1c2hcbiAgICAgIGhlaWdodDogQG9mZnNldEhlaWdodCBvciBAZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gICAgICB0ZXh0OiBkXG4gICAgICB3aWR0aDogQGdldENvbXB1dGVkVGV4dExlbmd0aCgpXG5cbiAgdHNwYW5zLnJlbW92ZSgpXG4gIHRlc3Rlci5yZW1vdmUoKSB1bmxlc3MgdGVzdGVyXG4gIHNpemVzXG4iLCJ2YXIgZm9udFRlc3RlciA9IHJlcXVpcmUoXCIuLi9jb3JlL2ZvbnQvdGVzdGVyLmNvZmZlZVwiKVxuLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIEdpdmVuIGEgc2luZ2xlIGZvbnQgb3IgYSBsaXN0IG9mIGZvbnQsIGRldGVybWluZXMgd2hpY2ggY2FuIGJlIHJlbmRlcmVkXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZDNwbHVzLmZvbnQudmFsaWRhdGUgPSBmdW5jdGlvbih0ZXN0X2ZvbnRzKSB7XG5cbiAgaWYgKCEodGVzdF9mb250cyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgIHRlc3RfZm9udHMgPSB0ZXN0X2ZvbnRzLnNwbGl0KFwiLFwiKVxuICB9XG5cbiAgdmFyIGZvbnRTdHJpbmcgPSB0ZXN0X2ZvbnRzLmpvaW4oXCIsIFwiKVxuICAgICwgY29tcGxldGVkID0gZDNwbHVzLmZvbnQudmFsaWRhdGUuY29tcGxldGVcblxuICBpZiAoZm9udFN0cmluZyBpbiBjb21wbGV0ZWQpIHtcbiAgICByZXR1cm4gY29tcGxldGVkW2ZvbnRTdHJpbmddXG4gIH1cblxuICB2YXIgdGVzdGVyID0gZm9udFRlc3RlcihcImRpdlwiKVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZV9lbGVtZW50KGZvbnQpIHtcblxuICAgIHJldHVybiB0ZXN0ZXIuYXBwZW5kKFwic3BhblwiKVxuICAgICAgLnN0eWxlKFwiZm9udC1mYW1pbHlcIixmb250KVxuICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsXCIzMnB4XCIpXG4gICAgICAuc3R5bGUoXCJwYWRkaW5nXCIsXCIwcHhcIilcbiAgICAgIC5zdHlsZShcIm1hcmdpblwiLFwiMHB4XCIpXG4gICAgICAudGV4dChcImFiY2RlZmdoaUFCQ0RFRkdISV8hQCMkJV4mKigpXysxMjM0NTY3ODkwXCIpXG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGRpZmZlcmVudChlbGVtMSxlbGVtMikge1xuXG4gICAgdmFyIHdpZHRoMSA9IGVsZW0xLm5vZGUoKS5vZmZzZXRXaWR0aCxcbiAgICAgICAgd2lkdGgyID0gZWxlbTIubm9kZSgpLm9mZnNldFdpZHRoXG5cbiAgICByZXR1cm4gd2lkdGgxICE9PSB3aWR0aDJcblxuICB9XG5cbiAgdmFyIG1vbm9zcGFjZSA9IGNyZWF0ZV9lbGVtZW50KFwibW9ub3NwYWNlXCIpLFxuICAgICAgcHJvcG9ydGlvbmFsID0gY3JlYXRlX2VsZW1lbnQoXCJzYW5zLXNlcmlmXCIpXG5cbiAgZm9yICggdmFyIGZvbnQgaW4gdGVzdF9mb250cyApIHtcblxuICAgIHZhciBmYW1pbHkgPSB0ZXN0X2ZvbnRzW2ZvbnRdLnRyaW0oKVxuXG4gICAgdmFyIHRlc3QgPSBjcmVhdGVfZWxlbWVudChmYW1pbHkrXCIsbW9ub3NwYWNlXCIpXG5cbiAgICB2YXIgdmFsaWQgPSBkaWZmZXJlbnQodGVzdCxtb25vc3BhY2UpXG4gICAgdGVzdC5yZW1vdmUoKVxuXG4gICAgaWYgKCF2YWxpZCkge1xuICAgICAgdmFyIHRlc3QgPSBjcmVhdGVfZWxlbWVudChmYW1pbHkrXCIsc2Fucy1zZXJpZlwiKVxuICAgICAgdmFsaWQgPSBkaWZmZXJlbnQodGVzdCxwcm9wb3J0aW9uYWwpXG4gICAgICB0ZXN0LnJlbW92ZSgpXG4gICAgfVxuXG4gICAgaWYgKHZhbGlkKSB7XG4gICAgICB2YWxpZCA9IGZhbWlseVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gIH1cblxuICBpZiAoIXZhbGlkKSB7XG4gICAgdmFsaWQgPSBcInNhbnMtc2VyaWZcIlxuICB9XG5cbiAgbW9ub3NwYWNlLnJlbW92ZSgpXG4gIHByb3BvcnRpb25hbC5yZW1vdmUoKVxuXG4gIGNvbXBsZXRlZFtmb250U3RyaW5nXSA9IHZhbGlkXG5cbiAgcmV0dXJuIHZhbGlkXG5cbn1cblxuZDNwbHVzLmZvbnQudmFsaWRhdGUuY29tcGxldGUgPSB7fVxuIiwidmFyIGRhdGFGb3JtYXQgPSByZXF1aXJlKFwiLi4vY29yZS9kYXRhL2Zvcm1hdC5qc1wiKSxcbiAgICBkYXRhS2V5cyA9IHJlcXVpcmUoXCIuLi9jb3JlL2RhdGEva2V5cy5qc1wiKSxcbiAgICBkYXRhTG9hZCA9IHJlcXVpcmUoXCIuLi9jb3JlL2RhdGEvbG9hZC5jb2ZmZWVcIiksXG4gICAgZmV0Y2hEYXRhICA9IHJlcXVpcmUoXCIuLi9jb3JlL2ZldGNoL2RhdGEuanNcIiksXG4gICAgbWV0aG9kUmVzZXQgPSByZXF1aXJlKFwiLi4vY29yZS9tZXRob2QvcmVzZXQuanNcIilcbi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBGb3JtIEVsZW1lbnQgc2hlbGxcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kM3BsdXMuZm9ybSA9IGZ1bmN0aW9uKCkge1xuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBJbml0aWFsaXplIHRoZSBnbG9iYWwgdmFyaWFibGUgb2JqZWN0LlxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgdmFyIHZhcnMgPSB7XG4gICAgXCJ0eXBlc1wiOiB7XG4gICAgICBcImF1dG9cIjogcmVxdWlyZShcIi4vdHlwZXMvYXV0by5qc1wiKSxcbiAgICAgIFwiYnV0dG9uXCI6IHJlcXVpcmUoXCIuL3R5cGVzL2J1dHRvbi9idXR0b24uanNcIiksXG4gICAgICBcImRyb3BcIjogcmVxdWlyZShcIi4vdHlwZXMvZHJvcC9kcm9wLmpzXCIpLFxuICAgICAgXCJ0b2dnbGVcIjogcmVxdWlyZShcIi4vdHlwZXMvdG9nZ2xlLmpzXCIpXG4gICAgfSxcbiAgICBcInNoZWxsXCI6IFwiZm9ybVwiXG4gIH1cblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gQ3JlYXRlIHRoZSBtYWluIGRyYXdpbmcgZnVuY3Rpb24uXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXJzLnNlbGYgPSBmdW5jdGlvbiggc2VsZWN0aW9uICkge1xuXG4gICAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAgIC8vIFNldCB0aW1pbmcgdG8gMCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHJ1bm5pbmcgdGhpcyBmdW5jdGlvbiBvciBpZiB0aGVcbiAgICAvLyBkYXRhIGxlbmd0aCBpcyBsb25nZXIgdGhhbiB0aGUgXCJsYXJnZVwiIGxpbWl0XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciBsYXJnZSA9IHZhcnMuZGF0YS52YWx1ZSBpbnN0YW5jZW9mIEFycmF5XG4gICAgICAgICAgICAgICAgJiYgdmFycy5kYXRhLnZhbHVlLmxlbmd0aCA+IHZhcnMuZGF0YS5sYXJnZVxuXG4gICAgdmFycy5kcmF3LnRpbWluZyA9IHZhcnMuZHJhdy5maXJzdCB8fCBsYXJnZSB8fCBkM3BsdXMuaWVcbiAgICAgICAgICAgICAgICAgICAgID8gMCA6IHZhcnMudGltaW5nLnVpXG5cbiAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgLy8gQ3JlYXRlL3VwZGF0ZSB0aGUgVUkgZWxlbWVudFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBpZiAoIHZhcnMuZGF0YS52YWx1ZSBpbnN0YW5jZW9mIEFycmF5ICkge1xuXG4gICAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXCJkcmF3aW5nIFxcXCJcIit2YXJzLnR5cGUudmFsdWUrXCJcXFwiXCIpXG5cbiAgICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgICAvLyBBbmFseXplIG5ldyBkYXRhLCBpZiBjaGFuZ2VkLlxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIGlmICggdmFycy5kYXRhLmNoYW5nZWQgKSB7XG4gICAgICAgIHZhcnMuZGF0YS5jYWNoZSA9IHt9XG4gICAgICAgIGRhdGFLZXlzKCB2YXJzICwgXCJkYXRhXCIgKVxuICAgICAgICBkYXRhRm9ybWF0KCB2YXJzIClcbiAgICAgIH1cblxuICAgICAgdmFycy5kYXRhLmFwcCA9IGZldGNoRGF0YSggdmFycyApXG5cbiAgICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgICAvLyBTb3J0IHRoZSBkYXRhLCBpZiBuZWVkZWQuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgaWYgKCB2YXJzLmRhdGEuY2hhbmdlZCB8fCB2YXJzLm9yZGVyLmNoYW5nZWQgfHwgdmFycy5vcmRlci5zb3J0LmNoYW5nZWQgKSB7XG5cbiAgICAgICAgZDNwbHVzLmFycmF5LnNvcnQoIHZhcnMuZGF0YS5hcHAgLCB2YXJzLm9yZGVyLnZhbHVlIHx8IHZhcnMudGV4dC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICwgdmFycy5vcmRlci5zb3J0LnZhbHVlICwgdmFycy5jb2xvci52YWx1ZSAsIHZhcnMgKVxuXG4gICAgICB9XG5cbiAgICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgICAvLyBTZXQgZmlyc3QgZWxlbWVudCBpbiBkYXRhIGFzIGZvY3VzIGlmIHRoZXJlIGlzIG5vIGZvY3VzIHNldC5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICBpZiAoICF2YXJzLmZvY3VzLnZhbHVlLmxlbmd0aCApIHtcblxuICAgICAgICB2YXIgZWxlbWVudCA9IHZhcnMuZGF0YS5lbGVtZW50LnZhbHVlXG5cbiAgICAgICAgaWYgKCBlbGVtZW50ICYmIGVsZW1lbnQubm9kZSgpLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzZWxlY3RcIiApIHtcbiAgICAgICAgICB2YXIgaSA9IGVsZW1lbnQucHJvcGVydHkoXCJzZWxlY3RlZEluZGV4XCIpXG4gICAgICAgICAgaSA9IGkgPCAwID8gMCA6IGlcbiAgICAgICAgICB2YXIgb3B0aW9uID0gZWxlbWVudC5zZWxlY3RBbGwoXCJvcHRpb25cIilbMF1baV1cbiAgICAgICAgICAgICwgdmFsID0gb3B0aW9uLmdldEF0dHJpYnV0ZShcImRhdGEtXCIrdmFycy5pZC52YWx1ZSkgfHwgb3B0aW9uLmdldEF0dHJpYnV0ZSh2YXJzLmlkLnZhbHVlKVxuICAgICAgICAgIGlmICh2YWwpIHZhcnMuZm9jdXMudmFsdWVbMF0gPSB2YWxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggIXZhcnMuZm9jdXMudmFsdWUubGVuZ3RoICYmIHZhcnMuZGF0YS5hcHAubGVuZ3RoICkge1xuICAgICAgICAgIHZhcnMuZm9jdXMudmFsdWVbMF0gPSB2YXJzLmRhdGEuYXBwWzBdW3ZhcnMuaWQudmFsdWVdXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICYmIHZhcnMuZm9jdXMudmFsdWUubGVuZ3RoICkgZDNwbHVzLmNvbnNvbGUubG9nKFwiXFxcInZhbHVlXFxcIiBzZXQgdG8gXFxcIlwiK3ZhcnMuZm9jdXMrXCJcXFwiXCIpXG5cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0TGV2ZWwoZCxkZXB0aCkge1xuXG4gICAgICAgIHZhciBkZXB0aCA9IHR5cGVvZiBkZXB0aCAhPT0gXCJudW1iZXJcIiA/IHZhcnMuaWQubmVzdGluZy5sZW5ndGggPT09IDFcbiAgICAgICAgICAgICAgICAgID8gMCA6IHZhcnMuaWQubmVzdGluZy5sZW5ndGgtMSA6IGRlcHRoXG4gICAgICAgICAgLCBsZXZlbCA9IHZhcnMuaWQubmVzdGluZ1tkZXB0aF1cblxuICAgICAgICBpZiAoIGRlcHRoID4gMCAmJiAoIShsZXZlbCBpbiBkKSB8fCBkW2xldmVsXSBpbnN0YW5jZW9mIEFycmF5KSApIHtcbiAgICAgICAgICByZXR1cm4gZ2V0TGV2ZWwoZCxkZXB0aC0xKVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBsZXZlbFxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAgIC8vIFJ1biB0aGVzZSB0aGluZ3MgaWYgdGhlIGRhdGEgaGFzIGNoYW5nZWQuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgaWYgKCB2YXJzLmRhdGEuY2hhbmdlZCApIHtcblxuICAgICAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHNlYXJjaCBib3ggaXMgbmVlZGVkLlxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgaWYgKCB2YXJzLnNlYXJjaC52YWx1ZSA9PT0gXCJhdXRvXCIgKSB7XG5cbiAgICAgICAgICBpZiAodmFycy5kYXRhLmFwcC5sZW5ndGggPiAxMCkge1xuICAgICAgICAgICAgdmFycy5zZWFyY2guZW5hYmxlZCA9IHRydWVcbiAgICAgICAgICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS5sb2coXCJTZWFyY2ggZW5hYmxlZC5cIilcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXJzLnNlYXJjaC5lbmFibGVkID0gZmFsc2VcbiAgICAgICAgICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS5sb2coXCJTZWFyY2ggZGlzYWJsZWQuXCIpXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICB2YXJzLnNlYXJjaC5lbmFibGVkID0gdmFycy5zZWFyY2gudmFsdWVcblxuICAgICAgICB9XG5cbiAgICAgICAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgICAgIC8vIFVwZGF0ZSBPUFRJT04gZWxlbWVudHMgd2l0aCB0aGUgbmV3IGRhdGEuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB2YXIgZWxlbWVudFRhZyA9IHZhcnMuZGF0YS5lbGVtZW50LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgID8gdmFycy5kYXRhLmVsZW1lbnQudmFsdWUubm9kZSgpLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA6IFwiXCJcbiAgICAgICAgaWYgKCB2YXJzLmRhdGEuZWxlbWVudC52YWx1ZSAmJiBlbGVtZW50VGFnID09PSBcInNlbGVjdFwiICkge1xuXG4gICAgICAgICAgdmFyIG9wdGlvbkRhdGEgPSBbXVxuICAgICAgICAgIGZvciAodmFyIGxldmVsIGluIHZhcnMuZGF0YS5uZXN0ZWQuYWxsKSB7XG4gICAgICAgICAgICBvcHRpb25EYXRhID0gb3B0aW9uRGF0YS5jb25jYXQodmFycy5kYXRhLm5lc3RlZC5hbGxbbGV2ZWxdKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG9wdGlvbnMgPSB2YXJzLmRhdGEuZWxlbWVudC52YWx1ZS5zZWxlY3RBbGwoXCJvcHRpb25cIilcbiAgICAgICAgICAgIC5kYXRhKG9wdGlvbkRhdGEsZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICAgIHZhciBsZXZlbCA9IGdldExldmVsKGQpXG4gICAgICAgICAgICAgIHJldHVybiBkICYmIGxldmVsIGluIGQgPyBkW2xldmVsXSA6IGZhbHNlXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgb3B0aW9ucy5leGl0KCkucmVtb3ZlKClcblxuICAgICAgICAgIG9wdGlvbnMuZW50ZXIoKS5hcHBlbmQoXCJvcHRpb25cIilcblxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKGQpe1xuXG4gICAgICAgICAgICAgIHZhciBsZXZlbCAgID0gZ2V0TGV2ZWwoZClcbiAgICAgICAgICAgICAgICAsIHRleHRLZXkgPSBsZXZlbCA9PT0gdmFycy5pZC52YWx1ZSA/IHZhcnMudGV4dC52YWx1ZSB8fCB2YXJzLmlkLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogdmFycy50ZXh0Lm5lc3RpbmcgIT09IHRydWUgJiYgbGV2ZWwgaW4gdmFycy50ZXh0Lm5lc3RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyB2YXJzLnRleHQubmVzdGluZ1tsZXZlbF0gOiBsZXZlbFxuXG4gICAgICAgICAgICAgIGZvciAoIHZhciBrIGluIGQgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBkW2tdICE9PSBcIm9iamVjdFwiICkge1xuXG4gICAgICAgICAgICAgICAgICBpZiAoIGsgPT09IHRleHRLZXkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5odG1sKGRba10pXG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmICggW1wiYWx0XCIsXCJ2YWx1ZVwiXS5pbmRleE9mKGspID49IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKGssZFtrXSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cihcImRhdGEtXCIrayxkW2tdKVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZFtsZXZlbF0gPT09IHZhcnMuZm9jdXMudmFsdWVbMF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgICBlbHNlIGlmICh2YXJzLmZvY3VzLmNoYW5nZWQgJiYgdmFycy5kYXRhLmVsZW1lbnQudmFsdWUpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRUYWcgPSB2YXJzLmRhdGEuZWxlbWVudC52YWx1ZS5ub2RlKCkudGFnTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGlmIChlbGVtZW50VGFnID09PSBcInNlbGVjdFwiKSB7XG4gICAgICAgICAgdmFycy5kYXRhLmVsZW1lbnQudmFsdWUuc2VsZWN0QWxsKFwib3B0aW9uXCIpXG4gICAgICAgICAgICAuZWFjaChmdW5jdGlvbihkKXtcbiAgICAgICAgICAgICAgdmFyIGxldmVsID0gZ2V0TGV2ZWwoZClcbiAgICAgICAgICAgICAgaWYgKGRbbGV2ZWxdID09PSB2YXJzLmZvY3VzLnZhbHVlWzBdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIHZhcnMudHlwZS52YWx1ZSAhPT0gXCJhdXRvXCIgKSB7XG5cbiAgICAgICAgaWYgKCAhdmFycy5jb250YWluZXIudWkgKSB7XG5cbiAgICAgICAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAgICAgICAvLyBTZWxlY3QgY29udGFpbmVyIERJViBmb3IgVUkgZWxlbWVudFxuICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgIHZhcnMuY29udGFpbmVyLnVpID0gdmFycy5jb250YWluZXIudmFsdWVcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJkaXYjZDNwbHVzX1wiK3ZhcnMudHlwZS52YWx1ZStcIl9cIit2YXJzLmNvbnRhaW5lci5pZClcbiAgICAgICAgICAgIC5kYXRhKFtcImNvbnRhaW5lclwiXSlcblxuICAgICAgICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAgICAgICAgIC8vIENyZWF0ZSBjb250YWluZXIgRElWIGZvciBVSSBlbGVtZW50XG4gICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgdmFyIGJlZm9yZSA9IHZhcnMuZGF0YS5lbGVtZW50LnZhbHVlID8gdmFycy5kYXRhLmVsZW1lbnQudmFsdWVbMF1bMF0gOiBudWxsXG5cbiAgICAgICAgICBpZiAoIGJlZm9yZSApIHtcblxuICAgICAgICAgICAgaWYgKCBiZWZvcmUuaWQgKSB7XG4gICAgICAgICAgICAgIGJlZm9yZSA9IFwiI1wiK2JlZm9yZS5pZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgdmFyIGlkID0gYmVmb3JlLmdldEF0dHJpYnV0ZSh2YXJzLmlkLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgPyB2YXJzLmlkLnZhbHVlIDogXCJkYXRhLVwiK3ZhcnMuaWQudmFsdWVcblxuICAgICAgICAgICAgICBpZiAoIGJlZm9yZS5nZXRBdHRyaWJ1dGUoaWQpICkge1xuICAgICAgICAgICAgICAgIGJlZm9yZSA9IFwiW1wiK2lkK1wiPVwiK2JlZm9yZS5nZXRBdHRyaWJ1dGUoaWQpK1wiXVwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlID0gbnVsbFxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhcnMuY29udGFpbmVyLnVpLmVudGVyKClcbiAgICAgICAgICAgIC5pbnNlcnQoXCJkaXZcIixiZWZvcmUpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsXCJkM3BsdXNfXCIrdmFycy50eXBlLnZhbHVlK1wiX1wiK3ZhcnMuY29udGFpbmVyLmlkKVxuICAgICAgICAgICAgLnN0eWxlKFwicG9zaXRpb25cIixcInJlbGF0aXZlXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJvdmVyZmxvd1wiLFwidmlzaWJsZVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwidmVydGljYWwtYWxpZ25cIixcInRvcFwiKVxuXG4gICAgICAgIH1cblxuICAgICAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAgICAgICAvLyBVcGRhdGUgQ29udGFpbmVyXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHZhcnMuY29udGFpbmVyLnVpXG4gICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLHZhcnMudWkuZGlzcGxheS52YWx1ZSlcblxuICAgICAgICB2YXJzLmNvbnRhaW5lci51aS50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgICAgICAuc3R5bGUoXCJtYXJnaW5cIix2YXJzLnVpLm1hcmdpbitcInB4XCIpXG5cbiAgICAgICAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAgICAgLy8gQ3JlYXRlIHRpdGxlLCBpZiBhdmFpbGFibGUuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHZhciB0aXRsZSA9IHZhcnMuY29udGFpbmVyLnVpLnNlbGVjdEFsbChcImRpdi5kM3BsdXNfdGl0bGVcIilcbiAgICAgICAgICAuZGF0YSh2YXJzLnRpdGxlLnZhbHVlID8gW3ZhcnMudGl0bGUudmFsdWVdIDogW10pXG5cbiAgICAgICAgdGl0bGUuZW50ZXIoKS5pbnNlcnQoXCJkaXZcIixcIiNkM3BsdXNfXCIrdmFycy50eXBlLnZhbHVlK1wiX1wiK3ZhcnMuY29udGFpbmVyLmlkKVxuICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIixcImQzcGx1c190aXRsZVwiKVxuICAgICAgICAgIC5zdHlsZShcImRpc3BsYXlcIixcImlubGluZS1ibG9ja1wiKVxuXG4gICAgICAgIHRpdGxlXG4gICAgICAgICAgLnN0eWxlKFwiY29sb3JcIix2YXJzLmZvbnQuY29sb3IpXG4gICAgICAgICAgLnN0eWxlKFwiZm9udC1mYW1pbHlcIix2YXJzLmZvbnQuZmFtaWx5LnZhbHVlKVxuICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLHZhcnMuZm9udC5zaXplK1wicHhcIilcbiAgICAgICAgICAuc3R5bGUoXCJmb250LXdlaWdodFwiLHZhcnMuZm9udC53ZWlnaHQpXG4gICAgICAgICAgLnN0eWxlKFwicGFkZGluZ1wiLHZhcnMudWkucGFkZGluZytcInB4XCIpXG4gICAgICAgICAgLnN0eWxlKFwiYm9yZGVyLWNvbG9yXCIsXCJ0cmFuc3BhcmVudFwiKVxuICAgICAgICAgIC5zdHlsZShcImJvcmRlci1zdHlsZVwiLFwic29saWRcIilcbiAgICAgICAgICAuc3R5bGUoXCJib3JkZXItd2lkdGhcIix2YXJzLnVpLmJvcmRlcitcInB4XCIpXG4gICAgICAgICAgLnRleHQoU3RyaW5nKVxuICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgdmFycy5tYXJnaW4ubGVmdCA9IHRoaXMub2Zmc2V0V2lkdGhcbiAgICAgICAgICB9KVxuXG4gICAgICB9XG5cbiAgICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgICAvLyBDYWxsIHNwZWNpZmljIFVJIGVsZW1lbnQgdHlwZSwgaWYgdGhlcmUgaXMgZGF0YS5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICBpZiAoIHZhcnMuZGF0YS52YWx1ZS5sZW5ndGggKSB7XG5cbiAgICAgICAgdmFyIGFwcCA9IHZhcnMuZm9ybWF0LmxvY2FsZS52YWx1ZS52aXN1YWxpemF0aW9uW3ZhcnMudHlwZS52YWx1ZV1cbiAgICAgICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWUoXCJkcmF3aW5nIFwiKyBhcHApXG4gICAgICAgIHZhcnMudHlwZXNbdmFycy50eXBlLnZhbHVlXSggdmFycyApXG4gICAgICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lRW5kKFwiZHJhd2luZyBcIisgYXBwKVxuXG4gICAgICB9XG4gICAgICBlbHNlIGlmICggdmFycy5kYXRhLnVybCAmJiAoIXZhcnMuZGF0YS5sb2FkZWQgfHwgdmFycy5kYXRhLnN0cmVhbSkgKSB7XG5cbiAgICAgICAgZGF0YUxvYWQoIHZhcnMgLCBcImRhdGFcIiAsIHZhcnMuc2VsZi5kcmF3IClcblxuICAgICAgfVxuXG4gICAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAgICAgLy8gSW5pdGlhbGl6YXRpb24gY29tcGxldGVcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICBtZXRob2RSZXNldCggdmFycyApXG4gICAgICB2YXJzLm1ldGhvZEdyb3VwID0gZmFsc2VcblxuICAgICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLmdyb3VwRW5kKClcblxuICAgIH1cblxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIERlZmluZSBtZXRob2RzIGFuZCBleHBvc2UgcHVibGljIHZhcmlhYmxlcy5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHZhciBtZXRob2RzID0gWyBcImFjdGl2ZVwiICwgXCJhZ2dzXCIgLCBcImFsdFwiICwgXCJjb2xvclwiICwgXCJjb250YWluZXJcIiAsIFwiZGVwdGhcIlxuICAgICAgICAgICAgICAgICwgXCJkZXZcIiAsIFwiZGF0YVwiICwgXCJkcmF3XCIgLCBcImZvY3VzXCIgLCBcImZvcm1hdFwiICwgXCJoZWlnaHRcIlxuICAgICAgICAgICAgICAgICwgXCJoaXN0b3J5XCIgLCBcImhvdmVyXCIgLCBcImljb25cIiAsIFwiaWRcIiAsIFwia2V5d29yZHNcIiAsIFwibWFyZ2luXCJcbiAgICAgICAgICAgICAgICAsIFwib3BlblwiICwgXCJvcmRlclwiICwgXCJyZW1vdmVcIiAsIFwic2VhcmNoXCIgLCBcInNlbGVjdFwiXG4gICAgICAgICAgICAgICAgLCBcInNlbGVjdEFsbFwiICwgXCJ0ZXh0XCIgLCBcInRpdGxlXCIgLCBcInR5cGVcIiAsIFwid2lkdGhcIiBdXG4gICAgLCBzdHlsZXMgID0gWyBcImRhdGFcIiAsIFwiZm9udFwiICwgXCJpY29uXCIgLCBcInRpbWluZ1wiICwgXCJ0aXRsZVwiICwgXCJ1aVwiIF1cblxuICBkM3BsdXMubWV0aG9kKCB2YXJzICwgbWV0aG9kcyAsIHN0eWxlcyApXG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIEZpbmFsbHksIHJldHVybiB0aGUgbWFpbiBVSSBmdW5jdGlvbiB0byB0aGUgdXNlclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcmV0dXJuIHZhcnMuc2VsZlxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gRGV0ZXJtaW5lcyBmb3JtIHR5cGUgYmFzZWQgb24gZGF0YSBsZW5ndGguXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggdmFycyApIHtcblxuICB2YXIgZGF0YUxlbmd0aCA9IHZhcnMuZGF0YS52YWx1ZS5sZW5ndGhcblxuICBpZiAoIGRhdGFMZW5ndGggPT09IDEgKSB7XG4gICAgdmFycy5zZWxmLnR5cGUoXCJidXR0b25cIikuZHJhdygpXG4gIH1cbiAgZWxzZSBpZiAoIGRhdGFMZW5ndGggPCA1ICkge1xuICAgIHZhcnMuc2VsZi50eXBlKFwidG9nZ2xlXCIpLmRyYXcoKVxuICB9XG4gIGVsc2Uge1xuICAgIHZhcnMuc2VsZi50eXBlKFwiZHJvcFwiKS5kcmF3KClcbiAgfVxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gQ3JlYXRlcyBhIEJ1dHRvblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIHZhcnMgKSB7XG5cbiAgdmFyIGNvbG9yID0gcmVxdWlyZShcIi4vZnVuY3Rpb25zL2NvbG9yLmpzXCIpXG4gICAgLCBpY29ucyA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9ucy9pY29ucy5qc1wiKVxuICAgICwgbW91c2VldmVudHMgPSByZXF1aXJlKFwiLi9mdW5jdGlvbnMvbW91c2VldmVudHMuanNcIilcbiAgICAsIHN0eWxlID0gcmVxdWlyZShcIi4vZnVuY3Rpb25zL3N0eWxlLmpzXCIpXG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIEJpbmQgRGF0YSB0byBCdXR0b25zXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXIgYnV0dG9uID0gdmFycy5jb250YWluZXIudWkuc2VsZWN0QWxsKFwiZGl2LmQzcGx1c19ub2RlXCIpXG4gICAgLmRhdGEodmFycy5kYXRhLmFwcCxmdW5jdGlvbihkKXtcbiAgICAgIHJldHVybiBkW3ZhcnMuaWQudmFsdWVdXG4gICAgfSlcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gRW50ZXIgQnV0dG9uc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWUoXCJlbnRlclwiKVxuXG4gIGJ1dHRvbi5lbnRlcigpLmFwcGVuZChcImRpdlwiKVxuICAgIC5hdHRyKFwiY2xhc3NcIixcImQzcGx1c19ub2RlXCIpXG4gICAgLmNhbGwoIGNvbG9yICwgdmFycyApXG4gICAgLmNhbGwoIHN0eWxlICwgdmFycyApXG4gICAgLmNhbGwoIGljb25zICwgdmFycyApXG4gICAgLmNhbGwoIG1vdXNlZXZlbnRzICwgdmFycyAsIGNvbG9yIClcblxuICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZUVuZChcImVudGVyXCIpXG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIFVwZGF0ZSBCdXR0b25zXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBpZiAodmFycy5kcmF3LnVwZGF0ZSB8fCB2YXJzLmRyYXcudGltaW5nKSB7XG5cbiAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZShcIm9yZGVyaW5nXCIpXG4gICAgYnV0dG9uLm9yZGVyKClcbiAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZUVuZChcIm9yZGVyaW5nXCIpXG5cbiAgICB2YXIgdXBkYXRlZEJ1dHRvbnMgPSBidXR0b25cblxuICB9XG4gIGVsc2Uge1xuXG4gICAgdmFyIGNoZWNrcyA9IFsgdmFycy5mb2N1cy5wcmV2aW91c1xuICAgICAgICAgICAgICAgICAsIHZhcnMuZm9jdXMudmFsdWVbMF1cbiAgICAgICAgICAgICAgICAgLCB2YXJzLmhvdmVyLnByZXZpb3VzXG4gICAgICAgICAgICAgICAgICwgdmFycy5ob3Zlci52YWx1ZSBdLmZpbHRlcihmdW5jdGlvbihjKXsgcmV0dXJuIGMgfSlcblxuICAgIHZhciB1cGRhdGVkQnV0dG9ucyA9IGJ1dHRvbi5maWx0ZXIoZnVuY3Rpb24oYil7XG4gICAgICByZXR1cm4gY2hlY2tzLmluZGV4T2YoYlt2YXJzLmlkLnZhbHVlXSkgPj0gMFxuICAgIH0pXG5cbiAgfVxuXG4gIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lKFwidXBkYXRlXCIpXG4gIGlmICh2YXJzLmRyYXcudGltaW5nKSB7XG4gICAgdXBkYXRlZEJ1dHRvbnNcbiAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgIC5jYWxsKCBjb2xvciAsIHZhcnMgKVxuICAgICAgLmNhbGwoIHN0eWxlICwgdmFycyApXG4gIH1cbiAgZWxzZSB7XG4gICAgdXBkYXRlZEJ1dHRvbnNcbiAgICAgIC5jYWxsKCBjb2xvciAsIHZhcnMgKVxuICAgICAgLmNhbGwoIHN0eWxlICwgdmFycyApXG4gIH1cblxuICB1cGRhdGVkQnV0dG9uc1xuICAgIC5jYWxsKCBpY29ucyAsIHZhcnMgKVxuICAgIC5jYWxsKCBtb3VzZWV2ZW50cyAsIHZhcnMgLCBjb2xvciApXG4gIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lRW5kKFwidXBkYXRlXCIpXG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIEV4aXQgQnV0dG9uc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgYnV0dG9uLmV4aXQoKS5yZW1vdmUoKVxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gRGVmaW5lcyBidXR0b24gY29sb3Jcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICggZWxlbSAsIHZhcnMgKSB7XG5cbiAgZWxlbVxuICAgIC5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIixmdW5jdGlvbihkKXtcblxuICAgICAgaWYgKCB2YXJzLmZvY3VzLnZhbHVlWzBdICE9PSBkW3ZhcnMuaWQudmFsdWVdICkge1xuXG4gICAgICAgIGlmICggdmFycy5ob3Zlci52YWx1ZSA9PT0gZFt2YXJzLmlkLnZhbHVlXSApIHtcbiAgICAgICAgICByZXR1cm4gZDNwbHVzLmNvbG9yLmxpZ2h0ZXIodmFycy51aS5jb2xvci5zZWNvbmRhcnkudmFsdWUsLjI1KVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiB2YXJzLnVpLmNvbG9yLnNlY29uZGFyeS52YWx1ZVxuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuXG4gICAgICAgIGlmICggdmFycy5ob3Zlci52YWx1ZSA9PT0gZFt2YXJzLmlkLnZhbHVlXSApIHtcbiAgICAgICAgICByZXR1cm4gZDMucmdiKHZhcnMudWkuY29sb3IucHJpbWFyeS52YWx1ZSkuZGFya2VyKDAuMTUpLnRvU3RyaW5nKClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdmFycy51aS5jb2xvci5wcmltYXJ5LnZhbHVlXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSlcbiAgICAuc3R5bGUoXCJjb2xvclwiLGZ1bmN0aW9uKGQpe1xuXG4gICAgICB2YXIgaW1hZ2UgPSBkW3ZhcnMuaWNvbi52YWx1ZV0gJiYgdmFycy5kYXRhLmFwcC5sZW5ndGggPCB2YXJzLmRhdGEubGFyZ2VcblxuICAgICAgaWYgKCB2YXJzLmZvY3VzLnZhbHVlWzBdID09PSBkW3ZhcnMuaWQudmFsdWVdICkge1xuICAgICAgICB2YXIgb3BhY2l0eSA9IDFcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgb3BhY2l0eSA9IDAuNzVcbiAgICAgIH1cblxuICAgICAgaWYgKCB2YXJzLmZvY3VzLnZhbHVlWzBdID09PSBkW3ZhcnMuaWQudmFsdWVdICYmIGRbdmFycy5jb2xvci52YWx1ZV0gJiYgIWltYWdlICkge1xuICAgICAgICB2YXIgY29sb3IgPSBkM3BsdXMuY29sb3IubGVnaWJsZShkW3ZhcnMuY29sb3IudmFsdWVdKVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIHZhcnMuZm9jdXMudmFsdWVbMF0gPT09IGRbdmFycy5pZC52YWx1ZV0gKSB7XG4gICAgICAgIHZhciBjb2xvciA9IGQzcGx1cy5jb2xvci50ZXh0KHZhcnMudWkuY29sb3IucHJpbWFyeS52YWx1ZSlcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgY29sb3IgPSBkM3BsdXMuY29sb3IudGV4dCh2YXJzLnVpLmNvbG9yLnNlY29uZGFyeS52YWx1ZSlcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbG9yID0gZDMucmdiKGNvbG9yKVxuXG4gICAgICByZXR1cm4gXCJyZ2JhKFwiK2NvbG9yLnIrXCIsXCIrY29sb3IuZytcIixcIitjb2xvci5iK1wiLFwiK29wYWNpdHkrXCIpXCJcblxuICAgIH0pXG4gICAgLnN0eWxlKFwiYm9yZGVyLWNvbG9yXCIsdmFycy51aS5jb2xvci5zZWNvbmRhcnkudmFsdWUpXG5cbn1cbiIsIi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vL1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCBlbGVtICwgdmFycyApIHtcblxuICB2YXIgcmV2ZXJzZWQgPSAodmFycy5mb250LmFsaWduLnZhbHVlID09PSBcInJpZ2h0XCIgJiYgIWQzcGx1cy5ydGwpXG4gICAgICAgICAgICAgICAgIHx8IChkM3BsdXMucnRsICYmIHZhcnMuZm9udC5hbGlnbi52YWx1ZSA9PT0gXCJyaWdodFwiKVxuXG4gIGVsZW1cbiAgICAuZWFjaChmdW5jdGlvbihkLGkpe1xuXG4gICAgICB2YXIgY2hpbGRyZW4gPSBbXCJsYWJlbFwiXVxuXG4gICAgICBpZiAoIGRbdmFycy5pY29uLnZhbHVlXSAmJiB2YXJzLmRhdGEuYXBwLmxlbmd0aCA8PSB2YXJzLmRhdGEubGFyZ2UgKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goXCJpY29uXCIpXG4gICAgICB9XG5cbiAgICAgIHZhciBpY29uR3JhcGhpYyA9IHZhcnMuaWNvbi5idXR0b24udmFsdWVcbiAgICAgIGlmICggZFt2YXJzLmlkLnZhbHVlXSA9PT0gdmFycy5mb2N1cy52YWx1ZVswXSAmJiB2YXJzLmljb24uc2VsZWN0LnZhbHVlICkge1xuICAgICAgICBpY29uR3JhcGhpYyA9IHZhcnMuaWNvbi5zZWxlY3QudmFsdWVcbiAgICAgICAgY2hpbGRyZW4ucHVzaChcInNlbGVjdGVkXCIpXG4gICAgICB9XG4gICAgICBlbHNlIGlmICggaWNvbkdyYXBoaWMgJiYgZC5kM3BsdXMuaWNvbiAhPT0gZmFsc2UgKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goXCJzZWxlY3RlZFwiKVxuICAgICAgfVxuXG4gICAgICB2YXIgYnVmZmVyID0gMFxuXG4gICAgICB2YXIgaXRlbXMgPSBkMy5zZWxlY3QodGhpcykuc2VsZWN0QWxsKFwiZGl2LmQzcGx1c19idXR0b25fZWxlbWVudFwiKVxuICAgICAgICAuZGF0YShjaGlsZHJlbixmdW5jdGlvbihjKXtcbiAgICAgICAgICByZXR1cm4gY1xuICAgICAgICB9KVxuXG4gICAgICBpdGVtcy5lbnRlcigpLmFwcGVuZChcImRpdlwiKVxuICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsZnVuY3Rpb24oYyl7XG4gICAgICAgICAgcmV0dXJuIGMgPT09IFwibGFiZWxcIiA/IFwiYmxvY2tcIiA6IFwiYWJzb2x1dGVcIlxuICAgICAgICB9KVxuXG4gICAgICBpdGVtcy5vcmRlcigpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIixmdW5jdGlvbihjKXtcbiAgICAgICAgICB2YXIgZXh0cmEgPSBcIlwiXG4gICAgICAgICAgaWYgKCBjID09PSBcInNlbGVjdGVkXCIgJiYgaWNvbkdyYXBoaWMuaW5kZXhPZihcImZhLVwiKSA9PT0gMCApIHtcbiAgICAgICAgICAgIGV4dHJhID0gXCIgZmEgXCIraWNvbkdyYXBoaWNcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFwiZDNwbHVzX2J1dHRvbl9lbGVtZW50IGQzcGx1c19idXR0b25fXCIgKyBjICsgZXh0cmFcbiAgICAgICAgfSlcbiAgICAgICAgLmh0bWwoZnVuY3Rpb24oYyl7XG4gICAgICAgICAgaWYgKCBjID09PSBcImxhYmVsXCIgKSB7XG4gICAgICAgICAgICB2YXIgayA9IHZhcnMudGV4dC52YWx1ZSAmJiB2YXJzLnRleHQudmFsdWUgaW4gZCAmJiAhKGRbdmFycy50ZXh0LnZhbHVlXSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgICAgPyB2YXJzLnRleHQudmFsdWUgOiB2YXJzLmlkLnZhbHVlXG4gICAgICAgICAgICByZXR1cm4gdmFycy5mb3JtYXQudmFsdWUoZFtrXSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGMgPT09IFwic2VsZWN0ZWRcIiAmJiBpY29uR3JhcGhpYy5pbmRleE9mKFwiZmEtXCIpIDwgMFxuICAgICAgICAgICAgICAgICA/IGljb25HcmFwaGljIDogXCJcIlxuICAgICAgICB9KVxuICAgICAgICAuc3R5bGUoXCJiYWNrZ3JvdW5kLWltYWdlXCIsZnVuY3Rpb24oYyl7XG4gICAgICAgICAgaWYgKGMgPT09IFwiaWNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ1cmwoJ1wiK2RbdmFycy5pY29uLnZhbHVlXStcIicpXCJcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFwibm9uZVwiXG4gICAgICAgIH0pXG4gICAgICAgIC5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIixmdW5jdGlvbihjKXtcbiAgICAgICAgICBpZiAoYyA9PT0gXCJpY29uXCIgJiYgZC5zdHlsZSA9PT0gXCJrbm9ja291dFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZFt2YXJzLmNvbG9yLnZhbHVlXSB8fCB2YXJzLnVpLmNvbG9yLnByaW1hcnkudmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFwidHJhbnNwYXJlbnRcIlxuICAgICAgICB9KVxuICAgICAgICAuc3R5bGUoXCJiYWNrZ3JvdW5kLXNpemVcIixcIjEwMCVcIilcbiAgICAgICAgLnN0eWxlKFwidGV4dC1hbGlnblwiLGZ1bmN0aW9uKGMpe1xuICAgICAgICAgIHJldHVybiBjID09PSBcImxhYmVsXCIgPyB2YXJzLmZvbnQuYWxpZ24udmFsdWUgOiBcImNlbnRlclwiXG4gICAgICAgIH0pXG4gICAgICAgIC5zdHlsZShcInBvc2l0aW9uXCIsZnVuY3Rpb24oYyl7XG4gICAgICAgICAgcmV0dXJuIGMgPT0gXCJsYWJlbFwiID8gXCJzdGF0aWNcIiA6IFwiYWJzb2x1dGVcIlxuICAgICAgICB9KVxuICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLGZ1bmN0aW9uKGMpe1xuXG4gICAgICAgICAgaWYgKCBjID09PSBcImxhYmVsXCIgKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJhdXRvXCJcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFycy5oZWlnaHQudmFsdWUpIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9ICh2YXJzLmhlaWdodC52YWx1ZS0odmFycy51aS5wYWRkaW5nKjIpLSh2YXJzLnVpLmJvcmRlcioyKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBidWZmZXIgPSB2YXJzLmZvbnQuc2l6ZSt2YXJzLnVpLnBhZGRpbmcrdmFycy51aS5ib3JkZXJcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGJ1ZmZlcitcInB4XCJcbiAgICAgICAgfSlcbiAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsZnVuY3Rpb24oYyl7XG4gICAgICAgICAgaWYgKCBjID09PSBcImljb25cIiApIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXIrXCJweFwiXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBcImF1dG9cIlxuICAgICAgICB9KVxuICAgICAgICAuc3R5bGUoXCJtYXJnaW4tdG9wXCIsZnVuY3Rpb24oYyl7XG4gICAgICAgICAgaWYgKCBjID09PSBcImxhYmVsXCIgKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIwcHhcIlxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5vZmZzZXRIZWlnaHQgfHwgdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBoID0gdGhpcy5vZmZzZXRIZWlnaHQgfHwgdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIGMgPT09IFwic2VsZWN0ZWRcIiApIHtcbiAgICAgICAgICAgIHZhciBoID0gdmFycy5mb250LnNpemVcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaCA9IGJ1ZmZlclxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gLWgvMitcInB4XCJcbiAgICAgICAgfSlcbiAgICAgICAgLnN0eWxlKFwidG9wXCIsZnVuY3Rpb24oYyl7XG4gICAgICAgICAgcmV0dXJuIGMgPT09IFwibGFiZWxcIiA/IFwiYXV0b1wiIDogXCI1MCVcIlxuICAgICAgICB9KVxuICAgICAgICAuc3R5bGUoXCJsZWZ0XCIsZnVuY3Rpb24oYyl7XG4gICAgICAgICAgaWYgKChjID09PSBcImljb25cIiAmJiAhcmV2ZXJzZWQpIHx8IChjID09PSBcInNlbGVjdGVkXCIgJiYgcmV2ZXJzZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFycy51aS5wYWRkaW5nK1wicHhcIlxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gXCJhdXRvXCJcbiAgICAgICAgfSlcbiAgICAgICAgLnN0eWxlKFwicmlnaHRcIixmdW5jdGlvbihjKXtcbiAgICAgICAgICBpZiAoKGMgPT09IFwiaWNvblwiICYmIHJldmVyc2VkKSB8fCAoYyA9PT0gXCJzZWxlY3RlZFwiICYmICFyZXZlcnNlZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YXJzLnVpLnBhZGRpbmcrXCJweFwiXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBcImF1dG9cIlxuICAgICAgICB9KVxuICAgICAgICAuc3R5bGUoZDNwbHVzLnByZWZpeCgpK1widHJhbnNpdGlvblwiLGZ1bmN0aW9uKGMpe1xuICAgICAgICAgIHJldHVybiBjID09PSBcInNlbGVjdGVkXCIgPyAodmFycy5kcmF3LnRpbWluZy8xMDAwKStcInNcIiA6IFwibm9uZVwiXG4gICAgICAgIH0pXG4gICAgICAgIC5zdHlsZShkM3BsdXMucHJlZml4KCkrXCJ0cmFuc2Zvcm1cIixmdW5jdGlvbihjKXtcbiAgICAgICAgICB2YXIgZGVncmVlID0gYyA9PT0gXCJzZWxlY3RlZFwiID8gdmFycy5pY29uLnNlbGVjdC5yb3RhdGUgOiBcIm5vbmVcIlxuICAgICAgICAgIHJldHVybiBcInJvdGF0ZShcIitkZWdyZWUrXCJkZWcpXCJcbiAgICAgICAgfSlcbiAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLGZ1bmN0aW9uKGMpe1xuICAgICAgICAgIHJldHVybiBjID09PSBcInNlbGVjdGVkXCIgPyB2YXJzLmljb24uc2VsZWN0Lm9wYWNpdHkgOiAxXG4gICAgICAgIH0pXG5cbiAgICAgIGl0ZW1zLmV4aXQoKS5yZW1vdmUoKVxuXG4gICAgICB2YXIgdGV4dCA9IGQzLnNlbGVjdCh0aGlzKS5zZWxlY3RBbGwoXCIuZDNwbHVzX2J1dHRvbl9sYWJlbFwiKVxuXG4gICAgICBpZiAoYnVmZmVyID4gMCkge1xuXG4gICAgICAgIGJ1ZmZlciArPSB2YXJzLnVpLnBhZGRpbmcqMlxuXG4gICAgICAgIHZhciBwID0gdmFycy51aS5wYWRkaW5nXG5cbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgIHZhciBwYWRkaW5nID0gcCtcInB4IFwiK2J1ZmZlcitcInB4XCJcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoY2hpbGRyZW4uaW5kZXhPZihcImljb25cIikgPj0gMCAmJiAhZDNwbHVzLnJ0bCkgfHwgKGNoaWxkcmVuLmluZGV4T2YoXCJzZWxlY3RlZFwiKSA+PSAwICYmIGQzcGx1cy5ydGwpKSB7XG4gICAgICAgICAgdmFyIHBhZGRpbmcgPSBwK1wicHggXCIrcCtcInB4IFwiK3ArXCJweCBcIitidWZmZXIrXCJweFwiXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHBhZGRpbmcgPSBwK1wicHggXCIrYnVmZmVyK1wicHggXCIrcCtcInB4IFwiK3ArXCJweFwiXG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0LnN0eWxlKFwicGFkZGluZ1wiLHBhZGRpbmcpXG5cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0ZXh0LnN0eWxlKFwicGFkZGluZ1wiLHZhcnMudWkucGFkZGluZytcInB4XCIpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdmFycy53aWR0aC52YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB2YXIgd2lkdGggPSB2YXJzLndpZHRoLnZhbHVlXG4gICAgICAgIHdpZHRoIC09IHBhcnNlRmxvYXQodGV4dC5zdHlsZShcInBhZGRpbmctbGVmdFwiKSwxMClcbiAgICAgICAgd2lkdGggLT0gcGFyc2VGbG9hdCh0ZXh0LnN0eWxlKFwicGFkZGluZy1yaWdodFwiKSwxMClcbiAgICAgICAgd2lkdGggLT0gdmFycy51aS5ib3JkZXIqMlxuICAgICAgICB3aWR0aCArPSBcInB4XCJcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgd2lkdGggPSBcImF1dG9cIlxuICAgICAgfVxuXG4gICAgICB0ZXh0LnN0eWxlKFwid2lkdGhcIix3aWR0aClcblxuICAgIH0pXG5cbn1cbiIsIi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vL1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCBlbGVtICwgdmFycyAsIGNvbG9yICkge1xuXG4gIGVsZW1cbiAgICAub24oZDNwbHVzLmV2dC5vdmVyLGZ1bmN0aW9uKGQsaSl7XG5cbiAgICAgIHZhcnMuc2VsZi5ob3ZlcihkW3ZhcnMuaWQudmFsdWVdKVxuXG4gICAgICBpZiAoIGQzcGx1cy5pZSB8fCAhdmFycy5kcmF3LnRpbWluZyApIHtcblxuICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJjdXJzb3JcIixcInBvaW50ZXJcIilcbiAgICAgICAgICAuY2FsbCggY29sb3IgLCB2YXJzIClcblxuICAgICAgfVxuICAgICAgZWxzZSB7XG5cbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiY3Vyc29yXCIsXCJwb2ludGVyXCIpXG4gICAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLnRpbWluZy5tb3VzZWV2ZW50cylcbiAgICAgICAgICAuY2FsbCggY29sb3IgLCB2YXJzIClcbiAgICAgIH1cblxuICAgIH0pXG4gICAgLm9uKGQzcGx1cy5ldnQub3V0LGZ1bmN0aW9uKGQpe1xuXG4gICAgICB2YXJzLnNlbGYuaG92ZXIoZmFsc2UpXG5cbiAgICAgIGlmICggZDNwbHVzLmllIHx8ICF2YXJzLmRyYXcudGltaW5nICkge1xuICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJjdXJzb3JcIixcImF1dG9cIilcbiAgICAgICAgICAuY2FsbCggY29sb3IgLCB2YXJzIClcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJjdXJzb3JcIixcImF1dG9cIilcbiAgICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMudGltaW5nLm1vdXNlZXZlbnRzKVxuICAgICAgICAgIC5jYWxsKCBjb2xvciAsIHZhcnMgKVxuICAgICAgfVxuXG4gICAgfSlcbiAgICAub24oZDNwbHVzLmV2dC5jbGljayxmdW5jdGlvbihkKXtcblxuICAgICAgaWYgKCB2YXJzLmlkLnZhbHVlIGluIGQgKSB7XG5cbiAgICAgICAgdmFycy5zZWxmLmZvY3VzKGRbdmFycy5pZC52YWx1ZV0pLmRyYXcoKVxuXG4gICAgICB9XG5cbiAgICB9KVxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy9cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICggZWxlbSAsIHZhcnMgKSB7XG5cbiAgZWxlbVxuICAgIC5zdHlsZShcInBvc2l0aW9uXCIsXCJyZWxhdGl2ZVwiKVxuICAgIC5zdHlsZShcIm1hcmdpblwiLHZhcnMudWkubWFyZ2luK1wicHhcIilcbiAgICAuc3R5bGUoXCJkaXNwbGF5XCIsdmFycy51aS5kaXNwbGF5LnZhbHVlKVxuICAgIC5zdHlsZShcImJvcmRlci1zdHlsZVwiLFwic29saWRcIilcbiAgICAuc3R5bGUoXCJib3JkZXItd2lkdGhcIix2YXJzLnVpLmJvcmRlcitcInB4XCIpXG4gICAgLnN0eWxlKFwiZm9udC1mYW1pbHlcIix2YXJzLmZvbnQuZmFtaWx5LnZhbHVlKVxuICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLHZhcnMuZm9udC5zaXplK1wicHhcIilcbiAgICAuc3R5bGUoXCJmb250LXdlaWdodFwiLHZhcnMuZm9udC53ZWlnaHQpXG4gICAgLnN0eWxlKFwibGV0dGVyLXNwYWNpbmdcIix2YXJzLmZvbnQuc3BhY2luZytcInB4XCIpXG5cbn1cbiIsIi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBDcmVhdGVzIERyb3Bkb3duIE1lbnVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCB2YXJzICkge1xuXG4gIHZhciBlbGVtZW50ID0gcmVxdWlyZShcIi4vZnVuY3Rpb25zL2VsZW1lbnQuanNcIilcbiAgICAsIGtleWJvYXJkID0gcmVxdWlyZShcIi4vZnVuY3Rpb25zL2tleWJvYXJkLmpzXCIpXG4gICAgLCB3aW5kb3dldmVudCA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9ucy93aW5kb3cuanNcIilcbiAgICAsIHdpZHRoID0gcmVxdWlyZShcIi4vZnVuY3Rpb25zL3dpZHRoLmpzXCIpXG4gICAgLCBidXR0b24gPSByZXF1aXJlKFwiLi9mdW5jdGlvbnMvYnV0dG9uLmpzXCIpXG4gICAgLCBzZWxlY3RvciA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9ucy9zZWxlY3Rvci5qc1wiKVxuICAgICwgdGl0bGUgPSByZXF1aXJlKFwiLi9mdW5jdGlvbnMvdGl0bGUuanNcIilcbiAgICAsIHNlYXJjaCA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9ucy9zZWFyY2guanNcIilcbiAgICAsIGxpc3QgPSByZXF1aXJlKFwiLi9mdW5jdGlvbnMvbGlzdC5qc1wiKVxuICAgICwgZGF0YSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9ucy9kYXRhLmpzXCIpXG4gICAgLCB1cGRhdGUgPSByZXF1aXJlKFwiLi9mdW5jdGlvbnMvdXBkYXRlLmpzXCIpXG5cbiAgdmFycy5tYXJnaW4udG9wID0gMFxuICB2YXJzLm1hcmdpbi50aXRsZSA9IDBcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gSGlqYWNrIGV2ZW50cyBvZiBvcmlnaW5hbCBlbGVtZW50LCBpZiBhcHBsaWNhYmxlLlxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgZWxlbWVudCggdmFycyApXG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIENhcHR1cmUga2V5Ym9hcmQgZXZlbnRzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBrZXlib2FyZCggdmFycyApXG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIEFwcGx5IGNsaWNrIGZ1bmN0aW9uIHRvIGFsbCBwYXJlbnQgd2luZG93cyB0byBjbG9zZSBkcm9wZG93bi5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHdpbmRvd2V2ZW50KCB2YXJzIClcblxuICAvLyBeXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gQ2hlY2sgdG8gbWFrZSBzdXJlIHdlIGhhdmUgYm90aCBhIGJ1dHRvbiBhbmQgbGlzdCB3aWR0aC5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHdpZHRoKCB2YXJzIClcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gQ3JlYXRlIG1haW4gYnV0dG9uLCBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgYnV0dG9uKCB2YXJzIClcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gQ3JlYXRlIFwic2VsZWN0b3JcIiB0byBob2xkIHRoZSBzZWFyY2ggYm94IGFuZCBzZWFyY2ggdmFycy5jb250YWluZXIubGlzdC5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHNlbGVjdG9yKCB2YXJzIClcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gQ3JlYXRlIGFuZCBzdHlsZSB0aGUgdGl0bGUgYm94LCBpZiBhcHBsaWNhYmxlLlxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgdGl0bGUoIHZhcnMgKVxuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBDcmVhdGUgYW5kIHN0eWxlIHRoZSBzZWFyY2ggYm94LCBpZiBhcHBsaWNhYmxlLlxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgc2VhcmNoKCB2YXJzIClcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gQ3JlYXRlIGFuZCBzdHlsZSB0aGUgaXRlbSBsaXN0LlxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgbGlzdCggdmFycyApXG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIEZpbHRlciBkYXRhIGJhc2VkIG9mZiBzZWFyY2ggdGVybSwgaWYgYXBwbGljYWJsZS5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGRhdGEoIHZhcnMgKVxuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBVcGRhdGVzIGFsbCBkaXZzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB1cGRhdGUoIHZhcnMgKVxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gQ2hlY2tzIHRvIHNlZSBpZiBhIGdpdmVuIHZhcmlhYmxlIGlzIGFsbG93ZWQgdG8gYmUgc2VsZWN0ZWQuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoIHZhcnMgLCB2YWx1ZSAsIGFjdGl2ZSApIHtcblxuICB2YXIgcmV0ID0gW11cbiAgICAsIGFjdGl2ZSA9IGFjdGl2ZSB8fCB2YXJzLmFjdGl2ZS52YWx1ZVxuXG4gIGlmICggYWN0aXZlIGluc3RhbmNlb2YgQXJyYXkgKSB7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdGl2ZS5sZW5ndGg7IGkrKykge1xuICAgICAgcmV0LnB1c2godGhpcyh2YXJzLHZhbHVlLGFjdGl2ZVtpXSkpXG4gICAgfVxuXG4gIH1cbiAgZWxzZSB7XG5cbiAgICB2YXIgdCA9IHR5cGVvZiBhY3RpdmVcblxuICAgIGlmICh0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXQucHVzaCh2YXJzLmRlcHRoLnZhbHVlID09PSBhY3RpdmUpXG4gICAgfVxuICAgIGVsc2UgaWYgKHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0LnB1c2goYWN0aXZlKHZhbHVlKSlcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXQucHVzaCh2YWx1ZSA9PT0gYWN0aXZlKVxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIHJldC5pbmRleE9mKHRydWUpID49IDBcblxufVxuIiwiLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIFRvZ2dsZXMgdGhlIHN0YXRlIG9mIHRoZSBkcm9wZG93biBtZW51LlxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCB2YXJzICkge1xuXG4gIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lKFwicm90YXRpbmcgYXJyb3dcIilcblxuICB2YXIgb2Zmc2V0ID0gdmFycy5pY29uLmRyb3AudmFsdWUgPT09IFwiJiN4Mjc2ZjtcIiA/IDkwIDogMFxuXG4gIGlmICh2YXJzLm9wZW4udmFsdWUgIT0gdmFycy5vcGVuLmZsaXBwZWQudmFsdWUpIHtcbiAgICB2YXIgcm90YXRlID0gMTgwICsgb2Zmc2V0XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIHJvdGF0ZSA9IG9mZnNldFxuICB9XG5cbiAgdmFycy5jb250YWluZXIuYnV0dG9uXG4gICAgLmljb24oe1xuICAgICAgXCJzZWxlY3RcIjoge1xuICAgICAgICBcIm9wYWNpdHlcIjogdmFycy5vcGVuLnZhbHVlID8gMC41IDogMSxcbiAgICAgICAgXCJyb3RhdGVcIjogcm90YXRlXG4gICAgICB9XG4gICAgfSlcbiAgICAuZHJhdygpXG5cbiAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWVFbmQoXCJyb3RhdGluZyBhcnJvd1wiKVxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gQ3JlYXRlcyBhbmQgc3R5bGVzIHRoZSBtYWluIGRyb3AgYnV0dG9uLlxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCB2YXJzICkge1xuXG4gIGlmICggIShcImJ1dHRvblwiIGluIHZhcnMuY29udGFpbmVyKSApIHtcblxuICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lKFwiY3JlYXRpbmcgbWFpbiBidXR0b25cIilcblxuICAgIHZhcnMuY29udGFpbmVyLmJ1dHRvbiA9IGQzcGx1cy5mb3JtKClcbiAgICAgIC5jb250YWluZXIodmFycy5jb250YWluZXIudWkpXG4gICAgICAudHlwZShcImJ1dHRvblwiKVxuICAgICAgLnVpKHtcbiAgICAgICAgXCJtYXJnaW5cIjogMFxuICAgICAgfSlcblxuICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lRW5kKFwiY3JlYXRpbmcgbWFpbiBidXR0b25cIilcblxuICB9XG5cbiAgaWYgKCB2YXJzLmZvY3VzLmNoYW5nZWQgfHwgdmFycy5kYXRhLmNoYW5nZWQgfHwgdmFycy5kZXB0aC5jaGFuZ2VkICkge1xuXG4gICAgdmFyIGRlcHRoID0gdmFycy5kZXB0aC52YWx1ZVxuXG4gICAgdmFyIGJ1dHRvbkRhdGEgPSBkM3BsdXMudXRpbC5jb3B5KHZhcnMuZGF0YS52YWx1ZS5maWx0ZXIoZnVuY3Rpb24oZCl7XG4gICAgICB2YXIgbWF0Y2ggPSBmYWxzZVxuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IHZhcnMuaWQubmVzdGluZy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIHZhciBsZXZlbCA9IHZhcnMuaWQubmVzdGluZ1tpXVxuICAgICAgICBtYXRjaCA9IGxldmVsIGluIGQgJiYgZFtsZXZlbF0gPT09IHZhcnMuZm9jdXMudmFsdWVbMF1cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgZGVwdGggPSBpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoXG4gICAgfSlbMF0pXG5cbiAgICBpZiAoICFidXR0b25EYXRhICkge1xuICAgICAgYnV0dG9uRGF0YSA9IHZhcnMuY29udGFpbmVyLmJ1dHRvbi5kYXRhKClbMF0gfHwgdmFycy5kYXRhLmFwcFswXVxuICAgIH1cblxuICAgIHZhcnMuY29udGFpbmVyLmJ1dHRvblxuICAgICAgLmRhdGEoW2J1dHRvbkRhdGFdKVxuICAgICAgLmlkKCB2YXJzLmlkLm5lc3RpbmcgKVxuICAgICAgLmRlcHRoKGRlcHRoKVxuXG4gIH1cblxuICB2YXJzLmNvbnRhaW5lci5idXR0b25cbiAgICAuZHJhdyh7XG4gICAgICBcInVwZGF0ZVwiOiB2YXJzLmRyYXcudXBkYXRlXG4gICAgfSlcbiAgICAuZm9jdXModmFycy5mb2N1cy52YWx1ZVswXSlcbiAgICAuZm9udCggdmFycy5mb250IClcbiAgICAuaWNvbih7XG4gICAgICBcImJ1dHRvblwiOiB2YXJzLmljb24uZHJvcC52YWx1ZSxcbiAgICAgIFwic2VsZWN0XCI6IHZhcnMuaWNvbi5kcm9wLnZhbHVlLFxuICAgICAgXCJ2YWx1ZVwiOiB2YXJzLmljb24udmFsdWVcbiAgICB9KVxuICAgIC50ZXh0KCB2YXJzLnRleHQudmFsdWUgKVxuICAgIC50aW1pbmcoe1xuICAgICAgXCJ1aVwiOiB2YXJzLmRyYXcudGltaW5nXG4gICAgfSlcbiAgICAudWkoe1xuICAgICAgXCJjb2xvclwiOiB2YXJzLnVpLmNvbG9yLFxuICAgICAgXCJwYWRkaW5nXCI6IHZhcnMudWkucGFkZGluZ1xuICAgIH0pXG4gICAgLndpZHRoKHZhcnMud2lkdGgudmFsdWUpXG4gICAgLmRyYXcoKVxuXG4gIHZhciBidXR0b24gPSB2YXJzLmNvbnRhaW5lci5idXR0b24uY29udGFpbmVyKE9iamVjdCkudWlcblxuICB2YXJzLm1hcmdpbi50b3AgKz0gYnV0dG9uLm5vZGUoKS5vZmZzZXRIZWlnaHQgfHwgYnV0dG9uLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcblxuICBidXR0b24ub24oZDNwbHVzLmV2dC5jbGljayxmdW5jdGlvbigpe1xuICAgIHZhcnMuc2VsZi5vcGVuKCF2YXJzLm9wZW4udmFsdWUpLmRyYXcoKVxuICB9KVxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gQ3JlYXRlcyBhbmQgcG9wdWxhdGVzIHRoZSBkcm9wZG93biBsaXN0IG9mIGl0ZW1zLlxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCB2YXJzICkge1xuXG4gIGlmICggdmFycy5kYXRhLnVybCAmJiAhdmFycy5kYXRhLmxvYWRlZCApIHtcbiAgICB2YXIgbG9hZGluZ09iamVjdCA9IHt9XG4gICAgbG9hZGluZ09iamVjdFt2YXJzLnRleHQudmFsdWUgfHwgdmFycy5pZC52YWx1ZV0gPSB2YXJzLmZvcm1hdC52YWx1ZSh2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUudWkubG9hZGluZylcbiAgICB2YXJzLmRhdGEuZmlsdGVyZWQgPSBbbG9hZGluZ09iamVjdF1cbiAgfVxuICBlbHNlIGlmICh2YXJzLm9wZW4udmFsdWUpIHtcblxuICAgIHZhciBzZWFyY2hUZXh0ICA9IHZhcnMudGV4dC5zb2xvLnZhbHVlLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICA/IHZhcnMudGV4dC5zb2xvLnZhbHVlWzBdLnRvTG93ZXJDYXNlKCkgOiBcIlwiXG4gICAgICAsIHNlYXJjaFdvcmRzID0gZDNwbHVzLnN0cmluZy5zdHJpcChzZWFyY2hUZXh0KS5zcGxpdChcIl9cIilcbiAgICAgICwgc2VhcmNoS2V5cyAgPSBbIHZhcnMuaWQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAsIHZhcnMudGV4dC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICwgdmFycy5hbHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAsIHZhcnMua2V5d29yZHMudmFsdWUgXVxuXG4gICAgc2VhcmNoS2V5cyA9IHNlYXJjaEtleXMuZmlsdGVyKGZ1bmN0aW9uKHQpeyByZXR1cm4gdCB9KVxuICAgIHNlYXJjaFdvcmRzID0gc2VhcmNoV29yZHMuZmlsdGVyKGZ1bmN0aW9uKHQpeyByZXR1cm4gdCAhPSBcIlwiOyB9KVxuXG4gICAgaWYgKCF2YXJzLnRleHQuc29sby52YWx1ZS5sZW5ndGggfHwgdmFycy50ZXh0LnNvbG8udmFsdWVbMF0gPT09IFwiXCIpIHtcbiAgICAgIHZhcnMuZGF0YS5maWx0ZXJlZCA9IHZhcnMuZGF0YS5hcHBcbiAgICAgIGlmICh2YXJzLmlkLm5lc3RpbmcubGVuZ3RoID4gMSAmJiB2YXJzLmRlcHRoLnZhbHVlIDwgdmFycy5pZC5uZXN0aW5nLmxlbmd0aC0xKSB7XG4gICAgICAgIHZhcnMuZGF0YS5maWx0ZXJlZCA9IHZhcnMuZGF0YS5maWx0ZXJlZC5maWx0ZXIoZnVuY3Rpb24oZCl7XG4gICAgICAgICAgaWYgKFwiZW5kUG9pbnRcIiBpbiBkLmQzcGx1cyAmJiBkLmQzcGx1cy5lbmRQb2ludCA9PT0gdmFycy5kZXB0aC52YWx1ZSkge1xuICAgICAgICAgICAgZC5kM3BsdXMuaWNvbiA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICB2YXIgc3RhcnRNYXRjaGVzID0gW11cbiAgICAgICAgLCBleGFjdE1hdGNoZXMgPSBbXVxuICAgICAgICAsIHNvZnRNYXRjaGVzICA9IFtdXG4gICAgICAgICwgc2VhcmNoRGF0YSAgID0gW11cblxuICAgICAgdmFycy5pZC5uZXN0aW5nLmZvckVhY2goZnVuY3Rpb24obil7XG4gICAgICAgIHNlYXJjaERhdGEgPSBzZWFyY2hEYXRhLmNvbmNhdCh2YXJzLmRhdGEubmVzdGVkLmFsbFtuXSlcbiAgICAgIH0pXG5cbiAgICAgIHNlYXJjaERhdGEuZm9yRWFjaChmdW5jdGlvbihkKXtcblxuICAgICAgICB2YXIgbWF0Y2ggPSBmYWxzZVxuXG4gICAgICAgIHNlYXJjaEtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpe1xuXG4gICAgICAgICAgaWYgKCAhbWF0Y2ggJiYga2V5IGluIGQgJiYgdHlwZW9mIGRba2V5XSA9PT0gXCJzdHJpbmdcIiApIHtcblxuICAgICAgICAgICAgdmFyIHRleHQgPSBkW2tleV0udG9Mb3dlckNhc2UoKVxuXG4gICAgICAgICAgICBpZiAoIFt2YXJzLnRleHQudmFsdWUsdmFycy5pZC52YWx1ZV0uaW5kZXhPZihrZXkpID49IDAgJiYgdGV4dC5pbmRleE9mKHNlYXJjaFRleHQpID09IDAgKSB7XG4gICAgICAgICAgICAgIHN0YXJ0TWF0Y2hlcy5wdXNoKGQpXG4gICAgICAgICAgICAgIG1hdGNoID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIHRleHQuaW5kZXhPZihzZWFyY2hUZXh0KSA+PSAwICkge1xuICAgICAgICAgICAgICBleGFjdE1hdGNoZXMucHVzaChkKVxuICAgICAgICAgICAgICBtYXRjaCA9IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgIHZhciB0ZXh0cyA9IGQzcGx1cy5zdHJpbmcuc3RyaXAodGV4dCkuc3BsaXQoXCJfXCIpXG5cbiAgICAgICAgICAgICAgZm9yICh0IGluIHRleHRzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoICFtYXRjaCApIHtcblxuICAgICAgICAgICAgICAgICAgZm9yIChzIGluIHNlYXJjaFdvcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0c1t0XS5pbmRleE9mKHNlYXJjaFdvcmRzW3NdKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHNvZnRNYXRjaGVzLnB1c2goZClcbiAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSlcblxuICAgICAgfSlcblxuICAgICAgdmFycy5kYXRhLmZpbHRlcmVkID0gZDMubWVyZ2UoWyBzdGFydE1hdGNoZXMgLCBleGFjdE1hdGNoZXMgLCBzb2Z0TWF0Y2hlcyBdKVxuXG4gICAgICB2YXJzLmRhdGEuZmlsdGVyZWQuZm9yRWFjaChmdW5jdGlvbihkLGkpe1xuICAgICAgICBkLmQzcGx1c19vcmRlciA9IGlcbiAgICAgIH0pXG5cbiAgICB9XG5cbiAgICBpZiAoIHZhcnMuZGF0YS5maWx0ZXJlZC5sZW5ndGggPT09IDAgKSB7XG5cbiAgICAgIHZhciBub0RhdGEgPSB7fVxuICAgICAgICAsIHN0ciA9IHZhcnMuZm9ybWF0LnZhbHVlKHZhcnMuZm9ybWF0LmxvY2FsZS52YWx1ZS51aS5ub1Jlc3VsdHMpXG4gICAgICBub0RhdGFbdmFycy50ZXh0LnZhbHVlIHx8IHZhcnMuaWQudmFsdWVdID0gZDNwbHVzLnN0cmluZy5mb3JtYXQoc3RyLFwiXFxcIlwiK3NlYXJjaFRleHQrXCJcXFwiXCIpXG4gICAgICB2YXJzLmRhdGEuZmlsdGVyZWQgPSBbIG5vRGF0YSBdXG5cbiAgICB9XG5cbiAgfVxuICBlbHNlIHtcbiAgICB2YXJzLmRhdGEuZmlsdGVyZWQgPSBbXVxuICB9XG5cbn1cbiIsIi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBPdmVycmlkZXMga2V5Ym9hcmQgYmVoYXZpb3Igb2YgdGhlIG9yaWdpbmFsIGlucHV0IGVsZW1lbnQuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoIHZhcnMgKSB7XG5cbiAgaWYgKHZhcnMuZGF0YS5lbGVtZW50LnZhbHVlKSB7XG5cbiAgICB2YXJzLmRhdGEuZWxlbWVudC52YWx1ZS5vbihcImZvY3VzLlwiK3ZhcnMuY29udGFpbmVyLmlkLGZ1bmN0aW9uKCl7XG4gICAgICB2YXJzLnNlbGYuZHJhdyh7XCJ1cGRhdGVcIjpmYWxzZX0pLmRyYXcoKVxuICAgIH0pXG5cbiAgICB2YXJzLmRhdGEuZWxlbWVudC52YWx1ZS5vbihcImJsdXIuXCIrdmFycy5jb250YWluZXIuaWQsZnVuY3Rpb24oKXtcblxuICAgICAgdmFyIHNlYXJjaCA9IHZhcnMuc2VhcmNoLmVuYWJsZWRcbiAgICAgICAgICAgICAgICAgPyBkMy5ldmVudC5yZWxhdGVkVGFyZ2V0ICE9IHZhcnMuY29udGFpbmVyLnZhbHVlLnNlbGVjdChcImlucHV0XCIpLm5vZGUoKVxuICAgICAgICAgICAgICAgICA6IHRydWVcblxuICAgICAgaWYgKHNlYXJjaCkge1xuICAgICAgICB2YXJzLnNlbGYuZHJhdyh7XCJ1cGRhdGVcIjpmYWxzZX0pLmRyYXcoKVxuICAgICAgfVxuXG4gICAgfSlcblxuICAgIHZhcnMuZGF0YS5lbGVtZW50LnZhbHVlLm9uKFwiY2hhbmdlLlwiK3ZhcnMuY29udGFpbmVyLmlkLGZ1bmN0aW9uKCl7XG4gICAgICB2YXJzLnNlbGYuZm9jdXModGhpcy52YWx1ZSkuZHJhdygpXG4gICAgfSlcblxuICAgIHZhcnMuZGF0YS5lbGVtZW50LnZhbHVlLm9uKFwia2V5ZG93bi5jYW5jZWxfXCIrdmFycy5jb250YWluZXIuaWQsZnVuY3Rpb24oKXtcbiAgICAgIHZhciBrZXkgPSBkMy5ldmVudC5rZXlDb2RlXG4gICAgICBpZiAoa2V5ICE9IDkpIHtcbiAgICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgfVxuICAgIH0pXG5cbiAgfVxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gQ2FsY3VsYXRlcyB0aGUgaGVpZ2h0IGFuZCBvcmllbnRhdGlvbiBvZiB0aGUgZHJvcGRvd24gbGlzdCwgYmFzZWQgb25cbi8vIGF2YWlsYWJsZSBzY3JlZW4gc3BhY2UuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoIHZhcnMgKSB7XG5cbiAgdmFyIGJ1dHRvbiA9IHZhcnMuY29udGFpbmVyLmJ1dHRvbi5jb250YWluZXIoKS5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblxuICB2YXJzLmhlaWdodC5zZWNvbmRhcnkgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSBidXR0b24uYm90dG9tIC0gdmFycy51aS5tYXJnaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAtIHZhcnMudWkucGFkZGluZyoyIC0gdmFycy51aS5ib3JkZXIqMlxuXG4gIGlmICggdmFycy5oZWlnaHQuc2Vjb25kYXJ5IDwgYnV0dG9uLmhlaWdodCozICkge1xuICAgIHZhcnMuaGVpZ2h0LnNlY29uZGFyeSA9IGJ1dHRvbi50b3AtMTBcbiAgICB2YXJzLnNlbGYub3Blbih7XCJmbGlwcGVkXCI6IHRydWV9KVxuICB9XG4gIGVsc2Uge1xuICAgIHZhcnMuc2VsZi5vcGVuKHtcImZsaXBwZWRcIjogZmFsc2V9KVxuICB9XG5cbiAgdmFyIHNjcm9sbGluZyA9IGZhbHNlXG4gIGlmICh2YXJzLmhlaWdodC5zZWNvbmRhcnkgPiB2YXJzLmhlaWdodC5tYXgpIHtcbiAgICB2YXJzLmhlaWdodC5zZWNvbmRhcnkgPSB2YXJzLmhlaWdodC5tYXhcbiAgfVxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gUG9wdWxhdGVzIGl0ZW0gbGlzdCBiYXNlZCBvbiBmaWx0ZXJlZCBkYXRhLlxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCB2YXJzICkge1xuXG4gIHZhciBhY3RpdmUgPSByZXF1aXJlKFwiLi9hY3RpdmUuanNcIilcblxuICBpZiAodmFycy5vcGVuLnZhbHVlKSB7XG5cbiAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZShcInVwZGF0aW5nIGxpc3QgaXRlbXNcIilcblxuICAgIGlmICggIShcIml0ZW1zXCIgaW4gdmFycy5jb250YWluZXIpICkge1xuXG4gICAgICB2YXJzLmNvbnRhaW5lci5pdGVtcyA9IGQzcGx1cy5mb3JtKClcbiAgICAgICAgLmNvbnRhaW5lcih2YXJzLmNvbnRhaW5lci5saXN0KVxuICAgICAgICAudHlwZShcImJ1dHRvblwiKVxuICAgICAgICAudWkoe1xuICAgICAgICAgIFwiYm9yZGVyXCI6IDAsXG4gICAgICAgICAgXCJkaXNwbGF5XCI6IFwiYmxvY2tcIixcbiAgICAgICAgICBcIm1hcmdpblwiOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53aWR0aChmYWxzZSlcblxuICAgIH1cblxuICAgIHZhciBsYXJnZSA9IHZhcnMuZHJhdy50aW1pbmcgPyB2YXJzLmRhdGEubGFyZ2UgOiAxXG4gICAgICAsIG9yZGVyID0gZDNwbHVzLnV0aWwuY29weSh2YXJzLm9yZGVyKVxuICAgICAgLCBkZWVwZXN0ID0gdmFycy5kZXB0aC52YWx1ZSA9PT0gdmFycy5pZC5uZXN0aW5nLmxlbmd0aC0xXG5cbiAgICBvcmRlci52YWx1ZSA9IHZhcnMudGV4dC5zb2xvLnZhbHVlLmxlbmd0aCAmJiB2YXJzLnRleHQuc29sby52YWx1ZVswXSAhPT0gXCJcIlxuICAgICAgICAgICAgICAgID8gXCJkM3BsdXNfb3JkZXJcIiA6IHZhcnMub3JkZXIudmFsdWVcblxuICAgIGlmICggdmFycy5mb2N1cy5jaGFuZ2VkIHx8ICF2YXJzLmNvbnRhaW5lci5pdGVtcy5mb2N1cygpLmxlbmd0aCApIHtcblxuICAgICAgdmFycy5jb250YWluZXIuaXRlbXNcbiAgICAgICAgLmZvY3VzKCB2YXJzLmZvY3VzLnZhbHVlWzBdICwgZnVuY3Rpb24odmFsdWUpe1xuXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZVswXVxuXG4gICAgICAgICAgdmFyIGNoYW5nZSA9IHZhbHVlICE9PSB2YXJzLmZvY3VzLnZhbHVlWzBdXG4gICAgICAgICAgaWYgKCBjaGFuZ2UgJiYgdmFycy5hY3RpdmUudmFsdWUgKSB7XG5cbiAgICAgICAgICAgIGNoYW5nZSA9IGFjdGl2ZSh2YXJzLHZhbHVlKVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCBjaGFuZ2UgKSB7XG5cbiAgICAgICAgICAgIHZhcnMuc2VsZi5mb2N1cyggdmFsdWUgKVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRhdGEgPSB2YXJzLmRhdGEuZmlsdGVyZWQuZmlsdGVyKGZ1bmN0aW9uKGYpe1xuICAgICAgICAgICAgcmV0dXJuIGZbdmFycy5pZC52YWx1ZV0gPT09IHZhbHVlXG4gICAgICAgICAgfSlbMF1cblxuICAgICAgICAgIGlmICggdmFycy5kZXB0aC52YWx1ZSA8IHZhcnMuaWQubmVzdGluZy5sZW5ndGggLSAxICYmIHZhcnMuaWQubmVzdGluZ1t2YXJzLmRlcHRoLnZhbHVlKzFdIGluIGRhdGEgKSB7XG5cbiAgICAgICAgICAgIHZhciBkZXB0aCA9IHZhcnMuZGVwdGgudmFsdWVcbiAgICAgICAgICAgICAgLCBzb2xvICA9IHZhcnMuaWQuc29sby52YWx1ZVxuXG4gICAgICAgICAgICB2YXJzLmhpc3Rvcnkuc3RhdGVzLnB1c2goZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgICB2YXJzLnNlbGZcbiAgICAgICAgICAgICAgICAuZGVwdGgoIGRlcHRoIClcbiAgICAgICAgICAgICAgICAuaWQoeyBcInNvbG9cIiA6IHNvbG8gfSlcbiAgICAgICAgICAgICAgICAuZHJhdygpXG5cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHZhcnMuc2VsZlxuICAgICAgICAgICAgICAuZGVwdGgoIHZhcnMuZGVwdGgudmFsdWUgKyAxIClcbiAgICAgICAgICAgICAgLmlkKHsgXCJzb2xvXCIgOiBbdmFsdWVdIH0pXG4gICAgICAgICAgICAgIC5kcmF3KClcblxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICggIXZhcnMuZGVwdGguY2hhbmdlZCApIHtcblxuICAgICAgICAgICAgdmFycy5zZWxmLm9wZW4oZmFsc2UpLmRyYXcoKVxuXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKCBjaGFuZ2UgKSB7XG4gICAgICAgICAgICB2YXJzLnNlbGYuZHJhdygpXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0pXG5cbiAgICB9XG5cbiAgICB2YXJzLmNvbnRhaW5lci5pdGVtc1xuICAgICAgLmFjdGl2ZSggdmFycy5hY3RpdmUudmFsdWUgKVxuICAgICAgLmRhdGEoe1xuICAgICAgICBcImxhcmdlXCI6IGxhcmdlLFxuICAgICAgICBcInZhbHVlXCI6IHZhcnMuZGF0YS5maWx0ZXJlZFxuICAgICAgfSlcbiAgICAgIC5kcmF3KHtcbiAgICAgICAgXCJ1cGRhdGVcIjogdmFycy5kcmF3LnVwZGF0ZVxuICAgICAgfSlcbiAgICAgIC5mb250KCB2YXJzLmZvbnQuc2Vjb25kYXJ5IClcbiAgICAgIC5pZCggdmFycy5pZC52YWx1ZSApXG4gICAgICAuaWNvbih7XG4gICAgICAgIFwiYnV0dG9uXCI6IGRlZXBlc3QgPyBmYWxzZSA6IHZhcnMuaWNvbi5uZXh0LFxuICAgICAgICBcInNlbGVjdFwiOiBkZWVwZXN0ID8gdmFycy5pY29uLnNlbGVjdCA6IGZhbHNlXG4gICAgICB9KVxuICAgICAgLm9yZGVyKCBvcmRlciApXG4gICAgICAudGV4dCggdmFycy50ZXh0LnNlY29uZGFyeS52YWx1ZSB8fCB2YXJzLnRleHQudmFsdWUgKVxuICAgICAgLnRpbWluZyh7XG4gICAgICAgIFwidWlcIjogdmFycy5kcmF3LnRpbWluZ1xuICAgICAgfSlcbiAgICAgIC51aSh7XG4gICAgICAgIFwiY29sb3JcIjoge1xuICAgICAgICAgIFwicHJpbWFyeVwiOiB2YXJzLmlkLm5lc3RpbmcubGVuZ3RoID09PSAxID8gdmFycy51aS5jb2xvci5wcmltYXJ5LnZhbHVlIDogdmFycy51aS5jb2xvci5zZWNvbmRhcnkudmFsdWUsXG4gICAgICAgICAgXCJzZWNvbmRhcnlcIjogdmFycy51aS5jb2xvci5zZWNvbmRhcnkudmFsdWVcbiAgICAgICAgfSxcbiAgICAgICAgXCJwYWRkaW5nXCI6IHZhcnMudWkucGFkZGluZ1xuICAgICAgfSlcbiAgICAgIC5kcmF3KClcblxuICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lRW5kKFwidXBkYXRpbmcgbGlzdCBpdGVtc1wiKVxuXG4gIH1cblxufVxuIiwiLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIEFzc2lnbnMgYmVoYXZpb3IgdG8gdGhlIHVzZXIncyBrZXlib2FyZCBmb3IgbmF2aWdhdGlvbi5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICggdmFycyApIHtcblxuICBkMy5zZWxlY3QoZG9jdW1lbnQpLm9uKFwia2V5ZG93bi5cIit2YXJzLmNvbnRhaW5lci5pZCxmdW5jdGlvbigpe1xuXG4gICAgaWYgKHZhcnMub3Blbi52YWx1ZSB8fCB2YXJzLmhvdmVyID09PSB0cnVlKSB7XG5cbiAgICAgIHZhciBrZXkgPSBkMy5ldmVudC5rZXlDb2RlLFxuICAgICAgICAgIG9wdGlvbnMgPSB2YXJzLmNvbnRhaW5lci5saXN0LnNlbGVjdChcImRpdlwiKS5zZWxlY3RBbGwoXCJkaXYuZDNwbHVzX25vZGVcIiksXG4gICAgICAgICAgaW5kZXggPSAwXG5cbiAgICAgIGlmICh0eXBlb2YgdmFycy5ob3ZlciA9PSBcImJvb2xlYW5cIikge1xuICAgICAgICBvcHRpb25zLmVhY2goZnVuY3Rpb24oZCxpKXtcbiAgICAgICAgICBpZiAoZC52YWx1ZSA9PSB2YXJzLmZvY3VzKSB7XG4gICAgICAgICAgICBpbmRleCA9IGlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5lYWNoKGZ1bmN0aW9uKGQsaSl7XG4gICAgICAgICAgaWYgKGQudmFsdWUgPT0gdmFycy5ob3Zlcikge1xuICAgICAgICAgICAgaW5kZXggPSBpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyBUYWJcbiAgICAgIGlmIChbOV0uaW5kZXhPZihrZXkpID49IDAgJiYgKCF2YXJzLnNlYXJjaC5lbmFibGVkIHx8ICh2YXJzLnNlYXJjaC5lbmFibGVkICYmICFkMy5ldmVudC5zaGlmdEtleSkpKSB7XG4gICAgICAgIHZhcnMuc2VsZi5kcmF3KHtcInVwZGF0ZVwiOmZhbHNlfSkuZGlzYWJsZSgpXG4gICAgICB9XG4gICAgICAvLyBEb3duIEFycm93XG4gICAgICBlbHNlIGlmIChbNDBdLmluZGV4T2Yoa2V5KSA+PSAwKSB7XG4gICAgICAgIGlmICh2YXJzLm9wZW4udmFsdWUpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gb3B0aW9ucy5zaXplKCktMSkge1xuICAgICAgICAgICAgaW5kZXggPSAwXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5kZXggKz0gMVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFycy5ob3ZlciAhPSBcImJvb2xlYW5cIikge1xuICAgICAgICAgIHZhciBob3ZlciA9IG9wdGlvbnMuZGF0YSgpW2luZGV4XS52YWx1ZVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBob3ZlciA9IHZhcnMuZm9jdXNcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YXJzLm9wZW4udmFsdWUpIHtcbiAgICAgICAgICB2YXJzLnNlbGYuZHJhdyh7XCJ1cGRhdGVcIjpmYWxzZX0pLmhvdmVyKGhvdmVyKS5kcmF3KDYwKVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhcnMuc2VsZi5kcmF3KHtcInVwZGF0ZVwiOmZhbHNlfSkuaG92ZXIoaG92ZXIpLmVuYWJsZSgpXG4gICAgICAgIH1cblxuICAgICAgfVxuICAgICAgLy8gVXAgQXJyb3dcbiAgICAgIGVsc2UgaWYgKFszOF0uaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgaWYgKHZhcnMub3Blbi52YWx1ZSkge1xuICAgICAgICAgIGlmIChpbmRleCA8PSAwKSB7XG4gICAgICAgICAgICBpbmRleCA9IG9wdGlvbnMuc2l6ZSgpLTFcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbmRleCAtPSAxXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YXJzLmhvdmVyICE9IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgdmFyIGhvdmVyID0gb3B0aW9ucy5kYXRhKClbaW5kZXhdLnZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGhvdmVyID0gdmFycy5mb2N1c1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhcnMub3Blbi52YWx1ZSkge1xuICAgICAgICAgIHZhcnMuc2VsZi5kcmF3KHtcInVwZGF0ZVwiOmZhbHNlfSkuaG92ZXIoaG92ZXIpLmRyYXcoNjApXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFycy5zZWxmLmRyYXcoe1widXBkYXRlXCI6ZmFsc2V9KS5ob3Zlcihob3ZlcikuZW5hYmxlKClcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgICAvLyBFbnRlci9SZXR1cm5cbiAgICAgIGVsc2UgaWYgKFsxM10uaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YXJzLmhvdmVyICE9IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgdmFycy5zZWxmLnZhbHVlKHZhcnMuaG92ZXIpLmRyYXcoKVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhcnMuc2VsZi5ob3Zlcih2YXJzLmZvY3VzKS50b2dnbGUoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBFc2NcbiAgICAgIGVsc2UgaWYgKFsyN10uaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgaWYgKHZhcnMub3Blbi52YWx1ZSkge1xuICAgICAgICAgIHZhcnMuc2VsZi5kaXNhYmxlKClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YXJzLmhvdmVyID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFycy5zZWxmLmhvdmVyKGZhbHNlKS5kcmF3KClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuXG4gIH0pXG5cbn1cbiIsIi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBDcmVhdGVzIGFuZCBwb3B1bGF0ZXMgdGhlIGRyb3Bkb3duIGxpc3Qgb2YgaXRlbXMuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoIHZhcnMgKSB7XG5cbiAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWUoXCJwb3B1bGF0aW5nIGxpc3RcIilcblxuICB2YXJzLmNvbnRhaW5lci5saXN0ID0gdmFycy5jb250YWluZXIuc2VsZWN0b3Iuc2VsZWN0QWxsKFwiZGl2LmQzcGx1c19kcm9wX2xpc3RcIilcbiAgICAuZGF0YShbXCJsaXN0XCJdKVxuXG4gIHZhcnMuY29udGFpbmVyLmxpc3QuZW50ZXIoKS5hcHBlbmQoXCJkaXZcIilcbiAgICAuYXR0cihcImNsYXNzXCIsXCJkM3BsdXNfZHJvcF9saXN0XCIpXG4gICAgLmF0dHIoXCJpZFwiLFwiZDNwbHVzX2Ryb3BfbGlzdF9cIit2YXJzLmNvbnRhaW5lci5pZClcbiAgICAuc3R5bGUoXCJvdmVyZmxvdy15XCIsXCJhdXRvXCIpXG4gICAgLnN0eWxlKFwib3ZlcmZsb3cteFwiLFwiaGlkZGVuXCIpXG5cbiAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWVFbmQoXCJwb3B1bGF0aW5nIGxpc3RcIilcblxufVxuIiwiLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIENhbGN1bGF0ZXMgc2Nyb2xsIHBvc2l0aW9uIG9mIGxpc3QuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoIHZhcnMgKSB7XG5cbiAgaWYgKHZhcnMub3Blbi52YWx1ZSkge1xuXG4gICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWUoXCJjYWxjdWxhdGluZyBoZWlnaHRcIilcblxuICAgIHZhciBoaWRkZW4gPSBmYWxzZVxuICAgIGlmICh2YXJzLmNvbnRhaW5lci5zZWxlY3Rvci5zdHlsZShcImRpc3BsYXlcIikgPT0gXCJub25lXCIpIHtcbiAgICAgIHZhciBoaWRkZW4gPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKGhpZGRlbikgdmFycy5jb250YWluZXIuc2VsZWN0b3Iuc3R5bGUoXCJkaXNwbGF5XCIsXCJibG9ja1wiKVxuXG4gICAgdmFyIHNlYXJjaEhlaWdodCA9IHZhcnMuc2VhcmNoLmVuYWJsZWQgPyB2YXJzLmNvbnRhaW5lci5zZWFyY2gubm9kZSgpLm9mZnNldEhlaWdodCB8fCB2YXJzLmNvbnRhaW5lci5zZWFyY2gubm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCA6IDBcblxuICAgIHZhciBvbGRfaGVpZ2h0ID0gdmFycy5jb250YWluZXIuc2VsZWN0b3Iuc3R5bGUoXCJoZWlnaHRcIiksXG4gICAgICAgIG9sZF9zY3JvbGwgPSB2YXJzLmNvbnRhaW5lci5zZWxlY3Rvci5wcm9wZXJ0eShcInNjcm9sbFRvcFwiKSxcbiAgICAgICAgbGlzdF9oZWlnaHQgPSB2YXJzLmNvbnRhaW5lci5saXN0LnN0eWxlKFwibWF4LWhlaWdodFwiKSxcbiAgICAgICAgbGlzdF9zY3JvbGwgPSB2YXJzLmNvbnRhaW5lci5saXN0LnByb3BlcnR5KFwic2Nyb2xsVG9wXCIpXG5cbiAgICB2YXJzLmNvbnRhaW5lci5zZWxlY3Rvci5zdHlsZShcImhlaWdodFwiLFwiYXV0b1wiKVxuICAgIHZhcnMuY29udGFpbmVyLmxpc3Quc3R5bGUoXCJtYXgtaGVpZ2h0XCIsXCIyMDAwMDBweFwiKVxuXG4gICAgdmFycy5jb250YWluZXIubGlzdEhlaWdodCA9IHBhcnNlRmxvYXQodmFycy5jb250YWluZXIuc2VsZWN0b3Iuc3R5bGUoXCJoZWlnaHRcIiksMTApXG5cbiAgICB2YXJzLmNvbnRhaW5lci5saXN0XG4gICAgICAuc3R5bGUoXCJtYXgtaGVpZ2h0XCIsbGlzdF9oZWlnaHQpXG4gICAgICAucHJvcGVydHkoXCJzY3JvbGxUb3BcIixsaXN0X3Njcm9sbClcblxuICAgIHZhcnMuY29udGFpbmVyLnNlbGVjdG9yXG4gICAgICAuc3R5bGUoXCJoZWlnaHRcIixvbGRfaGVpZ2h0KVxuICAgICAgLnByb3BlcnR5KFwic2Nyb2xsVG9wXCIsb2xkX3Njcm9sbClcblxuICAgIHZhciBzY3JvbGxpbmcgPSBmYWxzZVxuICAgIGlmICh2YXJzLmNvbnRhaW5lci5saXN0SGVpZ2h0ID4gdmFycy5oZWlnaHQuc2Vjb25kYXJ5KSB7XG4gICAgICB2YXJzLmNvbnRhaW5lci5saXN0SGVpZ2h0ID0gdmFycy5oZWlnaHQuc2Vjb25kYXJ5XG4gICAgICBzY3JvbGxpbmcgPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKGhpZGRlbikgdmFycy5jb250YWluZXIuc2VsZWN0b3Iuc3R5bGUoXCJkaXNwbGF5XCIsXCJub25lXCIpXG5cbiAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZUVuZChcImNhbGN1bGF0aW5nIGhlaWdodFwiKVxuXG4gICAgaWYgKHNjcm9sbGluZykge1xuXG4gICAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZShcImNhbGN1bGF0aW5nIHNjcm9sbCBwb3NpdGlvblwiKVxuXG4gICAgICB2YXIgb3B0aW9ucyA9IHZhcnMuY29udGFpbmVyLmxpc3Quc2VsZWN0KFwiZGl2XCIpLnNlbGVjdEFsbChcImRpdi5kM3BsdXNfbm9kZVwiKVxuICAgICAgdmFyIG9wdGlvbiA9IG9wdGlvbnNbMF1bMF1cbiAgICAgIG9wdGlvbnMuZWFjaChmdW5jdGlvbihkLGkpe1xuICAgICAgICBpZiAoZFt2YXJzLmlkLnZhbHVlXSA9PSB2YXJzLmZvY3VzLnZhbHVlWzBdKSB7XG4gICAgICAgICAgb3B0aW9uID0gdGhpc1xuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICB2YXIgaGlkZGVuID0gZmFsc2VcbiAgICAgIGlmICh2YXJzLmNvbnRhaW5lci5zZWxlY3Rvci5zdHlsZShcImRpc3BsYXlcIikgPT09IFwibm9uZVwiKSB7XG4gICAgICAgIGhpZGRlbiA9IHRydWVcbiAgICAgICAgdmFycy5jb250YWluZXIuc2VsZWN0b3Iuc3R5bGUoXCJkaXNwbGF5XCIsXCJibG9ja1wiKVxuICAgICAgfVxuXG4gICAgICB2YXIgYnV0dG9uX3RvcCA9IG9wdGlvbi5vZmZzZXRUb3AsXG4gICAgICAgICAgYnV0dG9uX2hlaWdodCA9IG9wdGlvbi5vZmZzZXRIZWlnaHQgfHwgb3B0aW9uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCxcbiAgICAgICAgICBsaXN0X3RvcCA9IHZhcnMuY29udGFpbmVyLmxpc3QucHJvcGVydHkoXCJzY3JvbGxUb3BcIilcblxuICAgICAgaWYgKGhpZGRlbikgdmFycy5jb250YWluZXIuc2VsZWN0b3Iuc3R5bGUoXCJkaXNwbGF5XCIsXCJub25lXCIpXG5cbiAgICAgIGlmICggaGlkZGVuIHx8IHZhcnMuZGF0YS5jaGFuZ2VkIHx8IHZhcnMuZGVwdGguY2hhbmdlZCApIHtcblxuICAgICAgICB2YXJzLmNvbnRhaW5lci5saXN0U2Nyb2xsID0gYnV0dG9uX3RvcFxuXG4gICAgICB9XG4gICAgICBlbHNlIHtcblxuICAgICAgICB2YXJzLmNvbnRhaW5lci5saXN0U2Nyb2xsID0gbGlzdF90b3BcblxuICAgICAgICBpZiAoYnV0dG9uX3RvcCA8IGxpc3RfdG9wKSB7XG4gICAgICAgICAgdmFycy5jb250YWluZXIubGlzdFNjcm9sbCA9IGJ1dHRvbl90b3BcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChidXR0b25fdG9wK2J1dHRvbl9oZWlnaHQgPiBsaXN0X3RvcCt2YXJzLmhlaWdodC5zZWNvbmRhcnktc2VhcmNoSGVpZ2h0KSB7XG4gICAgICAgICAgdmFycy5jb250YWluZXIubGlzdFNjcm9sbCA9IGJ1dHRvbl90b3AgLSAodmFycy5oZWlnaHQuc2Vjb25kYXJ5LWJ1dHRvbl9oZWlnaHQtc2VhcmNoSGVpZ2h0KVxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWVFbmQoXCJjYWxjdWxhdGluZyBzY3JvbGwgcG9zaXRpb25cIilcblxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhcnMuY29udGFpbmVyLmxpc3RTY3JvbGwgPSAwXG4gICAgfVxuXG4gIH1cbiAgZWxzZSB7XG4gICAgdmFycy5jb250YWluZXIubGlzdFNjcm9sbCA9IHZhcnMuY29udGFpbmVyLmxpc3QucHJvcGVydHkoXCJzY3JvbGxUb3BcIilcbiAgICB2YXJzLmNvbnRhaW5lci5saXN0SGVpZ2h0ID0gMFxuICB9XG5cbn1cbiIsIi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBDcmVhdGVzIGFuZCBzdHlsZXMgdGhlIHNlYXJjaCBib3gsIGlmIGVuYWJsZWQuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoIHZhcnMgKSB7XG5cbiAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWUoXCJjcmVhdGluZyBzZWFyY2hcIilcblxuICB2YXIgZGF0YSA9IHJlcXVpcmUoXCIuL2RhdGEuanNcIilcbiAgICAsIGl0ZW1zID0gcmVxdWlyZShcIi4vaXRlbXMuanNcIilcbiAgICAsIHVwZGF0ZSA9IHJlcXVpcmUoXCIuL3VwZGF0ZS5qc1wiKVxuXG4gIHZhcnMuY29udGFpbmVyLnNlYXJjaCA9IHZhcnMuY29udGFpbmVyLnNlbGVjdG9yLnNlbGVjdEFsbChcImRpdi5kM3BsdXNfZHJvcF9zZWFyY2hcIilcbiAgICAuZGF0YSh2YXJzLnNlYXJjaC5lbmFibGVkID8gW1wic2VhcmNoXCJdIDogW10pXG5cbiAgZnVuY3Rpb24gc2VhcmNoU3R5bGUoZWxlbSkge1xuXG4gICAgZWxlbVxuICAgICAgLnN0eWxlKFwicGFkZGluZ1wiLHZhcnMudWkucGFkZGluZytcInB4XCIpXG4gICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsXCJibG9ja1wiKVxuICAgICAgLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLHZhcnMudWkuY29sb3Iuc2Vjb25kYXJ5LnZhbHVlKVxuXG4gIH1cblxuICBmdW5jdGlvbiBpbnB1dFN0eWxlKGVsZW0pIHtcblxuICAgIHZhciB3aWR0aCA9IHZhcnMud2lkdGguc2Vjb25kYXJ5IC0gdmFycy51aS5wYWRkaW5nKjQgLSB2YXJzLnVpLmJvcmRlcioyXG5cbiAgICBlbGVtXG4gICAgICAuc3R5bGUoXCJwYWRkaW5nXCIsdmFycy51aS5wYWRkaW5nK1wicHhcIilcbiAgICAgIC5zdHlsZShcIndpZHRoXCIsd2lkdGgrXCJweFwiKVxuICAgICAgLnN0eWxlKFwiYm9yZGVyLXN0eWxlXCIsXCJzb2xpZFwiKVxuICAgICAgLnN0eWxlKFwiYm9yZGVyLXdpZHRoXCIsXCIwcHhcIilcbiAgICAgIC5zdHlsZShcImZvbnQtZmFtaWx5XCIsdmFycy5mb250LnNlY29uZGFyeS5mYW1pbHkudmFsdWUpXG4gICAgICAuc3R5bGUoXCJmb250LXNpemVcIix2YXJzLmZvbnQuc2Vjb25kYXJ5LnNpemUrXCJweFwiKVxuICAgICAgLnN0eWxlKFwiZm9udC13ZWlnaHRcIix2YXJzLmZvbnQuc2Vjb25kYXJ5LndlaWdodClcbiAgICAgIC5zdHlsZShcInRleHQtYWxpZ25cIix2YXJzLmZvbnQuc2Vjb25kYXJ5LmFsaWduKVxuICAgICAgLnN0eWxlKFwib3V0bGluZVwiLFwibm9uZVwiKVxuICAgICAgLnN0eWxlKGQzcGx1cy5wcmVmaXgoKStcImJvcmRlci1yYWRpdXNcIixcIjBcIilcbiAgICAgIC5hdHRyKFwicGxhY2Vob2xkZXJcIix2YXJzLmZvcm1hdC52YWx1ZSh2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUubWV0aG9kLnNlYXJjaCkpXG5cbiAgfVxuXG4gIGlmICh2YXJzLmRyYXcudGltaW5nKSB7XG5cbiAgICB2YXJzLmNvbnRhaW5lci5zZWFyY2gudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAuY2FsbChzZWFyY2hTdHlsZSlcblxuICAgIHZhcnMuY29udGFpbmVyLnNlYXJjaC5zZWxlY3QoXCJpbnB1dFwiKS50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgIC5jYWxsKGlucHV0U3R5bGUpXG5cbiAgfVxuICBlbHNlIHtcblxuICAgIHZhcnMuY29udGFpbmVyLnNlYXJjaFxuICAgICAgLmNhbGwoc2VhcmNoU3R5bGUpXG5cbiAgICB2YXJzLmNvbnRhaW5lci5zZWFyY2guc2VsZWN0KFwiaW5wdXRcIilcbiAgICAgIC5jYWxsKGlucHV0U3R5bGUpXG5cbiAgfVxuXG4gIHZhcnMuY29udGFpbmVyLnNlYXJjaC5lbnRlcigpXG4gICAgLmluc2VydChcImRpdlwiLFwiI2QzcGx1c19kcm9wX2xpc3RfXCIrdmFycy5jb250YWluZXIuaWQpXG4gICAgICAuYXR0cihcImNsYXNzXCIsXCJkM3BsdXNfZHJvcF9zZWFyY2hcIilcbiAgICAgIC5hdHRyKFwiaWRcIixcImQzcGx1c19kcm9wX3NlYXJjaF9cIit2YXJzLmNvbnRhaW5lci5pZClcbiAgICAgIC5jYWxsKHNlYXJjaFN0eWxlKVxuICAgICAgLmFwcGVuZChcImlucHV0XCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIixcImQzcGx1c19kcm9wX2lucHV0X1wiK3ZhcnMuY29udGFpbmVyLmlkKVxuICAgICAgICAuc3R5bGUoXCItd2Via2l0LWFwcGVhcmFuY2VcIixcIm5vbmVcIilcbiAgICAgICAgLmNhbGwoaW5wdXRTdHlsZSlcblxuICB2YXJzLmNvbnRhaW5lci5zZWFyY2guc2VsZWN0KFwiaW5wdXRcIikub24oXCJrZXl1cC5cIit2YXJzLmNvbnRhaW5lci5pZCxmdW5jdGlvbihkKXtcbiAgICBpZiAodmFycy50ZXh0LnNvbG9bMF0gIT09IHRoaXMudmFsdWUpIHtcbiAgICAgIHZhcnMuc2VsZi50ZXh0KHtcInNvbG9cIjpbdGhpcy52YWx1ZV19KVxuICAgICAgZGF0YSggdmFycyApXG4gICAgICBpdGVtcyggdmFycyApXG4gICAgICB1cGRhdGUoIHZhcnMgKVxuICAgIH1cbiAgfSlcblxuICB2YXJzLmNvbnRhaW5lci5zZWFyY2guZXhpdCgpLnJlbW92ZSgpXG5cbiAgaWYgKCB2YXJzLnNlYXJjaC5lbmFibGVkICkge1xuICAgIHZhcnMubWFyZ2luLnRpdGxlICs9IHZhcnMuY29udGFpbmVyLnNlYXJjaC5ub2RlKCkub2Zmc2V0SGVpZ2h0IHx8IHZhcnMuY29udGFpbmVyLnNlYXJjaC5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gIH1cblxuICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZUVuZChcImNyZWF0aW5nIHNlYXJjaFwiKVxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gQ3JlYXRlcyBhbmQgc3R5bGVzIHRoZSBkaXYgdGhhdCBob2xkcyB0aGUgc2VhcmNoIGJveCBhbmQgaXRlbSBsaXN0LlxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCB2YXJzICkge1xuXG4gIHZhcnMuY29udGFpbmVyLnNlbGVjdG9yID0gdmFycy5jb250YWluZXIudWlcbiAgICAuc2VsZWN0QWxsKFwiZGl2LmQzcGx1c19kcm9wX3NlbGVjdG9yXCIpXG4gICAgLmRhdGEoW1wic2VsZWN0b3JcIl0pXG5cbiAgdmFycy5jb250YWluZXIuc2VsZWN0b3IuZW50ZXIoKS5hcHBlbmQoXCJkaXZcIilcbiAgICAuYXR0cihcImNsYXNzXCIsXCJkM3BsdXNfZHJvcF9zZWxlY3RvclwiKVxuICAgIC5zdHlsZShcInBvc2l0aW9uXCIsXCJhYnNvbHV0ZVwiKVxuICAgIC5zdHlsZShcInRvcFwiLFwiMHB4XCIpXG4gICAgLnN0eWxlKFwiei1pbmRleFwiLFwiLTFcIilcbiAgICAuc3R5bGUoXCJvdmVyZmxvd1wiLFwiaGlkZGVuXCIpXG5cbiAgICB2YXJzLmNvbnRhaW5lci5zZWxlY3RvclxuICAgICAgLnN0eWxlKFwicGFkZGluZ1wiLHZhcnMudWkuYm9yZGVyK1wicHhcIilcblxufVxuIiwiLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIENyZWF0ZXMgYW5kIHN0eWxlcyB0aGUgdGl0bGUgYW5kIGJhY2sgYnV0dG9uLlxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCB2YXJzICkge1xuXG4gIGlmICggdmFycy5vcGVuLnZhbHVlICkge1xuXG4gICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWUoXCJjcmVhdGluZyB0aXRsZSBhbmQgYmFjayBidXR0b25cIilcblxuICAgIHZhciBzZWxmICAgID0gdGhpc1xuICAgICAgLCBlbmFibGVkID0gdmFycy5pZC5zb2xvLnZhbHVlLmxlbmd0aCA9PT0gMSAmJiB2YXJzLmRlcHRoLnZhbHVlID4gMFxuICAgICAgLCB0aXRsZSAgID0gZW5hYmxlZFxuICAgICAgLCBmb2N1cyAgID0gdmFycy5jb250YWluZXIuYnV0dG9uLmRhdGEoT2JqZWN0KS5hcHBbMF1cblxuICAgIHRpdGxlID0gdHJ1ZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFycy5pZC5uZXN0aW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGV2ZWwgPSB2YXJzLmlkLm5lc3RpbmdbaV1cbiAgICAgIGlmICggbGV2ZWwgaW4gZm9jdXMgJiYgZm9jdXNbbGV2ZWxdID09PSB2YXJzLmZvY3VzLnZhbHVlWzBdICkge1xuICAgICAgICB0aXRsZSA9IGZhbHNlXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhcnMuY29udGFpbmVyLnRpdGxlID0gdmFycy5jb250YWluZXIuc2VsZWN0b3Iuc2VsZWN0QWxsKFwiZGl2LmQzcGx1c19kcm9wX3RpdGxlXCIpXG4gICAgICAuZGF0YShlbmFibGVkID8gW1widGl0bGVcIl0gOiBbXSlcblxuICAgIGZ1bmN0aW9uIGJveFN0eWxlKGVsZW0pIHtcblxuICAgICAgZWxlbVxuICAgICAgICAuc3R5bGUoXCJwYWRkaW5nXCIsdmFycy51aS5wYWRkaW5nK1wicHhcIilcbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLFwiYmxvY2tcIilcbiAgICAgICAgLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLHZhcnMudWkuY29sb3Iuc2Vjb25kYXJ5LnZhbHVlKVxuICAgICAgICAuc3R5bGUoXCJmb250LWZhbWlseVwiLHZhcnMuZm9udC5zZWNvbmRhcnkuZmFtaWx5LnZhbHVlKVxuICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIix2YXJzLmZvbnQuc2Vjb25kYXJ5LnNpemUrXCJweFwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXdlaWdodFwiLHZhcnMuZm9udC5zZWNvbmRhcnkud2VpZ2h0KVxuICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFsaWduXCIsdmFycy5mb250LnNlY29uZGFyeS5hbGlnbilcbiAgICAgICAgLnN0eWxlKFwiY29sb3JcIixkM3BsdXMuY29sb3IudGV4dCh2YXJzLnVpLmNvbG9yLnNlY29uZGFyeS52YWx1ZSkpXG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiYWNrU3R5bGUoZWxlbSkge1xuXG4gICAgICBpZiAoICFlbGVtLmVtcHR5KCkgKSB7XG5cbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHZhcnMuaWNvbi5iYWNrLnZhbHVlLmluZGV4T2YoXCJmYS1cIikgPT09IDAgPyBcIiBmYSBcIit2YXJzLmljb24uYmFjay52YWx1ZSA6IFwiXCJcbiAgICAgICAgY2xhc3NOYW1lID0gXCJkM3BsdXNfZHJvcF9iYWNrXCIgKyBjbGFzc05hbWVcblxuICAgICAgICB2YXIgdGV4dCA9IHZhcnMuaWNvbi5iYWNrLnZhbHVlLmluZGV4T2YoXCJmYS1cIikgPT09IDAgPyBcIlwiIDogdmFycy5pY29uLmJhY2sudmFsdWVcblxuICAgICAgICBlbGVtXG4gICAgICAgICAgLnN0eWxlKFwicG9zaXRpb25cIixcImFic29sdXRlXCIpXG4gICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLGNsYXNzTmFtZSlcbiAgICAgICAgICAuc3R5bGUoXCJ0b3BcIix2YXJzLnVpLnBhZGRpbmcrKHZhcnMuZm9udC5zZWNvbmRhcnkuc2l6ZS8yKS8yLjUrXCJweFwiKVxuICAgICAgICAgIC5odG1sKHRleHQpXG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRpdGxlU3R5bGUoZWxlbSkge1xuXG4gICAgICB2YXIgdGV4dCA9IHRpdGxlID8gdmFycy5mb2N1cy52YWx1ZS5sZW5ndGggOiB2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUudWkuYmFja1xuXG4gICAgICBlbGVtXG4gICAgICAgIC50ZXh0KHZhcnMuZm9ybWF0LnZhbHVlKHRleHQpKVxuICAgICAgICAuc3R5bGUoXCJwYWRkaW5nXCIsXCIwcHggXCIrdmFycy51aS5wYWRkaW5nKjIrXCJweFwiKVxuXG4gICAgfVxuXG4gICAgaWYgKHZhcnMuZHJhdy50aW1pbmcpIHtcblxuICAgICAgdmFycy5jb250YWluZXIudGl0bGUudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAgIC5jYWxsKGJveFN0eWxlKVxuXG4gICAgICB2YXJzLmNvbnRhaW5lci50aXRsZS5zZWxlY3QoXCJkaXYuZDNwbHVzX2Ryb3BfdGl0bGVfdGV4dFwiKVxuICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAgIC5jYWxsKHRpdGxlU3R5bGUpXG5cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgIHZhcnMuY29udGFpbmVyLnRpdGxlXG4gICAgICAgIC5jYWxsKGJveFN0eWxlKVxuXG4gICAgICB2YXJzLmNvbnRhaW5lci50aXRsZS5zZWxlY3QoXCJkaXYuZDNwbHVzX2Ryb3BfdGl0bGVfdGV4dFwiKVxuICAgICAgICAuY2FsbCh0aXRsZVN0eWxlKVxuXG4gICAgfVxuXG4gICAgdmFycy5jb250YWluZXIudGl0bGUuc2VsZWN0KFwic3Bhbi5kM3BsdXNfZHJvcF9iYWNrXCIpXG4gICAgICAuY2FsbChiYWNrU3R5bGUpXG5cbiAgICB2YXIgZW50ZXIgPSB2YXJzLmNvbnRhaW5lci50aXRsZS5lbnRlcigpXG4gICAgICAuaW5zZXJ0KFwiZGl2XCIsXCIjZDNwbHVzX2Ryb3BfbGlzdF9cIit2YXJzLmNvbnRhaW5lci5pZClcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLFwiZDNwbHVzX2Ryb3BfdGl0bGVcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLFwiZDNwbHVzX2Ryb3BfdGl0bGVfXCIrdmFycy5jb250YWluZXIuaWQpXG4gICAgICAgIC5jYWxsKGJveFN0eWxlKVxuXG4gICAgZW50ZXIuYXBwZW5kKFwic3BhblwiKVxuICAgICAgLmF0dHIoXCJpZFwiLFwiZDNwbHVzX2Ryb3BfYmFja19cIit2YXJzLmNvbnRhaW5lci5pZClcbiAgICAgIC5hdHRyKFwiY2xhc3NcIixcImQzcGx1c19kcm9wX2JhY2tcIilcbiAgICAgIC5jYWxsKGJhY2tTdHlsZSlcblxuICAgIGVudGVyLmFwcGVuZChcImRpdlwiKVxuICAgICAgLmF0dHIoXCJpZFwiLFwiZDNwbHVzX2Ryb3BfdGl0bGVfdGV4dF9cIit2YXJzLmNvbnRhaW5lci5pZClcbiAgICAgIC5hdHRyKFwiY2xhc3NcIixcImQzcGx1c19kcm9wX3RpdGxlX3RleHRcIilcbiAgICAgIC5jYWxsKHRpdGxlU3R5bGUpXG5cbiAgICB2YXJzLmNvbnRhaW5lci50aXRsZVxuICAgICAgLm9uKGQzcGx1cy5ldnQub3ZlcixmdW5jdGlvbihkLGkpe1xuXG4gICAgICAgIHZhciBjb2xvciA9IGQzcGx1cy5jb2xvci5saWdodGVyKHZhcnMudWkuY29sb3Iuc2Vjb25kYXJ5LnZhbHVlKVxuXG4gICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImN1cnNvclwiLFwicG9pbnRlclwiKVxuICAgICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy50aW1pbmcubW91c2VldmVudHMpXG4gICAgICAgICAgLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLGNvbG9yKVxuICAgICAgICAgIC5zdHlsZShcImNvbG9yXCIsZDNwbHVzLmNvbG9yLnRleHQoY29sb3IpKVxuXG4gICAgICB9KVxuICAgICAgLm9uKGQzcGx1cy5ldnQub3V0LGZ1bmN0aW9uKGQpe1xuXG4gICAgICAgIHZhciBjb2xvciA9IHZhcnMudWkuY29sb3Iuc2Vjb25kYXJ5LnZhbHVlXG5cbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiY3Vyc29yXCIsXCJhdXRvXCIpXG4gICAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLnRpbWluZy5tb3VzZWV2ZW50cylcbiAgICAgICAgICAuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsY29sb3IpXG4gICAgICAgICAgLnN0eWxlKFwiY29sb3JcIixkM3BsdXMuY29sb3IudGV4dChjb2xvcikpXG5cbiAgICAgIH0pXG4gICAgICAub24oZDNwbHVzLmV2dC5jbGljayxmdW5jdGlvbihkKXtcbiAgICAgICAgdmFycy5oaXN0b3J5LmJhY2soKVxuICAgICAgfSlcblxuICAgIHZhcnMuY29udGFpbmVyLnRpdGxlLmV4aXQoKS5yZW1vdmUoKVxuXG4gICAgaWYgKCBlbmFibGVkICkge1xuICAgICAgdmFycy5tYXJnaW4udGl0bGUgKz0gdmFycy5jb250YWluZXIudGl0bGUubm9kZSgpLm9mZnNldEhlaWdodCB8fCB2YXJzLmNvbnRhaW5lci50aXRsZS5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gICAgfVxuXG4gICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWVFbmQoXCJjcmVhdGluZyB0aXRsZSBhbmQgYmFjayBidXR0b25cIilcblxuICB9XG5cbn1cbiIsIi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBSZWRyYXdzIG9ubHkgdGhlIGRyb3AgZG93biBsaXN0LlxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCB2YXJzICkge1xuXG4gIHZhciBpdGVtcyA9IHJlcXVpcmUoXCIuL2l0ZW1zLmpzXCIpXG4gICAgLCBoZWlnaHQgPSByZXF1aXJlKFwiLi9oZWlnaHQuanNcIilcbiAgICAsIHNjcm9sbGxpc3QgPSByZXF1aXJlKFwiLi9zY3JvbGwuanNcIilcbiAgICAsIGFycm93ID0gcmVxdWlyZShcIi4vYXJyb3cuanNcIilcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gSWYgdGhlIG1lbnUgaXMgb3Blbiwgc2V0IHRoZSBjb250YWluZXIgZWxlbWVudCdzIHotaW5kZXggdG8gJzk5OTknLlxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgaWYgKCB2YXJzLmRyYXcudGltaW5nICkge1xuXG4gICAgdmFycy5jb250YWluZXIudWkudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAuZWFjaChcInN0YXJ0XCIsZnVuY3Rpb24oKXtcbiAgICAgICAgaWYgKHZhcnMub3Blbi52YWx1ZSkge1xuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcInotaW5kZXhcIiw5OTk5KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLnN0eWxlKFwibWFyZ2luXCIsdmFycy51aS5tYXJnaW4rXCJweFwiKVxuICAgICAgLmVhY2goXCJlbmRcIixmdW5jdGlvbigpe1xuICAgICAgICBpZiAoIXZhcnMub3Blbi52YWx1ZSkge1xuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcInotaW5kZXhcIixcImF1dG9cIilcbiAgICAgICAgfVxuICAgICAgfSlcblxuICB9XG4gIGVsc2Uge1xuXG4gICAgdmFycy5jb250YWluZXIudWlcbiAgICAgIC5zdHlsZShcIm1hcmdpblwiLHZhcnMudWkubWFyZ2luK1wicHhcIilcbiAgICAgIC5zdHlsZShcInotaW5kZXhcIixmdW5jdGlvbigpe1xuICAgICAgICBpZiAodmFycy5vcGVuLnZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIDk5OTlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gXCJhdXRvXCJcbiAgICAgICAgfVxuICAgICAgfSlcblxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIFVwZGF0ZSBsaXN0IGl0ZW1zIGJhc2VkIG9uIGZpbHRlcmVkIGRhdGEuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBpdGVtcyggdmFycyApXG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIENhbGN1bGF0ZSB0aGUgaGVpZ2h0IGFuZCBvcmllbnRhdGlvbiBvZiB0aGUgZHJvcGRvd24gbGlzdC5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGhlaWdodCggdmFycyApXG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIENhbGN1bGF0ZSBzY3JvbGwgcG9zaXRpb24gb2YgZHJvcGRvd24gbWVudS5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHNjcm9sbGxpc3QoIHZhcnMgKVxuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBSb3RhdGUgdGhlIGRyb3Bkb3duIGJ1dHRvbiBhcnJvdyBhcHByb3ByaWF0ZWx5LlxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgYXJyb3coIHZhcnMgKVxuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBVcGRhdGUgTGlzdFxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWUoXCJkcmF3aW5nIGxpc3RcIilcblxuICBmdW5jdGlvbiB1cGRhdGUoZWxlbSkge1xuXG4gICAgZWxlbVxuICAgICAgLnN0eWxlKFwibGVmdFwiLGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmICh2YXJzLmZvbnQuYWxpZ24udmFsdWUgPT09IFwibGVmdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHZhcnMubWFyZ2luLmxlZnQrXCJweFwiXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFycy5mb250LmFsaWduLnZhbHVlID09PSBcImNlbnRlclwiKSB7XG4gICAgICAgICAgcmV0dXJuIHZhcnMubWFyZ2luLmxlZnQtKCh2YXJzLndpZHRoLnNlY29uZGFyeS12YXJzLndpZHRoLnZhbHVlKS8yKStcInB4XCJcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gXCJhdXRvXCJcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5zdHlsZShcInJpZ2h0XCIsZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHZhcnMuZm9udC5hbGlnbi52YWx1ZSA9PT0gXCJyaWdodFwiID8gXCIwcHhcIiA6IFwiYXV0b1wiXG4gICAgICB9KVxuICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsdmFycy5jb250YWluZXIubGlzdEhlaWdodCtcInB4XCIpXG4gICAgICAuc3R5bGUoXCJwYWRkaW5nXCIsdmFycy51aS5ib3JkZXIrXCJweFwiKVxuICAgICAgLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLHZhcnMudWkuY29sb3Iuc2Vjb25kYXJ5LnZhbHVlKVxuICAgICAgLnN0eWxlKFwiei1pbmRleFwiLGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB2YXJzLm9wZW4udmFsdWUgPyBcIjk5OTlcIiA6IFwiLTFcIjtcbiAgICAgIH0pXG4gICAgICAuc3R5bGUoXCJ3aWR0aFwiLCh2YXJzLndpZHRoLnNlY29uZGFyeS0odmFycy51aS5ib3JkZXIqMikpK1wicHhcIilcbiAgICAgIC5zdHlsZShcInRvcFwiLGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB2YXJzLm9wZW4uZmxpcHBlZC52YWx1ZSA/IFwiYXV0b1wiIDogdmFycy5tYXJnaW4udG9wK1wicHhcIlxuICAgICAgfSlcbiAgICAgIC5zdHlsZShcImJvdHRvbVwiLGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB2YXJzLm9wZW4uZmxpcHBlZC52YWx1ZSA/IHZhcnMubWFyZ2luLnRvcCtcInB4XCIgOiBcImF1dG9cIlxuICAgICAgfSlcbiAgICAgIC5zdHlsZShcIm9wYWNpdHlcIix2YXJzLm9wZW4udmFsdWUgPyAxIDogMClcblxuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoKGVsZW0pIHtcblxuICAgIGVsZW1cbiAgICAgIC5zdHlsZShcInRvcFwiLGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB2YXJzLm9wZW4uZmxpcHBlZC52YWx1ZSA/IFwiYXV0b1wiIDogdmFycy5tYXJnaW4udG9wK1wicHhcIlxuICAgICAgfSlcbiAgICAgIC5zdHlsZShcImJvdHRvbVwiLGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB2YXJzLm9wZW4uZmxpcHBlZC52YWx1ZSA/IHZhcnMubWFyZ2luLnRvcCtcInB4XCIgOiBcImF1dG9cIlxuICAgICAgfSlcbiAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwhdmFycy5vcGVuLnZhbHVlID8gXCJub25lXCIgOiBudWxsKVxuXG4gICAgaWYgKHZhcnMuc2VhcmNoLmVuYWJsZWQgJiYgdmFycy5vcGVuLnZhbHVlKSB7XG4gICAgICB2YXJzLmNvbnRhaW5lci5zZWxlY3Rvci5zZWxlY3QoXCJkaXYuZDNwbHVzX2Ryb3Bfc2VhcmNoIGlucHV0XCIpLm5vZGUoKS5mb2N1cygpXG4gICAgfVxuXG4gIH1cblxuICB2YXIgbWF4X2hlaWdodCA9IHZhcnMub3Blbi52YWx1ZSA/IHZhcnMuaGVpZ2h0LnNlY29uZGFyeS12YXJzLm1hcmdpbi50aXRsZSA6IDBcblxuICBpZiAoIXZhcnMuZHJhdy50aW1pbmcpIHtcblxuICAgIHZhcnMuY29udGFpbmVyLnNlbGVjdG9yLmNhbGwodXBkYXRlKS5jYWxsKGZpbmlzaClcblxuICAgIHZhcnMuY29udGFpbmVyLmxpc3RcbiAgICAgIC5zdHlsZShcIndpZHRoXCIsdmFycy53aWR0aC5zZWNvbmRhcnktdmFycy51aS5ib3JkZXIqMitcInB4XCIpXG4gICAgICAuc3R5bGUoXCJtYXgtaGVpZ2h0XCIsbWF4X2hlaWdodCtcInB4XCIpXG4gICAgICAucHJvcGVydHkoXCJzY3JvbGxUb3BcIix2YXJzLmNvbnRhaW5lci5saXN0U2Nyb2xsKVxuXG4gIH1cbiAgZWxzZSB7XG4gICAgdmFycy5jb250YWluZXIuc2VsZWN0b3IudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAuZWFjaChcInN0YXJ0XCIsZnVuY3Rpb24oKXtcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLHZhcnMub3Blbi52YWx1ZSA/IFwiYmxvY2tcIiA6IG51bGwpXG4gICAgICB9KVxuICAgICAgLmNhbGwodXBkYXRlKVxuICAgICAgLmVhY2goXCJlbmRcIixmdW5jdGlvbigpe1xuXG4gICAgICAgIGQzLnNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgICAgICAuY2FsbChmaW5pc2gpXG5cbiAgICAgIH0pXG5cbiAgICBmdW5jdGlvbiBzY3JvbGxUb3BUd2VlbihzY3JvbGxUb3ApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGkgPSBkMy5pbnRlcnBvbGF0ZU51bWJlcih0aGlzLnNjcm9sbFRvcCwgc2Nyb2xsVG9wKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7IHRoaXMuc2Nyb2xsVG9wID0gaSh0KTsgfTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXJzLmNvbnRhaW5lci5saXN0LnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgICAgLnN0eWxlKFwid2lkdGhcIix2YXJzLndpZHRoLnNlY29uZGFyeS12YXJzLnVpLmJvcmRlcioyK1wicHhcIilcbiAgICAgIC5zdHlsZShcIm1heC1oZWlnaHRcIixtYXhfaGVpZ2h0K1wicHhcIilcbiAgICAgIC50d2VlbihcInNjcm9sbFwiLHNjcm9sbFRvcFR3ZWVuKHZhcnMuY29udGFpbmVyLmxpc3RTY3JvbGwpKVxuICB9XG5cbiAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWVFbmQoXCJkcmF3aW5nIGxpc3RcIilcblxufVxuIiwidmFyIGZvbnRUZXN0ZXIgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vY29yZS9mb250L3Rlc3Rlci5jb2ZmZWVcIilcbi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBJZiBubyB3aWR0aHMgYXJlIGRlZmluZWQsIHRoZW4gdGhpcyBjYWxjdWxhdGVzIHRoZSB3aWR0aCBuZWVkZWQgdG8gZml0IHRoZVxuLy8gbG9uZ2VzdCBlbnRyeSBpbiB0aGUgbGlzdC5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICggdmFycyApIHtcblxuICB2YXIgZGF0YSA9IFtdLCBidWZmZXIgPSAwXG4gIGZvciAoIHZhciBsZXZlbCBpbiB2YXJzLmRhdGEubmVzdGVkLmFsbCApIHtcbiAgICB2YXIgbmV3RGF0YSA9IHZhcnMuZGF0YS5uZXN0ZWQuYWxsW2xldmVsXVxuICAgICAgLCBrZXkgICAgID0gZDNwbHVzLm9iamVjdC52YWxpZGF0ZSh2YXJzLnRleHQubmVzdGluZykgJiYgbGV2ZWwgaW4gdmFycy50ZXh0Lm5lc3RpbmdcbiAgICAgICAgICAgICAgICA/IHZhcnMudGV4dC5uZXN0aW5nW2xldmVsXVswXSA6IGxldmVsXG5cbiAgICBpZiAoIFt2YXJzLmlkLnZhbHVlLHZhcnMudGV4dC52YWx1ZV0uaW5kZXhPZihrZXkpIDwgMCApIHtcbiAgICAgIG5ld0RhdGEgPSBkM3BsdXMudXRpbC5jb3B5KG5ld0RhdGEpXG4gICAgICBuZXdEYXRhLmZvckVhY2goZnVuY3Rpb24oZCl7XG4gICAgICAgIGRbdmFycy50ZXh0LnZhbHVlIHx8IHZhcnMuaWQudmFsdWVdID0gZFtrZXldXG4gICAgICB9KVxuICAgIH1cbiAgICBkYXRhID0gZGF0YS5jb25jYXQoIG5ld0RhdGEgKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0V2lkdGgoIHR5cGUgKSB7XG5cbiAgICB2YXIga2V5ICA9IHR5cGUgPT09IFwicHJpbWFyeVwiID8gXCJ2YWx1ZVwiIDogdHlwZVxuICAgICAgLCBpY29uID0ga2V5ID09PSBcInZhbHVlXCIgPyB2YXJzLmljb24uZHJvcC52YWx1ZVxuICAgICAgICAgICAgIDogdmFycy5pY29uLnNlbGVjdC52YWx1ZSB8fCB2YXJzLmljb24uZHJvcC52YWx1ZVxuICAgICAgLCB0ZXh0ID0ga2V5ID09PSBcInZhbHVlXCIgPyB2YXJzLnRleHQudmFsdWVcbiAgICAgICAgICAgICA6IHZhcnMudGV4dC5zZWNvbmRhcnkudmFsdWUgfHwgdmFycy50ZXh0LnZhbHVlXG4gICAgICAsIGZvbnQgPSBrZXkgPT09IFwidmFsdWVcIiA/IHZhcnMuZm9udCA6IHZhcnMuZm9udC5zZWNvbmRhcnlcblxuICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lKFwiY2FsY3VsYXRpbmcgXCIrdHlwZStcIiB3aWR0aFwiKVxuXG4gICAgdmFyIGJ1dHRvbiA9IGQzcGx1cy5mb3JtKClcbiAgICAgIC5jb250YWluZXIoIGZvbnRUZXN0ZXIoKSApXG4gICAgICAuZGF0YSh7XG4gICAgICAgIFwibGFyZ2VcIjogOTk5OSxcbiAgICAgICAgXCJ2YWx1ZVwiOiBkYXRhXG4gICAgICB9KVxuICAgICAgLmRyYXcoeyBcInVwZGF0ZVwiOiBmYWxzZSB9KVxuICAgICAgLmZvbnQoIGZvbnQgKVxuICAgICAgLmljb24oeyBcImJ1dHRvblwiOiBpY29uLCBcInZhbHVlXCI6IHZhcnMuaWNvbi52YWx1ZSB9KVxuICAgICAgLmlkKHZhcnMuaWQudmFsdWUpXG4gICAgICAudGltaW5nKHtcbiAgICAgICAgXCJ1aVwiOiAwXG4gICAgICB9KVxuICAgICAgLnRleHQoIHRleHQgfHwgdmFycy5pZC52YWx1ZSApXG4gICAgICAudHlwZSggXCJidXR0b25cIiApXG4gICAgICAudWkoe1xuICAgICAgICBcImJvcmRlclwiOiB0eXBlID09PSBcInByaW1hcnlcIiA/IHZhcnMudWkuYm9yZGVyIDogMCxcbiAgICAgICAgXCJkaXNwbGF5XCI6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIFwibWFyZ2luXCI6IDAsXG4gICAgICAgIFwicGFkZGluZ1wiOiB2YXJzLnVpLnBhZGRpbmdcbiAgICAgIH0pXG4gICAgICAud2lkdGgoZmFsc2UpXG4gICAgICAuZHJhdygpXG5cbiAgICB2YXIgdyA9IFtdXG4gICAgYnV0dG9uLnNlbGVjdEFsbChcImRpdi5kM3BsdXNfbm9kZVwiKS5lYWNoKGZ1bmN0aW9uKG8pe1xuICAgICAgdy5wdXNoKHRoaXMub2Zmc2V0V2lkdGgpXG4gICAgfSkucmVtb3ZlKClcblxuICAgIHZhciBkcm9wV2lkdGggPSB7fVxuICAgIGRyb3BXaWR0aFtrZXldID0gZDMubWF4KHcpXG5cbiAgICB2YXJzLnNlbGYud2lkdGgoIGRyb3BXaWR0aCApXG5cbiAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZUVuZChcImNhbGN1bGF0aW5nIFwiK3R5cGUrXCIgd2lkdGhcIilcblxuICB9XG5cbiAgaWYgKCB0eXBlb2YgdmFycy53aWR0aC52YWx1ZSAhPT0gXCJudW1iZXJcIiApIHtcblxuICAgIGdldFdpZHRoKCBcInByaW1hcnlcIiApXG5cbiAgfVxuXG4gIGlmICggdHlwZW9mIHZhcnMud2lkdGguc2Vjb25kYXJ5ICE9PSBcIm51bWJlclwiICkge1xuXG4gICAgaWYgKCAhdmFycy50ZXh0LnNlY29uZGFyeS52YWx1ZSB8fCB2YXJzLnRleHQudmFsdWUgPT09IHZhcnMudGV4dC5zZWNvbmRhcnkudmFsdWUgKSB7XG4gICAgICB2YXJzLnNlbGYud2lkdGgoe1wic2Vjb25kYXJ5XCI6IHZhcnMud2lkdGgudmFsdWV9KVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGdldFdpZHRoKCBcInNlY29uZGFyeVwiIClcbiAgICB9XG5cbiAgfVxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gUmVjdXJzaXZlIGZ1bmN0aW9uIHRoYXQgYXBwbGllcyBhIGNsaWNrIGV2ZW50IHRvIGFsbCBwYXJlbnQgd2luZG93cyB0aGF0XG4vLyB3aWxsIGNsb3NlIHRoZSBkcm9wZG93biBpZiBpdCBpcyBvcGVuLlxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciB3aW5kb3dFdmVudHMgPSBmdW5jdGlvbiAoIHZhcnMgLCBlbGVtICkge1xuXG4gIGlmICggZWxlbSA9PT0gdW5kZWZpbmVkICkge1xuICAgIHZhciBlbGVtID0gd2luZG93XG4gIH1cblxuICBkMy5zZWxlY3QoZWxlbSkub24oXCJjbGljay5cIit2YXJzLmNvbnRhaW5lci5pZCxmdW5jdGlvbigpe1xuXG4gICAgdmFyIGVsZW1lbnQgPSBkMy5ldmVudC50YXJnZXQgfHwgZDMuZXZlbnQudG9FbGVtZW50XG4gICAgICAsIHBhcmVudCAgPSBlbGVtZW50LnBhcmVudE5vZGVcblxuICAgIGlmICggcGFyZW50ICYmIFtcImQzcGx1c19ub2RlXCIsXCJkM3BsdXNfZHJvcF90aXRsZVwiXS5pbmRleE9mKHBhcmVudC5jbGFzc05hbWUpID49IDAgKSB7XG4gICAgICBlbGVtZW50ID0gcGFyZW50LnBhcmVudE5vZGVcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudCAmJiBwYXJlbnQgJiYgIWQzcGx1cy51dGlsLmNoaWxkKHZhcnMuY29udGFpbmVyLnVpLCBlbGVtZW50KSAmJiB2YXJzLm9wZW4udmFsdWUpIHtcbiAgICAgIHZhcnMuc2VsZi5vcGVuKCF2YXJzLm9wZW4udmFsdWUpLmRyYXcoKVxuICAgIH1cblxuICB9KVxuXG4gIHRyeSB7XG4gICAgdmFyIHNhbWVfb3JpZ2luID0gd2luZG93LnBhcmVudC5sb2NhdGlvbi5ob3N0ID09PSB3aW5kb3cubG9jYXRpb24uaG9zdDtcbiAgfVxuICBjYXRjaCAoZSkge1xuICAgIHZhciBzYW1lX29yaWdpbiA9IGZhbHNlXG4gIH1cblxuICBpZiAoc2FtZV9vcmlnaW4pIHtcbiAgICBpZiAoZWxlbS5zZWxmICE9PSB3aW5kb3cudG9wKSB7XG4gICAgICB3aW5kb3dFdmVudHMoIHZhcnMgLCBlbGVtLnBhcmVudCApXG4gICAgfVxuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3aW5kb3dFdmVudHNcbiIsIi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBDcmVhdGVzIGEgc2V0IG9mIFRvZ2dsZSBCdXR0b25zXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggdmFycyApIHtcblxuICBpZiAoICEoXCJidXR0b25zXCIgaW4gdmFycy5jb250YWluZXIpICkge1xuXG4gICAgdmFycy5jb250YWluZXIuYnV0dG9ucyA9IGQzcGx1cy5mb3JtKClcbiAgICAgIC5jb250YWluZXIodmFycy5jb250YWluZXIudWkpXG4gICAgICAudHlwZShcImJ1dHRvblwiKVxuXG4gIH1cblxuICB2YXIgZGF0YUxlbmd0aCAgPSB2YXJzLmRhdGEuYXBwLmxlbmd0aFxuICAgICwgYnV0dG9uV2lkdGggPSB2YXJzLndpZHRoLnZhbHVlXG4gICAgICAgICAgICAgICAgICA/IHZhcnMud2lkdGgudmFsdWUvZGF0YUxlbmd0aFxuICAgICAgICAgICAgICAgICAgOiBmYWxzZVxuXG4gIHZhciB0b2dnbGVzID0gdmFycy5jb250YWluZXIudWkuc2VsZWN0QWxsKFwiZGl2LmQzcGx1c190b2dnbGVcIilcbiAgICAuZGF0YSh2YXJzLmRhdGEuYXBwLGZ1bmN0aW9uKGQpe1xuICAgICAgcmV0dXJuIGRbdmFycy5pZC52YWx1ZV1cbiAgICB9KVxuXG4gIHRvZ2dsZXMuZW50ZXIoKS5hcHBlbmQoXCJkaXZcIilcbiAgICAuYXR0cihcImNsYXNzXCIsXCJkM3BsdXNfdG9nZ2xlXCIpXG4gICAgLnN0eWxlKFwiZGlzcGxheVwiLFwiaW5saW5lLWJsb2NrXCIpXG4gICAgLnN0eWxlKFwidmVydGljYWwtYWxpZ25cIixcInRvcFwiKVxuXG4gIHRvZ2dsZXMub3JkZXIoKVxuICAgIC5lYWNoKGZ1bmN0aW9uKGQpe1xuXG4gICAgICBpZiAoIShcImZvcm1cIiBpbiBkLmQzcGx1cykpIHtcbiAgICAgICAgZC5kM3BsdXMuZm9ybSA9IGQzcGx1cy5mb3JtKClcbiAgICAgICAgICAuY29udGFpbmVyKGQzLnNlbGVjdCh0aGlzKSlcbiAgICAgIH1cblxuICAgICAgdmFyIGlkID0gdmFycy5pZC5uZXN0aW5nLmxlbmd0aCA+IHZhcnMuZGVwdGgudmFsdWUgPyB2YXJzLmlkLm5lc3RpbmdbdmFycy5kZXB0aC52YWx1ZSsxXSA6IHZhcnMuaWQudmFsdWVcblxuICAgICAgaWYgKGRbaWRdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZC5kM3BsdXMuZm9ybVxuICAgICAgICAgIC5jb250YWluZXIoe1wiaWRcIjogdmFycy5jb250YWluZXIuaWQrXCJfXCIrZFt2YXJzLmlkLnZhbHVlXX0pXG4gICAgICAgICAgLmRhdGEoZFtpZF0pXG4gICAgICAgICAgLmlkKHZhcnMuaWQubmVzdGluZy5zbGljZSgxKSlcbiAgICAgICAgICAudHlwZShcImRyb3BcIilcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkLmQzcGx1cy5mb3JtXG4gICAgICAgICAgLmRhdGEoW2RdKVxuICAgICAgICAgIC5pZCh2YXJzLmlkLnZhbHVlKVxuICAgICAgICAgIC50eXBlKFwiYnV0dG9uXCIpXG4gICAgICB9XG5cbiAgICAgIGQuZDNwbHVzLmZvcm1cbiAgICAgICAgLmNvbG9yKHZhcnMuY29sb3IpXG4gICAgICAgIC5mb2N1cyh2YXJzLmZvY3VzLnZhbHVlWzBdLGZ1bmN0aW9uKHZhbHVlKXtcblxuICAgICAgICAgIGlmICh2YWx1ZVswXSAhPT0gdmFycy5mb2N1cy52YWx1ZVswXSkge1xuICAgICAgICAgICAgdmFycy5zZWxmLmZvY3VzKHZhbHVlWzBdKS5kcmF3KClcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSlcbiAgICAgICAgLmljb24oe1xuICAgICAgICAgIFwic2VsZWN0XCI6IGZhbHNlLFxuICAgICAgICAgIFwidmFsdWVcIjogdmFycy5pY29uLnZhbHVlXG4gICAgICAgIH0pXG4gICAgICAgIC5mb250KHZhcnMuZm9udClcbiAgICAgICAgLmZvcm1hdCh2YXJzLmZvcm1hdClcbiAgICAgICAgLm9yZGVyKHZhcnMub3JkZXIpXG4gICAgICAgIC50ZXh0KHZhcnMudGV4dC52YWx1ZSlcbiAgICAgICAgLnVpKHtcbiAgICAgICAgICBcImJvcmRlclwiOiB2YXJzLnVpLmJvcmRlcixcbiAgICAgICAgICBcImNvbG9yXCI6IHZhcnMudWkuY29sb3IsXG4gICAgICAgICAgXCJkaXNwbGF5XCI6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgICAgXCJtYXJnaW5cIjogMCxcbiAgICAgICAgICBcInBhZGRpbmdcIjogdmFycy51aS5wYWRkaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC53aWR0aChidXR0b25XaWR0aClcbiAgICAgICAgLmRyYXcoKVxuXG4gICAgfSlcblxufVxuIiwiI1xuIyBDdXN0b20gc3R5bGluZyBhbmQgYmVoYXZpb3IgZm9yIGJyb3dzZXIgY29uc29sZSBzdGF0ZW1lbnRzLlxuI1xud2lraSA9IHJlcXVpcmUgXCIuL3dpa2kuY29mZmVlXCJcbmQzcGx1cy5jb25zb2xlID0gKHR5cGUsIG1lc3NhZ2UsIHN0eWxlKSAtPlxuICBzdHlsZSA9IHN0eWxlIG9yIFwiXCJcbiAgaWYgZDNwbHVzLmllIG9yIHR5cGVvZiBJbnN0YWxsVHJpZ2dlciBpc250ICd1bmRlZmluZWQnXG4gICAgY29uc29sZS5sb2cgXCJbIEQzcGx1cyBdIFwiICsgbWVzc2FnZVxuICBlbHNlIGlmIHR5cGUgaXMgXCJncm91cENvbGxhcHNlZFwiXG4gICAgaWYgd2luZG93LmNocm9tZSBhbmQgbmF2aWdhdG9yLm9uTGluZVxuICAgICAgY29uc29sZVt0eXBlXSBcIiVjJWMgXCIgKyBtZXNzYWdlLCBcInBhZGRpbmc6M3B4IDEwcHg7bGluZS1oZWlnaHQ6MjVweDtiYWNrZ3JvdW5kLXNpemU6MjBweDtiYWNrZ3JvdW5kLXBvc2l0aW9uOnRvcCBsZWZ0O2JhY2tncm91bmQtaW1hZ2U6dXJsKCdodHRwOi8vZDNwbHVzLm9yZy9hc3NldHMvaW1nL2Zhdmljb24uaWNvJyk7XCIsIFwiZm9udC13ZWlnaHQ6MjAwO1wiICsgc3R5bGVcbiAgICBlbHNlXG4gICAgICBjb25zb2xlW3R5cGVdIFwiJWNEM3BsdXMlYyBcIiArIG1lc3NhZ2UsIFwibGluZS1oZWlnaHQ6MjVweDtmb250LXdlaWdodDo4MDA7Y29sb3I6I2IzNWMxZTttYXJnaW4tbGVmdDowcHg7XCIsIFwiZm9udC13ZWlnaHQ6MjAwO1wiICsgc3R5bGVcbiAgZWxzZVxuICAgIGNvbnNvbGVbdHlwZV0gXCIlY1wiICsgbWVzc2FnZSwgc3R5bGUgKyBcImZvbnQtd2VpZ2h0OjIwMDtcIlxuICByZXR1cm5cblxuZDNwbHVzLmNvbnNvbGUuY29tbWVudCA9IChtZXNzYWdlKSAtPlxuICB0aGlzIFwibG9nXCIsIG1lc3NhZ2UsIFwiY29sb3I6I2FhYTtcIlxuICByZXR1cm5cblxuZDNwbHVzLmNvbnNvbGUuZXJyb3IgPSAobWVzc2FnZSwgdXJsKSAtPlxuICB0aGlzIFwiZ3JvdXBDb2xsYXBzZWRcIiwgXCJFUlJPUjogXCIgKyBtZXNzYWdlLCBcImZvbnQtd2VpZ2h0OjgwMDtjb2xvcjojRDc0QjAzO1wiXG4gIEBzdGFjaygpXG4gIEB3aWtpIHVybFxuICBAZ3JvdXBFbmQoKVxuICByZXR1cm5cblxuZDNwbHVzLmNvbnNvbGUuZ3JvdXAgPSAobWVzc2FnZSkgLT5cbiAgdGhpcyBcImdyb3VwXCIsIG1lc3NhZ2UsIFwiY29sb3I6Izg4ODtcIlxuICByZXR1cm5cblxuZDNwbHVzLmNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQgPSAobWVzc2FnZSkgLT5cbiAgdGhpcyBcImdyb3VwQ29sbGFwc2VkXCIsIG1lc3NhZ2UsIFwiY29sb3I6Izg4ODtcIlxuICByZXR1cm5cblxuZDNwbHVzLmNvbnNvbGUuZ3JvdXBFbmQgPSAtPlxuICBjb25zb2xlLmdyb3VwRW5kKCkgIHVubGVzcyBkM3BsdXMuaWVcbiAgcmV0dXJuXG5cbmQzcGx1cy5jb25zb2xlLmxvZyA9IChtZXNzYWdlKSAtPlxuICB0aGlzIFwibG9nXCIsIG1lc3NhZ2UsIFwiY29sb3I6IzQ0NDQ0NDtcIlxuICByZXR1cm5cblxuZDNwbHVzLmNvbnNvbGUuc3RhY2sgPSAtPlxuICB1bmxlc3MgZDNwbHVzLmllXG4gICAgZXJyID0gbmV3IEVycm9yKClcbiAgICBpZiBlcnIuc3RhY2tcbiAgICAgIHN0YWNrID0gZXJyLnN0YWNrLnNwbGl0KFwiXFxuXCIpXG4gICAgICBzdGFjayA9IHN0YWNrLmZpbHRlcigoZSkgLT5cbiAgICAgICAgZS5pbmRleE9mKFwiRXJyb3JcIikgaXNudCAwIGFuZCBlLmluZGV4T2YoXCJkM3BsdXMuanM6XCIpIDwgMCBhbmQgZS5pbmRleE9mKFwiZDNwbHVzLm1pbi5qczpcIikgPCAwXG4gICAgICApXG4gICAgICBpZiBzdGFjay5sZW5ndGhcbiAgICAgICAgc3BsaXR0ZXIgPSAoaWYgd2luZG93LmNocm9tZSB0aGVuIFwiYXQgXCIgZWxzZSBcIkBcIilcbiAgICAgICAgdXJsID0gc3RhY2tbMF0uc3BsaXQoc3BsaXR0ZXIpWzFdXG4gICAgICAgIHN0YWNrID0gdXJsLnNwbGl0KFwiOlwiKVxuICAgICAgICBzdGFjay5wb3AoKSAgaWYgc3RhY2subGVuZ3RoIGlzIDNcbiAgICAgICAgbGluZSA9IHN0YWNrLnBvcCgpXG4gICAgICAgIHBhZ2UgPSBzdGFjay5qb2luKFwiOlwiKS5zcGxpdChcIi9cIilcbiAgICAgICAgcGFnZSA9IHBhZ2VbcGFnZS5sZW5ndGggLSAxXVxuICAgICAgICBtZXNzYWdlID0gXCJsaW5lIFwiICsgbGluZSArIFwiIG9mIFwiICsgcGFnZSArIFwiOiBcIiArIHVybFxuICAgICAgICB0aGlzIFwibG9nXCIsIG1lc3NhZ2UsIFwiY29sb3I6I0Q3NEIwMztcIlxuICByZXR1cm5cblxuZDNwbHVzLmNvbnNvbGUudGltZSA9IChtZXNzYWdlKSAtPlxuICBjb25zb2xlLnRpbWUgbWVzc2FnZSB1bmxlc3MgZDNwbHVzLmllXG4gIHJldHVyblxuXG5kM3BsdXMuY29uc29sZS50aW1lRW5kID0gKG1lc3NhZ2UpIC0+XG4gIGNvbnNvbGUudGltZUVuZCBtZXNzYWdlIHVubGVzcyBkM3BsdXMuaWVcbiAgcmV0dXJuXG5cbmQzcGx1cy5jb25zb2xlLndhcm5pbmcgPSAobWVzc2FnZSwgdXJsKSAtPlxuICB0aGlzIFwiZ3JvdXBDb2xsYXBzZWRcIiwgbWVzc2FnZSwgXCJjb2xvcjojODg4O1wiXG4gIEBzdGFjaygpXG4gIEB3aWtpIHVybFxuICBAZ3JvdXBFbmQoKVxuICByZXR1cm5cblxuZDNwbHVzLmNvbnNvbGUud2lraSA9ICh1cmwpIC0+XG4gIGlmIHVybFxuICAgIGlmIHVybCBvZiB3aWtpXG4gICAgICB1cmwgPSBkM3BsdXMucmVwbyArIFwid2lraS9cIiArIHdpa2lbdXJsXVxuICAgIHRoaXMgXCJsb2dcIiwgXCJkb2N1bWVudGF0aW9uOiBcIiArIHVybCwgXCJjb2xvcjojYWFhO1wiXG4gIHJldHVyblxuXG5tb2R1bGUuZXhwb3J0cyA9IGQzcGx1cy5jb25zb2xlXG4iLCIjIyMqXG4gKiBDcmVhdGVzIGN1c3RvbSBtb3VzZSBldmVudHMgYmFzZWQgb24gSUUgYW5kIFRvdWNoIERldmljZXMuXG4gIyMjXG5kM3BsdXMudG91Y2ggPSBpZiAoXCJvbnRvdWNoc3RhcnRcIiBvZiB3aW5kb3cpIG9yIHdpbmRvdy5Eb2N1bWVudFRvdWNoIGFuZCBkb2N1bWVudCBpbnN0YW5jZW9mIERvY3VtZW50VG91Y2ggdGhlbiB0cnVlIGVsc2UgZmFsc2VcbmlmIGQzcGx1cy50b3VjaFxuICBkM3BsdXMuZXZ0ID1cbiAgICBjbGljazogXCJjbGlja1wiXG4gICAgZG93bjogXCJ0b3VjaHN0YXJ0XCJcbiAgICB1cDogXCJ0b3VjaGVuZFwiXG4gICAgb3ZlcjogXCJ0b3VjaHN0YXJ0XCJcbiAgICBvdXQ6IFwidG91Y2hlbmRcIlxuICAgIG1vdmU6IFwidG91Y2htb3ZlXCJcbmVsc2VcbiAgZDNwbHVzLmV2dCA9XG4gICAgY2xpY2s6IFwiY2xpY2tcIlxuICAgIGRvd246IFwibW91c2Vkb3duXCJcbiAgICB1cDogXCJtb3VzZXVwXCJcbiAgICBvdmVyOiBpZiBkM3BsdXMuaWUgdGhlbiBcIm1vdXNlZW50ZXJcIiBlbHNlIFwibW91c2VvdmVyXCJcbiAgICBvdXQ6IGlmIGQzcGx1cy5pZSB0aGVuIFwibW91c2VsZWF2ZVwiIGVsc2UgXCJtb3VzZW91dFwiXG4gICAgbW92ZTogXCJtb3VzZW1vdmVcIlxuIiwiLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIERldGVybWluZXMgaWYgdGhlIGN1cnJlbnQgYnJvd3NlciBpcyBJbnRlcm5ldCBFeHBsb3Jlci5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kM3BsdXMuaWUgPSAvKkBjY19vbiFAKi9mYWxzZVxuIiwiIyMjKlxuICogQ2FsY3VsYXRlcyB0aGUgY29ycmVjdCBDU1MgdmVuZG9yIHByZWZpeCBiYXNlZCBvbiB0aGUgY3VycmVudCBicm93c2VyLlxuICMjI1xuZDNwbHVzLnByZWZpeCA9IC0+XG5cbiAgaWYgXCItd2Via2l0LXRyYW5zZm9ybVwiIG9mIGRvY3VtZW50LmJvZHkuc3R5bGVcbiAgICB2YWwgPSBcIi13ZWJraXQtXCJcbiAgZWxzZSBpZiBcIi1tb3otdHJhbnNmb3JtXCIgb2YgZG9jdW1lbnQuYm9keS5zdHlsZVxuICAgIHZhbCA9IFwiLW1vei1cIlxuICBlbHNlIGlmIFwiLW1zLXRyYW5zZm9ybVwiIG9mIGRvY3VtZW50LmJvZHkuc3R5bGVcbiAgICB2YWwgPSBcIi1tcy1cIlxuICBlbHNlIGlmIFwiLW8tdHJhbnNmb3JtXCIgb2YgZG9jdW1lbnQuYm9keS5zdHlsZVxuICAgIHZhbCA9IFwiLW8tXCJcbiAgZWxzZVxuICAgIHZhbCA9IFwiXCJcblxuICBkM3BsdXMucHJlZml4ID0gLT5cbiAgICB2YWxcblxuICB2YWxcbiIsIi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBEZXRlY3RzIHJpZ2h0LXRvLWxlZnQgdGV4dCBkaXJlY3Rpb24gb24gdGhlIHBhZ2UuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZDNwbHVzLnJ0bCA9IGQzLnNlbGVjdChcImh0bWxcIikuYXR0cihcImRpclwiKSA9PSBcInJ0bFwiXG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gRGV0ZWN0cyBzY3JvbGxiYXIgd2lkdGggZm9yIGN1cnJlbnQgYnJvd3Nlci5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kM3BsdXMuc2Nyb2xsYmFyID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gIGlubmVyLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gIGlubmVyLnN0eWxlLmhlaWdodCA9IFwiMjAwcHhcIjtcblxuICB2YXIgb3V0ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBvdXRlci5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgb3V0ZXIuc3R5bGUudG9wID0gXCIwcHhcIjtcbiAgb3V0ZXIuc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gIG91dGVyLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICBvdXRlci5zdHlsZS53aWR0aCA9IFwiMjAwcHhcIjtcbiAgb3V0ZXIuc3R5bGUuaGVpZ2h0ID0gXCIxNTBweFwiO1xuICBvdXRlci5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gIG91dGVyLmFwcGVuZENoaWxkKGlubmVyKTtcblxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG91dGVyKTtcbiAgdmFyIHcxID0gaW5uZXIub2Zmc2V0V2lkdGg7XG4gIG91dGVyLnN0eWxlLm92ZXJmbG93ID0gXCJzY3JvbGxcIjtcbiAgdmFyIHcyID0gaW5uZXIub2Zmc2V0V2lkdGg7XG4gIGlmICh3MSA9PSB3MikgdzIgPSBvdXRlci5jbGllbnRXaWR0aDtcblxuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG91dGVyKTtcblxuICB2YXIgdmFsID0gKHcxIC0gdzIpXG5cbiAgZDNwbHVzLnNjcm9sbGJhciA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHZhbFxuICB9XG5cbiAgcmV0dXJuIHZhbDtcblxufVxuIiwiZDNwbHVzLndpa2kgPVxuICBhY3RpdmU6ICAgICBcIlNlZ21lbnRpbmctRGF0YSNhY3RpdmVcIlxuICBhZ2dzOiAgICAgICBcIkN1c3RvbS1BZ2dyZWdhdGlvbnNcIlxuICBhbHQ6ICAgICAgICBcIkFsdC1UZXh0LVBhcmFtZXRlcnNcIlxuICBhdHRyczogICAgICBcIkF0dHJpYnV0ZS1EYXRhI2F4ZXNcIlxuICBheGVzOiAgICAgICBcIkF4aXMtUGFyYW1ldGVyc1wiXG4gIGJhY2tncm91bmQ6IFwiQmFja2dyb3VuZFwiXG4gIGNvbG9yOiAgICAgIFwiQ29sb3ItUGFyYW1ldGVyc1wiXG4gIGNvbnRhaW5lcjogIFwiQ29udGFpbmVyLUVsZW1lbnRcIlxuICBjb29yZHM6ICAgICBcIkdlb2dyYXBoeS1EYXRhXCJcbiAgY3N2OiAgICAgICAgXCJDU1YtRXhwb3J0XCJcbiAgZGF0YTogICAgICAgXCJEYXRhLVBvaW50c1wiXG4gIGRlcHRoOiAgICAgIFwiVmlzaWJsZS1EZXB0aFwiXG4gIGRlc2NzOiAgICAgIFwiVmFsdWUtRGVmaW5pdGlvbnNcIlxuICBkZXY6ICAgICAgICBcIlZlcmJvc2UtTW9kZVwiXG4gIGRyYXc6ICAgICAgIFwiRHJhd1wiXG4gIGVkZ2VzOiAgICAgIFwiRWRnZXMtTGlzdFwiXG4gIGVycm9yOiAgICAgIFwiQ3VzdG9tLUVycm9yLU1lc3NhZ2VcIlxuICBmb2N1czogICAgICBcIkZvY3VzLUVsZW1lbnRcIlxuICBmb250OiAgICAgICBcIkZvbnQtU3R5bGVzXCJcbiAgZm9vdGVyOiAgICAgXCJDdXN0b20tRm9vdGVyXCJcbiAgZm9ybWF0OiAgICAgXCJWYWx1ZS1Gb3JtYXR0aW5nXCJcbiAgaGVpZ2h0OiAgICAgXCJIZWlnaHRcIlxuICBoaXN0b3J5OiAgICBcIlVzZXItSGlzdG9yeVwiXG4gIGhvdmVyOiAgICAgIFwiSG92ZXItRWxlbWVudFwiXG4gIGljb246ICAgICAgIFwiSWNvbi1QYXJhbWV0ZXJzXCJcbiAgaWQ6ICAgICAgICAgXCJVbmlxdWUtSURcIlxuICBrZXl3b3JkczogICBcIktleXdvcmQtUGFyYW1ldGVyc1wiXG4gIGxhYmVsczogICAgIFwiRGF0YS1MYWJlbHNcIlxuICBsZWdlbmQ6ICAgICBcIkxlZ2VuZFwiXG4gIGxpbmtzOiAgICAgIFwiTGluay1TdHlsZXNcIlxuICBtYXJnaW46ICAgICBcIk91dGVyLU1hcmdpbnNcIlxuICBtZXNzYWdlczogICBcIlN0YXR1cy1NZXNzYWdlc1wiXG4gIG1ldGhvZDogICAgIFwiTWV0aG9kc1wiXG4gIG5vZGVzOiAgICAgIFwiTm9kZS1Qb3NpdGlvbnNcIlxuICBvcGVuOiAgICAgICBcIk9wZW5cIlxuICBvcmRlcjogICAgICBcIkRhdGEtT3JkZXJpbmdcIlxuICByZW1vdmU6ICAgICBcIlJlbW92ZVwiXG4gIHNlYXJjaDogICAgIFwiU2VhcmNoLUJveFwiXG4gIHNlbGVjdDogICAgIFwiU2VsZWN0aW5nLUVsZW1lbnRzI3NlbGVjdFwiXG4gIHNlbGVjdEFsbDogIFwiU2VsZWN0aW5nLUVsZW1lbnRzI3NlbGVjdGFsbFwiXG4gIHNoYXBlOiAgICAgIFwiRGF0YS1TaGFwZXNcIlxuICBzaXplOiAgICAgICBcIlNpemUtUGFyYW1ldGVyc1wiXG4gIHRlbXA6ICAgICAgIFwiU2VnbWVudGluZy1EYXRhI3RlbXBcIlxuICB0ZXh0OiAgICAgICBcIlRleHQtUGFyYW1ldGVyc1wiXG4gIHRpbWU6ICAgICAgIFwiVGltZS1QYXJhbWV0ZXJzXCJcbiAgdGltZWxpbmU6ICAgXCJUaW1lbGluZVwiXG4gIHRpbWluZzogICAgIFwiQW5pbWF0aW9uLVRpbWluZ1wiXG4gIHRpdGxlOiAgICAgIFwiQ3VzdG9tLVRpdGxlc1wiXG4gIHRvb2x0aXA6ICAgIFwiVG9vbHRpcC1QYXJhbWV0ZXJzXCJcbiAgdG90YWw6ICAgICAgXCJTZWdtZW50aW5nLURhdGEjdG90YWxcIlxuICB0eXBlOiAgICAgICBcIk91dHB1dC1UeXBlXCJcbiAgdWk6ICAgICAgICAgXCJDdXN0b20tSW50ZXJmYWNlXCJcbiAgd2lkdGg6ICAgICAgXCJXaWR0aFwiXG4gIHg6ICAgICAgICAgIFwiQXhpcy1QYXJhbWV0ZXJzXCJcbiAgeTogICAgICAgICAgXCJBeGlzLVBhcmFtZXRlcnNcIlxuICB6b29tOiAgICAgICBcIlpvb21pbmdcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IGQzcGx1cy53aWtpXG4iLCIjXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4jIEZpbmRzIHRoZSBtYXhpbXVtIGFyZWEgcmVjdGFuZ2xlIHRoYXQgZml0cyBpbnNpZGUgYSBwb2x5Z29uXG4jLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiMgcG9seSBpcyBhbiBhcnJheSBvZiB0d28tZGltZW5zaW9uYWwgYXJyYXlzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHBvaW50cyBvZiB0aGUgcG9seWdvblxuXG4jIG9wdGlvbnMgaXMgYSBkaWN0aW9uYXJ5IG9mIG9wdGlvbnMgd2l0aCBhdHRyaWJ1dGVzXG4gICMgYW5nbGU7IHNwZWNpZmllcyB0aGUgcm90YXRpb24gb2YgdGhlIHBvbHlnb24uIEFuIGFuZ2xlIG9mIHplcm8gbWVhbnMgdGhhdFxuICAjIHRoZSBsb25nZXIgc2lkZSBvZiB0aGUgcG9seWdvbiAodGhlIHdpZHRoKSB3aWxsIGJlIGFsaWduZWQgd2l0aCB0aGUgeCBheGlzLlxuICAjIEFuIGFuZ2xlIG9mICs5MCBhbmQvb3IgLTkwIG1lYW5zIHRoYXQgdGhlIGxvbmdlciBzaWRlIG9mIHRoZSBwb2x5Z29uICh0aGUgd2lkdGgpXG4gICMgd2lsbCBiZSBhbGlnbmVkIHdpdGggdGhlIHkgYXhpcy4gVGhlIHBhcmFtZXRlciBhbmdsZSBjYW4gYmVcbiAgICAjIC0gYSBudW1iZXIgYmV0d2VlbiAtOTAgYW5kICs5MCBzcGVjaWZ5aW5nIHRoZSBhbmdsZSBvZiByb3RhdGlvbiBvZiB0aGUgcG9seWdvbi4gIFxuICAgICMgLSBhIHN0cmluZyB3aGljaCBpcyBwYXJzZWQgdG8gYSBudW1iZXJcbiAgICAjIC0gYW4gYXJyYXkgb2YgbnVtYmVycywgc3BlY2lmeWluZyB0aGUgcG9zc2libGUgcm90YXRpb25zIG9mIHRoZSBwb2x5Z29uXG4gICAgIyAtIHVuc3BlY2lmaWVkLCB3aGljaCBtZWFucyB0aGUgcG9seWdvbiBjYW4gaGF2ZSBhbnkgcG9zc2libGUgYW5nbGVcblxuICAjIGFzcGVjdFJhdGlvOyB0aGUgcmF0aW8gYmV0d2VlbiB0aGUgd2lkdGggYW5kIHRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZSxcbiAgIyBpLmUuIHdpZHRoL2hlaWdodC4gVGhlIHBhcmFtZXRlciBhc3BlY3RSYXRpbyBjYW4gYmVcbiAgICAjIC0gYSBudW1iZXJcbiAgICAjIC0gYSBzdHJpbmcgd2hpY2ggaXMgcGFyc2VkIHRvIGEgbnVtYmVyXG4gICAgIyAtIGFuIGFycmF5IG9mIG51bWJlcnMsIHNwZWNpZnlpbmcgdGhlIHBvc3NpYmxlIGFzcGVjdFJhdGlvcyBvZiB0aGUgcG9seWdvblxuXG4gICMgbWF4QXNwZWN0UmF0aW87IG1heGltdW0gYXNwZWN0IHJhdGlvICh3aWR0aC9oZWlnaHQpLiBEZWZhdWx0IGlzIDE1LlxuICAjIFRoaXMgc2hvdWxkIGJlIHVzZWQgaWYgdGhlIGFzcGVjdFJhdGlvIGlzIG5vdCBwcm92aWRlZC5cblxuICAjIG5UcmllczsgdGhlIG51bWJlciBvZiByYW5kb21seSBkcmF3biBwb2ludHMgaW5zaWRlIHRoZSBwb2x5Z29uIHdoaWNoXG4gICMgdGhlIGFsZ29yaXRobSBleHBsb3JlcyBhcyBwb3NzaWJsZSBjZW50ZXIgcG9pbnRzIG9mIHRoZSBtYXhpbWFsIHJlY3RhbmdsZS5cbiAgIyBEZWZhdWx0IHZhbHVlIGlzIDIwLlxuXG4gICMgbWluV2lkdGg7IHRoZSBtaW5pbXVtIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUuIERlZmF1bHQgaXMgMC5cblxuICAjIG1pbkhlaWdodDsgdGhlIG1pbmltdW0gaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUuIERlZmF1bHQgaXMgMC5cblxuICAjIHRvbGVyYW5jZTsgVGhlIHNpbXBsaWZpY2F0aW9uIHRvbGVyYW5jZSBmYWN0b3IuIFNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kIDEuXG4gICMgRGVmYXVsdCBpcyAwLjAyLiBMYXJnZXIgdG9sZXJhbmNlIGNvcnJlc3BvbmRzIHRvIG1vcmUgZXh0ZW5zaXZlIHNpbXBsaWZpY2F0aW9uLlxuXG4gICMgb3JpZ2luOyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSByZWN0YW5nbGUuIElmIHNwZWNpZmllZCwgdGhlIHJlY3RhbmdsZSBpc1xuICAjIGZpeGVkIGF0IHRoYXQgcG9pbnQsIG90aGVyd2lzZSB0aGUgYWxnb3JpdGhtIG9wdGltaXplcyBhY3Jvc3MgYWxsIHBvc3NpYmxlIHBvaW50cy5cbiAgIyBUaGUgcGFyYW1ldGVyIG9yaWdpbiBjYW4gYmVcbiAgICAjIC0gYSB0d28gZGltZW5zaW9uYWwgYXJyYXkgc3BlY2lmeWluZyB0aGUgeCBhbmQgeSBjb29yZGluYXRlIG9mIHRoZSBvcmlnaW5cbiAgICAjIC0gYW4gYXJyYXkgb2YgdHdvIGRpbWVuc2lvbmFsIGFycmF5cyBzcGVjaWZ5aW5nIHRoZSB0aGUgcG9zc2libGUgY2VudGVyIHBvaW50c1xuICAgICMgb2YgdGhlIG1heGltYWwgcmVjdGFuZ2xlLlxuXG4jIFJldHVybnMgdGhlIGxhcmdlc3QgZm91bmQgcmVjdGFuZ2xlIGFzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlc1xuICAjIHdpZHRoIC0gdGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgIyBoZWlnaHQgLSB0aGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgIyBjeCAtIHRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHJlY3RhbmdsZSdzIGNlbnRlclxuICAjIGN5IC0gdGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgcmVjdGFuZ2xlJ3MgY2VudGVyXG4gICMgYW5nbGUgLSByb3RhdGlvbiBhbmdsZSBpbiBkZWdyZWVzLiBUaGUgYW5jaG9yIG9mIHJvdGF0aW9uIGlzIHRoZSBjZW50ZXIgcG9pbnRcblxuc2ltcGxpZnkgPSByZXF1aXJlICdzaW1wbGlmeS1qcydcblxuZDNwbHVzLmdlb20ubGFyZ2VzdFJlY3QgPSAocG9seSwgb3B0aW9ucykgLT5cbiAgaWYgcG9seS5sZW5ndGggPCAzXG4gICAgZDNwbHVzLmNvbnNvbGUuZXJyb3IgJ3BvbHlnb24gaGFzIHRvIGhhdmUgYXQgbGVhc3QgMyBwb2ludHMnXG4gICAgcmV0dXJuIG51bGxcbiAgIyMgRm9yIHZpc3VhbGl6YXRpb24gZGVidWdnaW5nIHB1cnBvc2VzICMjXG4gIGV2ZW50cyA9IFtdXG5cbiAgIyMjIyMjIyMjIyBBbGdvcml0aG0gY29uc3RhbnRzICMjIyMjIyMjIyNcbiAgIyBzdGVwIHNpemUgZm9yIHRoZSBhc3BlY3QgcmF0aW9cbiAgYXNwZWN0UmF0aW9TdGVwID0gMC41XG4gICMgc3RlcCBzaXplIGZvciBhbmdsZXMgKGluIGRlZ3JlZXMpOyBoYXMgbGluZWFyIGltcGFjdCBvbiBydW5uaW5nIHRpbWVcbiAgYW5nbGVTdGVwID0gNVxuICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuXG4gICMjIyMjIFVzZXIncyBpbnB1dCBub3JtYWxpemF0aW9uICMjIyMjXG4gIGlmIG5vdCBvcHRpb25zPyB0aGVuIG9wdGlvbnMgPSB7fVxuICAjIG1heGltdW0gYWxsb3dlZCBhc3BlY3QgcmF0aW8gZm9yIHRoZSByZWN0YW5nbGUgc29sdXRpb25cbiAgaWYgbm90IG9wdGlvbnMubWF4QXNwZWN0UmF0aW8/IHRoZW4gb3B0aW9ucy5tYXhBc3BlY3RSYXRpbyA9IDE1XG4gIGlmIG5vdCBvcHRpb25zLm1pbldpZHRoPyB0aGVuIG9wdGlvbnMubWluV2lkdGggPSAwXG4gIGlmIG5vdCBvcHRpb25zLm1pbkhlaWdodD8gdGhlbiBvcHRpb25zLm1pbkhlaWdodCA9IDBcbiAgaWYgbm90IG9wdGlvbnMudG9sZXJhbmNlPyB0aGVuIG9wdGlvbnMudG9sZXJhbmNlID0gMC4wMlxuICBpZiBub3Qgb3B0aW9ucy5uVHJpZXM/IHRoZW4gb3B0aW9ucy5uVHJpZXMgPSAyMCAjIERlZmF1bHQgdmFsdWUgZm9yIHRoZSBudW1iZXIgb2YgcG9zc2libGUgY2VudGVyIHBvaW50cyBvZiB0aGUgbWF4aW1hbCByZWN0YW5nbGVcbiAgXG4gIGlmIG9wdGlvbnMuYW5nbGU/XG4gICAgaWYgb3B0aW9ucy5hbmdsZSBpbnN0YW5jZW9mIEFycmF5IHRoZW4gYW5nbGVzID0gb3B0aW9ucy5hbmdsZVxuICAgIGVsc2UgaWYgdHlwZW9mIG9wdGlvbnMuYW5nbGUgaXMgJ251bWJlcicgdGhlbiBhbmdsZXMgPSBbb3B0aW9ucy5hbmdsZV1cbiAgICBlbHNlIGlmIHR5cGVvZiBvcHRpb25zLmFuZ2xlIGlzICdzdHJpbmcnIGFuZCBub3QgaXNOYU4ob3B0aW9ucy5hbmdsZSkgdGhlbiBhbmdsZXMgPSBbTnVtYmVyKG9wdGlvbnMuYW5nbGUpXVxuICBpZiBub3QgYW5nbGVzPyB0aGVuIGFuZ2xlcyA9IGQzLnJhbmdlIC05MCwgOTArYW5nbGVTdGVwLCBhbmdsZVN0ZXBcbiAgXG4gIGlmIG9wdGlvbnMuYXNwZWN0UmF0aW8/XG4gICAgaWYgb3B0aW9ucy5hc3BlY3RSYXRpbyBpbnN0YW5jZW9mIEFycmF5IHRoZW4gYXNwZWN0UmF0aW9zID0gb3B0aW9ucy5hc3BlY3RSYXRpb1xuICAgIGVsc2UgaWYgdHlwZW9mIG9wdGlvbnMuYXNwZWN0UmF0aW8gaXMgJ251bWJlcicgdGhlbiBhc3BlY3RSYXRpb3MgPSBbb3B0aW9ucy5hc3BlY3RSYXRpb11cbiAgICBlbHNlIGlmIHR5cGVvZiBvcHRpb25zLmFzcGVjdFJhdGlvIGlzICdzdHJpbmcnIGFuZCBub3QgaXNOYU4ob3B0aW9ucy5hc3BlY3RSYXRpbykgdGhlbiBhc3BlY3RSYXRpb3MgPSBbTnVtYmVyKG9wdGlvbnMuYXNwZWN0UmF0aW8pXVxuICBcbiAgaWYgb3B0aW9ucy5vcmlnaW4/XG4gICAgaWYgb3B0aW9ucy5vcmlnaW4gaW5zdGFuY2VvZiBBcnJheVxuICAgICAgaWYgb3B0aW9ucy5vcmlnaW5bMF0gaW5zdGFuY2VvZiBBcnJheSB0aGVuIG9yaWdpbnMgPSBvcHRpb25zLm9yaWdpblxuICAgICAgZWxzZSBvcmlnaW5zID0gW29wdGlvbnMub3JpZ2luXVxuXG5cbiAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuICBhcmVhID0gTWF0aC5hYnMoZDMuZ2VvbS5wb2x5Z29uKHBvbHkpLmFyZWEoKSkgIyB0YWtlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBzaWduZWQgYXJlYVxuICBpZiBhcmVhIGlzIDBcbiAgICBkM3BsdXMuY29uc29sZS5lcnJvciAncG9seWdvbiBoYXMgMCBhcmVhJ1xuICAgIHJldHVybiBudWxsXG4gICMgZ2V0IHRoZSB3aWR0aCBvZiB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBvcmlnaW5hbCBwb2x5Z29uIHRvIGRldGVybWluZSB0b2xlcmFuY2VcbiAgW21pbngsIG1heHhdID0gZDMuZXh0ZW50IHBvbHksIChkKSAtPiBkWzBdXG4gIFttaW55LCBtYXh5XSA9IGQzLmV4dGVudCBwb2x5LCAoZCkgLT4gZFsxXVxuXG4gICMgc2ltcGxpZnkgcG9seWdvblxuICB0b2xlcmFuY2UgPSBNYXRoLm1pbihtYXh4IC0gbWlueCwgbWF4eSAtIG1pbnkpICogb3B0aW9ucy50b2xlcmFuY2VcbiAgdGVtcFBvbHkgPSAoe3g6cFswXSwgeTpwWzFdfSBmb3IgcCBpbiBwb2x5KVxuXG4gIGlmIHRvbGVyYW5jZSA+IDBcbiAgICB0ZW1wUG9seSA9IHNpbXBsaWZ5IHRlbXBQb2x5LCB0b2xlcmFuY2VcbiAgICBwb2x5ID0gKFtwLngsIHAueV0gZm9yIHAgaW4gdGVtcFBvbHkpXG4gIGlmIG9wdGlvbnMudmRlYnVnIHRoZW4gZXZlbnRzLnB1c2ggdHlwZTogJ3NpbXBsaWZ5JywgcG9seTogcG9seVxuICBcbiAgIyBnZXQgdGhlIHdpZHRoIG9mIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIHNpbXBsaWZpZWQgcG9seWdvblxuICBbbWlueCwgbWF4eF0gPSBkMy5leHRlbnQgcG9seSwgKGQpIC0+IGRbMF1cbiAgW21pbnksIG1heHldID0gZDMuZXh0ZW50IHBvbHksIChkKSAtPiBkWzFdXG4gIGJCb3ggPSBbW21pbngsIG1pbnldLCBbbWF4eCwgbWlueV0sIFttYXh4LCBtYXh5XSAsW21pbngsIG1heHldXVxuICBbYm94V2lkdGgsIGJveEhlaWdodF0gPSBbbWF4eCAtIG1pbngsIG1heHkgLSBtaW55XVxuICBcbiAgIyBkaXNjcmV0aXplIHRoZSBiaW5hcnkgc2VhcmNoIGZvciBvcHRpbWFsIHdpZHRoIHRvIGEgcmVzb2x1dGlvbiBvZiB0aGlzIHRpbWVzIHRoZSBwb2x5Z29uIHdpZHRoXG4gIHdpZHRoU3RlcCA9IE1hdGgubWluKGJveFdpZHRoLCBib3hIZWlnaHQpLzUwXG4gIFxuICAjIHBvcHVsYXRlIHBvc3NpYmxlIGNlbnRlciBwb2ludHMgd2l0aCByYW5kb20gcG9pbnRzIGluc2lkZSB0aGUgcG9seWdvblxuICBpZiBub3Qgb3JpZ2lucz9cbiAgICBvcmlnaW5zID0gW11cbiAgICAjIGdldCB0aGUgY2VudHJvaWQgb2YgdGhlIHBvbHlnb25cbiAgICBjZW50cm9pZCA9IGQzLmdlb20ucG9seWdvbihwb2x5KS5jZW50cm9pZCgpXG4gICAgaWYgcG9pbnRJblBvbHkoY2VudHJvaWQsIHBvbHkpIHRoZW4gb3JpZ2lucy5wdXNoIGNlbnRyb2lkXG4gICAgIyBnZXQgZmV3IG1vcmUgcG9pbnRzIGluc2lkZSB0aGUgcG9seWdvblxuICAgIHdoaWxlIG9yaWdpbnMubGVuZ3RoIDwgb3B0aW9ucy5uVHJpZXNcbiAgICAgIHJuZFggPSBNYXRoLnJhbmRvbSgpICogYm94V2lkdGggKyBtaW54XG4gICAgICBybmRZID0gTWF0aC5yYW5kb20oKSAqIGJveEhlaWdodCArIG1pbnlcbiAgICAgIHJuZFBvaW50ID0gW3JuZFgsIHJuZFldXG4gICAgICBpZiBwb2ludEluUG9seShybmRQb2ludCwgcG9seSkgdGhlbiBvcmlnaW5zLnB1c2ggcm5kUG9pbnRcbiAgaWYgb3B0aW9ucy52ZGVidWcgdGhlbiBldmVudHMucHVzaCB0eXBlOiAnb3JpZ2lucycsIHBvaW50czogb3JpZ2luc1xuICBtYXhBcmVhID0gMFxuICBtYXhSZWN0ID0gbnVsbFxuICBmb3IgYW5nbGUgaW4gYW5nbGVzXG4gICAgYW5nbGVSYWQgPSAtYW5nbGUqTWF0aC5QSS8xODBcbiAgICBpZiBvcHRpb25zLnZkZWJ1ZyB0aGVuIGV2ZW50cy5wdXNoXG4gICAgICB0eXBlOiAnYW5nbGUnXG4gICAgICBhbmdsZTogYW5nbGVcbiAgICBmb3Igb3JpZ09yaWdpbiwgaSBpbiBvcmlnaW5zXG4gICAgICAjIGdlbmVyYXRlIGltcHJvdmVkIG9yaWdpbnNcbiAgICAgIFtwMVcsIHAyV10gPSBpbnRlcnNlY3RQb2ludHMgcG9seSwgb3JpZ09yaWdpbiwgYW5nbGVSYWRcbiAgICAgIFtwMUgsIHAySF0gPSBpbnRlcnNlY3RQb2ludHMgcG9seSwgb3JpZ09yaWdpbiwgYW5nbGVSYWQgKyBNYXRoLlBJLzJcbiAgICAgIG1vZGlmT3JpZ2lucyA9IFtdXG4gICAgICBpZiBwMVc/IGFuZCBwMlc/IHRoZW4gbW9kaWZPcmlnaW5zLnB1c2ggWyhwMVdbMF0gKyBwMldbMF0pLzIsIChwMVdbMV0gKyBwMldbMV0pLzJdICMgYXZlcmFnZSBhbG9uZyB3aXRoIHdpZHRoIGF4aXNcbiAgICAgIGlmIHAxSD8gYW5kIHAySD8gdGhlbiBtb2RpZk9yaWdpbnMucHVzaCBbKHAxSFswXSArIHAySFswXSkvMiwgKHAxSFsxXSArIHAySFsxXSkvMl0gIyBhdmVyYWdlIGFsb25nIHdpdGggaGVpZ2h0IGF4aXNcbiAgICAgIFxuICAgICAgaWYgb3B0aW9ucy52ZGVidWcgdGhlbiBldmVudHMucHVzaCB0eXBlOiAnbW9kaWZPcmlnaW4nLCBpZHg6IGksIHAxVzogcDFXLCBwMlc6IHAyVywgcDFIOiBwMUgsIHAySDogcDJILCBtb2RpZk9yaWdpbnM6IG1vZGlmT3JpZ2luc1xuICAgICAgZm9yIG9yaWdpbiBpbiBtb2RpZk9yaWdpbnNcbiAgICAgICAgaWYgb3B0aW9ucy52ZGVidWcgdGhlbiBldmVudHMucHVzaCB0eXBlOiAnb3JpZ2luJywgY3g6IG9yaWdpblswXSwgY3k6IG9yaWdpblsxXVxuICAgICAgICBbcDFXLCBwMlddID0gaW50ZXJzZWN0UG9pbnRzIHBvbHksIG9yaWdpbiwgYW5nbGVSYWRcbiAgICAgICAgbWluU3FEaXN0VyA9IE1hdGgubWluIHNxdWFyZWREaXN0KG9yaWdpbiwgcDFXKSwgc3F1YXJlZERpc3Qob3JpZ2luLCBwMlcpXG4gICAgICAgIG1heFdpZHRoID0gMipNYXRoLnNxcnQobWluU3FEaXN0VylcbiAgICAgICAgXG4gICAgICAgIFtwMUgsIHAySF0gPSBpbnRlcnNlY3RQb2ludHMgcG9seSwgb3JpZ2luLCBhbmdsZVJhZCArIE1hdGguUEkvMlxuICAgICAgICBtaW5TcURpc3RIID0gTWF0aC5taW4gc3F1YXJlZERpc3Qob3JpZ2luLCBwMUgpLCBzcXVhcmVkRGlzdChvcmlnaW4sIHAySClcbiAgICAgICAgbWF4SGVpZ2h0ID0gMipNYXRoLnNxcnQobWluU3FEaXN0SClcbiAgICAgICAgY29udGludWUgaWYgbWF4V2lkdGggKiBtYXhIZWlnaHQgPCBtYXhBcmVhXG4gICAgICAgIGlmIGFzcGVjdFJhdGlvcz8gdGhlbiBhUmF0aW9zID0gYXNwZWN0UmF0aW9zXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBtaW5Bc3BlY3RSYXRpbyA9IE1hdGgubWF4IDEsIG9wdGlvbnMubWluV2lkdGggLyBtYXhIZWlnaHQsIG1heEFyZWEvKG1heEhlaWdodCptYXhIZWlnaHQpXG4gICAgICAgICAgbWF4QXNwZWN0UmF0aW8gPSBNYXRoLm1pbiBvcHRpb25zLm1heEFzcGVjdFJhdGlvLCBtYXhXaWR0aC9vcHRpb25zLm1pbkhlaWdodCwgKG1heFdpZHRoKm1heFdpZHRoKS9tYXhBcmVhXG4gICAgICAgICAgYVJhdGlvcyA9IGQzLnJhbmdlKG1pbkFzcGVjdFJhdGlvLCBtYXhBc3BlY3RSYXRpbyArIGFzcGVjdFJhdGlvU3RlcCwgYXNwZWN0UmF0aW9TdGVwKVxuICAgICAgICBmb3IgYVJhdGlvIGluIGFSYXRpb3NcbiAgICAgICAgICAjIGRvIGEgYmluYXJ5IHNlYXJjaCB0byBmaW5kIHRoZSBtYXggd2lkdGggdGhhdCB3b3Jrc1xuICAgICAgICAgIGxlZnQgPSBNYXRoLm1heCBvcHRpb25zLm1pbldpZHRoLCBNYXRoLnNxcnQobWF4QXJlYSphUmF0aW8pXG4gICAgICAgICAgcmlnaHQgPSBNYXRoLm1pbiBtYXhXaWR0aCwgbWF4SGVpZ2h0KmFSYXRpb1xuICAgICAgICAgIGNvbnRpbnVlIGlmIHJpZ2h0ICogbWF4SGVpZ2h0IDwgbWF4QXJlYVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChyaWdodCAtIGxlZnQpID49IHdpZHRoU3RlcFxuICAgICAgICAgICAgaWYgb3B0aW9ucy52ZGVidWcgdGhlbiBldmVudHMucHVzaCB0eXBlOiAnYVJhdGlvJywgYVJhdGlvOiBhUmF0aW9cbiAgICAgICAgICBcbiAgICAgICAgICB3aGlsZSAocmlnaHQgLSBsZWZ0KSA+PSB3aWR0aFN0ZXBcbiAgICAgICAgICAgIHdpZHRoID0gKGxlZnQgKyByaWdodCkgLyAyXG4gICAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIGFSYXRpb1xuICAgICAgICAgICAgW3gwLCB5MF0gPSBvcmlnaW5cbiAgICAgICAgICAgIHJlY3RQb2x5ID0gW1xuICAgICAgICAgICAgICBbeDAgLSB3aWR0aC8yLCB5MCAtIGhlaWdodC8yXSxcbiAgICAgICAgICAgICAgW3gwICsgd2lkdGgvMiwgeTAgLSAgaGVpZ2h0LzJdLFxuICAgICAgICAgICAgICBbeDAgKyB3aWR0aC8yLCB5MCArIGhlaWdodC8yXSxcbiAgICAgICAgICAgICAgW3gwIC0gd2lkdGgvMiwgeTAgKyBoZWlnaHQvMl1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgIHJlY3RQb2x5ID0gcm90YXRlUG9seSByZWN0UG9seSwgYW5nbGVSYWQsIG9yaWdpblxuICAgICAgICAgICAgaWYgcG9seUluc2lkZVBvbHkocmVjdFBvbHksIHBvbHkpXG4gICAgICAgICAgICAgIGluc2lkZVBvbHkgPSB0cnVlXG4gICAgICAgICAgICAgICMgd2Uga25vdyB0aGF0IHRoZSBhcmVhIGlzIGFscmVhZHkgZ3JlYXRlciB0aGFuIHRoZSBtYXhBcmVhIGZvdW5kIHNvIGZhclxuICAgICAgICAgICAgICBtYXhBcmVhID0gd2lkdGggKiBoZWlnaHRcbiAgICAgICAgICAgICAgbWF4UmVjdCA9IFxuICAgICAgICAgICAgICAgIGN4OiB4MFxuICAgICAgICAgICAgICAgIGN5OiB5MFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgYW5nbGU6IGFuZ2xlXG4gICAgICAgICAgICAgIGxlZnQgPSB3aWR0aCAjIGluY3JlYXNlIHRoZSB3aWR0aCBpbiB0aGUgYmluYXJ5IHNlYXJjaFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBpbnNpZGVQb2x5ID0gZmFsc2VcbiAgICAgICAgICAgICAgcmlnaHQgPSB3aWR0aCAjIGRlY3JlYXNlIHRoZSB3aWR0aCBpbiB0aGUgYmluYXJ5IHNlYXJjaFxuICAgICAgICAgICAgaWYgb3B0aW9ucy52ZGVidWcgdGhlbiBldmVudHMucHVzaFxuICAgICAgICAgICAgICB0eXBlOiAncmVjdGFuZ2xlJ1xuICAgICAgICAgICAgICBjeDogeDBcbiAgICAgICAgICAgICAgY3k6IHkwXG4gICAgICAgICAgICAgIHdpZHRoOiB3aWR0aFxuICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgICBhcmVhRnJhY3Rpb246ICh3aWR0aCpoZWlnaHQpL2FyZWFcbiAgICAgICAgICAgICAgYW5nbGU6IGFuZ2xlXG4gICAgICAgICAgICAgIGluc2lkZVBvbHk6IGluc2lkZVBvbHlcbiAgcmV0dXJuIFttYXhSZWN0LCBtYXhBcmVhLCBldmVudHNdXG5cblxuI15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuIyBIZWxwZXIgZnVuY3Rpb25zXG4jLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiMgUmV0dXJucyB0aGUgc3F1YXJlZCBldWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMgYSBhbmQgYlxuc3F1YXJlZERpc3QgPSAoYSwgYikgLT5cbiAgZGVsdGF4ID0gYlswXSAtIGFbMF1cbiAgZGVsdGF5ID0gYlsxXSAtIGFbMV1cbiAgcmV0dXJuIGRlbHRheCpkZWx0YXggKyBkZWx0YXkqZGVsdGF5XG5cblxuIyBDaGVja3Mgd2hldGhlciB0aGUgaG9yaXpvbnRhbCByYXkgZ29pbmcgdGhyb3VnaCBwb2ludCBwIGludGVyc2VjdHMgdGhlIHNlZ21lbnQgcDFwMlxuIyBJbXBsZW1lbnRhdGlvbiBmcm9tOiBodHRwOi8vcm9zZXR0YWNvZGUub3JnL3dpa2kvUmF5LWNhc3RpbmdfYWxnb3JpdGhtI0NvZmZlZVNjcmlwdFxucmF5SW50ZXJzZWN0c1NlZ21lbnQgPSAocCwgcDEsIHAyKSAtPlxuICBbYSwgYl0gPSBpZiBwMVsxXSA8IHAyWzFdIHRoZW4gW3AxLCBwMl0gZWxzZSBbcDIsIHAxXVxuICBpZiBwWzFdIGlzIGJbMV0gb3IgcFsxXSBpcyBhWzFdXG4gICAgcFsxXSArPSBOdW1iZXIuTUlOX1ZBTFVFXG4gIGlmIHBbMV0gPiBiWzFdIG9yIHBbMV0gPCBhWzFdIHRoZW4gZmFsc2VcbiAgZWxzZSBpZiBwWzBdID4gYVswXSBhbmQgcFswXSA+IGJbMF0gdGhlbiBmYWxzZVxuICBlbHNlIGlmIHBbMF0gPCBhWzBdIGFuZCBwWzBdIDwgYlswXSB0aGVuIHRydWVcbiAgZWxzZVxuICAgIG1BQiA9IChiWzFdIC0gYVsxXSkgLyAoYlswXSAtIGFbMF0pXG4gICAgbUFQID0gKHBbMV0gLSBhWzFdKSAvIChwWzBdIC0gYVswXSlcbiAgICBtQVAgPiBtQUJcblxuIyBDaGVja3Mgd2hldGhlciB0aGUgcG9pbnQgcCBpcyBpbnNpZGUgYSBwb2x5Z29uIHVzaW5nIHRoZSBSYXktQ2FzdGluZyBhbGdvcml0aG1cbiMgSW1wbGVtZW50YXRpb24gZnJvbTogaHR0cDovL3Jvc2V0dGFjb2RlLm9yZy93aWtpL1JheS1jYXN0aW5nX2FsZ29yaXRobSNDb2ZmZWVTY3JpcHRcbnBvaW50SW5Qb2x5ID0gKHAsIHBvbHkpIC0+XG4gIGkgPSAtMVxuICBuID0gcG9seS5sZW5ndGhcbiAgYiA9IHBvbHlbbi0xXVxuICBjID0gMFxuICB3aGlsZSArK2kgPCBuXG4gICAgYSA9IGJcbiAgICBiID0gcG9seVtpXVxuICAgIGMrKyBpZiByYXlJbnRlcnNlY3RzU2VnbWVudChwLCBhLCBiKVxuICByZXR1cm4gYyAlIDIgaXNudCAwXG5cbiMgQ2hlY2tzIHdoZXRoZXIgdGhlIHBvaW50IHAgaXMgaW5zaWRlIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGxpbmUgc2VnbWVudCBwMXExXG5wb2ludEluU2VnbWVudEJveCA9IChwLCBwMSwgcTEpIC0+XG4gICMgYWxsb3cgZm9yIHNvbWUgbWFyZ2lucyBkdWUgdG8gbnVtZXJpY2FsIGVycm9yc1xuICBlcHMgPSAxZS05XG4gIFtweCwgcHldID0gcFxuICByZXR1cm4gZmFsc2UgaWYgcHggPCBNYXRoLm1pbihwMVswXSwgcTFbMF0pIC0gZXBzIG9yXG4gICAgcHggPiBNYXRoLm1heChwMVswXSwgcTFbMF0pICsgZXBzIG9yXG4gICAgcHkgPCBNYXRoLm1pbihwMVsxXSwgcTFbMV0pIC0gZXBzIG9yXG4gICAgcHkgPiBNYXRoLm1heChwMVsxXSwgcTFbMV0pICsgZXBzXG4gIHJldHVybiB0cnVlXG5cbiMgRmluZHMgdGhlIGludGVyc2VjdGlvbiBwb2ludCAoaWYgdGhlcmUgaXMgb25lKSBvZiB0aGUgbGluZXMgcDFxMSBhbmQgcDJxMlxubGluZUludGVyc2VjdGlvbiA9IChwMSwgcTEsIHAyLCBxMikgLT5cbiAgIyBhbGxvdyBmb3Igc29tZSBtYXJnaW5zIGR1ZSB0byBudW1lcmljYWwgZXJyb3JzXG4gIGVwcyA9IDFlLTlcbiAgIyBmaW5kIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnQgYmV0d2VlbiB0aGUgdHdvIGluZmluaXRlIGxpbmVzXG4gIGR4MSA9IHAxWzBdIC0gcTFbMF1cbiAgZHkxID0gcDFbMV0gLSBxMVsxXVxuICBkeDIgPSBwMlswXSAtIHEyWzBdXG4gIGR5MiA9IHAyWzFdIC0gcTJbMV1cbiAgZGVub20gPSBkeDEgKiBkeTIgLSBkeTEgKiBkeDJcbiAgcmV0dXJuIG51bGwgaWYgTWF0aC5hYnMoZGVub20pIDwgZXBzXG4gIGNyb3NzMSA9IHAxWzBdKnExWzFdIC0gcDFbMV0qcTFbMF1cbiAgY3Jvc3MyID0gcDJbMF0qcTJbMV0gLSBwMlsxXSpxMlswXVxuXG4gIHB4ID0gKGNyb3NzMSpkeDIgLSBjcm9zczIqZHgxKSAvIGRlbm9tXG4gIHB5ID0gKGNyb3NzMSpkeTIgLSBjcm9zczIqZHkxKSAvIGRlbm9tXG4gIHJldHVybiBbcHgsIHB5XVxuXG4jIENoZWNrcyB3aGV0aGVyIHRoZSBsaW5lIHNlZ21lbnRzIHAxcTEgYW5kIHAycTIgaW50ZXJzZWN0XG5zZWdtZW50c0ludGVyc2VjdCA9IChwMSwgcTEsIHAyLCBxMikgLT5cbiAgcCA9IGxpbmVJbnRlcnNlY3Rpb24gcDEsIHExLCBwMiwgcTJcbiAgcmV0dXJuIGZhbHNlIGlmIG5vdCBwP1xuICByZXR1cm4gcG9pbnRJblNlZ21lbnRCb3gocCwgcDEsIHExKSBhbmQgcG9pbnRJblNlZ21lbnRCb3gocCwgcDIsIHEyKVxuXG4jIENoZWNrIGlmIHBvbHlnb24gcG9seUEgaXMgaW5zaWRlIHBvbHlnb24gcG9seUJcbnBvbHlJbnNpZGVQb2x5ID0gKHBvbHlBLCBwb2x5QikgLT5cbiAgaUEgPSAtMVxuICBuQSA9IHBvbHlBLmxlbmd0aFxuICBuQiA9IHBvbHlCLmxlbmd0aFxuICBiQSA9IHBvbHlBW25BLTFdXG4gIFxuICB3aGlsZSArK2lBIDwgbkFcbiAgICBhQSA9IGJBXG4gICAgYkEgPSBwb2x5QVtpQV1cbiAgICBcbiAgICBpQiA9IC0xXG4gICAgYkIgPSBwb2x5QltuQi0xXVxuICAgIHdoaWxlICsraUIgPCBuQlxuICAgICAgYUIgPSBiQlxuICAgICAgYkIgPSBwb2x5QltpQl1cbiAgICAgIHJldHVybiBmYWxzZSBpZiBzZWdtZW50c0ludGVyc2VjdCBhQSwgYkEsIGFCLCBiQlxuXG4gIHJldHVybiBwb2ludEluUG9seSBwb2x5QVswXSwgcG9seUJcblxuIyBSb3RhdGVzIHRoZSBwb2ludCBwIGZvciBhbHBoYSByYWRpYW5zIGFyb3VuZCB0aGUgb3JpZ2luIFxucm90YXRlUG9pbnQgPSAocCwgYWxwaGEsIG9yaWdpbikgLT5cbiAgaWYgbm90IG9yaWdpbj8gdGhlbiBvcmlnaW4gPSBbMCwwXVxuICB4c2hpZnRlZCA9IHBbMF0gLSBvcmlnaW5bMF1cbiAgeXNoaWZ0ZWQgPSBwWzFdIC0gb3JpZ2luWzFdXG4gIGNvc0FscGhhID0gTWF0aC5jb3MgYWxwaGFcbiAgc2luQWxwaGEgPSBNYXRoLnNpbiBhbHBoYVxuICByZXR1cm4gWyBjb3NBbHBoYSAqIHhzaGlmdGVkIC0gc2luQWxwaGEgKiB5c2hpZnRlZCArIG9yaWdpblswXSxcbiAgICAgICAgICAgc2luQWxwaGEgKiB4c2hpZnRlZCArIGNvc0FscGhhICogeXNoaWZ0ZWQgKyBvcmlnaW5bMV1cbiAgXVxuXG4jIFJvdGF0ZXMgdGhlIHBvbHlnb24gZm9yIGFscGhhIHJhZGlhbnMgYXJvdW5kIHRoZSBvcmlnaW4gIFxucm90YXRlUG9seSA9IChwb2x5LCBhbHBoYSwgb3JpZ2luKSAtPiByb3RhdGVQb2ludChwb2ludCwgYWxwaGEsIG9yaWdpbikgZm9yIHBvaW50IGluIHBvbHlcblxuIyBHaXZlcyB0aGUgMiBjbG9zZXN0IGludGVyc2VjdGlvbiBwb2ludHMgYmV0d2VlbiBhIHJheSB3aXRoIGFscGhhIHJhZGlhbnNcbiMgZnJvbSB0aGUgb3JpZ2luIGFuZCB0aGUgcG9seWdvbi4gVGhlIHR3byBwb2ludHMgc2hvdWxkIGxpZSBvbiBvcHBvc2l0ZSBzaWRlcyBvZiB0aGUgb3JpZ2luXG5pbnRlcnNlY3RQb2ludHMgPSAocG9seSwgb3JpZ2luLCBhbHBoYSkgLT4gIFxuICBlcHMgPSAxZS05XG4gIG9yaWdpbiA9IFtvcmlnaW5bMF0gKyBlcHMqTWF0aC5jb3MoYWxwaGEpLCBvcmlnaW5bMV0gKyBlcHMqTWF0aC5zaW4oYWxwaGEpXVxuICBbeDAsIHkwXSA9IG9yaWdpblxuICBzaGlmdGVkT3JpZ2luID0gW3gwICsgTWF0aC5jb3MoYWxwaGEpLCB5MCArIE1hdGguc2luKGFscGhhKV1cbiAgXG4gIGlkeCA9IDBcbiAgaWYgTWF0aC5hYnMoc2hpZnRlZE9yaWdpblswXSAtIHgwKSA8IGVwcyB0aGVuIGlkeCA9IDFcbiAgaSA9IC0xXG4gIG4gPSBwb2x5Lmxlbmd0aFxuICBiID0gcG9seVtuLTFdXG4gIG1pblNxRGlzdExlZnQgPSBOdW1iZXIuTUFYX1ZBTFVFXG4gIG1pblNxRGlzdFJpZ2h0ID0gTnVtYmVyLk1BWF9WQUxVRVxuICBjbG9zZXN0UG9pbnRMZWZ0ID0gbnVsbFxuICBjbG9zZXN0UG9pbnRSaWdodCA9IG51bGxcbiAgd2hpbGUgKytpIDwgblxuICAgIGEgPSBiXG4gICAgYiA9IHBvbHlbaV1cbiAgICBwID0gbGluZUludGVyc2VjdGlvbiBvcmlnaW4sIHNoaWZ0ZWRPcmlnaW4sIGEsIGJcbiAgICBpZiBwPyBhbmQgcG9pbnRJblNlZ21lbnRCb3ggcCwgYSwgYlxuICAgICAgc3FEaXN0ID0gc3F1YXJlZERpc3Qgb3JpZ2luLCBwXG4gICAgICBpZiBwW2lkeF0gPCBvcmlnaW5baWR4XVxuICAgICAgICBpZiBzcURpc3QgPCBtaW5TcURpc3RMZWZ0XG4gICAgICAgICAgbWluU3FEaXN0TGVmdCA9IHNxRGlzdFxuICAgICAgICAgIGNsb3Nlc3RQb2ludExlZnQgPSBwXG4gICAgICBlbHNlIGlmIHBbaWR4XSA+IG9yaWdpbltpZHhdXG4gICAgICAgIGlmIHNxRGlzdCA8IG1pblNxRGlzdFJpZ2h0XG4gICAgICAgICAgbWluU3FEaXN0UmlnaHQgPSBzcURpc3RcbiAgICAgICAgICBjbG9zZXN0UG9pbnRSaWdodCA9IHBcbiAgcmV0dXJuIFtjbG9zZXN0UG9pbnRMZWZ0LCBjbG9zZXN0UG9pbnRSaWdodF1cbiIsImQzcGx1cyAgICAgICAgICAgICAgID0gd2luZG93LmQzcGx1cyBvciB7fVxud2luZG93LmQzcGx1cyAgICAgICAgPSBkM3BsdXNcblxuZDNwbHVzLnZlcnNpb24gICAgICAgPSBcIjEuNS4wIC0gQXF1YVwiXG5kM3BsdXMucmVwbyAgICAgICAgICA9IFwiaHR0cHM6Ly9naXRodWIuY29tL2FsZXhhbmRlcnNpbW9lcy9kM3BsdXMvXCJcblxuZDNwbHVzLmFycmF5ICAgICAgICAgPSB7fVxuZDNwbHVzLmNvbG9yICAgICAgICAgPSB7fVxuZDNwbHVzLmRhdGEgICAgICAgICAgPSB7fVxuZDNwbHVzLmRyYXcgICAgICAgICAgPSB7fVxuZDNwbHVzLmZvbnQgICAgICAgICAgPSB7fVxuZDNwbHVzLmdlb20gICAgICAgICAgPSB7fVxuZDNwbHVzLmxvY2FsZSAgICAgICAgPSB7fVxuZDNwbHVzLm1ldGhvZCAgICAgICAgPSB7fVxuZDNwbHVzLm5ldHdvcmsgICAgICAgPSB7fVxuZDNwbHVzLm51bWJlciAgICAgICAgPSB7fVxuZDNwbHVzLm9iamVjdCAgICAgICAgPSB7fVxuZDNwbHVzLnNoYXBlICAgICAgICAgPSB7fVxuZDNwbHVzLnN0cmluZyAgICAgICAgPSB7fVxuZDNwbHVzLnN0eWxlICAgICAgICAgPSB7fVxuZDNwbHVzLnRvb2x0aXAgICAgICAgPSB7fVxuZDNwbHVzLnVpICAgICAgICAgICAgPSB7fVxuZDNwbHVzLnV0aWwgICAgICAgICAgPSB7fVxuZDNwbHVzLnpvb20gICAgICAgICAgPSB7fVxuXG5zdHlsZXNoZWV0ICAgICAgICAgICA9IHJlcXVpcmUgXCIuL3N0eWxlL3NoZWV0LmNvZmZlZVwiXG5tZXNzYWdlICAgICAgICAgICAgICA9IHJlcXVpcmUgXCIuL2dlbmVyYWwvY29uc29sZS5jb2ZmZWVcIlxuXG5pZiBzdHlsZXNoZWV0IFwiZDNwbHVzLmNzc1wiXG4gIG1lc3NhZ2Uud2FybmluZyBcImQzcGx1cy5jc3MgaGFzIGJlZW4gZGVwcmVjYXRlZCwgeW91IGRvIG5vdCBuZWVkIHRvIGxvYWQgdGhpcyBmaWxlLlwiLCBcImh0dHBzOi8vZ2l0aHViLmNvbS9hbGV4YW5kZXJzaW1vZXMvZDNwbHVzL3JlbGVhc2VzL3RhZy92MS40LjBcIlxuIixudWxsLCJkM3BsdXMubG9jYWxlLmVuX1VTID0ge1xuXG4gIFwiZGV2XCIgICAgICAgICAgOiB7XG5cbiAgICBcImFjY2VwdGVkXCIgICAgIDogXCJ7MH0gaXMgbm90IGFuIGFjY2VwdGVkIHZhbHVlIGZvciB7MX0sIHBsZWFzZSB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmc6IHsyfS5cIixcbiAgICBcImRlcHJlY2F0ZWRcIiAgIDogXCJ0aGUgezB9IG1ldGhvZCBoYXMgYmVlbiByZW1vdmVkLCBwbGVhc2UgdXBkYXRlIHlvdXIgY29kZSB0byB1c2UgezF9LlwiLFxuICAgIFwibm9DaGFuZ2VcIiAgICAgOiBcInswfSB3YXMgbm90IHVwZGF0ZWQgYmVjYXVzZSBpdCBkaWQgbm90IGNoYW5nZS5cIixcbiAgICBcIm5vQ29udGFpbmVyXCIgIDogXCJjYW5ub3QgZmluZCBhIGNvbnRhaW5lciBvbiB0aGUgcGFnZSBtYXRjaGluZyB7MH0uXCIsXG4gICAgXCJvZlwiICAgICAgICAgICA6IFwib2ZcIixcbiAgICBcIm9sZFN0eWxlXCIgICAgIDogXCJzdHlsZSBwcm9wZXJ0aWVzIGZvciB7MH0gaGF2ZSBub3cgYmVlbiBlbWJlZGRlZCBkaXJlY3RseSBpbnRvIC57MX0oKS5cIixcbiAgICBcInNhbWVFZGdlXCIgICAgIDogXCJlZGdlcyBjYW5ub3QgbGluayB0byB0aGVtc2VsdmVzLiBhdXRvbWF0aWNhbGx5IHJlbW92aW5nIHNlbGYtcmVmZXJlbmNpbmcgZWRnZSB7MH0uXCIsXG4gICAgXCJzZXRcIiAgICAgICAgICA6IFwiezB9IGhhcyBiZWVuIHNldC5cIixcbiAgICBcInNldExvbmdcIiAgICAgIDogXCJ7MH0gaGFzIGJlZW4gc2V0IHRvIHsxfS5cIixcbiAgICBcInNldENvbnRhaW5lclwiIDogXCJwbGVhc2UgZGVmaW5lIGEgY29udGFpbmVyIGRpdiB1c2luZyAuY29udGFpbmVyKClcIlxuXG4gIH0sXG5cbiAgXCJlcnJvclwiICAgICAgICA6IHtcblxuICAgIFwiYWNjZXB0ZWRcIiAgICAgOiBcInswfSBpcyBub3QgYW4gYWNjZXB0ZWQgezF9IGZvciB7Mn0gdmlzdWFsaXphdGlvbnMsIHBsZWFzZSB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmc6IHszfS5cIixcbiAgICBcImNvbm5lY3Rpb25zXCIgIDogXCJubyBjb25uZWN0aW9ucyBhdmFpbGFibGUgZm9yIHswfS5cIixcbiAgICBcImRhdGFcIiAgICAgICAgIDogXCJubyBkYXRhIGF2YWlsYWJsZVwiLFxuICAgIFwiZGF0YVllYXJcIiAgICAgOiBcIm5vIGRhdGEgYXZhaWxhYmxlIGZvciB7MH0uXCIsXG4gICAgXCJsaWJcIiAgICAgICAgICA6IFwiezB9IHZpc3VhbGl6YXRpb25zIHJlcXVpcmUgbG9hZGluZyB0aGUgezF9IGxpYnJhcnkuXCIsXG4gICAgXCJsaWJzXCIgICAgICAgICA6IFwiezB9IHZpc3VhbGl6YXRpb25zIHJlcXVpcmUgbG9hZGluZyB0aGUgZm9sbG93aW5nIGxpYnJhcmllczogezF9LlwiLFxuICAgIFwibWV0aG9kXCIgICAgICAgOiBcInswfSB2aXN1YWxpemF0aW9ucyByZXF1aXJlIHNldHRpbmcgdGhlIHsxfSBtZXRob2QuXCIsXG4gICAgXCJtZXRob2RzXCIgICAgICA6IFwiezB9IHZpc3VhbGl6YXRpb25zIHJlcXVpcmUgc2V0dGluZyB0aGUgZm9sbG93aW5nIG1ldGhvZHM6IHsxfS5cIlxuXG4gIH0sXG5cbiAgXCJmb3JtYXRcIiAgICAgICA6IHtcbiAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB0aG91c2FuZHM6IFwiLFwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIiRcIiwgXCJcIl0sXG4gICAgZGF0ZVRpbWU6IFwiJUEsICVCICUtZCwgJVkgJVhcIixcbiAgICBkYXRlOiBcIiUtbS8lLWQvJVlcIixcbiAgICB0aW1lOiBcIiVJOiVNOiVTICVwXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSxcbiAgICBkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcbiAgICBzaG9ydERheXM6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcbiAgICBtb250aHM6IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl1cbiAgfSxcblxuICBcImxvd2VyY2FzZVwiICAgIDogWyBcImFcIlxuICAgICAgICAgICAgICAgICAgICwgXCJhbmRcIlxuICAgICAgICAgICAgICAgICAgICwgXCJhdFwiXG4gICAgICAgICAgICAgICAgICAgLCBcImJ1dFwiXG4gICAgICAgICAgICAgICAgICAgLCBcImluXCJcbiAgICAgICAgICAgICAgICAgICAsIFwib2ZcIlxuICAgICAgICAgICAgICAgICAgICwgXCJvclwiXG4gICAgICAgICAgICAgICAgICAgLCBcInRoZVwiXG4gICAgICAgICAgICAgICAgICAgLCBcInRvXCJcbiAgICAgICAgICAgICAgICAgICAsIFwid2l0aFwiXG4gIF0sXG5cbiAgXCJtZXNzYWdlXCIgICAgICA6IHtcblxuICAgIFwiZGF0YVwiICAgICAgICAgOiBcImFuYWx5emluZyBkYXRhXCIsXG4gICAgXCJkcmF3XCIgICAgICAgICA6IFwiZHJhd2luZyB2aXN1YWxpemF0aW9uXCIsXG4gICAgXCJpbml0aWFsaXppbmdcIiA6IFwiaW5pdGlhbGl6aW5nIHswfVwiLFxuICAgIFwibG9hZGluZ1wiICAgICAgOiBcImxvYWRpbmcgZGF0YVwiLFxuICAgIFwidG9vbHRpcFJlc2V0XCIgOiBcInJlc2V0dGluZyB0b29sdGlwc1wiLFxuICAgIFwidWlcIiAgICAgICAgICAgOiBcInVwZGF0aW5nIHVpXCJcblxuICB9LFxuXG4gIFwibWV0aG9kXCIgICAgICAgOiB7XG5cbiAgICBcImFjdGl2ZVwiICAgICAgIDogXCJhY3RpdmUgc2VnbWVudHNcIixcbiAgICBcImNvbG9yXCIgICAgICAgIDogXCJjb2xvclwiLFxuICAgIFwiZGVwdGhcIiAgICAgICAgOiBcImRlcHRoXCIsXG4gICAgXCJkZXZcIiAgICAgICAgICA6IFwidmVyYm9zZVwiLFxuICAgIFwiZm9jdXNcIiAgICAgICAgOiBcImZvY3VzXCIsXG4gICAgXCJpY29uXCIgICAgICAgICA6IFwiaWNvblwiLFxuICAgIFwiaWRcIiAgICAgICAgICAgOiBcImlkXCIsXG4gICAgXCJoZWlnaHRcIiAgICAgICA6IFwiaGVpZ2h0XCIsXG4gICAgXCJsYWJlbHNcIiAgICAgICA6IFwibGFiZWxzXCIsXG4gICAgXCJsZWdlbmRcIiAgICAgICA6IFwibGVnZW5kXCIsXG4gICAgXCJtYXJnaW5cIiAgICAgICA6IFwibWFyZ2luXCIsXG4gICAgXCJtZXNzYWdlc1wiICAgICA6IFwic3RhdHVzIG1lc3NhZ2VzXCIsXG4gICAgXCJtb2RlXCIgICAgICAgICA6IFwibW9kZVwiLFxuICAgIFwib3JkZXJcIiAgICAgICAgOiBcIm9yZGVyXCIsXG4gICAgXCJzZWFyY2hcIiAgICAgICA6IFwic2VhcmNoXCIsXG4gICAgXCJzaGFwZVwiICAgICAgICA6IFwic2hhcGVcIixcbiAgICBcInNpemVcIiAgICAgICAgIDogXCJzaXplXCIsXG4gICAgXCJzdHlsZVwiICAgICAgICA6IFwic3R5bGVcIixcbiAgICBcInRlbXBcIiAgICAgICAgIDogXCJ0ZW1wb3Jhcnkgc2VnbWVudHNcIixcbiAgICBcInRleHRcIiAgICAgICAgIDogXCJ0ZXh0XCIsXG4gICAgXCJ0aW1lXCIgICAgICAgICA6IFwidGltZVwiLFxuICAgIFwidGltZWxpbmVcIiAgICAgOiBcInRpbWVsaW5lXCIsXG4gICAgXCJ0b3RhbFwiICAgICAgICA6IFwidG90YWwgc2VnbWVudHNcIixcbiAgICBcInR5cGVcIiAgICAgICAgIDogXCJ0eXBlXCIsXG4gICAgXCJ3aWR0aFwiICAgICAgICA6IFwid2lkdGhcIixcbiAgICBcInhcIiAgICAgICAgICAgIDogXCJ4IGF4aXNcIixcbiAgICBcInlcIiAgICAgICAgICAgIDogXCJ5IGF4aXNcIixcbiAgICBcInpvb21cIiAgICAgICAgIDogXCJ6b29tXCJcblxuICB9LFxuXG4gIFwidGltZVwiICAgICAgICAgOiBbIFwiZGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgLCBcImRheVwiXG4gICAgICAgICAgICAgICAgICAgLCBcIm1vbnRoXCJcbiAgICAgICAgICAgICAgICAgICAsIFwidGltZVwiXG4gICAgICAgICAgICAgICAgICAgLCBcInllYXJcIlxuXG4gIF0sXG5cbiAgXCJ0aW1lRm9ybWF0XCI6IHtcbiAgICBcIkZ1bGxZZWFyXCI6IFwiJVlcIixcbiAgICBcIk1vbnRoXCI6IFwiJUJcIixcbiAgICBcIk1vbnRoU21hbGxcIjogXCIlYlwiLFxuICAgIFwiRGF0ZVwiOiBcIiVBICUtZFwiLFxuICAgIFwiRGF0ZVNtYWxsXCI6IFwiJS1kXCIsXG4gICAgXCJIb3Vyc1wiOiBcIiVJICVwXCIsXG4gICAgXCJNaW51dGVzXCI6IFwiJUk6JU1cIixcbiAgICBcIlNlY29uZHNcIjogXCIlU3NcIixcbiAgICBcIk1pbGxpc2Vjb25kc1wiOiBcIiVMbXNcIixcbiAgICBcIkZ1bGxZZWFyLU1vbnRoXCI6IFwiJWIgJVlcIixcbiAgICBcIkZ1bGxZZWFyLURhdGVcIjogXCIlLW0vJS1kLyVZXCIsXG4gICAgXCJNb250aC1EYXRlXCI6IFwiJWIgJS1kXCIsXG4gICAgXCJIb3Vycy1NaW51dGVzXCI6IFwiJUk6JU0gJXBcIixcbiAgICBcIkhvdXJzLVNlY29uZHNcIjogXCIlSTolTTolUyAlcFwiLFxuICAgIFwiSG91cnMtTWlsbGlzZWNvbmRzXCI6IFwiJUg6JU06JVMuJUxcIlxuICB9LFxuXG4gIFwidWlcIiAgICAgICAgICAgOiB7XG5cbiAgICBcImFuZFwiICAgICAgICAgIDogXCJhbmRcIixcbiAgICBcImJhY2tcIiAgICAgICAgIDogXCJiYWNrXCIsXG4gICAgXCJjb2xsYXBzZVwiICAgICA6IFwiY2xpY2sgdG8gY29sbGFwc2VcIixcbiAgICBcImVycm9yXCIgICAgICAgIDogXCJlcnJvclwiLFxuICAgIFwiZXhwYW5kXCIgICAgICAgOiBcImNsaWNrIHRvIGV4cGFuZFwiLFxuICAgIFwiaW5jbHVkaW5nXCIgICAgOiBcImluY2x1ZGluZ1wiLFxuICAgIFwibG9hZGluZ1wiICAgICAgOiBcImxvYWRpbmcuLi5cIixcbiAgICBcIm1vcmVcIiAgICAgICAgIDogXCJ7MH0gbW9yZVwiLFxuICAgIFwibW9yZUluZm9cIiAgICAgOiBcImNsaWNrIGZvciBtb3JlIGluZm9cIixcbiAgICBcIm5vUmVzdWx0c1wiICAgIDogXCJubyByZXN1bHRzIG1hdGNoaW5nIHswfS5cIixcbiAgICBcInByaW1hcnlcIiAgICAgIDogXCJwcmltYXJ5IGNvbm5lY3Rpb25zXCIsXG4gICAgXCJzaGFyZVwiICAgICAgICA6IFwic2hhcmVcIixcbiAgICBcInRvdGFsXCIgICAgICAgIDogXCJ0b3RhbFwiLFxuICAgIFwidmFsdWVzXCIgICAgICAgOiBcInZhbHVlc1wiXG5cbiAgfSxcblxuICBcInVwcGVyY2FzZVwiICAgIDogWyBcInR2XCJcbiAgICAgICAgICAgICAgICAgICAsIFwidWlcIlxuICBdLFxuXG4gIFwidmlzdWFsaXphdGlvblwiOiB7XG5cbiAgICBcImJ1YmJsZXNcIiAgICAgIDogXCJCdWJibGVzXCIsXG4gICAgXCJjaGFydFwiICAgICAgICA6IFwiQ2hhcnRcIixcbiAgICBcImdlb19tYXBcIiAgICAgIDogXCJHZW8gTWFwXCIsXG4gICAgXCJsaW5lXCIgICAgICAgICA6IFwiTGluZSBQbG90XCIsXG4gICAgXCJuZXR3b3JrXCIgICAgICA6IFwiTmV0d29ya1wiLFxuICAgIFwicmluZ3NcIiAgICAgICAgOiBcIlJpbmdzXCIsXG4gICAgXCJzY2F0dGVyXCIgICAgICA6IFwiU2NhdHRlciBQbG90XCIsXG4gICAgXCJzdGFja2VkXCIgICAgICA6IFwiU3RhY2tlZCBBcmVhXCIsXG4gICAgXCJ0cmVlX21hcFwiICAgICA6IFwiVHJlZSBNYXBcIlxuXG4gIH1cblxufVxuIiwiZDNwbHVzLmxvY2FsZS5ta19NSyA9IHtcbiAgICBcImRldlwiOiB7XG4gICAgICAgIFwiYWNjZXB0ZWRcIjogXCJ7MH0g0L3QtSDQtSDQv9GA0LjRhNCw0YLQtdC9YSDQstGA0LXQtNC90L7RgdGC0LAg0LfQsCB7MX0sINCy0LUg0LzQvtC70LjQvNC1INC60L7RgNC40YHRgtC10YLQtSDQtdC00L1hINC+0LQg0YHQu9C10LTQvdC40LLQtSDQstGA0LXQtNC90L7RgdGC0Lg6IHsyfS5cIixcbiAgICAgICAgXCJkZXByZWNhdGVkXCI6IFwiezB9INC80LXRgtC+0LQg0LUg0L7RgtGB0YLRgNCw0L3QtdGC0LAsINCy0LUg0LzQvtC70LjQvNC1INC+0LHQvdC+0LLQtdGC0LUg0LPQviDQstCw0YjQuNC+0YIg0LrQvtC0INC30LAg0LTQsCDRgdC1INC60L7RgNC40YHRgtC4IHsxfS5cIixcbiAgICAgICAgXCJub0NoYW5nZVwiOiBcInswfSDQvdC1INC1INCw0LbRg9GA0LjRgNCw0L3QsCwg0LHQuNC00LXRmNGc0Lgg0L3QtdC80LDRiNC1INC/0YDQvtC80LXQvdC4LlwiLFxuICAgICAgICBcIm5vQ29udGFpbmVyXCI6IFwi0L3QtSDQvNC+0LZlINC00LAg0YHQtSDQvdCw0ZjQtNC1INC60L7QvdGC0LXRmNC90LXRgCDQvdCwINGB0YLRgNCw0L3QuNGG0LDRgtCwINC60L7RmCDRgdC1INGB0L7QstC/0LDRk9CwINGB0L4gezB9LlwiLFxuICAgICAgICBcIm9mXCI6IFwi0L3QsFwiLFxuICAgICAgICBcIm9sZFN0eWxlXCI6IFwi0YHQstC+0ZjRgdGC0LLQsNGC0LAg0LfQsCDRgdGC0LjQu9C+0YIg0LfQsCB7MH0g0YHQtdCz0LAg0YHQtSDQstCz0YDQsNC00LXQvdC4INC00LjRgNC10LrRgtC90L4g0LLQvi4gezF9ICgpLlwiLFxuICAgICAgICBcInNhbWVFZGdlXCI6IFwi0YDQsNCx0L7QstC40YLQtSDQvdC1INC80L7QttC1INC00LAg0LjQvNCw0LDRgiDQsNC70LrQsCDRgdCw0LzQuNGC0LUg0LrQvtC9INGB0LXQsdC1LiDQsNCy0YLQvtC80LDRgtGB0LrQuCDQs9C4INC+0YLRgdGC0YDQsNC90YPQstCw0Lwg0YDQsNCx0L7QstC40YLQtSDQutC+0Lgg0YHQtSDRgdCw0LzQvi3RgNC10YTQtdGA0LXQvdGG0LjRgNCw0LDRgiB7MH0uXCIsXG4gICAgICAgIFwic2V0XCI6IFwiezB9INC1INC90LDQvNC10YHRgtC10L0uXCIsXG4gICAgICAgIFwic2V0TG9uZ1wiOiBcInswfSDQtSDQv9C+0YHRgtCw0LLQtdC9INC90LAgezF9LlwiLFxuICAgICAgICBcInNldENvbnRhaW5lclwiOiBcItCS0LUg0LzQvtC70LjQvNC1INC00LXRhNC40L3QuNGA0LDRmNGC0LUg0LrQvtC90YLQtdGY0L3QtdGAIGRpdiDQutC+0YDQuNGB0YLQtdGY0ZzQuCAuY29udGFpbmVyKClcIlxuICAgIH0sXG4gICAgXCJlcnJvclwiOiB7XG4gICAgICAgIFwiYWNjZXB0ZWRcIjogXCJ7MH0g0L3QtSDQtSDQv9GA0LjRhNCw0YLQu9C40LLQsCDQt9CwIHsxfSB7Mn0g0LLQuNC30YPQtdC70LjQt9Cw0YbQuNGY0LAsINCy0LUg0LzQvtC70LjQvNC1INC60L7RgNC40YHRgtC10YLQtSDQtdC00L3QsCDQvtC0INGB0LvQtdC00L3QuNCy0LU6IHszfS5cIixcbiAgICAgICAgXCJjb25uZWN0aW9uc1wiOiBcItC90LXQvNCwINC60L7QvdC10LrRhtC40Lgg0L3QsCDRgNCw0YHQv9C+0LvQsNCz0LDRmtC1INC30LAgezB9LlwiLFxuICAgICAgICBcImRhdGFcIjogXCLQvdC10LzQsCDQv9C+0LTQsNGC0L7RhtC4XCIsXG4gICAgICAgIFwiZGF0YVllYXJcIjogXCLQndC10LzQsCDQtNC+0YHRgtCw0L/QvdC4INC/0L7QtNCw0YLQvtGG0Lgg0LfQsCB7MH0uXCIsXG4gICAgICAgIFwibGliXCI6IFwiezB9INCy0LjQt9GD0LDQu9C40LfQsNGG0LjQuCDQsdCw0YDQsNCw0YIg0LLRh9C40YLRg9Cy0LDRmtC1INC90LAg0LHQuNCx0LvQuNC+0YLQtdC60LDRgtCwIHsxfSAuXCIsXG4gICAgICAgIFwibGlic1wiOiBcInswfSDQstC40LfRg9Cw0LvQuNC30LDRhtC40Lgg0LHQsNGA0LDQsNGCINCy0YfQuNGC0YPQstCw0ZrQtSDQvdCwINGB0LvQtdC00L3QuNCy0LUg0LHQuNCx0LvQuNC+0YLQtdC60Lg6IHsxfS5cIixcbiAgICAgICAgXCJtZXRob2RcIjogXCJ7MH0g0LLQuNC30YPQsNC70LjQt9Cw0YbQuNC4INCx0LDRgNCwINC/0L7RgdGC0LDQstGD0LLQsNGa0LUg0L3QsCB7MX0g0LzQtdGC0L7QtNC+0YIuXCIsXG4gICAgICAgIFwibWV0aG9kc1wiOiBcInswfSDQstC40LfRg9Cw0LvQuNC30LDRhtC40Lgg0LHQsNGA0LDQsNGCINC/0L7RgdGC0LDQstGD0LLQsNGa0LUg0L3QsCDRgdC70LXQtNC90LjQstC1INC80LXRgtC+0LTQuDogezF9LlwiXG4gICAgfSxcbiAgICBcImZvcm1hdFwiOiB7XG4gICAgICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgICAgICB0aG91c2FuZHM6IFwiLlwiLFxuICAgICAgICBncm91cGluZzogWzNdLFxuICAgICAgICBjdXJyZW5jeTogW1wiXCIsIFwiINC00LXQvS5cIl0sXG4gICAgICAgIGRhdGVUaW1lOiBcIiVBLCAlZSAlQiAlWSDQsy4gJVhcIixcbiAgICAgICAgZGF0ZTogXCIlZC4lbS4lWVwiLFxuICAgICAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgICAgIGRheXM6IFtcItC90LXQtNC10LvQsFwiLCBcItC/0L7QvdC10LTQtdC70L3QuNC6XCIsIFwi0LLRgtC+0YDQvdC40LpcIiwgXCLRgdGA0LXQtNCwXCIsIFwi0YfQtdGC0LLRgNGC0L7QulwiLCBcItC/0LXRgtC+0LpcIiwgXCLRgdCw0LHQvtGC0LBcIl0sXG4gICAgICAgIHNob3J0RGF5czogW1wi0L3QtdC0XCIsIFwi0L/QvtC9XCIsIFwi0LLRgtC+XCIsIFwi0YHRgNC1XCIsIFwi0YfQtdGCXCIsIFwi0L/QtdGCXCIsIFwi0YHQsNCxXCJdLFxuICAgICAgICBtb250aHM6IFtcItGY0LDQvdGD0LDRgNC4XCIsIFwi0YTQtdCy0YDRg9Cw0YDQuFwiLCBcItC80LDRgNGCXCIsIFwi0LDQv9GA0LjQu1wiLCBcItC80LDRmFwiLCBcItGY0YPQvdC4XCIsIFwi0ZjRg9C70LhcIiwgXCLQsNCy0LPRg9GB0YJcIiwgXCLRgdC10L/RgtC10LzQstGA0LhcIiwgXCLQvtC60YLQvtC80LLRgNC4XCIsIFwi0L3QvtC10LzQstGA0LhcIiwgXCLQtNC10LrQtdC80LLRgNC4XCJdLFxuICAgICAgICBzaG9ydE1vbnRoczogW1wi0ZjQsNC9XCIsIFwi0YTQtdCyXCIsIFwi0LzQsNGAXCIsIFwi0LDQv9GAXCIsIFwi0LzQsNGYXCIsIFwi0ZjRg9C9XCIsIFwi0ZjRg9C7XCIsIFwi0LDQstCzXCIsIFwi0YHQtdC/XCIsIFwi0L7QutGCXCIsIFwi0L3QvtC1XCIsIFwi0LTQtdC6XCJdXG4gICAgfSxcbiAgICBcImxvd2VyY2FzZVwiOiBbXG4gICAgICAgIFwiYVwiLFxuICAgICAgICBcItC4XCIsXG4gICAgICAgIFwi0LLQvlwiLFxuICAgICAgICBcItC90L5cIixcbiAgICAgICAgXCLQvdCwXCIsXG4gICAgICAgIFwi0LjQu9C4XCIsXG4gICAgICAgIFwi0LTQsFwiLFxuICAgICAgICBcItGB0LVcIixcbiAgICAgICAgXCLRgdC+XCJcbiAgICBdLFxuICAgIFwibWV0aG9kXCI6IHtcbiAgICAgICAgXCJhY3RpdmVcIjogXCLQsNC60YLQuNCy0L3QuCDRgdC10LPQvNC10L3RgtC4XCIsXG4gICAgICAgIFwiY29sb3JcIjogXCLQsdC+0ZjQsFwiLFxuICAgICAgICBcImRlcHRoXCI6IFwi0LTQu9Cw0LHQvtGH0LjQvdCwXCIsXG4gICAgICAgIFwiZGV2XCI6IFwi0L7Qv9GI0LjRgNC90L5cIixcbiAgICAgICAgXCJmb2N1c1wiOiBcItGE0L7QutGD0YFcIixcbiAgICAgICAgXCJpY29uXCI6IFwi0LjQutC+0L3QsFwiLFxuICAgICAgICBcImlkXCI6IFwiSURcIixcbiAgICAgICAgXCJoZWlnaHRcIjogXCLQstC40YHQuNC90LBcIixcbiAgICAgICAgXCJsYWJlbHNcIjogXCLQtdGC0LjQutC10YLQuFwiLFxuICAgICAgICBcImxlZ2VuZFwiOiBcItC70LXQs9C10L3QtNCwXCIsXG4gICAgICAgIFwibWFyZ2luXCI6IFwi0LzQsNGA0LPQuNC90LBcIixcbiAgICAgICAgXCJtZXNzYWdlc1wiOiBcItC/0L7RgNCw0LrQuCDQt9CwINGB0YLQsNGC0YPRgdC+0YJcIixcbiAgICAgICAgXCJvcmRlclwiOiBcItGG0LXQu1wiLFxuICAgICAgICBcInNlYXJjaFwiOiBcItCx0LDRgNCw0ZhcIixcbiAgICAgICAgXCJzaGFwZVwiOiBcItGE0L7RgNC80LBcIixcbiAgICAgICAgXCJzaXplXCI6IFwi0LPQvtC70LXQvNC40L3QsFwiLFxuICAgICAgICBcInN0eWxlXCI6IFwi0YHRgtC40LtcIixcbiAgICAgICAgXCJ0ZW1wXCI6IFwi0L/RgNC40LLRgNC10LzQtdC90Lgg0YHQtdCz0LzQtdC90YLQuFwiLFxuICAgICAgICBcInRleHRcIjogXCLRgtC10LrRgdGCXCIsXG4gICAgICAgIFwidGltZVwiOiBcItCy0YDQtdC80LVcIixcbiAgICAgICAgXCJ0aW1lbGluZVwiOiBcItCy0YDQtdC80LXQv9C70L7QslwiLFxuICAgICAgICBcInRvdGFsXCI6IFwi0JLQutGD0L/QvdC+INGB0LXQs9C80LXQvdGC0LhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwi0YLQuNC/XCIsXG4gICAgICAgIFwid2lkdGhcIjogXCLRiNC40YDQuNC90LBcIixcbiAgICAgICAgXCJ4XCI6IFwieCDQvtGB0LrQsNGC0LBcIixcbiAgICAgICAgXCJ5XCI6IFwieSDQvtGB0LrQsNGC0LBcIixcbiAgICAgICAgXCJ6b29tXCI6IFwi0LfRg9C8XCIsXG4gICAgICAgIFwibW9kZVwiOiBcItGA0LXQttC40LxcIlxuICAgIH0sXG4gICAgXCJ0aW1lXCI6IFtcbiAgICAgICAgXCLQtNCw0YLRg9C8XCIsXG4gICAgICAgIFwi0LTQtdC9XCIsXG4gICAgICAgIFwi0LzQtdGB0LXRhlwiLFxuICAgICAgICBcItCy0YDQtdC80LVcIixcbiAgICAgICAgXCLQs9C+0LTQuNC90LBcIlxuICAgIF0sXG4gICAgXCJ2aXN1YWxpemF0aW9uXCI6IHtcbiAgICAgICAgXCJidWJibGVzXCI6IFwi0JzQtdGD0YDRh9C40ZrQsFwiLFxuICAgICAgICBcImNoYXJ0XCI6IFwi0KLQsNCx0LXQu9CwXCIsXG4gICAgICAgIFwiZ2VvX21hcFwiOiBcItCT0LXQviDQvNCw0L/QsFwiLFxuICAgICAgICBcImxpbmVcIjogXCLQm9C40L3QuNGB0LrQuCDQs9GA0LDRhNC40LpcIixcbiAgICAgICAgXCJuZXR3b3JrXCI6IFwi0JzRgNC10LbQsFwiLFxuICAgICAgICBcInJpbmdzXCI6IFwi0J/RgNGB0YLQtdC90LhcIixcbiAgICAgICAgXCJzY2F0dGVyXCI6IFwi0KDQsNGB0L/RgNGB0LrQsNC9INCz0YDQsNGE0LjQulwiLFxuICAgICAgICBcInN0YWNrZWRcIjogXCLQndCw0YDQtdC00LXQvdCwINC/0L7QstGA0YjQuNC90LBcIixcbiAgICAgICAgXCJ0cmVlX21hcFwiOiBcItCc0LDQv9CwINCy0L4g0LLQuNC0INC90LAg0LTRgNCy0L5cIlxuICAgIH0sXG4gICAgXCJ1aVwiOiB7XG4gICAgICAgIFwiYW5kXCI6IFwi0LhcIixcbiAgICAgICAgXCJiYWNrXCI6IFwi0L3QsNC30LDQtFwiLFxuICAgICAgICBcImNvbGxhcHNlXCI6IFwi0LrQu9C40LrQvdC4INC30LAg0LTQsCDRgdC1INGB0L7QsdC10YDQtVwiLFxuICAgICAgICBcImVycm9yXCI6IFwi0LPRgNC10YjQutCwXCIsXG4gICAgICAgIFwiZXhwYW5kXCI6IFwi0LrQu9C40LrQvdC4INC30LAg0LTQsCDRgdC1INC/0YDQvtGI0LjRgNC4XCIsXG4gICAgICAgIFwibG9hZGluZ1wiOiBcItCh0LUg0LLRh9C40YLRg9Cy0LAgLi4uXCIsXG4gICAgICAgIFwibW9yZVwiOiBcInswfSDQv9C+0LLQtdGc0LVcIixcbiAgICAgICAgXCJtb3JlSW5mb1wiOiBcItC60LvQuNC60L3QtdGC0LUg0LfQsCDQv9C+0LLQtdGc0LUg0LjQvdGE0L7RgNC80LDRhtC40LhcIixcbiAgICAgICAgXCJub1Jlc3VsdHNcIjogXCLQndC10LzQsCDRgNC10LfRg9C70YLQsNGC0Lgg0LfQsCDQv9C+0ZjQsNCy0YPQstCw0ZrQtSDQvdCwIHswfS5cIixcbiAgICAgICAgXCJwcmltYXJ5XCI6IFwi0L7RgdC90L7QstC90L4g0LLRgNGB0LrQuFwiLFxuICAgICAgICBcInNoYXJlXCI6IFwi0YPQtNC10LtcIixcbiAgICAgICAgXCJ0b3RhbFwiOiBcItCS0LrRg9C/0L3QvlwiLFxuICAgICAgICBcInZhbHVlc1wiOiBcItCy0YDQtdC00L3QvtGB0YLQuFwiLFxuICAgICAgICBcImluY2x1ZGluZ1wiOiBcItCy0LrQu9GD0YfRg9Cy0LDRmNGc0LhcIlxuICAgIH0sXG4gICAgXCJtZXNzYWdlXCI6IHtcbiAgICAgICAgXCJkYXRhXCI6IFwi0LDQvdCw0LvQuNC30LjRgNCw0ZrQtSDQvdCwINC/0L7QtNCw0YLQvtGG0LjRgtC1XCIsXG4gICAgICAgIFwiZHJhd1wiOiBcItGG0YDRgtCw0ZrQtSDQvdCwINCy0LjQt9GD0LXQu9C40LfQsNGG0LjRmNCwXCIsXG4gICAgICAgIFwiaW5pdGlhbGl6aW5nXCI6IFwi0LjQvdC40YbQuNGY0LDQu9C40LfQsNGG0LjRmNCwIHswfVwiLFxuICAgICAgICBcImxvYWRpbmdcIjogXCLQstGH0LjRgtGD0LLQsNGa0LUg0L3QsCDQv9C+0LTQsNGC0L7RhtC4XCIsXG4gICAgICAgIFwidG9vbHRpcFJlc2V0XCI6IFwi0YDQtdGB0LXRgtC40YDQsNGa0LUg0L3QsCDQvtCx0ZjQsNGB0L3Rg9Cy0LDRmtCw0YLQsFwiLFxuICAgICAgICBcInVpXCI6IFwi0LDQttGD0YDQuNGA0LDRmtC1INC90LAg0LrQvtGA0LjQvdC40YfQutC40L7RgiDQuNC90YLQtdGA0YTQtdGY0YFcIlxuICAgIH0sXG4gICAgXCJ1cHBlcmNhc2VcIjogW1xuICAgICAgICBcIlRWXCIsXG4gICAgICAgIFwiVUlcIlxuICAgIF1cbn1cbiIsImQzcGx1cy5sb2NhbGUucHRfQlIgPSB7XG4gICAgXCJkZXZcIjoge1xuICAgICAgICBcImFjY2VwdGVkXCI6IFwiezB9IG7Do28gw6kgdW0gdmFsb3IgYWNlaXRvIHBhcmEgezF9LCBwb3IgZmF2b3IsIHVzZSB1bSBkb3Mgc2VndWludGVzIHByb2NlZGltZW50b3M6IHsyfS5cIixcbiAgICAgICAgXCJkZXByZWNhdGVkXCI6IFwiezB9IG3DqXRvZG8gZm9pIHJlbW92aWRvLCBwb3IgZmF2b3IgYXR1YWxpemUgc2V1IGPDs2RpZ28gcGFyYSB1dGlsaXphciB7MX0uXCIsXG4gICAgICAgIFwibm9DaGFuZ2VcIjogXCJ7MH0gbsOjbyBmb2kgYXR1YWxpemFkbyBwb3JxdWUgZWxlIG7Do28gbXVkb3UuXCIsXG4gICAgICAgIFwibm9Db250YWluZXJcIjogXCJOw6NvIGZvaSBwb3Nzw612ZWwgZW5jb250cmFyIHVtIGxvY2FsIG5hIHDDoWdpbmEgY29ycmVzcG9uZGVudGUgYSB7MH0uXCIsXG4gICAgICAgIFwib2ZcIjogXCJkZVwiLFxuICAgICAgICBcIm9sZFN0eWxlXCI6IFwicHJvcHJpZWRhZGVzIGRlIGVzdGlsbyBwYXJhIHswfSBqw6EgZm9yYW0gaW5jb3Jwb3JhZG9zIGRpcmV0YW1lbnRlIG5vLiB7MX0gKCkuXCIsXG4gICAgICAgIFwic2FtZUVkZ2VcIjogXCJib3JkYXMgbsOjbyBwb2RlbSB2aW5jdWxhciBhIHNpIG1lc21vcy4gcmVtb3ZlbmRvIGF1dG9tYXRpY2FtZW50ZSBib3JkYSBkZSBhdXRvLXJlZmVyw6puY2lhIHswfS5cIixcbiAgICAgICAgXCJzZXRcIjogXCJ7MH0gZm9pIGRlZmluaWRhLlwiLFxuICAgICAgICBcInNldExvbmdcIjogXCJ7MH0gZm9pIGRlZmluaWRhIHBhcmEgezF9LlwiLFxuICAgICAgICBcInNldENvbnRhaW5lclwiOiBcInBvciBmYXZvciwgZGVmaW5hIHVtIGRpdiB1dGlsaXphbmRvIC5jb250YWluZXIoKVwiXG4gICAgfSxcbiAgICBcImVycm9yXCI6IHtcbiAgICAgICAgXCJhY2NlcHRlZFwiOiBcInswfSBuw6NvIMOpIHVtIHJlY29uaGVjaWRvIHsxfSBwYXJhIHsyfSB2aXN1YWxpemHDp8O1ZXMsIHBvciBmYXZvciwgdXNlIHVtIGRvcyBzZWd1aW50ZXMgcHJvY2VkaW1lbnRvczogezN9LlwiLFxuICAgICAgICBcImNvbm5lY3Rpb25zXCI6IFwiTsOjbyBow6EgY29uZXjDtWVzIGRpc3BvbsOtdmVpcyBwYXJhIHswfS5cIixcbiAgICAgICAgXCJkYXRhXCI6IFwiTsOjbyBow6EgZGFkb3MgZGlzcG9uw612ZWlzXCIsXG4gICAgICAgIFwiZGF0YVllYXJcIjogXCJOw6NvIGjDoSBkYWRvcyBkaXNwb27DrXZlaXMgcGFyYSB7MH0uXCIsXG4gICAgICAgIFwibGliXCI6IFwiQSB2aXN1YWxpemHDp8OjbyB7MH0gbmVjZXNzaXRhIHF1ZSBzZWphIGNhcnJlZ2FkbyBhIGJpYmxpb3RlY2EgezF9LlwiLFxuICAgICAgICBcImxpYnNcIjogXCJBIHZpc3VhbGl6YcOnw6NvIHswfSBuZWNlc3NpdGEgcXVlIHNlamEgY2FycmVnYWRvIGFzIGJpYmxpb3RlY2FzIHsxfS5cIixcbiAgICAgICAgXCJtZXRob2RcIjogXCJBIHZpc3VhbGl6YcOnw6NvIHswfSBleGlnZSBhIGRlZmluacOnw6NvIGRvIG3DqXRvZG8gezF9LlwiLFxuICAgICAgICBcIm1ldGhvZHNcIjogXCJBIHZpc3VhbGl6YcOnw6NvIHswfSBleGlnZSBhIGRlZmluacOnw6NvIGRvcyBtw6l0b2RvcyB7MX0uXCJcbiAgICB9LFxuICAgIFwiZm9ybWF0XCI6IHtcbiAgICAgICAgZGVjaW1hbDogJywnLFxuICAgICAgICB0aG91c2FuZHM6ICcuJyxcbiAgICAgICAgZ3JvdXBpbmc6IFszXSxcbiAgICAgICAgY3VycmVuY3k6IFsnUiQnLCAnJ10sXG4gICAgICAgIGRhdGVUaW1lOiAnJUEsICVlIGRlICVCIGRlICVZLiAlWCcsXG4gICAgICAgIGRhdGU6ICclZC8lbS8lWScsXG4gICAgICAgIHRpbWU6ICclSDolTTolUycsXG4gICAgICAgIHBlcmlvZHM6IFsnQU0nLCAnUE0nXSxcbiAgICAgICAgZGF5czogWydEb21pbmdvJywgJ1NlZ3VuZGEnLCAnVGVyw6dhJywgJ1F1YXJ0YScsICdRdWludGEnLCAnU2V4dGEnLCAnU8OhYmFkbyddLFxuICAgICAgICBzaG9ydERheXM6IFsnRG9tJywgJ1NlZycsICdUZXInLCAnUXVhJywgJ1F1aScsICdTZXgnLCAnU8OhYiddLFxuICAgICAgICBtb250aHM6IFsnSmFuZWlybycsICdGZXZlcmVpcm8nLCAnTWFyw6dvJywgJ0FicmlsJywgJ01haW8nLCAnSnVuaG8nLCAnSnVsaG8nLCAnQWdvc3RvJywgJ1NldGVtYnJvJywgJ091dHVicm8nLCAnTm92ZW1icm8nLCAnRGV6ZW1icm8nXSxcbiAgICAgICAgc2hvcnRNb250aHM6IFsnSmFuJywgJ0ZldicsICdNYXInLCAnQWJyJywgJ01haScsICdKdW4nLCAnSnVsJywgJ0FnbycsICdTZXQnLCAnT3V0JywgJ05vdicsICdEZXonXVxuICAgIH0sXG4gICAgXCJsb3dlcmNhc2VcIjogW1xuICAgICAgICBcImFcIixcbiAgICAgICAgXCJjb21cIixcbiAgICAgICAgXCJkZVwiLFxuICAgICAgICBcImVcIixcbiAgICAgICAgXCJlbVwiLFxuICAgICAgICBcIm1hc1wiLFxuICAgICAgICBcIm91XCIsXG4gICAgICAgIFwicGFyYVwiLFxuICAgICAgICBcInVtXCJcbiAgICBdLFxuICAgIFwibWV0aG9kXCI6IHtcbiAgICAgICAgXCJhY3RpdmVcIjogXCJzZWdtZW50b3MgYXRpdm9zXCIsXG4gICAgICAgIFwiY29sb3JcIjogXCJjb3JcIixcbiAgICAgICAgXCJkZXB0aFwiOiBcInByb2Z1bmRpZGFkZVwiLFxuICAgICAgICBcImRldlwiOiBcInZlcmJvc29cIixcbiAgICAgICAgXCJmb2N1c1wiOiBcImZvY29cIixcbiAgICAgICAgXCJpY29uXCI6IFwiw61jb25lXCIsXG4gICAgICAgIFwiaWRcIjogXCJpZFwiLFxuICAgICAgICBcImhlaWdodFwiOiBcImFsdHVyYVwiLFxuICAgICAgICBcImxhYmVsc1wiOiBcInLDs3R1bG9zXCIsXG4gICAgICAgIFwibGVnZW5kXCI6IFwibGVnZW5kYVwiLFxuICAgICAgICBcIm1hcmdpblwiOiBcIm1hcmdlbVwiLFxuICAgICAgICBcIm1lc3NhZ2VzXCI6IFwibWVuc2FnZW5zIGRlIHN0YXR1c1wiLFxuICAgICAgICBcIm9yZGVyXCI6IFwib3JkZW5hclwiLFxuICAgICAgICBcInNlYXJjaFwiOiBcInBlc3F1aXNhclwiLFxuICAgICAgICBcInNoYXBlXCI6IFwiZm9ybWFcIixcbiAgICAgICAgXCJzaXplXCI6IFwidGFtYW5ob1wiLFxuICAgICAgICBcInN0eWxlXCI6IFwiZXN0aWxvXCIsXG4gICAgICAgIFwidGVtcFwiOiBcInNlZ21lbnRvcyB0ZW1wb3LDoXJpb3NcIixcbiAgICAgICAgXCJ0ZXh0XCI6IFwidGV4dG9cIixcbiAgICAgICAgXCJ0aW1lXCI6IFwidGVtcG9cIixcbiAgICAgICAgXCJ0aW1lbGluZVwiOiBcImNyb25vZ3JhbWFcIixcbiAgICAgICAgXCJ0b3RhbFwiOiBcInNlZ21lbnRvcyB0b3RhaXNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGlwb1wiLFxuICAgICAgICBcIndpZHRoXCI6IFwibGFyZ3VyYVwiLFxuICAgICAgICBcInhcIjogXCJlaXhvIHhcIixcbiAgICAgICAgXCJ5XCI6IFwiZWl4byB5XCIsXG4gICAgICAgIFwiem9vbVwiOiBcInpvb21cIixcbiAgICAgICAgXCJtb2RlXCI6IFwibW9kb1wiXG4gICAgfSxcbiAgICBcInRpbWVcIjogW1xuICAgICAgICBcImFub1wiLFxuICAgICAgICBcImRhdGFcIixcbiAgICAgICAgXCJkaWFcIixcbiAgICAgICAgXCJob3JhXCIsXG4gICAgICAgIFwibcOqc1wiXG4gICAgXSxcbiAgICBcInZpc3VhbGl6YXRpb25cIjoge1xuICAgICAgICBcImJ1YmJsZXNcIjogXCJCb2xoYXNcIixcbiAgICAgICAgXCJjaGFydFwiOiBcIkdyw6FmaWNvXCIsXG4gICAgICAgIFwiZ2VvX21hcFwiOiBcIk1hcGFcIixcbiAgICAgICAgXCJsaW5lXCI6IFwiR3LDoWZpY28gZGUgTGluaGFcIixcbiAgICAgICAgXCJuZXR3b3JrXCI6IFwiUmVkZVwiLFxuICAgICAgICBcInJpbmdzXCI6IFwiQW7DqWlzXCIsXG4gICAgICAgIFwic2NhdHRlclwiOiBcIkRpc3BlcnPDo29cIixcbiAgICAgICAgXCJzdGFja2VkXCI6IFwiRXZvbHXDp8Ojb1wiLFxuICAgICAgICBcInRyZWVfbWFwXCI6IFwiVHJlZSBNYXBcIlxuICAgIH0sXG4gICAgXCJ1aVwiOiB7XG4gICAgICAgIFwiYW5kXCI6IFwiZVwiLFxuICAgICAgICBcImJhY2tcIjogXCJkZSB2b2x0YVwiLFxuICAgICAgICBcImNvbGxhcHNlXCI6IFwiQ2xpcXVlIHBhcmEgZmVjaGFyXCIsXG4gICAgICAgIFwiZXJyb3JcIjogXCJlcnJvXCIsXG4gICAgICAgIFwiZXhwYW5kXCI6IFwiY2xpcXVlIHBhcmEgZXhwYW5kaXJcIixcbiAgICAgICAgXCJsb2FkaW5nXCI6IFwiY2FycmVnYW5kbyAuLi5cIixcbiAgICAgICAgXCJtb3JlXCI6IFwibWFpcyB7MH1cIixcbiAgICAgICAgXCJtb3JlSW5mb1wiOiBcImNsaXF1ZSBwYXJhIG1haXMgaW5mb3JtYcOnw7Vlc1wiLFxuICAgICAgICBcIm5vUmVzdWx0c1wiOiBcIm5lbmh1bSByZXN1bHRhZG8gcGFyYSB7MH0uXCIsXG4gICAgICAgIFwicHJpbWFyeVwiOiBcImNvbmV4w7VlcyBwcmltw6FyaWFzXCIsXG4gICAgICAgIFwic2hhcmVcIjogXCJwYXJ0aWNpcGHDp8Ojb1wiLFxuICAgICAgICBcInRvdGFsXCI6IFwidG90YWxcIixcbiAgICAgICAgXCJ2YWx1ZXNcIjogXCJ2YWxvcmVzXCIsXG4gICAgICAgIFwiaW5jbHVkaW5nXCI6IFwiaW5jbHVpbmRvXCJcbiAgICB9LFxuICAgIFwibWVzc2FnZVwiOiB7XG4gICAgICAgIFwiZGF0YVwiOiBcImFuYWxpc2FuZG8gZGFkb3NcIixcbiAgICAgICAgXCJkcmF3XCI6IFwiZGVzZW5oYW5kbyB2aXN1YWxpemHDp8Ojb1wiLFxuICAgICAgICBcImluaXRpYWxpemluZ1wiOiBcImluaWNpYWxpemFuZG8gezB9XCIsXG4gICAgICAgIFwibG9hZGluZ1wiOiBcImNhcnJlZ2FuZG8gZGFkb3NcIixcbiAgICAgICAgXCJ0b29sdGlwUmVzZXRcIjogXCJyZWRlZmluaW5kbyBhcyBkaWNhc1wiLFxuICAgICAgICBcInVpXCI6IFwiYXR1YWxpemFuZG8gaW50ZXJmYWNlXCJcbiAgICB9LFxuICAgIFwidXBwZXJjYXNlXCI6IFtcbiAgICAgICAgXCJUVlwiXG4gICAgXVxufVxuIiwiZDNwbHVzLmxvY2FsZS56aF9DTiA9IHtcbiAgICBcImRldlwiOiB7XG4gICAgICAgIFwiYWNjZXB0ZWRcIjogXCJ7MH3kuI3mmK97MX3nmoTlj6/mjqXlj5flgLwsIOivt+eUqOS4i+WIl+S5i+S4gOeahOWAvDp7Mn1cIixcbiAgICAgICAgXCJkZXByZWNhdGVkXCI6IFwiezB955qE5pa55rOV5bey6KKr56e76ZmkLCDor7fmm7TmlrDmgqjnmoTku6PnoIHljrvkvb/nlKh7MX1cIixcbiAgICAgICAgXCJub0NoYW5nZVwiOiBcInswfeayoeacieabtOaWsCwg5Zug5Li65a6D5bm25rKh5pyJ5pS55Y+Y44CCXCIsXG4gICAgICAgIFwibm9Db250YWluZXJcIjogXCLml6Dms5XlnKjor6XpobXmib7liLDlrrnlmajljrvljLnphY17MH1cIixcbiAgICAgICAgXCJvZlwiOiBcIueahFwiLFxuICAgICAgICBcIm9sZFN0eWxlXCI6IFwi5qC35byP5bGe5oCnezB9546w5Zyo5bey57uP55u05o6l5bWM5YWl5Yiw44CCezF977yI77yJ44CCXCIsXG4gICAgICAgIFwic2FtZUVkZ2VcIjogXCLovrnnvJjkuI3og73pk77mjqXliLDoh6rlt7HjgILoh6rliqjljrvpmaToh6rmiJHlj4LnhafovrnnvJh7MH3jgIJcIixcbiAgICAgICAgXCJzZXRcIjogXCJ7MH3lt7Lnu4/ooqvorr7nva7jgIJcIixcbiAgICAgICAgXCJzZXRMb25nXCI6IFwiezB96KKr6K6+572u5Li6ezF944CCXCIsXG4gICAgICAgIFwic2V0Q29udGFpbmVyXCI6IFwi6K+35L2/55SoKCnlrrnlmajmnaXlrprkuYlkaXblrrnlmahcIlxuICAgIH0sXG4gICAgXCJlcnJvclwiOiB7XG4gICAgICAgIFwiYWNjZXB0ZWRcIjogXCJ7MH3lr7nkuo57Mn3nmoTlj6/op4bljJbmlYjmnpzlubbkuI3mmK/kuIDkuKrlj6/mjqXlj5fnmoR7MX0sIOivt+S9v+eUqOWmguS4i+eahOS4gOS4qu+8mnszfS5cIixcbiAgICAgICAgXCJjb25uZWN0aW9uc1wiOiBcIuayoeacieWvuXswfeWPr+eUqOeahOi/nuaOpeOAglwiLFxuICAgICAgICBcImRhdGFcIjogXCLml6Dlj6/nlKjmlbDmja5cIixcbiAgICAgICAgXCJkYXRhWWVhclwiOiBcIuayoeacieaVsOaNruWvuXswfeWPr+eUqOOAglwiLFxuICAgICAgICBcImxpYlwiOiBcInswfeeahOWPr+inhuWMluimgeaxguijhei9vXsxfeW6k+OAglwiLFxuICAgICAgICBcImxpYnNcIjogXCJ7MH3nmoTlj6/op4bljJbpnIDopoHliqDovb3ku6XkuIvlupPvvJp7MX3jgIJcIixcbiAgICAgICAgXCJtZXRob2RcIjogXCJ7MH3nmoTlj6/op4bljJbopoHmsYLorr7nva57MX3mlrnms5XjgIJcIixcbiAgICAgICAgXCJtZXRob2RzXCI6IFwiezB955qE5Y+v6KeG5YyW6KaB5rGC6K6+572u5Lul5LiL5pa55rOV77yaezF944CCXCJcbiAgICB9LFxuICAgIFwiZm9ybWF0XCI6IHtcbiAgICAgICAgZGVjaW1hbDogXCIuXCIsXG4gICAgICAgIHRob3VzYW5kczogXCIsXCIsXG4gICAgICAgIGdyb3VwaW5nOiBbM10sXG4gICAgICAgIGN1cnJlbmN5OiBbXCLCpVwiLCBcIlwiXSxcbiAgICAgICAgZGF0ZVRpbWU6IFwiJUEgJUIgJWUgJVkgJVhcIixcbiAgICAgICAgZGF0ZTogXCIlWS8lLW0vJS1kXCIsXG4gICAgICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICAgICAgcGVyaW9kczogW1wi5LiK5Y2IXCIsIFwi5LiL5Y2IXCJdLFxuICAgICAgICBkYXlzOiBbXCLmmJ/mnJ/ml6VcIiwgXCLmmJ/mnJ/kuIBcIiwgXCLmmJ/mnJ/kuoxcIiwgXCLmmJ/mnJ/kuIlcIiwgXCLmmJ/mnJ/lm5tcIiwgXCLmmJ/mnJ/kupRcIiwgXCLmmJ/mnJ/lha1cIl0sXG4gICAgICAgIHNob3J0RGF5czogW1wi5pif5pyf5pelXCIsIFwi5pif5pyf5LiAXCIsIFwi5pif5pyf5LqMXCIsIFwi5pif5pyf5LiJXCIsIFwi5pif5pyf5ZubXCIsIFwi5pif5pyf5LqUXCIsIFwi5pif5pyf5YWtXCJdLFxuICAgICAgICBtb250aHM6IFtcIuS4gOaciFwiLCBcIuS6jOaciFwiLCBcIuS4ieaciFwiLCBcIuWbm+aciFwiLCBcIuS6lOaciFwiLCBcIuWFreaciFwiLCBcIuS4g+aciFwiLCBcIuWFq+aciFwiLCBcIuS5neaciFwiLCBcIuWNgeaciFwiLCBcIuWNgeS4gOaciFwiLCBcIuWNgeS6jOaciFwiXSxcbiAgICAgICAgc2hvcnRNb250aHM6IFtcIuS4gOaciFwiLCBcIuS6jOaciFwiLCBcIuS4ieaciFwiLCBcIuWbm+aciFwiLCBcIuS6lOaciFwiLCBcIuWFreaciFwiLCBcIuS4g+aciFwiLCBcIuWFq+aciFwiLCBcIuS5neaciFwiLCBcIuWNgeaciFwiLCBcIuWNgeS4gOaciFwiLCBcIuWNgeS6jOaciFwiXVxuICAgIH0sXG4gICAgXCJsb3dlcmNhc2VcIjogW1xuICAgICAgICBcIuS4gOS4qlwiLFxuICAgICAgICBcIuWSjFwiLFxuICAgICAgICBcIuWcqFwiLFxuICAgICAgICBcIuS9huaYr1wiLFxuICAgICAgICBcIuWcqC4uLumHjFwiLFxuICAgICAgICBcIueahFwiLFxuICAgICAgICBcIuaIluiAhVwiLFxuICAgICAgICBcIui/mVwiLFxuICAgICAgICBcIuWQkVwiLFxuICAgICAgICBcIuS4ji4uLuS4gOi1t1wiXG4gICAgXSxcbiAgICBcIm1ldGhvZFwiOiB7XG4gICAgICAgIFwiYWN0aXZlXCI6IFwi5rS76LeD5q61XCIsXG4gICAgICAgIFwiY29sb3JcIjogXCLpopzoibJcIixcbiAgICAgICAgXCJkZXB0aFwiOiBcIua3seW6plwiLFxuICAgICAgICBcImRldlwiOiBcIuivpue7hlwiLFxuICAgICAgICBcImZvY3VzXCI6IFwi54Sm54K5XCIsXG4gICAgICAgIFwiaWNvblwiOiBcIuWbvuagh1wiLFxuICAgICAgICBcImlkXCI6IFwi6Lqr5Lu96K6k6K+BXCIsXG4gICAgICAgIFwiaGVpZ2h0XCI6IFwi6auY5bqmXCIsXG4gICAgICAgIFwibGFiZWxzXCI6IFwi5qCH562+XCIsXG4gICAgICAgIFwibGVnZW5kXCI6IFwi5Zu+5L6L5rOo6YeKXCIsXG4gICAgICAgIFwibWFyZ2luXCI6IFwi5aSW6L656LedXCIsXG4gICAgICAgIFwibWVzc2FnZXNcIjogXCLnirbmgIHmtojmga9cIixcbiAgICAgICAgXCJvcmRlclwiOiBcIuinhOWImVwiLFxuICAgICAgICBcInNlYXJjaFwiOiBcIuaQnOe0olwiLFxuICAgICAgICBcInNoYXBlXCI6IFwi5b2i54q2XCIsXG4gICAgICAgIFwic2l6ZVwiOiBcIuWkp+Wwj1wiLFxuICAgICAgICBcInN0eWxlXCI6IFwi5qC35byPXCIsXG4gICAgICAgIFwidGVtcFwiOiBcIuaaguaXtuaAp+WMuuautVwiLFxuICAgICAgICBcInRleHRcIjogXCLmlofmnKxcIixcbiAgICAgICAgXCJ0aW1lXCI6IFwi5pe26Ze0XCIsXG4gICAgICAgIFwidGltZWxpbmVcIjogXCLml7bpl7TovbRcIixcbiAgICAgICAgXCJ0b3RhbFwiOiBcIuaAu+autVwiLFxuICAgICAgICBcInR5cGVcIjogXCLnsbvlnotcIixcbiAgICAgICAgXCJ3aWR0aFwiOiBcIuWuveW6plwiLFxuICAgICAgICBcInhcIjogXCJY6L20XCIsXG4gICAgICAgIFwieVwiOiBcIlnovbRcIixcbiAgICAgICAgXCJ6b29tXCI6IFwi57yp5pS+XCIsXG4gICAgICAgIFwibW9kZVwiOiBcIuaooeW8j1wiXG4gICAgfSxcbiAgICBcInRpbWVcIjogW1xuICAgICAgICBcIuaXpVwiLFxuICAgICAgICBcIuaYn+acn1wiLFxuICAgICAgICBcIuaciFwiLFxuICAgICAgICBcIuaXtumXtFwiLFxuICAgICAgICBcIuW5tFwiXG4gICAgXSxcbiAgICBcInZpc3VhbGl6YXRpb25cIjoge1xuICAgICAgICBcImJ1YmJsZXNcIjogXCLmsJTms6FcIixcbiAgICAgICAgXCJjaGFydFwiOiBcIuWbvuihqFwiLFxuICAgICAgICBcImdlb19tYXBcIjogXCLlnLDnkIblnLDlm75cIixcbiAgICAgICAgXCJsaW5lXCI6IFwi57q/5Zu+XCIsXG4gICAgICAgIFwibmV0d29ya1wiOiBcIue9kee7nFwiLFxuICAgICAgICBcInJpbmdzXCI6IFwi54m55oCnXCIsXG4gICAgICAgIFwic2NhdHRlclwiOiBcIuaVo+eCueWbvlwiLFxuICAgICAgICBcInN0YWNrZWRcIjogXCLloIbnp6/pnaLnp6/lm75cIixcbiAgICAgICAgXCJ0cmVlX21hcFwiOiBcIuagkeWbvlwiXG4gICAgfSxcbiAgICBcInVpXCI6IHtcbiAgICAgICAgXCJhbmRcIjogXCLlkoxcIixcbiAgICAgICAgXCJiYWNrXCI6IFwi5ZCO6Z2iXCIsXG4gICAgICAgIFwiY29sbGFwc2VcIjogXCLngrnlh7vlkIjlubZcIixcbiAgICAgICAgXCJlcnJvclwiOiBcIumUmeivr1wiLFxuICAgICAgICBcImV4cGFuZFwiOiBcIuWNleWHu+S7peWxleW8gFwiLFxuICAgICAgICBcImxvYWRpbmdcIjogXCLovb3lhaXkuK0uLi5cIixcbiAgICAgICAgXCJtb3JlXCI6IFwiezB95pu05aSaXCIsXG4gICAgICAgIFwibW9yZUluZm9cIjogXCLngrnlh7vkuobop6Pmm7TlpJrkv6Hmga9cIixcbiAgICAgICAgXCJub1Jlc3VsdHNcIjogXCLmsqHmnInnu5PmnpzljLnphY17MH3jgIJcIixcbiAgICAgICAgXCJwcmltYXJ5XCI6IFwi5Li76KaB6L+e5o6lXCIsXG4gICAgICAgIFwic2hhcmVcIjogXCLlhbHkuqtcIixcbiAgICAgICAgXCJ0b3RhbFwiOiBcIuaAu1wiLFxuICAgICAgICBcInZhbHVlc1wiOiBcIuWAvFwiLFxuICAgICAgICBcImluY2x1ZGluZ1wiOiBcIuWMheaLrFwiXG4gICAgfSxcbiAgICBcIm1lc3NhZ2VcIjoge1xuICAgICAgICBcImRhdGFcIjogXCLliIbmnpDmlbDmja5cIixcbiAgICAgICAgXCJkcmF3XCI6IFwi57uY5Yi25Y+v6KeG5YyWXCIsXG4gICAgICAgIFwiaW5pdGlhbGl6aW5nXCI6IFwi5Yid5aeL5YyWezB9XCIsXG4gICAgICAgIFwibG9hZGluZ1wiOiBcIuWKoOi9veaVsOaNrlwiLFxuICAgICAgICBcInRvb2x0aXBSZXNldFwiOiBcIumHjee9ruW3peWFt+aPkOekulwiLFxuICAgICAgICBcInVpXCI6IFwi5pu05pawVUlcIlxuICAgIH0sXG4gICAgXCJ1cHBlcmNhc2VcIjogW1xuICAgICAgICBcIueUteinhlwiLFxuICAgICAgICBcIueUqOaIt+eVjOmdolwiLFxuICAgICAgICBcIueglOWPkVwiXG4gICAgXVxufVxuIiwiLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gQ3JlYXRlIGR1bW15IG1ldGhvZHMgdG8gY2F0Y2ggZGVwcmVjYXRlc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZDNwbHVzLm1ldGhvZC5heGlzID0gZnVuY3Rpb24oIGF4aXMgKSB7XG5cbiAgdmFyIGF4aXMgPSBheGlzIHx8IFwieFwiXG5cbiAgcmV0dXJuIHtcbiAgICBcImFjY2VwdGVkXCIgICAgOiBbIEFycmF5ICwgQm9vbGVhbiAsIEZ1bmN0aW9uICwgT2JqZWN0ICwgU3RyaW5nIF0sXG4gICAgXCJkYXRhRmlsdGVyXCIgIDogdHJ1ZSxcbiAgICBcImRlcHJlY2F0ZXNcIiAgOiBbIGF4aXMrXCJheGlzXCIgLCBheGlzK1wiYXhpc192YWxcIiAsIGF4aXMrXCJheGlzX3ZhclwiIF0sXG4gICAgXCJkb21haW5cIiAgICAgIDogZmFsc2UsXG4gICAgXCJsaW5lc1wiICAgICAgIDogW10sXG4gICAgXCJtdXRlXCIgICAgICAgIDogZDNwbHVzLm1ldGhvZC5maWx0ZXIodHJ1ZSksXG4gICAgXCJyYW5nZVwiICAgICAgIDogZmFsc2UsXG4gICAgXCJyZXNldFwiICAgICAgIDogWyBcInJhbmdlXCIgXSxcbiAgICBcInNjYWxlXCIgICAgICAgOiB7XG4gICAgICBcImFjY2VwdGVkXCIgICA6IFsgXCJsaW5lYXJcIiAsIFwibG9nXCIgLCBcImNvbnRpbnVvdXNcIiAsIFwic2hhcmVcIiBdLFxuICAgICAgXCJ2YWx1ZVwiICAgICAgOiBcImxpbmVhclwiLFxuICAgICAgXCJkZXByZWNhdGVzXCIgOiBbIFwibGF5b3V0XCIgLCBcInVuaXF1ZV9heGlzXCIgLCBcInlheGlzX3NjYWxlXCIgXVxuICAgIH0sXG4gICAgXCJzb2xvXCIgICAgICAgIDogZDNwbHVzLm1ldGhvZC5maWx0ZXIodHJ1ZSksXG4gICAgXCJzdGFja2VkXCIgICAgIDoge1xuICAgICAgXCJhY2NlcHRlZFwiIDogWyBCb29sZWFuIF0sXG4gICAgICBcInZhbHVlXCIgICAgOiBmYWxzZVxuICAgIH0sXG4gICAgXCJ2YWx1ZVwiICAgICAgIDogZmFsc2UsXG4gICAgXCJ6ZXJvZmlsbFwiICAgIDoge1xuICAgICAgXCJhY2NlcHRlZFwiIDogWyBCb29sZWFuIF0sXG4gICAgICBcInZhbHVlXCIgICAgOiBmYWxzZVxuICAgIH1cbiAgfVxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBDcmVhdGUgZHVtbXkgbWV0aG9kcyB0byBjYXRjaCBkZXByZWNhdGVzXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kM3BsdXMubWV0aG9kLmZpbHRlciA9IGZ1bmN0aW9uKCBnbG9iYWwgKSB7XG5cbiAgdmFyIGdsb2JhbCA9IGdsb2JhbCB8fCBmYWxzZVxuXG4gIHJldHVybiB7XG4gICAgXCJhY2NlcHRlZFwiIDogWyBBcnJheSAsIEJvb2xlYW4gLCBGdW5jdGlvbiAsIE51bWJlciAsIE9iamVjdCAsIFN0cmluZyBdLFxuICAgIFwiZ2xvYmFsXCIgICA6IGdsb2JhbCxcbiAgICBcInByb2Nlc3NcIiAgOiBBcnJheSxcbiAgICBcInZhbHVlXCIgICAgOiBbIF1cbiAgfVxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gR2V0L3NldCBmdW5jdGlvbiBmb3IgbWV0aG9kc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmQzcGx1cy5tZXRob2QuZnVuY3Rpb24gPSBmdW5jdGlvbigga2V5ICwgdmFycyApIHtcblxuICByZXR1cm4gZnVuY3Rpb24oIHVzZXIgLCBjYWxsYmFjayApIHtcblxuICAgIHZhciBhY2NlcHRlZCA9IGtleSBpbiB2YXJzICYmIGQzcGx1cy5vYmplY3QudmFsaWRhdGUodmFyc1trZXldKVxuICAgICAgICAgICAgICAgICAgICYmIFwiYWNjZXB0ZWRcIiBpbiB2YXJzW2tleV0gPyB2YXJzW2tleV0uYWNjZXB0ZWRcbiAgICAgICAgICAgICAgICAgOiBrZXkgaW4gdmFycyA/IHR5cGVvZiB2YXJzW2tleV0gOiBudWxsXG5cbiAgICBpZiAoIHR5cGVvZiBhY2NlcHRlZCA9PT0gXCJmdW5jdGlvblwiICkge1xuICAgICAgYWNjZXB0ZWQgPSBhY2NlcHRlZCggdmFycyApXG4gICAgfVxuXG4gICAgaWYgKCBhY2NlcHRlZCAhPT0gbnVsbCAmJiAhKGFjY2VwdGVkIGluc3RhbmNlb2YgQXJyYXkpICkge1xuICAgICAgYWNjZXB0ZWQgPSBbIGFjY2VwdGVkIF1cbiAgICB9XG5cbiAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgLy8gSWYgbm8gYXJndW1lbnRzIGhhdmUgYmVlbiBwYXNzZWQsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgb2JqZWN0LlxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBpZiAoIHVzZXIgPT09IE9iamVjdCApIHtcbiAgICAgIHJldHVybiB2YXJzW2tleV1cbiAgICB9XG4gICAgZWxzZSBpZiAoICFhcmd1bWVudHMubGVuZ3RoXG4gICAgICAgICAgICAgICYmICgoYWNjZXB0ZWQgPT09IG51bGwgJiYgIShcInZhbHVlXCIgaW4gdmFycykpXG4gICAgICAgICAgICAgIHx8IChhY2NlcHRlZCAhPT0gdW5kZWZpbmVkICYmIGFjY2VwdGVkLmluZGV4T2YodW5kZWZpbmVkKSA8IDApKSApIHtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gdmFyc1trZXldKSB7XG4gICAgICAgIHJldHVybiB2YXJzW2tleV0udmFsdWVcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFyc1trZXldXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAgIC8vIFdhcm4gaWYgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIHVzZSB0aGUgb2xkIC5zdHlsZSgpIG1ldGhvZC5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgaWYgKCBrZXkgPT09IFwic3R5bGVcIiAmJiB0eXBlb2YgdXNlciA9PT0gXCJvYmplY3RcIiApIHtcblxuICAgICAgdmFyIHN0ciA9IHZhcnMuZm9ybWF0LmxvY2FsZS52YWx1ZS5kZXYub2xkU3R5bGVcblxuICAgICAgaWYgKCAoIHZhcnMuZGV2LnZhbHVlIHx8ICgga2V5ID09PSBcImRldlwiICYmIHVzZXIgKSApXG4gICAgICAgICAgICYmICF2YXJzLm1ldGhvZEdyb3VwICYmIHZhcnMubWV0aG9kR3JvdXAgIT09IFwid2FpdFwiICkge1xuICAgICAgICB2YXJzLm1ldGhvZEdyb3VwID0gdHJ1ZVxuICAgICAgICBkM3BsdXMuY29uc29sZS5ncm91cENvbGxhcHNlZChcIm1ldGhvZCBiZWhhdmlvclwiKVxuICAgICAgfVxuXG4gICAgICBmb3IgKCB2YXIgcyBpbiB1c2VyICkge1xuXG4gICAgICAgIGQzcGx1cy5jb25zb2xlLndhcm5pbmcoIGQzcGx1cy5zdHJpbmcuZm9ybWF0KHN0cixcIlxcXCJcIitzK1wiXFxcIlwiLHMpICwgcyApXG5cbiAgICAgICAgdmFycy5zZWxmW3NdKHVzZXJbc10pXG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhcnMuc2VsZlxuXG4gICAgfVxuXG4gICAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAgIC8vIFNldCBhbGwgZm9udCBmYW1pbGllcyBhbmQgd2VpZ2h0cywgaWYgY2FsbGluZyAuZm9udCgpXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGlmICgga2V5ID09PSBcImZvbnRcIiAmJiBkM3BsdXMub2JqZWN0LnZhbGlkYXRlKHVzZXIpXG4gICAgICAgICAmJiBcImZhbWlseVwiIGluIHVzZXIgJiYgdHlwZW9mIHVzZXIuZmFtaWx5ID09PSBcInN0cmluZ1wiICkge1xuXG4gICAgICBmdW5jdGlvbiBjaGVja0ZhbWlseSAoIG8gKSB7XG5cbiAgICAgICAgaWYgKCBkM3BsdXMub2JqZWN0LnZhbGlkYXRlKCBvICkgKSB7XG5cbiAgICAgICAgICBpZiAoIFwiZmFtaWx5XCIgaW4gbyApIHtcbiAgICAgICAgICAgIG8uZmFtaWx5LnZhbHVlID0gby5mYW1pbHkucHJvY2VzcyggdXNlci5mYW1pbHkgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgZm9yICggdmFyIG0gaW4gbyApIHtcbiAgICAgICAgICAgICAgY2hlY2tGYW1pbHkob1ttXSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgY2hlY2tGYW1pbHkoIHZhcnMgKVxuXG4gICAgfVxuXG4gICAgZDNwbHVzLm1ldGhvZC5vYmplY3QoIHZhcnMgLCBrZXkgLCB2YXJzICwga2V5ICwgdXNlciApXG5cbiAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgLy8gSWYgZGVmaW5pbmcgYSBjYWxsYmFjayBmdW5jdGlvbiwgc2V0IGl0LlxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBpZiAoIHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiICkge1xuICAgICAgdmFyc1trZXldLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB9XG5cbiAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgLy8gSWYgdGhlIG1ldGhvZCBpcyBub3QgY2hhaW5hYmxlLCByZXR1cm4gdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgaWYgKHZhcnNba2V5XS5jaGFpbmFibGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdmFyc1trZXldLnZhbHVlXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHZhcnMuc2VsZlxuICAgIH1cblxuICB9XG5cbn1cbiIsIi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBDcmVhdGUgZHVtbXkgbWV0aG9kcyB0byBjYXRjaCBkZXByZWNhdGVzXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZDNwbHVzLm1ldGhvZC5pbml0ID0gZnVuY3Rpb24oIHZhcnMgLCBvYmogLCBtZXRob2QgKSB7XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIEluaXRpYWxpemUgYSBmZXcgZ2xvYmFscy5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIG9iai5wcmV2aW91cyA9IGZhbHNlXG4gIG9iai5jaGFuZ2VkICA9IGZhbHNlXG4gIG9iai5pbml0aWFsaXplZCA9IGZhbHNlXG4gIG9iai5nZXRWYXJzICA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHZhcnNcbiAgfVxuXG4gIGlmICggXCJpbml0XCIgaW4gb2JqICYmICEoXCJ2YWx1ZVwiIGluIG9iaikgKSB7XG4gICAgb2JqLnZhbHVlID0gb2JqLmluaXQoIHZhcnMgKVxuICAgIGRlbGV0ZSBvYmouaW5pdFxuICB9XG5cbiAgaWYgKCBcInByb2Nlc3NcIiBpbiBvYmogKSB7XG4gICAgb2JqLnZhbHVlID0gZDNwbHVzLm1ldGhvZC5wcm9jZXNzKCBvYmogLCBvYmoudmFsdWUgKVxuICB9XG5cbiAgZm9yICggdmFyIG8gaW4gb2JqICkge1xuXG4gICAgaWYgKCBvID09PSBcImRlcHJlY2F0ZXNcIiApIHtcblxuICAgICAgdmFyIGRlcHMgPSBvYmpbb10gaW5zdGFuY2VvZiBBcnJheSA/IG9ialtvXSA6IFtvYmpbb11dXG5cbiAgICAgIGRlcHMuZm9yRWFjaChmdW5jdGlvbihkKXtcblxuICAgICAgICB2YXJzLnNlbGZbZF0gPSAoZnVuY3Rpb24oZGVwLG4pIHtcblxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG5cbiAgICAgICAgICAgIGlmICggdmFycy5kZXYudmFsdWUgJiYgdmFycy5tZXRob2RHcm91cCApIHtcbiAgICAgICAgICAgICAgZDNwbHVzLmNvbnNvbGUuZ3JvdXBFbmQoKVxuICAgICAgICAgICAgICB2YXJzLm1ldGhvZEdyb3VwID0gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN0ciA9IHZhcnMuZm9ybWF0LmxvY2FsZS52YWx1ZS5kZXYuZGVwcmVjYXRlZFxuICAgICAgICAgICAgZGVwID0gXCJcXC5cIitkZXArXCIoKVwiXG4gICAgICAgICAgICBkM3BsdXMuY29uc29sZS5lcnJvciggZDNwbHVzLnN0cmluZy5mb3JtYXQoc3RyLGRlcCxcIlxcLlwiK24rXCIoKVwiKSAsIG4gKVxuICAgICAgICAgICAgcmV0dXJuIHZhcnMuc2VsZjtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9KShkLG1ldGhvZClcblxuICAgICAgfSlcblxuICAgIH1cbiAgICBlbHNlIGlmICggbyA9PT0gXCJnbG9iYWxcIiApIHtcblxuICAgICAgaWYgKCAhKG1ldGhvZCBpbiB2YXJzKSApIHtcbiAgICAgICAgdmFyc1ttZXRob2RdID0gW11cbiAgICAgIH1cblxuICAgIH1cbiAgICBlbHNlIGlmICggZDNwbHVzLm9iamVjdC52YWxpZGF0ZSggb2JqW29dICkgKSB7XG5cbiAgICAgIGQzcGx1cy5tZXRob2QuaW5pdCggdmFycyAsIG9ialtvXSAsIG8gKVxuXG4gICAgfVxuXG4gIH1cblxuICBvYmouaW5pdGlhbGl6ZWQgPSB0cnVlXG5cbn1cbiIsIi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBEZXRlY3RzIGlzIHdlIHNob3VsZCBzZXQgdGhlIG9iamVjdCBvciBjaGVjayBhbGwga2V5cyBvZiBvYmplY3QuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZDNwbHVzLm1ldGhvZC5vYmplY3QgPSBmdW5jdGlvbiggdmFycyAsIG1ldGhvZCAsIG9iamVjdCAsIGtleSAsIHZhbHVlICkge1xuXG4gIGlmIChbIFwiYWNjZXB0ZWRcIiAsIFwiZ2V0VmFyc1wiIF0uaW5kZXhPZihrZXkpIDwgMCkge1xuXG4gICAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAgIC8vIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0byBqdXN0IHNldCB0aGUgbG9jYWwgdmFyaWFibGUgb3IgdG8gZGlnIGludG9cbiAgICAvLyB0aGUgb2JqZWN0IHBhc3NlZCBsb29raW5nIGZvciBrZXlzLlxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgcGFzc2luZ09iamVjdCAgPSBkM3BsdXMub2JqZWN0LnZhbGlkYXRlKHZhbHVlKVxuICAgICAgLCBhcHByb3ZlZE9iamVjdCA9IHBhc3NpbmdPYmplY3QgJiYgKCAhKFwidmFsdWVcIiBpbiB2YWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAhKGQzLmtleXModmFsdWUpWzBdIGluIG9iamVjdFtrZXldKSApXG5cbiAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgLy8gU2V0IHZhbHVlIG9mIGtleS5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgaWYgKCB2YWx1ZSA9PT0gbnVsbCB8fCAhcGFzc2luZ09iamVjdCB8fCBhcHByb3ZlZE9iamVjdCApIHtcblxuICAgICAgaWYgKCBhcHByb3ZlZE9iamVjdCApIHtcbiAgICAgICAgZDNwbHVzLm1ldGhvZC5zZXQoIHZhcnMgLCBtZXRob2QgLCBvYmplY3Rba2V5XSAsIFwidmFsdWVcIiAsIHZhbHVlIClcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkM3BsdXMubWV0aG9kLnNldCggdmFycyAsIG1ldGhvZCAsIG9iamVjdCAsIGtleSAsIHZhbHVlIClcbiAgICAgIH1cblxuICAgIH1cbiAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgLy8gSWYgaXQncyBhbiBvYmplY3QsIGRpZyB0aHJvdWdoIGl0IGFuZCBzZXQgaW5uZXIgdmFsdWVzLlxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBlbHNlIGlmICggcGFzc2luZ09iamVjdCApIHtcblxuICAgICAgZm9yIChkIGluIHZhbHVlKSB7XG5cbiAgICAgICAgZDNwbHVzLm1ldGhvZC5vYmplY3QoIHZhcnMgLCBtZXRob2QgLCBvYmplY3Rba2V5XSAsIGQgLCB2YWx1ZVtkXSApXG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cbn1cbiIsIi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIFByb2Nlc3Mgb2JqZWN0J3MgdmFsdWVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmQzcGx1cy5tZXRob2QucHJvY2VzcyA9IGZ1bmN0aW9uKCBvYmplY3QgLCB2YWx1ZSApIHtcblxuICBpZiAoIG9iamVjdC5wcm9jZXNzID09PSBBcnJheSApIHtcbiAgICByZXR1cm4gZDNwbHVzLmFycmF5LnVwZGF0ZShkM3BsdXMudXRpbC5jb3B5KG9iamVjdC52YWx1ZSksdmFsdWUpXG4gIH1cbiAgZWxzZSBpZiAoIHR5cGVvZiBvYmplY3QucHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgKSB7XG4gICAgcmV0dXJuIG9iamVjdC5wcm9jZXNzW3ZhbHVlXVxuICB9XG4gIGVsc2UgaWYgKCB0eXBlb2Ygb2JqZWN0LnByb2Nlc3MgPT09IFwiZnVuY3Rpb25cIiApIHtcbiAgICByZXR1cm4gb2JqZWN0LnByb2Nlc3ModmFsdWUpXG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxufVxuIiwiLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gRnVuY3Rpb24gdG8gcHJvY2VzcyBkYXRhIGJ5IHVybCBvciBlbGVtZW50LlxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZDNwbHVzLm1ldGhvZC5wcm9jZXNzRGF0YSA9IGZ1bmN0aW9uICggdmFsdWUgLCBzZWxmICkge1xuXG4gIGlmICggdHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiICYmICFkM3BsdXMudXRpbC5kM3NlbGVjdGlvbiggdmFsdWUgKSApIHtcblxuICAgIHJldHVybiB2YWx1ZVxuXG4gIH1cbiAgZWxzZSB7XG5cbiAgICBpZiAoIHNlbGYgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgIHZhciBzZWxmID0gdGhpc1xuICAgIH1cblxuICAgIHZhciB2YXJzID0gc2VsZi5nZXRWYXJzKClcbiAgICAgICwgbWF5YmVVUkwgPSB2YWx1ZS5pbmRleE9mKFwiL1wiKSA+PSAwXG5cbiAgICBpZiAoICFtYXliZVVSTCAmJiBkM3BsdXMudXRpbC5kM3NlbGVjdGlvbiggdmFsdWUgKSApIHtcblxuICAgICAgcmV0dXJuIHZhbHVlXG5cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgIGlmICggIW1heWJlVVJMICYmICFkMy5zZWxlY3RBbGwoIHZhbHVlICkuZW1wdHkoKSApIHtcblxuICAgICAgICByZXR1cm4gZDMuc2VsZWN0QWxsKCB2YWx1ZSApXG5cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuXG4gICAgICAgIHNlbGYudXJsID0gdmFsdWVcbiAgICAgICAgcmV0dXJuIFtdXG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBbXVxuXG4gIH1cblxufVxuIiwiLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIFNldHMgYSBtZXRob2QncyB2YWx1ZS5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kM3BsdXMubWV0aG9kLnNldCA9IGZ1bmN0aW9uKCB2YXJzICwgbWV0aG9kICwgb2JqZWN0ICwga2V5ICwgdmFsdWUgKSB7XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIENyZWF0ZSByZWZlcmVuY2UgdGV4dCBmb3IgY29uc29sZSBzdGF0ZW1lbnRzLlxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgaWYgKCBrZXkgPT09IFwidmFsdWVcIiB8fCAha2V5IHx8IGtleSA9PT0gbWV0aG9kICkge1xuXG4gICAgdmFyIHRleHQgPSBcIlxcLlwiK21ldGhvZCtcIigpXCJcblxuICB9XG4gIGVsc2Uge1xuXG4gICAgdmFyIG9mID0gdmFycy5mb3JtYXQubG9jYWxlLnZhbHVlLmRldi5vZlxuICAgICAgLCB0ZXh0ID0gXCJcXFwiXCIra2V5K1wiXFxcIiBcIitvZitcIiBcXC5cIittZXRob2QrXCIoKVwiXG5cbiAgfVxuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBGaW5kIGFwcHJvcHJpYXRlIFwiYWNjZXB0ZWRcIiBsaXN0LlxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgaWYgKGtleSA9PT0gXCJ2YWx1ZVwiICYmIFwiYWNjZXB0ZWRcIiBpbiBvYmplY3QpIHtcblxuICAgIHZhciBhY2NlcHRlZCA9IG9iamVjdC5hY2NlcHRlZFxuXG4gIH1cbiAgZWxzZSBpZiAoIGQzcGx1cy5vYmplY3QudmFsaWRhdGUoIG9iamVjdFtrZXldICkgJiYgXCJhY2NlcHRlZFwiIGluIG9iamVjdFtrZXldICkge1xuXG4gICAgdmFyIGFjY2VwdGVkID0gb2JqZWN0W2tleV0uYWNjZXB0ZWRcblxuICB9XG4gIGVsc2Uge1xuXG4gICAgdmFyIGFjY2VwdGVkID0gbnVsbFxuXG4gIH1cblxuICBpZiAoIHR5cGVvZiBhY2NlcHRlZCA9PT0gXCJmdW5jdGlvblwiICkge1xuICAgIGFjY2VwdGVkID0gYWNjZXB0ZWQoIHZhcnMgKVxuICB9XG5cbiAgaWYgKCBhY2NlcHRlZCAhPT0gbnVsbCAmJiAhKGFjY2VwdGVkIGluc3RhbmNlb2YgQXJyYXkpICkge1xuICAgIGFjY2VwdGVkID0gWyBhY2NlcHRlZCBdXG4gIH1cblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbGxvd2VkLlxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgdmFyIGFsbG93ZWQgPSB0cnVlXG4gIGlmIChhY2NlcHRlZCBpbnN0YW5jZW9mIEFycmF5KSB7XG5cbiAgICB2YXIgY29uc3RydWN0b3IgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gdmFsdWUgOiB2YWx1ZS5jb25zdHJ1Y3RvclxuXG4gICAgYWxsb3dlZCA9IGFjY2VwdGVkLmluZGV4T2YodmFsdWUpID49IDBcbiAgICAgICAgICAgICAgfHwgYWNjZXB0ZWQuaW5kZXhPZihjb25zdHJ1Y3RvcikgPj0gMFxuXG4gIH1cblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gSWYgdmFsdWUgaXMgbm90IGFsbG93ZWQsIHNob3cgYW4gZXJyb3IgbWVzc2FnZSBpbiB0aGUgY29uc29sZS5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGlmIChhbGxvd2VkID09PSBmYWxzZSkge1xuXG4gICAgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICB2YXIgc3RyID0gdmFycy5mb3JtYXQubG9jYWxlLnZhbHVlLmRldi5hY2NlcHRlZFxuICAgICAgICAsIHJlY3MgPSBbXVxuICAgICAgICAsIHZhbCA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKVxuICAgICAgICAsIGFuZCA9IHZhcnMuZm9ybWF0LmxvY2FsZS52YWx1ZS51aS5hbmRcblxuICAgICAgaWYgKCB0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgIHZhbCA9IFwiXFxcIlwiK3ZhbCtcIlxcXCJcIlxuICAgICAgfVxuXG4gICAgICBhY2NlcHRlZC5mb3JFYWNoKGZ1bmN0aW9uKGEpe1xuXG4gICAgICAgIGlmICggdHlwZW9mIGEgPT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgcmVjcy5wdXNoKFwiXFxcIlwiK2ErXCJcXFwiXCIpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHR5cGVvZiBhID09PSBcImZ1bmN0aW9uXCIgKSB7XG4gICAgICAgICAgcmVjcy5wdXNoKGEudG9TdHJpbmcoKS5zcGxpdChcIigpXCIpWzBdLnN1YnN0cmluZyg5KSlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZWNzLnB1c2goYS50b1N0cmluZygpKVxuICAgICAgICB9XG5cbiAgICAgIH0pXG5cbiAgICAgIHJlY3MgPSBkM3BsdXMuc3RyaW5nLmxpc3QocmVjcyxhbmQpXG4gICAgICBkM3BsdXMuY29uc29sZS53YXJuaW5nKCBkM3BsdXMuc3RyaW5nLmZvcm1hdChzdHIsdmFsLHRleHQscmVjcykgLCBtZXRob2QgKVxuXG4gICAgfVxuXG4gIH1cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIE90aGVyd2lzZSwgc2V0IHRoZSB2YWx1ZSFcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGVsc2Uge1xuXG4gICAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAgIC8vIElmIHRoZSBtZXRob2Qgd2UgYXJlIHNldHRpbmcgaGFzIGEgbmVzdGVkIFwidmFsdWVcIiBrZXksIGNoYW5nZSB0aGVcbiAgICAvLyByZWZlcmVuY2Ugb2JqZWN0IGFuZCBrZXkgdG8gcmVmbGVjdCB0aGF0LlxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBpZiAoIGQzcGx1cy5vYmplY3QudmFsaWRhdGUoIG9iamVjdFtrZXldICkgJiYgXCJ2YWx1ZVwiIGluIG9iamVjdFtrZXldICkge1xuXG4gICAgICB2YXIgcGFyZW50S2V5ID0ga2V5XG4gICAgICBvYmplY3QgPSBvYmplY3Rba2V5XVxuICAgICAga2V5ID0gXCJ2YWx1ZVwiXG5cbiAgICB9XG5cbiAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAgIC8vIElmIHRoZXJlIGlzIGEgcHJvY2VzcyBmdW5jdGlvbiwgcnVuIGl0LlxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgaWYgKCBrZXkgPT09IFwidmFsdWVcIiAmJiBcInByb2Nlc3NcIiBpbiBvYmplY3QgKSB7XG5cbiAgICAgIHZhbHVlID0gZDNwbHVzLm1ldGhvZC5wcm9jZXNzKCBvYmplY3QgLCB2YWx1ZSApXG5cbiAgICB9XG5cbiAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgLy8gSWYgdmFsdWUgaGFzIG5vdCBjaGFuZ2VkLCBzaG93IGEgY29tbWVudCBpbiB0aGUgY29uc29sZS5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgaWYgKCAhKG9iamVjdFtrZXldIGluc3RhbmNlb2YgQXJyYXkpICYmIG9iamVjdFtrZXldID09PSB2YWx1ZSAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICB2YXIgc3RyID0gdmFycy5mb3JtYXQubG9jYWxlLnZhbHVlLmRldi5ub0NoYW5nZVxuICAgICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLmNvbW1lbnQoZDNwbHVzLnN0cmluZy5mb3JtYXQoc3RyLHRleHQpKVxuXG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAgICAgLy8gTWFyayB0aGUgbWV0aG9kIGFzIGJlaW5nIGNoYW5nZWQuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgb2JqZWN0LmNoYW5nZWQgPSB0cnVlXG5cbiAgICAgIGlmICggXCJoaXN0b3J5XCIgaW4gdmFycyAmJiBtZXRob2QgIT09IFwiZHJhd1wiICkge1xuICAgICAgICB2YXIgY29weSA9IGQzcGx1cy51dGlsLmNvcHkob2JqZWN0KVxuICAgICAgICBjb3B5Lm1ldGhvZCA9IG1ldGhvZFxuICAgICAgICB2YXJzLmhpc3RvcnkuY2hhaW4ucHVzaChjb3B5KVxuICAgICAgfVxuXG4gICAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAgICAgLy8gQmVmb3JlIHVwZGF0aW5nIHRoZSB2YWx1ZSwgc3RvcmUgdGhlIHByZXZpb3VzIG9uZSBmb3IgcmVmZXJlbmNlLlxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIG9iamVjdC5wcmV2aW91cyA9IG9iamVjdFtrZXldXG5cbiAgICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgICAvLyBTZXQgdGhlIHZhcmlhYmxlIVxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIGlmICggXCJpZFwiIGluIHZhcnMgJiYga2V5ID09PSBcInZhbHVlXCIgJiYgXCJuZXN0aW5nXCIgaW4gb2JqZWN0ICkge1xuXG4gICAgICAgIGlmICggbWV0aG9kICE9PSBcImlkXCIgKSB7XG5cbiAgICAgICAgICBpZiAoIHR5cGVvZiBvYmplY3QubmVzdGluZyAhPT0gXCJvYmplY3RcIiApIHtcbiAgICAgICAgICAgIG9iamVjdC5uZXN0aW5nID0ge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIGQzcGx1cy5vYmplY3QudmFsaWRhdGUoIHZhbHVlICkgKSB7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGlkIGluIHZhbHVlKSB7XG5cbiAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgdmFsdWVbaWRdID09PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIHZhbHVlW2lkXSA9IFt2YWx1ZVtpZF1dXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmplY3QubmVzdGluZyA9IGQzcGx1cy5vYmplY3QubWVyZ2UoIG9iamVjdC5uZXN0aW5nICwgdmFsdWUgKVxuXG4gICAgICAgICAgICBpZiAoICEodmFycy5pZC52YWx1ZSBpbiBvYmplY3QubmVzdGluZykgKSB7XG4gICAgICAgICAgICAgIG9iamVjdC5uZXN0aW5nW3ZhcnMuaWQudmFsdWVdID0gdmFsdWVbZDMua2V5cyh2YWx1ZSlbMF1dXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgKSB7XG4gICAgICAgICAgICBvYmplY3QubmVzdGluZ1t2YXJzLmlkLnZhbHVlXSA9IHZhbHVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqZWN0Lm5lc3RpbmdbdmFycy5pZC52YWx1ZV0gPSBbIHZhbHVlIF1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvYmplY3Rba2V5XSA9IG9iamVjdC5uZXN0aW5nW3ZhcnMuaWQudmFsdWVdWzBdXG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgIGlmICggdmFsdWUgaW5zdGFuY2VvZiBBcnJheSApIHtcblxuICAgICAgICAgICAgb2JqZWN0Lm5lc3RpbmcgPSB2YWx1ZVxuXG4gICAgICAgICAgICBpZiAoXCJkZXB0aFwiIGluIHZhcnMgJiYgdmFycy5kZXB0aC52YWx1ZSA8IHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlW3ZhcnMuZGVwdGgudmFsdWVdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZVswXVxuICAgICAgICAgICAgICBpZiAoXCJkZXB0aFwiIGluIHZhcnMpIHtcbiAgICAgICAgICAgICAgICB2YXJzLmRlcHRoLnZhbHVlID0gMFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIG9iamVjdFtrZXldID0gdmFsdWVcbiAgICAgICAgICAgIG9iamVjdC5uZXN0aW5nID0gW3ZhbHVlXVxuICAgICAgICAgICAgaWYgKFwiZGVwdGhcIiBpbiB2YXJzKSB7XG4gICAgICAgICAgICAgIHZhcnMuZGVwdGgudmFsdWUgPSAwXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgICBlbHNlIGlmICggbWV0aG9kID09PSBcImRlcHRoXCIgKSB7XG5cbiAgICAgICAgaWYgKHZhbHVlID49IHZhcnMuaWQubmVzdGluZy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXJzLmRlcHRoLnZhbHVlID0gdmFycy5pZC5uZXN0aW5nLmxlbmd0aC0xXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgdmFycy5kZXB0aC52YWx1ZSA9IDBcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXJzLmRlcHRoLnZhbHVlID0gdmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIHZhcnMuaWQudmFsdWUgPSB2YXJzLmlkLm5lc3RpbmdbdmFycy5kZXB0aC52YWx1ZV1cblxuICAgICAgICBpZiAoIHR5cGVvZiB2YXJzLnRleHQubmVzdGluZyA9PT0gXCJvYmplY3RcIiApIHtcblxuICAgICAgICAgIHZhciBuID0gdmFycy50ZXh0Lm5lc3RpbmdbdmFycy5pZC52YWx1ZV1cbiAgICAgICAgICBpZiAoIG4gKSB7XG4gICAgICAgICAgICB2YXJzLnRleHQubmVzdGluZ1t2YXJzLmlkLnZhbHVlXSA9IHR5cGVvZiBuID09IFwic3RyaW5nXCIgPyBbbl0gOiBuXG4gICAgICAgICAgICB2YXJzLnRleHQudmFsdWUgPSBuIGluc3RhbmNlb2YgQXJyYXkgPyBuWzBdIDogblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICggZDNwbHVzLm9iamVjdC52YWxpZGF0ZShvYmplY3Rba2V5XSkgJiYgZDNwbHVzLm9iamVjdC52YWxpZGF0ZSh2YWx1ZSkgKSB7XG5cbiAgICAgICAgb2JqZWN0W2tleV0gPSBkM3BsdXMub2JqZWN0Lm1lcmdlKCBvYmplY3Rba2V5XSAsIHZhbHVlIClcblxuICAgICAgfVxuICAgICAgZWxzZSB7XG5cbiAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZVxuXG4gICAgICB9XG5cbiAgICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgICAvLyBBZGQgbWV0aG9kIHRvIGRhdGEgc29sby9tdXRlIGFycmF5IGlmIGFwcGxpY2FibGUuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgaWYgKCBrZXkgPT09IFwidmFsdWVcIiAmJiBvYmplY3QuZ2xvYmFsICkge1xuXG4gICAgICAgIHZhciBoYXNWYWx1ZSA9IG9iamVjdFtrZXldLmxlbmd0aCA+IDBcbiAgICAgICAgICAsIGsgPSBwYXJlbnRLZXkgfHwga2V5XG5cbiAgICAgICAgaWYgKCBrIGluIHZhcnMgJiYgKCAoIGhhc1ZhbHVlICYmIHZhcnMuZGF0YVtrXS5pbmRleE9mKG1ldGhvZCkgPCAwIClcbiAgICAgICAgfHwgKCAhaGFzVmFsdWUgJiYgdmFycy5kYXRhW2tdLmluZGV4T2YobWV0aG9kKSA+PSAwICkgKSApIHtcblxuICAgICAgICAgIHZhcnMuZGF0YVtrXSA9IGQzcGx1cy5hcnJheS51cGRhdGUodmFycy5kYXRhW2tdLG1ldGhvZClcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAgIC8vIEFkZCBtZXRob2QgdG8gZGF0YSBmaWx0ZXIgYXJyYXkgaWYgYXBwbGljYWJsZS5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICBpZiAoIGtleSA9PT0gXCJ2YWx1ZVwiICYmIG9iamVjdC5kYXRhRmlsdGVyICYmIHZhcnMuZGF0YVxuICAgICAgJiYgdmFycy5kYXRhLmZpbHRlcnMuaW5kZXhPZihtZXRob2QpIDwgMCApIHtcblxuICAgICAgICB2YXJzLmRhdGEuZmlsdGVycy5wdXNoKCBtZXRob2QgKVxuXG4gICAgICB9XG5cbiAgICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgICAvLyBSZXNldCBhc3NvY2lhdGVkIHZhcmlhYmxlcyBnaXZlbiBpZiBcInZhbHVlXCIgaXMgY2hhbmdlZC5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICBpZiAoa2V5ID09PSBcInZhbHVlXCIgJiYgb2JqZWN0LnJlc2V0KSB7XG5cbiAgICAgICAgdmFyIHJlc2V0ID0gdHlwZW9mIG9iamVjdC5yZXNldCA9PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICA/IFsgb2JqZWN0LnJlc2V0IF0gOiBvYmplY3QucmVzZXRcblxuICAgICAgICByZXNldC5mb3JFYWNoKGZ1bmN0aW9uKHIpe1xuICAgICAgICAgIG9iamVjdFtyXSA9IGZhbHNlXG4gICAgICAgIH0pXG5cbiAgICAgIH1cblxuICAgICAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAgIC8vIERpc3BsYXkgY29uc29sZSBtZXNzYWdlLCBpZiBhcHBsaWNhYmxlLlxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIGlmICggKCB2YXJzLmRldi52YWx1ZSB8fCBrZXkgPT09IFwiZGV2XCIgKSAmJiBvYmplY3QuY2hhbmdlZFxuICAgICAgICAgICAmJiBvYmplY3Rba2V5XSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHZhciBsb25nQXJyYXkgPSBvYmplY3Rba2V5XSBpbnN0YW5jZW9mIEFycmF5ICYmIG9iamVjdFtrZXldLmxlbmd0aCA+IDEwXG4gICAgICAgICAgLCBkM3NlbGVjdGlvbiA9IGQzcGx1cy51dGlsLmQzc2VsZWN0aW9uKG9iamVjdFtrZXldKVxuICAgICAgICAgICwgdHlwZUZ1bmN0aW9uID0gdHlwZW9mIG9iamVjdFtrZXldID09PSBcImZ1bmN0aW9uXCJcblxuICAgICAgICB2YXIgdmFsU3RyaW5nID0gIWxvbmdBcnJheSAmJiAhZDNzZWxlY3Rpb24gJiYgIXR5cGVGdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgID8gdHlwZW9mIG9iamVjdFtrZXldID09PSBcInN0cmluZ1wiID8gb2JqZWN0W2tleV1cbiAgICAgICAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KG9iamVjdFtrZXldKSA6IG51bGxcblxuICAgICAgICBpZiAoICggdmFycy5kZXYudmFsdWUgfHwgKCBrZXkgPT09IFwiZGV2XCIgJiYgdXNlciApIClcbiAgICAgICAgICAgICAmJiAhdmFycy5tZXRob2RHcm91cCAmJiB2YXJzLm1ldGhvZEdyb3VwICE9PSBcIndhaXRcIiApIHtcbiAgICAgICAgICB2YXJzLm1ldGhvZEdyb3VwID0gdHJ1ZVxuICAgICAgICAgIGQzcGx1cy5jb25zb2xlLmdyb3VwQ29sbGFwc2VkKFwibWV0aG9kIGJlaGF2aW9yXCIpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHZhbFN0cmluZyAhPT0gbnVsbCAmJiB2YWxTdHJpbmcubGVuZ3RoIDwgMjYwICkge1xuXG4gICAgICAgICAgdmFyIHN0ciA9IHZhcnMuZm9ybWF0LmxvY2FsZS52YWx1ZS5kZXYuc2V0TG9uZ1xuICAgICAgICAgIGQzcGx1cy5jb25zb2xlLmxvZyhkM3BsdXMuc3RyaW5nLmZvcm1hdChzdHIsdGV4dCxcIlxcXCJcIit2YWxTdHJpbmcrXCJcXFwiXCIpKVxuXG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgIHZhciBzdHIgPSB2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUuZGV2LnNldFxuICAgICAgICAgIGQzcGx1cy5jb25zb2xlLmxvZyhkM3BsdXMuc3RyaW5nLmZvcm1hdChzdHIsdGV4dCkpXG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgLy8gSWYgdGhlcmUgaXMgYSBjYWxsYmFjayBmdW5jdGlvbiBub3QgYXNzb2NpYXRlZCB3aXRoIGEgVVJMLCBydW4gaXQuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGlmICgga2V5ID09PSBcInZhbHVlXCIgJiYgb2JqZWN0LmNhbGxiYWNrICYmICFvYmplY3QudXJsICkge1xuXG4gICAgICBvYmplY3QuY2FsbGJhY2sodmFsdWUpXG5cbiAgICB9XG5cbiAgfVxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gR2xvYmFsIG1ldGhvZCBzaGVsbC5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kM3BsdXMubWV0aG9kID0gZnVuY3Rpb24oIHZhcnMgLCBtZXRob2RzICwgc3R5bGVzICkge1xuXG4gIHZhciBtZXRob2RzICAgPSBtZXRob2RzIHx8IFtdXG4gICAgLCBzdHlsZXMgICAgPSBzdHlsZXMgfHwgW11cbiAgICAsIGluaXRTdHlsZSA9IGQzcGx1cy5zdHlsZVsgZDNwbHVzLm1ldGhvZC5zdHlsZS52YWx1ZSBdXG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIExvb3AgdGhyb3VnaCBlYWNoIHNwZWNpZmllZCBtZXRob2QgYW5kIGFwcGx5IGl0IHRvIHRoZSBvYmplY3QuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24obSkge1xuXG4gICAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAgIC8vIENsb25lIG1ldGhvZCBkZWZhdWx0cy5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgaWYgKCAhKG0gaW4gdmFycykgKSB7XG4gICAgICB2YXJzW21dID0ge31cbiAgICB9XG5cbiAgICB2YXJzW21dID0gZDNwbHVzLm9iamVjdC5tZXJnZSggZDNwbHVzLm1ldGhvZFttXSAsIHZhcnNbbV0gKVxuXG4gICAgaWYgKCBzdHlsZXMuaW5kZXhPZihtKSA+PSAwICkge1xuICAgICAgdmFyc1ttXSA9IGQzcGx1cy5vYmplY3QubWVyZ2UoIGluaXRTdHlsZVttXSAsIHZhcnNbbV0gKVxuICAgICAgc3R5bGVzLnNwbGljZShzdHlsZXMuaW5kZXhPZihtKSwxKVxuICAgIH1cblxuICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAvLyBSdW4gaW5pdGlhbGl6YXRpb24gb24gYWxsIGlubmVyIHByb3BlcnRpZXMuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGQzcGx1cy5tZXRob2QuaW5pdCggdmFycyAsIHZhcnNbbV0gLCBtIClcblxuICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAvLyBDcmVhdGUgdGhlIG1haW4gc2V0L2dldCBmdW5jdGlvbi5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFycy5zZWxmW21dID0gKGQzcGx1cy5tZXRob2QuZnVuY3Rpb24pKCBtICwgdmFycyApXG5cbiAgfSlcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gTG9vcCB0aHJvdWdoIHJlbWFpbmluZyBzdHlsZXMgYW5kIGNyZWF0ZSBtZXRob2RzIGZvciB0aGVtLlxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgc3R5bGVzLmZvckVhY2goZnVuY3Rpb24obSl7XG5cbiAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgLy8gQ2xvbmUgc3R5bGUgZGVmYXVsdHMuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhcnNbbV0gPSBkM3BsdXMub2JqZWN0Lm1lcmdlKCB2YXJzW21dIHx8IHt9ICwgaW5pdFN0eWxlW21dIClcblxuICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAvLyBSdW4gaW5pdGlhbGl6YXRpb24gb24gYWxsIGlubmVyIHByb3BlcnRpZXMuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGQzcGx1cy5tZXRob2QuaW5pdCggdmFycyAsIHZhcnNbbV0gLCBtIClcblxuICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAvLyBDcmVhdGUgdGhlIG1haW4gc2V0L2dldCBmdW5jdGlvbi5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFycy5zZWxmW21dID0gKGQzcGx1cy5tZXRob2QuZnVuY3Rpb24pKCBtICwgdmFycyApXG5cbiAgfSlcblxufVxuIiwiZDNwbHVzLm1ldGhvZC5hY3RpdmUgPSB7XG4gIFwiYWNjZXB0ZWRcIiAgIDogWyBmYWxzZSAsIEFycmF5ICwgRnVuY3Rpb24gLCBOdW1iZXIgLCBPYmplY3QgLCBTdHJpbmcgXSxcbiAgXCJkZXByZWNhdGVzXCIgOiBcImFjdGl2ZV92YXJcIixcbiAgXCJtdXRlXCIgICAgICAgOiBkM3BsdXMubWV0aG9kLmZpbHRlcih0cnVlKSxcbiAgXCJzb2xvXCIgICAgICAgOiBkM3BsdXMubWV0aG9kLmZpbHRlcih0cnVlKSxcbiAgXCJzcG90bGlnaHRcIiAgOiB7XG4gICAgXCJhY2NlcHRlZFwiICAgOiBbIEJvb2xlYW4gXSxcbiAgICBcImRlcHJlY2F0ZXNcIiA6IFwic3BvdGxpZ2h0XCIsXG4gICAgXCJ2YWx1ZVwiICAgICAgOiBmYWxzZVxuICB9LFxuICBcInZhbHVlXCIgICAgICA6IGZhbHNlXG59XG4iLCJkM3BsdXMubWV0aG9kLmFnZ3MgPSB7XG4gIFwiYWNjZXB0ZWRcIiAgIDogWyBPYmplY3QgXSxcbiAgXCJkZXByZWNhdGVkXCIgOiBcIm5lc3RpbmdfYWdnc1wiLFxuICBcInZhbHVlXCIgICAgICA6IHt9XG59XG4iLCJkM3BsdXMubWV0aG9kLmFsdCA9IHtcbiAgXCJhY2NlcHRlZFwiIDogWyBmYWxzZSAsIEFycmF5ICwgRnVuY3Rpb24gLCBPYmplY3QgLCBTdHJpbmcgXSxcbiAgXCJtdXRlXCIgICAgIDogZDNwbHVzLm1ldGhvZC5maWx0ZXIodHJ1ZSksXG4gIFwic29sb1wiICAgICA6IGQzcGx1cy5tZXRob2QuZmlsdGVyKHRydWUpLFxuICBcInZhbHVlXCIgICAgOiBcImFsdFwiXG59XG4iLCJkM3BsdXMubWV0aG9kLmF0dHJzID0ge1xuICBcImFjY2VwdGVkXCIgOiBbIGZhbHNlICwgQXJyYXkgLCBPYmplY3QgLCBTdHJpbmcgXSxcbiAgXCJkZWxpbWl0ZXJcIiA6IHtcbiAgICBcImFjY2VwdGVkXCIgOiBbIFN0cmluZyBdLFxuICAgIFwidmFsdWVcIiAgICA6IFwifFwiXG4gIH0sXG4gIFwiZmlsZXR5cGVcIiA6IHtcbiAgICBcImFjY2VwdGVkXCIgOiBbIGZhbHNlICwgXCJqc29uXCIgLCBcInhtbFwiICxcImh0bWxcIlxuICAgICAgICAgICAgICAgICAsIFwiY3N2XCIgLCBcImRzdlwiICwgXCJ0c3ZcIiAsIFwidHh0XCIgXSxcbiAgICBcInZhbHVlXCIgICAgOiBmYWxzZVxuICB9LFxuICBcInByb2Nlc3NcIiAgOiBkM3BsdXMubWV0aG9kLnByb2Nlc3NEYXRhLFxuICBcInZhbHVlXCIgICAgOiBmYWxzZVxufVxuIiwiZDNwbHVzLm1ldGhvZC5heGVzID0ge1xuICBcIm1pcnJvclwiIDoge1xuICAgIFwiYWNjZXB0ZWRcIiAgIDogWyBCb29sZWFuIF0sXG4gICAgXCJkZXByZWNhdGVzXCIgOiBbIFwibWlycm9yX2F4aXNcIiAsIFwibWlycm9yX2F4ZXNcIiBdLFxuICAgIFwidmFsdWVcIiAgICAgIDogZmFsc2VcbiAgfSxcbiAgXCJ2YWx1ZXNcIiA6IFsgXCJ4XCIgLCBcInlcIiBdXG59XG4iLCJkM3BsdXMubWV0aG9kLmNvbG9yID0ge1xuICBcImFjY2VwdGVkXCIgICA6IFsgZmFsc2UgLCBBcnJheSAsIEZ1bmN0aW9uICwgT2JqZWN0ICwgU3RyaW5nIF0sXG4gIFwiZGVwcmVjYXRlc1wiIDogXCJjb2xvcl92YXJcIixcbiAgXCJpbml0XCIgICAgICAgOiBmdW5jdGlvbiAoIHZhcnMgKSB7XG5cbiAgICBpZiAoIHZhcnMuc2hlbGwgPT09IFwiZm9ybVwiICkge1xuICAgICAgcmV0dXJuIFwiY29sb3JcIlxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICB9LFxuICBcIm11dGVcIiAgICAgIDogZDNwbHVzLm1ldGhvZC5maWx0ZXIodHJ1ZSksXG4gIFwic29sb1wiICAgICAgOiBkM3BsdXMubWV0aG9kLmZpbHRlcih0cnVlKVxufVxuIiwiZDNwbHVzLm1ldGhvZC5jb250YWluZXIgPSB7XG4gIFwiYWNjZXB0ZWRcIiA6IFsgQXJyYXkgLCBPYmplY3QgLCBTdHJpbmcgXSxcbiAgXCJlbGVtZW50XCIgIDogZmFsc2UsXG4gIFwiaWRcIiAgICAgICA6IFwiZGVmYXVsdFwiLFxuICBcInByb2Nlc3NcIiAgOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgaWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG4gICAgICB2YXIgc2hlbGwgPSB0aGlzLmdldFZhcnMoKS5zaGVsbFxuICAgICAgcmV0dXJuIHNoZWxsID09PSBcImZvcm1cIiA/IGQzLnNlbGVjdChcImJvZHlcIikgOiB2YWx1ZVxuICAgIH1cbiAgICBlbHNlIGlmICggZDNwbHVzLnV0aWwuZDNzZWxlY3Rpb24odmFsdWUpICkge1xuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuICAgIGVsc2UgaWYgKCB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5ICkge1xuICAgICAgcmV0dXJuIGQzLnNlbGVjdCh2YWx1ZVswXVswXSlcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gZDMuc2VsZWN0KHZhbHVlKVxuICAgIH1cblxuICB9LFxuICBcInZhbHVlXCIgICAgOiBmYWxzZVxufVxuIiwiZDNwbHVzLm1ldGhvZC5jb29yZHMgPSB7XG4gIFwiYWNjZXB0ZWRcIiA6IFsgZmFsc2UgLCBBcnJheSAsIEZ1bmN0aW9uICwgT2JqZWN0ICwgU3RyaW5nIF0sXG4gIFwiZmlsZXR5cGVcIiA6IHtcbiAgICBcImFjY2VwdGVkXCIgOiBbIFwianNvblwiIF0sXG4gICAgXCJ2YWx1ZVwiICAgIDogXCJqc29uXCJcbiAgfSxcbiAgXCJtdXRlXCIgICAgIDogZDNwbHVzLm1ldGhvZC5maWx0ZXIoZmFsc2UpLFxuICBcInByb2Nlc3NcIiAgOiBkM3BsdXMubWV0aG9kLnByb2Nlc3NEYXRhLFxuICBcInNvbG9cIiAgICAgOiBkM3BsdXMubWV0aG9kLmZpbHRlcihmYWxzZSksXG4gIFwidmFsdWVcIiAgICA6IGZhbHNlXG59XG4iLCJ2YXIgZmV0Y2hWYWx1ZSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL2ZldGNoL3ZhbHVlLmpzXCIpXG5cbmQzcGx1cy5tZXRob2QuY3N2ID0ge1xuICBcImFjY2VwdGVkXCIgIDogWyB1bmRlZmluZWQgLCBBcnJheSAsIFN0cmluZyBdLFxuICBcImNoYWluYWJsZVwiIDogZmFsc2UsXG4gIFwiZGF0YVwiICAgICAgOiBbXSxcbiAgXCJwcm9jZXNzXCIgICA6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICB2YXIgdmFycyA9IHRoaXMuZ2V0VmFycygpXG5cbiAgICBpZiAoIHZhcnMucmV0dXJuZWQgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGlmICggdmFsdWUgaW5zdGFuY2VvZiBBcnJheSApIHtcbiAgICAgIHZhciBjb2x1bW5zID0gdmFsdWVcbiAgICB9XG4gICAgZWxzZSBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgIHZhciBjb2x1bW5zID0gWyB2YWx1ZSBdXG4gICAgfVxuXG4gICAgdmFyIGNzdl90b19yZXR1cm4gPSBbXSxcbiAgICAgICAgdGl0bGVzID0gW10sXG4gICAgICAgIHRpdGxlID0gdmFycy50aXRsZS52YWx1ZSB8fCBcIk15IEQzcGx1cyBBcHAgRGF0YVwiXG5cbiAgICB0aXRsZSA9IGQzcGx1cy5zdHJpbmcuc3RyaXAodGl0bGUpXG5cbiAgICBpZiAoIWNvbHVtbnMpIHtcbiAgICAgIHZhciBjb2x1bW5zID0gW3ZhcnMuaWQudmFsdWVdXG4gICAgICBpZiAodmFycy50aW1lLnZhbHVlKSBjb2x1bW5zLnB1c2godmFycy50aW1lLnZhbHVlKVxuICAgICAgaWYgKHZhcnMuc2l6ZS52YWx1ZSkgY29sdW1ucy5wdXNoKHZhcnMuc2l6ZS52YWx1ZSlcbiAgICAgIGlmICh2YXJzLnRleHQudmFsdWUpIGNvbHVtbnMucHVzaCh2YXJzLnRleHQudmFsdWUpXG4gICAgfVxuXG4gICAgY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uKGMpe1xuICAgICAgdGl0bGVzLnB1c2godmFycy5mb3JtYXQudmFsdWUoYykpXG4gICAgfSlcblxuICAgIGNzdl90b19yZXR1cm4ucHVzaCh0aXRsZXMpO1xuXG4gICAgdmFycy5yZXR1cm5lZC5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG4pe1xuICAgICAgdmFyIGFyciA9IFtdXG4gICAgICBjb2x1bW5zLmZvckVhY2goZnVuY3Rpb24oYyl7XG4gICAgICAgIGFyci5wdXNoKGZldGNoVmFsdWUodmFycyxuLGMpKVxuICAgICAgfSlcbiAgICAgIGNzdl90b19yZXR1cm4ucHVzaChhcnIpXG4gICAgfSlcblxuICAgIHZhciBjc3ZfZGF0YSA9IFwiZGF0YTp0ZXh0L2NzdjtjaGFyc2V0PXV0Zi04LFwiXG4gICAgY3N2X3RvX3JldHVybi5mb3JFYWNoKGZ1bmN0aW9uKGMsaSl7XG4gICAgICBkYXRhU3RyaW5nID0gYy5qb2luKFwiLFwiKVxuICAgICAgY3N2X2RhdGEgKz0gaSA8IGNzdl90b19yZXR1cm4ubGVuZ3RoID8gZGF0YVN0cmluZyArIFwiXFxuXCIgOiBkYXRhU3RyaW5nXG4gICAgfSlcblxuICAgIGlmIChkM3BsdXMuaWUpIHtcblxuICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbY3N2X2RhdGFdLHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0L2NzdjtjaGFyc2V0PXV0Zi04O1wiLFxuICAgICAgfSlcbiAgICAgIG5hdmlnYXRvci5tc1NhdmVCbG9iKGJsb2IsdGl0bGUrXCIuY3N2XCIpXG5cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgIHZhciBlbmNvZGVkVXJpID0gZW5jb2RlVVJJKGNzdl9kYXRhKVxuICAgICAgdmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKVxuICAgICAgbGluay5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGVuY29kZWRVcmkpXG4gICAgICBsaW5rLnNldEF0dHJpYnV0ZShcImRvd25sb2FkXCIsdGl0bGUrXCIuY3N2XCIpXG4gICAgICBsaW5rLmNsaWNrKClcblxuICAgIH1cblxuICAgIHRoaXMuZGF0YSA9IGNzdl90b19yZXR1cm5cblxuICAgIHJldHVybiBjb2x1bW5zXG5cbiAgfSxcbiAgXCJ2YWx1ZVwiICAgICA6IHVuZGVmaW5lZFxufVxuIiwiZDNwbHVzLm1ldGhvZC5kYXRhID0ge1xuICBcImFjY2VwdGVkXCIgOiBbIGZhbHNlICwgQXJyYXkgLCBGdW5jdGlvbiAsIFN0cmluZyBdLFxuICBcImNhY2hlXCIgICAgOiB7fSxcbiAgXCJkZWxpbWl0ZXJcIiA6IHtcbiAgICBcImFjY2VwdGVkXCIgOiBbIFN0cmluZyBdLFxuICAgIFwidmFsdWVcIiAgICA6IFwifFwiXG4gIH0sXG4gIFwiZWxlbWVudFwiOiB7XG4gICAgXCJwcm9jZXNzXCI6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuICAgICAgaWYgKCBkM3BsdXMudXRpbC5kM3NlbGVjdGlvbih2YWx1ZSkgKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdmFsdWVcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhZDMuc2VsZWN0KHZhbHVlKS5lbXB0eSgpKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gZDMuc2VsZWN0KHZhbHVlKVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQpIHtcblxuICAgICAgICB2YXIgdmFycyA9IHRoaXMuZ2V0VmFycygpXG5cbiAgICAgICAgdmFycy5zZWxmLmNvbnRhaW5lcihkMy5zZWxlY3QoZWxlbWVudC5ub2RlKCkucGFyZW50Tm9kZSkpXG5cbiAgICAgICAgZWxlbWVudFxuICAgICAgICAgIC5zdHlsZShcInBvc2l0aW9uXCIsXCJhYnNvbHV0ZVwiLFwiaW1wb3J0YW50XCIpXG4gICAgICAgICAgLnN0eWxlKFwiY2xpcFwiLFwicmVjdCgxcHggMXB4IDFweCAxcHgpXCIsXCJpbXBvcnRhbnRcIilcbiAgICAgICAgICAuc3R5bGUoXCJjbGlwXCIsXCJyZWN0KDFweCwgMXB4LCAxcHgsIDFweClcIixcImltcG9ydGFudFwiKVxuICAgICAgICAgIC5zdHlsZShcIndpZHRoXCIsXCIxcHhcIixcImltcG9ydGFudFwiKVxuICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLFwiMXB4XCIsXCJpbXBvcnRhbnRcIilcbiAgICAgICAgICAuc3R5bGUoXCJtYXJnaW5cIixcIi0xcHhcIixcImltcG9ydGFudFwiKVxuICAgICAgICAgIC5zdHlsZShcInBhZGRpbmdcIixcIjBcIixcImltcG9ydGFudFwiKVxuICAgICAgICAgIC5zdHlsZShcImJvcmRlclwiLFwiMFwiLFwiaW1wb3J0YW50XCIpXG4gICAgICAgICAgLnN0eWxlKFwib3ZlcmZsb3dcIixcImhpZGRlblwiLFwiaW1wb3J0YW50XCIpXG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZW1lbnRcblxuICAgIH0sXG4gICAgXCJ2YWx1ZVwiOiBmYWxzZVxuICB9LFxuICBcImZpbGV0eXBlXCIgOiB7XG4gICAgXCJhY2NlcHRlZFwiIDogWyBmYWxzZSAsIFwianNvblwiICwgXCJ4bWxcIiAsXCJodG1sXCJcbiAgICAgICAgICAgICAgICAgLCBcImNzdlwiICwgXCJkc3ZcIiAsIFwidHN2XCIgLCBcInR4dFwiIF0sXG4gICAgXCJ2YWx1ZVwiICAgIDogZmFsc2VcbiAgfSxcbiAgXCJmaWx0ZXJzXCIgIDogW10sXG4gIFwibXV0ZVwiICAgICA6IFtdLFxuICBcInByb2Nlc3NcIiAgOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cbiAgICB2YXIgdmFycyA9IHRoaXMuZ2V0VmFycygpXG5cbiAgICBpZiAoIHZhcnMuY29udGFpbmVyLmlkID09PSBcImRlZmF1bHRcIiAmJiB2YWx1ZS5sZW5ndGggKSB7XG4gICAgICB2YXJzLnNlbGYuY29udGFpbmVyKHtcImlkXCI6IFwiZGVmYXVsdFwiK3ZhbHVlLmxlbmd0aH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIGQzcGx1cy5tZXRob2QucHJvY2Vzc0RhdGEoIHZhbHVlICwgdGhpcyApXG4gIH0sXG4gIFwic29sb1wiICAgICA6IFtdLFxuICBcInZhbHVlXCIgICAgOiBmYWxzZVxufVxuIiwiZDNwbHVzLm1ldGhvZC5kZXB0aCA9IHtcbiAgXCJhY2NlcHRlZFwiIDogWyBGdW5jdGlvbiAsIE51bWJlciBdLFxuICBcInZhbHVlXCIgICAgOiAwXG59XG4iLCJkM3BsdXMubWV0aG9kLmRlc2NzID0ge1xuICBcImFjY2VwdGVkXCIgOiBbIGZhbHNlICwgRnVuY3Rpb24gLCBPYmplY3QgXSxcbiAgXCJ2YWx1ZVwiICAgIDogZmFsc2Vcbn1cbiIsImQzcGx1cy5tZXRob2QuZGV2ID0ge1xuICBcImFjY2VwdGVkXCIgOiBbIEJvb2xlYW4gXSxcbiAgXCJ2YWx1ZVwiICAgIDogZmFsc2Vcbn1cbiIsInZhciBwYXJzZUVsZW1lbnQgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9wYXJzZS9lbGVtZW50LmpzXCIpXG5kM3BsdXMubWV0aG9kLmRyYXcgPSB7XG4gIFwiYWNjZXB0ZWRcIiA6IFsgdW5kZWZpbmVkICwgRnVuY3Rpb24gXSxcbiAgXCJmaXJzdFwiICAgIDogdHJ1ZSxcbiAgXCJmcm96ZW5cIiAgIDogZmFsc2UsXG4gIFwicHJvY2Vzc1wiICA6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICBpZiAoIHRoaXMuaW5pdGlhbGl6ZWQgPT09IGZhbHNlICkge1xuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWVcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIHZhciB2YXJzICAgID0gdGhpcy5nZXRWYXJzKClcbiAgICAgICwgY2hhbmdlcyA9IFwiaGlzdG9yeVwiIGluIHZhcnMgPyB2YXJzLmhpc3RvcnkuY2hhaW4gOiBbXVxuXG4gICAgaWYgKCBcImRhdGFcIiBpbiB2YXJzICYmIHZhcnMuZGF0YS52YWx1ZSAmJiBkM3BsdXMudXRpbC5kM3NlbGVjdGlvbiggdmFycy5kYXRhLnZhbHVlICkgKSB7XG4gICAgICB2YXJzLmRhdGEudmFsdWUgPSBwYXJzZUVsZW1lbnQoIHZhcnMgKVxuICAgIH1cblxuICAgIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdGhpcy52YWx1ZSA9PT0gXCJmdW5jdGlvblwiICkge1xuICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlXG4gICAgfVxuXG4gICAgaWYgKCB2YXJzLmNvbnRhaW5lci52YWx1ZSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgIHZhciBzdHIgPSB2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUuZGV2LnNldENvbnRhaW5lclxuICAgICAgZDNwbHVzLmNvbnNvbGUud2FybmluZyggc3RyICwgXCJjb250YWluZXJcIiApXG5cbiAgICB9XG4gICAgZWxzZSBpZiAoIHZhcnMuY29udGFpbmVyLnZhbHVlLmVtcHR5KCkgKSB7XG5cbiAgICAgIHZhciBzdHIgPSB2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUuZGV2Lm5vQ29udGFpbmVyXG4gICAgICBkM3BsdXMuY29uc29sZS53YXJuaW5nKCBkM3BsdXMuc3RyaW5nLmZvcm1hdChzdHIsXCJcXFwiXCIrdmFycy5jb250YWluZXIudmFsdWUrXCJcXFwiXCIpICwgXCJjb250YWluZXJcIiApXG5cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgIGlmICggdmFycy5kZXYudmFsdWUgKSB7XG4gICAgICAgIGlmICggdmFycy5tZXRob2RHcm91cCApIHtcbiAgICAgICAgICB2YXJzLm1ldGhvZEdyb3VwID0gXCJ3YWl0XCJcbiAgICAgICAgICBkM3BsdXMuY29uc29sZS5ncm91cEVuZCgpXG4gICAgICAgIH1cbiAgICAgICAgZDNwbHVzLmNvbnNvbGUudGltZShcInRvdGFsIGRyYXcgdGltZVwiKVxuICAgICAgfVxuXG4gICAgICB2YXJzLmNvbnRhaW5lci52YWx1ZS5jYWxsKHZhcnMuc2VsZilcblxuICAgIH1cblxuICAgIGlmICggdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiYgY2hhbmdlcy5sZW5ndGggKSB7XG5cbiAgICAgIHZhciBjaGFuZ2VzT2JqZWN0ID0ge31cbiAgICAgIGNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbihjKXtcbiAgICAgICAgdmFyIG1ldGhvZCA9IGMubWV0aG9kXG4gICAgICAgIGRlbGV0ZSBjLm1ldGhvZFxuICAgICAgICBjaGFuZ2VzT2JqZWN0W21ldGhvZF0gPSBjXG4gICAgICB9KVxuXG4gICAgICB2YWx1ZShjaGFuZ2VzT2JqZWN0KVxuXG4gICAgICB2YXJzLmhpc3RvcnkuY2hhaW4gPSBbXVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlXG5cbiAgfSxcbiAgXCJ1cGRhdGVcIiAgIDogdHJ1ZSxcbiAgXCJ2YWx1ZVwiICAgIDogdW5kZWZpbmVkXG59XG4iLCJkM3BsdXMubWV0aG9kLmVkZ2VzID0ge1xuICBcImFjY2VwdGVkXCIgICAgOiBbIGZhbHNlICwgQXJyYXkgLCBGdW5jdGlvbiAsIFN0cmluZyBdLFxuICBcImNvbm5lY3Rpb25zXCIgOiBmdW5jdGlvbihmb2N1cyxpZCxvYmplY3RzKSB7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXNcblxuICAgIGlmICghc2VsZi52YWx1ZSkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgaWYgKCFpZCkgdmFyIGlkID0gXCJpZFwiXG5cbiAgICB2YXIgZWRnZXMgPSBzZWxmLnJlc3RyaWN0ZWQgfHwgc2VsZi52YWx1ZSxcbiAgICAgICAgdGFyZ2V0cyA9IFtdXG5cbiAgICBpZiAoIWZvY3VzKSB7XG4gICAgICByZXR1cm4gZWRnZXNcbiAgICB9XG5cbiAgICB2YXIgY29ubmVjdGlvbnMgPSBlZGdlcy5maWx0ZXIoZnVuY3Rpb24oZWRnZSl7XG5cbiAgICAgIHZhciBtYXRjaCA9IGZhbHNlXG5cbiAgICAgIGlmIChlZGdlW3NlbGYuc291cmNlXVtpZF0gPT0gZm9jdXMpIHtcbiAgICAgICAgbWF0Y2ggPSB0cnVlXG4gICAgICAgIGlmIChvYmplY3RzKSB7XG4gICAgICAgICAgdGFyZ2V0cy5wdXNoKGVkZ2Vbc2VsZi50YXJnZXRdKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlZGdlW3NlbGYudGFyZ2V0XVtpZF0gPT0gZm9jdXMpIHtcbiAgICAgICAgbWF0Y2ggPSB0cnVlXG4gICAgICAgIGlmIChvYmplY3RzKSB7XG4gICAgICAgICAgdGFyZ2V0cy5wdXNoKGVkZ2Vbc2VsZi5zb3VyY2VdKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXRjaFxuXG4gICAgfSlcblxuICAgIHJldHVybiBvYmplY3RzID8gdGFyZ2V0cyA6IGNvbm5lY3Rpb25zXG5cbiAgfSxcbiAgXCJkZWxpbWl0ZXJcIiA6IHtcbiAgICBcImFjY2VwdGVkXCIgOiBbIFN0cmluZyBdLFxuICAgIFwidmFsdWVcIiAgICA6IFwifFwiXG4gIH0sXG4gIFwiZmlsZXR5cGVcIiAgICA6IHtcbiAgICBcImFjY2VwdGVkXCIgOiBbIGZhbHNlICwgXCJqc29uXCIgLCBcInhtbFwiICxcImh0bWxcIlxuICAgICAgICAgICAgICAgICAsIFwiY3N2XCIgLCBcImRzdlwiICwgXCJ0c3ZcIiAsIFwidHh0XCIgXSxcbiAgICBcInZhbHVlXCIgICAgOiBmYWxzZVxuICB9LFxuICBcImludGVycG9sYXRlXCIgOiB7XG4gICAgXCJhY2NlcHRlZFwiICAgOiBbXCJiYXNpc1wiLCBcImNhcmRpbmFsXCIsIFwibGluZWFyXCIsIFwibW9ub3RvbmVcIiwgXCJzdGVwXCJdLFxuICAgIFwidmFsdWVcIiAgICAgIDogXCJiYXNpc1wiXG4gIH0sXG4gIFwibGFiZWxcIiAgICAgICA6IGZhbHNlLFxuICBcImxpbWl0XCIgICAgICAgOiB7XG4gICAgXCJhY2NlcHRlZFwiIDogW2ZhbHNlLCBGdW5jdGlvbiwgTnVtYmVyXSxcbiAgICBcInZhbHVlXCIgICAgOiBmYWxzZVxuICB9LFxuICBcInByb2Nlc3NcIiAgICAgOiBkM3BsdXMubWV0aG9kLnByb2Nlc3NEYXRhLFxuICBcInNpemVcIiAgICAgICAgOiBmYWxzZSxcbiAgXCJzb3VyY2VcIiAgICAgIDogXCJzb3VyY2VcIixcbiAgXCJ0YXJnZXRcIiAgICAgIDogXCJ0YXJnZXRcIixcbiAgXCJ2YWx1ZVwiICAgICAgIDogZmFsc2Vcbn1cbiIsImQzcGx1cy5tZXRob2QuZXJyb3IgPSB7XG4gIFwiYWNjZXB0ZWRcIiA6IFsgQm9vbGVhbiAsIFN0cmluZyBdLFxuICBcInZhbHVlXCIgICAgOiBmYWxzZVxufVxuIiwiZDNwbHVzLm1ldGhvZC5mb2N1cyA9IHtcbiAgXCJhY2NlcHRlZFwiICAgOiBbIGZhbHNlICwgQXJyYXkgLCBGdW5jdGlvbiAsIE51bWJlciAsIFN0cmluZyBdLFxuICBcImRlcHJlY2F0ZXNcIiA6IFwiaGlnaGxpZ2h0XCIsXG4gIFwicHJvY2Vzc1wiICAgIDogZnVuY3Rpb24odmFsdWUpIHtcblxuICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkpIHZhbHVlID0gW3ZhbHVlXVxuXG4gICAgICB2YXIgdmFycyA9IHRoaXMuZ2V0VmFycygpXG5cbiAgICAgIGlmICggW1wic3RyaW5nXCIsXCJudW1iZXJcIl0uaW5kZXhPZih0eXBlb2YgdmFsdWVbMF0pID49IDAgJiYgdmFycy5kYXRhLmVsZW1lbnQudmFsdWUgKSB7XG5cbiAgICAgICAgdmFyIGVsZW1lbnRUYWcgID0gdmFycy5kYXRhLmVsZW1lbnQudmFsdWUubm9kZSgpLnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICwgZWxlbWVudFR5cGUgPSB2YXJzLmRhdGEuZWxlbWVudC52YWx1ZS5hdHRyKFwidHlwZVwiKVxuXG4gICAgICAgIGlmIChlbGVtZW50VGFnID09PSBcInNlbGVjdFwiKSB7XG5cbiAgICAgICAgICB2YXJzLmRhdGEuZWxlbWVudC52YWx1ZS5zZWxlY3RBbGwoXCJvcHRpb25cIikuZWFjaChmdW5jdGlvbihkLGkpe1xuXG4gICAgICAgICAgICBpZiAoZCAmJiBkW3ZhcnMuaWQudmFsdWVdID09PSB2YWx1ZVswXSkge1xuICAgICAgICAgICAgICB2YXJzLmRhdGEuZWxlbWVudC52YWx1ZS5ub2RlKCkuc2VsZWN0ZWRJbmRleCA9IGlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0pXG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VGFnID09PSBcImlucHV0XCIgJiYgZWxlbWVudFR5cGUgPT09IFwicmFkaW9cIikge1xuXG4gICAgICAgICAgdmFycy5kYXRhLmVsZW1lbnQudmFsdWVcbiAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKGQpe1xuXG4gICAgICAgICAgICAgIGlmIChkICYmIGRbdmFycy5pZC52YWx1ZV0gPT09IHZhbHVlWzBdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja2VkID0gdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tlZCA9IGZhbHNlXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSlcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlXG5cbiAgICB9XG5cbiAgfSxcbiAgXCJ0b29sdGlwXCIgICAgOiB7XG4gICAgXCJhY2NlcHRlZFwiIDogWyBCb29sZWFuIF0sXG4gICAgXCJ2YWx1ZVwiICAgIDogdHJ1ZVxuICB9LFxuICBcInZhbHVlXCIgICAgICA6IFtdXG59XG4iLCJkM3BsdXMubWV0aG9kLmZvb3RlciA9IHtcbiAgXCJhY2NlcHRlZFwiIDogWyBmYWxzZSAsIE51bWJlciAsIFN0cmluZyBdLFxuICBcImxpbmtcIiAgICAgOiBmYWxzZSxcbiAgXCJ2YWx1ZVwiICAgIDogZmFsc2Vcbn1cbiIsImQzcGx1cy5tZXRob2QuZm9ybWF0ID0ge1xuICBcImFjY2VwdGVkXCIgICA6IFsgRnVuY3Rpb24gLCBTdHJpbmcgXSxcbiAgXCJkZXByZWNhdGVzXCIgOiBbIFwibnVtYmVyX2Zvcm1hdFwiICwgXCJ0ZXh0X2Zvcm1hdFwiIF0sXG4gIFwibG9jYWxlXCIgICAgIDoge1xuICAgIFwiYWNjZXB0ZWRcIiA6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZDMua2V5cyhkM3BsdXMubG9jYWxlKVxuICAgIH0sXG4gICAgXCJwcm9jZXNzXCIgIDogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICB2YXIgZGVmYXVsdExvY2FsZSA9IFwiZW5fVVNcIlxuICAgICAgICAsIHJldHVybk9iamVjdCAgPSBkM3BsdXMubG9jYWxlW2RlZmF1bHRMb2NhbGVdXG5cbiAgICAgIGlmICggdmFsdWUgIT09IGRlZmF1bHRMb2NhbGUgKSB7XG4gICAgICAgIHJldHVybk9iamVjdCA9IGQzcGx1cy5vYmplY3QubWVyZ2UoIHJldHVybk9iamVjdCAsIGQzcGx1cy5sb2NhbGVbdmFsdWVdIClcbiAgICAgIH1cblxuICAgICAgdGhpcy5sYW5ndWFnZSA9IHZhbHVlXG5cbiAgICAgIHJldHVybiByZXR1cm5PYmplY3RcblxuICAgIH0sXG4gICAgXCJ2YWx1ZVwiICAgIDogXCJlbl9VU1wiXG4gIH0sXG4gIFwibnVtYmVyXCIgICAgIDoge1xuICAgIFwiYWNjZXB0ZWRcIiA6IFsgZmFsc2UgLCBGdW5jdGlvbiBdLFxuICAgIFwidmFsdWVcIiAgICA6IGZhbHNlXG4gIH0sXG4gIFwicHJvY2Vzc1wiICAgIDogZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgaWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgKSB7XG4gICAgICB2YXIgdmFycyA9IHRoaXMuZ2V0VmFycygpXG4gICAgICB2YXJzLnNlbGYuZm9ybWF0KHtcImxvY2FsZVwiOiB2YWx1ZX0pXG4gICAgfVxuICAgIGVsc2UgaWYgKCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiApIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnZhbHVlXG5cbiAgfSxcbiAgXCJ0ZXh0XCIgICAgICAgOiB7XG4gICAgXCJhY2NlcHRlZFwiIDogWyBmYWxzZSAsIEZ1bmN0aW9uIF0sXG4gICAgXCJ2YWx1ZVwiICAgIDogZmFsc2VcbiAgfSxcbiAgXCJ2YWx1ZVwiICAgICAgOiBmdW5jdGlvbiggdmFsdWUgLCBrZXkgKSB7XG5cbiAgICB2YXIgdmFycyA9IHRoaXMuZ2V0VmFycygpXG5cbiAgICBpZiAoIHZhcnMudGltZSAmJiB2YXJzLnRpbWUudmFsdWUgJiYga2V5ID09PSB2YXJzLnRpbWUudmFsdWUgKSB7XG4gICAgICB2YXIgZiA9IHZhcnMudGltZS5mb3JtYXQudmFsdWUgfHwgdmFycy5kYXRhLnRpbWUuZm9ybWF0XG4gICAgICAgICwgdiA9IHZhbHVlLmNvbnN0cnVjdG9yID09PSBEYXRlID8gdmFsdWUgOiBuZXcgRGF0ZSh2YWx1ZSlcbiAgICAgIC8vIGNvbnNvbGUubG9nKGQzLmxvY2FsZSh2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUuZm9ybWF0KS50aW1lRm9ybWF0KVxuICAgICAgLy8gZiA9IGQzLmxvY2FsZSh2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUuZm9ybWF0KS50aW1lRm9ybWF0XG4gICAgICByZXR1cm4gZiggdiApXG4gICAgfVxuICAgIGVsc2UgaWYgKCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgKSB7XG4gICAgICB2YXIgZiA9IHRoaXMubnVtYmVyLnZhbHVlIHx8IGQzcGx1cy5udW1iZXIuZm9ybWF0XG4gICAgICByZXR1cm4gZiggdmFsdWUgLCBrZXkgKVxuICAgIH1cbiAgICBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuICAgICAgdmFyIGYgPSB0aGlzLnRleHQudmFsdWUgfHwgZDNwbHVzLnN0cmluZy50aXRsZVxuICAgICAgcmV0dXJuIGYoIHZhbHVlICwga2V5IClcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpXG4gICAgfVxuXG4gIH1cbn1cbiIsImQzcGx1cy5tZXRob2QuaGVpZ2h0ID0ge1xuICBcImFjY2VwdGVkXCIgIDogWyBmYWxzZSAsIE51bWJlciBdLFxuICBcInNlY29uZGFyeVwiIDogZmFsc2UsXG4gIFwidmFsdWVcIiAgICAgOiBmYWxzZVxufVxuIiwiZDNwbHVzLm1ldGhvZC5oaXN0b3J5ID0ge1xuICBcImFjY2VwdGVkXCIgOiBbIEJvb2xlYW4gXSxcbiAgXCJiYWNrXCIgICAgIDogZnVuY3Rpb24oKSB7XG5cbiAgICBpZiAodGhpcy5zdGF0ZXMubGVuZ3RoID4gMCkge1xuXG4gICAgICB2YXIgZnVuYyA9IHRoaXMuc3RhdGVzLnBvcCgpXG5cbiAgICAgIGZ1bmMoKVxuXG4gICAgfVxuXG4gIH0sXG4gIFwiY2hhaW5cIiAgICA6IFtdLFxuICBcInN0YXRlc1wiICAgOiBbXSxcbiAgXCJ2YWx1ZVwiICAgIDogdHJ1ZVxufVxuIiwiZDNwbHVzLm1ldGhvZC5ob3ZlciA9IHtcbiAgXCJhY2NlcHRlZFwiIDogWyBmYWxzZSAsIE51bWJlciAsIFN0cmluZyBdLFxuICBcInZhbHVlXCIgICAgOiBmYWxzZVxufVxuIiwiZDNwbHVzLm1ldGhvZC5pY29uID0ge1xuICBcImFjY2VwdGVkXCIgICA6IFsgZmFsc2UgLCBBcnJheSAsIEZ1bmN0aW9uICwgT2JqZWN0ICwgU3RyaW5nIF0sXG4gIFwiZGVwcmVjYXRlc1wiIDogXCJpY29uX3ZhclwiLFxuICBcInN0eWxlXCIgICAgICA6IHtcbiAgICBcImFjY2VwdGVkXCIgICA6IFsgT2JqZWN0ICwgU3RyaW5nIF0sXG4gICAgXCJkZXByZWNhdGVzXCIgOiBcImljb25fc3R5bGVcIixcbiAgICBcInZhbHVlXCIgICAgICA6IFwiZGVmYXVsdFwiXG4gIH0sXG4gIFwidmFsdWVcIiAgICAgIDogXCJpY29uXCJcbn1cbiIsImQzcGx1cy5tZXRob2QuaWQgPSB7XG4gIFwiYWNjZXB0ZWRcIiAgICA6IFsgQXJyYXkgLCBTdHJpbmcgXSxcbiAgXCJkYXRhRmlsdGVyXCIgIDogdHJ1ZSxcbiAgXCJkZXByZWNhdGVzXCIgIDogWyBcImlkX3ZhclwiICwgXCJuZXN0aW5nXCIgXSxcbiAgXCJpbml0XCIgICAgICAgIDogZnVuY3Rpb24gKCB2YXJzICkge1xuXG4gICAgaWYgKCB2YXJzLnNoZWxsID09PSBcImZvcm1cIiApIHtcbiAgICAgIHRoaXMubmVzdGluZyA9IFsgXCJ2YWx1ZVwiIF1cbiAgICAgIHJldHVybiBcInZhbHVlXCJcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLm5lc3RpbmcgPSBbIFwiaWRcIiBdXG4gICAgICByZXR1cm4gXCJpZFwiXG4gICAgfVxuXG4gIH0sXG4gIFwibXV0ZVwiICAgICAgICA6IGQzcGx1cy5tZXRob2QuZmlsdGVyKHRydWUpLFxuICBcInNvbG9cIiAgICAgICAgOiBkM3BsdXMubWV0aG9kLmZpbHRlcih0cnVlKVxufVxuIiwiZDNwbHVzLm1ldGhvZC5rZXl3b3JkcyA9IHtcbiAgXCJhY2NlcHRlZFwiIDogWyBmYWxzZSAsIEFycmF5ICwgRnVuY3Rpb24gLCBPYmplY3QgLCBTdHJpbmcgXSxcbiAgXCJtdXRlXCIgICAgIDogZDNwbHVzLm1ldGhvZC5maWx0ZXIodHJ1ZSksXG4gIFwic29sb1wiICAgICA6IGQzcGx1cy5tZXRob2QuZmlsdGVyKHRydWUpLFxuICBcInZhbHVlXCIgICAgOiBcImtleXdvcmRzXCJcbn1cbiIsImQzcGx1cy5tZXRob2QubGFiZWxzID0ge1xuICBcImFjY2VwdGVkXCIgOiBbIEJvb2xlYW4gXSAsXG4gIFwicmVzaXplXCIgICA6IHtcbiAgICBcImFjY2VwdGVkXCIgOiBbIEJvb2xlYW4gXSxcbiAgICBcInZhbHVlXCIgICAgOiB0cnVlXG4gIH0sXG4gIFwidmFsdWVcIiAgICA6IHRydWVcbn1cbiIsImQzcGx1cy5tZXRob2QubGVnZW5kID0ge1xuICBcImFjY2VwdGVkXCIgOiBbIEJvb2xlYW4gXSxcbiAgXCJ2YWx1ZVwiICAgIDogdHJ1ZVxufVxuIiwiZDNwbHVzLm1ldGhvZC5tYXJnaW4gPSB7XG4gIFwiYWNjZXB0ZWRcIiA6IFsgTnVtYmVyICwgT2JqZWN0ICwgU3RyaW5nIF0sXG4gIFwicHJvY2Vzc1wiICA6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICAgICwgc2lkZXMgPSBbIFwidG9wXCIgLCBcInJpZ2h0XCIgLCBcImJvdHRvbVwiICwgXCJsZWZ0XCIgXVxuXG4gICAgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgdmFyIHZhbHVlID0gc2VsZi52YWx1ZVxuICAgIH1cblxuICAgIHZhciB1c2VyVmFsdWUgPSB2YWx1ZVxuXG4gICAgaWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgKSB7XG5cbiAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoXCIgXCIpXG5cbiAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24odixpKXtcbiAgICAgICAgdmFsdWVbaV0gPSBwYXJzZUZsb2F0KHYsMTApXG4gICAgICB9KVxuXG4gICAgICBpZiAoIHZhbHVlLmxlbmd0aCA9PT0gMSApIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZVswXVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIHZhbHVlLmxlbmd0aCA9PT0gMiApIHtcbiAgICAgICAgdmFsdWUgPSB7XG4gICAgICAgICAgXCJ0b3BcIiAgICA6IHZhbHVlWzBdLFxuICAgICAgICAgIFwicmlnaHRcIiAgOiB2YWx1ZVsxXSxcbiAgICAgICAgICBcImJvdHRvbVwiIDogdmFsdWVbMF0sXG4gICAgICAgICAgXCJsZWZ0XCIgICA6IHZhbHVlWzFdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCB2YWx1ZS5sZW5ndGggPT09IDMgKSB7XG4gICAgICAgIHZhbHVlID0ge1xuICAgICAgICAgIFwidG9wXCIgICAgOiB2YWx1ZVswXSxcbiAgICAgICAgICBcInJpZ2h0XCIgIDogdmFsdWVbMV0sXG4gICAgICAgICAgXCJib3R0b21cIiA6IHZhbHVlWzJdLFxuICAgICAgICAgIFwibGVmdFwiICAgOiB2YWx1ZVsxXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICggdmFsdWUubGVuZ3RoID09PSA0ICkge1xuICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICBcInRvcFwiICAgIDogdmFsdWVbMF0sXG4gICAgICAgICAgXCJyaWdodFwiICA6IHZhbHVlWzFdLFxuICAgICAgICAgIFwiYm90dG9tXCIgOiB2YWx1ZVsyXSxcbiAgICAgICAgICBcImxlZnRcIiAgIDogdmFsdWVbM11cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhbHVlID0gMFxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgKSB7XG5cbiAgICAgIHNpZGVzLmZvckVhY2goZnVuY3Rpb24oc2lkZSl7XG4gICAgICAgIHNlbGZbc2lkZV0gPSB2YWx1ZVxuICAgICAgfSlcblxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgZm9yICggdmFyIHNpZGUgaW4gdmFsdWUgKSB7XG5cbiAgICAgICAgdmFyIHNpZGVJbmRleCA9IHNpZGVzLmluZGV4T2Yoc2lkZSlcblxuICAgICAgICBpZiAoc2lkZUluZGV4ID49IDApIHtcblxuICAgICAgICAgIHNpZGVzLnNwbGljZShzaWRlSW5kZXgsMSlcbiAgICAgICAgICBzZWxmW3NpZGVdID0gdmFsdWVbc2lkZV1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgc2lkZXMuZm9yRWFjaChmdW5jdGlvbihrKXtcbiAgICAgICAgc2VsZltrXSA9IDBcbiAgICAgIH0pXG5cbiAgICB9XG5cbiAgICByZXR1cm4gdXNlclZhbHVlXG5cbiAgfSxcbiAgXCJ2YWx1ZVwiICAgIDogMFxufVxuIiwiZDNwbHVzLm1ldGhvZC5tZXNzYWdlcyA9IHtcbiAgXCJhY2NlcHRlZFwiIDogWyBCb29sZWFuICwgU3RyaW5nIF0sXG4gIFwidmFsdWVcIiAgICA6IHRydWVcbn1cbiIsImQzcGx1cy5tZXRob2Qubm9kZXMgPSB7XG4gIFwiYWNjZXB0ZWRcIiA6IFsgZmFsc2UgLCBBcnJheSAsIEZ1bmN0aW9uICwgU3RyaW5nIF0sXG4gIFwiZGVsaW1pdGVyXCIgOiB7XG4gICAgXCJhY2NlcHRlZFwiIDogWyBTdHJpbmcgXSxcbiAgICBcInZhbHVlXCIgICAgOiBcInxcIlxuICB9LFxuICBcImZpbGV0eXBlXCIgOiB7XG4gICAgXCJhY2NlcHRlZFwiIDogWyBmYWxzZSAsIFwianNvblwiICwgXCJ4bWxcIiAsXCJodG1sXCJcbiAgICAgICAgICAgICAgICAgLCBcImNzdlwiICwgXCJkc3ZcIiAsIFwidHN2XCIgLCBcInR4dFwiIF0sXG4gICAgXCJ2YWx1ZVwiICAgIDogZmFsc2VcbiAgfSxcbiAgXCJwcm9jZXNzXCIgIDogZDNwbHVzLm1ldGhvZC5wcm9jZXNzRGF0YSxcbiAgXCJ2YWx1ZVwiICAgIDogZmFsc2Vcbn1cbiIsImQzcGx1cy5tZXRob2Qub3BlbiA9IHtcbiAgXCJhY2NlcHRlZFwiIDogWyBCb29sZWFuIF0sXG4gIFwiZmxpcHBlZFwiICA6IHtcbiAgICBcImFjY2VwdGVkXCIgOiBbIEJvb2xlYW4gXSxcbiAgICBcInZhbHVlXCIgICAgOiBmYWxzZVxuICB9LFxuICBcInZhbHVlXCIgICAgOiBmYWxzZVxufVxuIiwiZDNwbHVzLm1ldGhvZC5vcmRlciA9IHtcbiAgXCJhY2NlcHRlZFwiIDogWyBmYWxzZSAsIEZ1bmN0aW9uICwgU3RyaW5nIF0sXG4gIFwic29ydFwiICAgICA6IHtcbiAgICBcImFjY2VwdGVkXCIgICA6IFsgXCJhc2NcIiAsIFwiZGVzY1wiIF0sXG4gICAgXCJ2YWx1ZVwiICAgICAgOiBcImFzY1wiLFxuICAgIFwiZGVwcmVjYXRlc1wiIDogWyBcInNvcnRcIiBdXG4gIH0sXG4gIFwidmFsdWVcIiAgICA6IGZhbHNlXG59XG4iLCJkM3BsdXMubWV0aG9kLnJlbW92ZSA9IHtcbiAgXCJhY2NlcHRlZFwiIDogdW5kZWZpbmVkLFxuICBcInByb2Nlc3NcIiAgOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgaWYgKCB0aGlzLmluaXRpYWxpemVkICkge1xuICAgICAgdmFyIHZhcnMgPSB0aGlzLmdldFZhcnMoKVxuICAgICAgdmFycy5jb250YWluZXIudmFsdWUucmVtb3ZlKClcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cblxuICB9LFxuICBcInZhbHVlXCIgICAgOiB1bmRlZmluZWRcbn1cbiIsImQzcGx1cy5tZXRob2QucmVzaXplID0ge1xuICBcImFjY2VwdGVkXCIgOiBbIEJvb2xlYW4gXSxcbiAgXCJ2YWx1ZVwiICAgIDogZmFsc2Vcbn1cbiIsImQzcGx1cy5tZXRob2Quc2VhcmNoID0ge1xuICBcImFjY2VwdGVkXCIgOiBbIFwiYXV0b1wiICwgQm9vbGVhbiBdLFxuICBcInByb2Nlc3NcIiAgOiBmdW5jdGlvbih2YWx1ZSkge1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIkJvb2xlYW5cIikge1xuICAgICAgdGhpcy5lbmFibGVkID0gdmFsdWVcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVcblxuICB9LFxuICBcInZhbHVlXCIgICAgOiBcImF1dG9cIlxufVxuIiwiZDNwbHVzLm1ldGhvZC5zZWxlY3QgPSB7XG4gIFwiYWNjZXB0ZWRcIiAgOiBbIFN0cmluZyBdLFxuICBcImNoYWluYWJsZVwiIDogZmFsc2UsXG4gIFwicHJvY2Vzc1wiICAgOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgdmFyIHZhcnMgPSB0aGlzLmdldFZhcnMoKVxuXG4gICAgcmV0dXJuIHZhcnMuY29udGFpbmVyLnZhbHVlICYmIHZhbHVlXG4gICAgICAgICA/IHZhcnMuY29udGFpbmVyLnZhbHVlLnNlbGVjdCh2YWx1ZSlcbiAgICAgICAgIDogdmFsdWVcblxuICB9LFxuICBcInZhbHVlXCIgICAgIDogdW5kZWZpbmVkXG59XG4iLCJkM3BsdXMubWV0aG9kLnNlbGVjdEFsbCA9IHtcbiAgXCJhY2NlcHRlZFwiICA6IFsgU3RyaW5nIF0sXG4gIFwiY2hhaW5hYmxlXCIgOiBmYWxzZSxcbiAgXCJwcm9jZXNzXCIgICA6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICB2YXIgdmFycyA9IHRoaXMuZ2V0VmFycygpXG5cbiAgICByZXR1cm4gdmFycy5jb250YWluZXIudmFsdWUgJiYgdmFsdWVcbiAgICAgICAgID8gdmFycy5jb250YWluZXIudmFsdWUuc2VsZWN0QWxsKHZhbHVlKVxuICAgICAgICAgOiB2YWx1ZVxuXG4gIH0sXG4gIFwidmFsdWVcIiAgICAgOiB1bmRlZmluZWRcbn1cbiIsImQzcGx1cy5tZXRob2Quc2hhcGUgPSB7XG4gIFwiYWNjZXB0ZWRcIiA6IGZ1bmN0aW9uKCB2YXJzICkge1xuICAgIHJldHVybiB2YXJzLnNoZWxsID09PSBcInRleHR3cmFwXCIgPyBbIFwiY2lyY2xlXCIgLCBcInNxdWFyZVwiIF1cbiAgICAgICAgIDogWyBcImNpcmNsZVwiICwgXCJkb251dFwiICwgXCJsaW5lXCJcbiAgICAgICAgICwgXCJzcXVhcmVcIiAsIFwiYXJlYVwiICwgXCJjb29yZGluYXRlc1wiIF1cbiAgfSxcbiAgXCJ2YWx1ZVwiICAgIDogZmFsc2Vcbn1cbiIsImQzcGx1cy5tZXRob2Quc2l6ZSA9IHtcbiAgXCJhY2NlcHRlZFwiICAgIDogZnVuY3Rpb24oIHZhcnMgKSB7XG5cbiAgICBpZiAoIHZhcnMuc2hlbGwgPT09IFwidGV4dHdyYXBcIiApIHtcbiAgICAgIHJldHVybiBbIEFycmF5ICwgZmFsc2UgXVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBbIEFycmF5ICwgQm9vbGVhbiAsIEZ1bmN0aW9uICwgT2JqZWN0ICwgU3RyaW5nIF1cbiAgICB9XG5cbiAgfSxcbiAgXCJkYXRhRmlsdGVyXCIgIDogdHJ1ZSxcbiAgXCJkZXByZWNhdGVzXCIgIDogWyBcInZhbHVlXCIgLCBcInZhbHVlX3ZhclwiIF0sXG4gIFwibXV0ZVwiICAgICAgICA6IGQzcGx1cy5tZXRob2QuZmlsdGVyKHRydWUpLFxuICBcInNjYWxlXCIgICAgICAgOiB7XG4gICAgXCJhY2NlcHRlZFwiICAgOiBbIEZ1bmN0aW9uIF0sXG4gICAgXCJkZXByZWNhdGVzXCIgOiBcInNpemVfc2NhbGVcIixcbiAgICBcInZhbHVlXCIgICAgICA6IGQzLnNjYWxlLnNxcnQoKVxuICB9LFxuICBcInNvbG9cIiAgICAgICAgOiBkM3BsdXMubWV0aG9kLmZpbHRlcih0cnVlKSxcbiAgXCJ0aHJlc2hvbGRcIiAgIDogdHJ1ZSxcbiAgXCJ2YWx1ZVwiICAgICAgIDogZmFsc2Vcbn1cbiIsImQzcGx1cy5tZXRob2Quc3R5bGUgPSB7XG4gIFwiYWNjZXB0ZWRcIiA6IGZ1bmN0aW9uKCB2YXJzICl7XG4gICAgcmV0dXJuIGQzLmtleXMoZDNwbHVzLnN0eWxlKS5maWx0ZXIoZnVuY3Rpb24ocyl7XG4gICAgICByZXR1cm4gdHlwZW9mIGQzcGx1cy5zdHlsZVtzXSA9PT0gXCJvYmplY3RcIlxuICAgIH0pXG4gIH0sXG4gIFwidmFsdWVcIiAgICA6IFwiZGVmYXVsdFwiXG59XG4iLCJkM3BsdXMubWV0aG9kLnRlbXAgPSB7XG4gIFwiYWNjZXB0ZWRcIjogWyBmYWxzZSAsIEFycmF5ICwgRnVuY3Rpb24gLCBPYmplY3QgLCBTdHJpbmcgXSxcbiAgXCJkZXByZWNhdGVzXCI6IFsgXCJlbHNlX3ZhclwiICwgXCJlbHNlXCIgXSxcbiAgXCJtdXRlXCI6IGQzcGx1cy5tZXRob2QuZmlsdGVyKHRydWUpLFxuICBcInNvbG9cIjogZDNwbHVzLm1ldGhvZC5maWx0ZXIodHJ1ZSksXG4gIFwidmFsdWVcIjogZmFsc2Vcbn1cbiIsImQzcGx1cy5tZXRob2QudGV4dCA9IHtcbiAgXCJhY2NlcHRlZFwiICAgOiBbIEFycmF5ICwgQm9vbGVhbiAsIEZ1bmN0aW9uICwgT2JqZWN0ICwgU3RyaW5nIF0sXG4gIFwiZGVwcmVjYXRlc1wiIDogWyBcIm5hbWVfYXJyYXlcIiAsIFwidGV4dF92YXJcIiBdLFxuICBcImh0bWxcIiAgICAgOiB7XG4gICAgXCJhY2NlcHRlZFwiIDogWyBCb29sZWFuIF0sXG4gICAgXCJ2YWx1ZVwiICAgIDogZmFsc2VcbiAgfSxcbiAgXCJpbml0XCIgICAgIDogZnVuY3Rpb24gKCB2YXJzICkge1xuXG4gICAgaWYgKCB2YXJzLnNoZWxsID09PSBcInRleHR3cmFwXCIgKSB7XG4gICAgICB2YXIgcyA9IHRoaXMuc3BsaXRcbiAgICAgIHRoaXMuYnJlYWsgPSBuZXcgUmVnRXhwKFwiW15cXFxcc1xcXFxcIitzLmpvaW4oXCJcXFxcXCIpK1wiXStcXFxcXCIrcy5qb2luKFwiP1xcXFxcIikrXCI/XCIsXCJnXCIpXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgfSxcbiAgXCJuZXN0aW5nXCIgICAgOiB0cnVlLFxuICBcIm11dGVcIiAgICAgICA6IGQzcGx1cy5tZXRob2QuZmlsdGVyKHRydWUpLFxuICBcInNvbG9cIiAgICAgICA6IGQzcGx1cy5tZXRob2QuZmlsdGVyKHRydWUpLFxuICBcInNlY29uZGFyeVwiICA6IHtcbiAgICBcImFjY2VwdGVkXCIgOiBbIEFycmF5ICwgQm9vbGVhbiAsIEZ1bmN0aW9uICwgT2JqZWN0ICwgU3RyaW5nIF0sXG4gICAgXCJuZXN0aW5nXCIgIDogdHJ1ZSxcbiAgICBcInZhbHVlXCIgICAgOiBmYWxzZVxuICB9LFxuICBcInNwbGl0XCIgICAgICA6IFsgXCItXCIgLCBcIi9cIiAsIFwiO1wiICwgXCI6XCIgLCBcIiZcIiBdXG59XG4iLCJkM3BsdXMubWV0aG9kLnRpbWUgPSB7XG4gIFwiYWNjZXB0ZWRcIiAgICA6IFsgQXJyYXkgLCBCb29sZWFuICwgRnVuY3Rpb24gLCBPYmplY3QgLCBTdHJpbmcgXSxcbiAgXCJkYXRhRmlsdGVyXCIgIDogdHJ1ZSxcbiAgXCJkZXByZWNhdGVzXCIgIDogWyBcInllYXJcIiAsIFwieWVhcl92YXJcIiBdLFxuICBcImZpeGVkXCIgICAgICAgOiB7XG4gICAgXCJhY2NlcHRlZFwiICAgOiBbIEJvb2xlYW4gXSxcbiAgICBcImRlcHJlY2F0ZXNcIiA6IFsgXCJzdGF0aWNfYXhpc1wiICwgXCJzdGF0aWNfYXhlc1wiIF0sXG4gICAgXCJ2YWx1ZVwiICAgICAgOiB0cnVlXG4gIH0sXG4gIFwiZm9ybWF0XCIgICAgICA6IHtcbiAgICBcImFjY2VwdGVkXCIgOiBbZmFsc2UsIFN0cmluZ10sXG4gICAgXCJ2YWx1ZVwiICAgIDogZmFsc2VcbiAgfSxcbiAgXCJtdXRlXCIgICAgICAgIDogZDNwbHVzLm1ldGhvZC5maWx0ZXIoZmFsc2UpLFxuICBcInNvbG9cIiAgICAgICAgOiBkM3BsdXMubWV0aG9kLmZpbHRlcihmYWxzZSksXG4gIFwidmFsdWVcIiAgICAgICA6IGZhbHNlXG59XG4iLCJkM3BsdXMubWV0aG9kLnRpbWVsaW5lID0ge1xuICBcImFjY2VwdGVkXCIgOiBbIEJvb2xlYW4gXSxcbiAgXCJ2YWx1ZVwiICAgIDogdHJ1ZVxufVxuIiwiZDNwbHVzLm1ldGhvZC50aXRsZSA9IHtcbiAgXCJhY2NlcHRlZFwiIDogWyBmYWxzZSAsIEZ1bmN0aW9uICwgU3RyaW5nIF0sXG4gIFwibGlua1wiICAgICA6IGZhbHNlLFxuICBcInN1YlwiICAgICAgOiB7XG4gICAgXCJhY2NlcHRlZFwiICAgOiBbIGZhbHNlICwgU3RyaW5nIF0sXG4gICAgXCJkZXByZWNhdGVzXCIgOiBcInN1Yl90aXRsZVwiLFxuICAgIFwibGlua1wiICAgICAgIDogZmFsc2UsXG4gICAgXCJ2YWx1ZVwiICAgICAgOiBmYWxzZSxcbiAgfSxcbiAgXCJ0b3RhbFwiICAgIDoge1xuICAgIFwiYWNjZXB0ZWRcIiAgIDogWyBCb29sZWFuICwgT2JqZWN0IF0sXG4gICAgXCJkZXByZWNhdGVzXCIgOiBcInRvdGFsX2JhclwiLFxuICAgIFwibGlua1wiICAgICAgIDogZmFsc2UsXG4gICAgXCJ2YWx1ZVwiICAgICAgOiBmYWxzZVxuICB9LFxuICBcInByb2Nlc3NcIiAgOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgdmFyIHZhcnMgPSB0aGlzLmdldFZhcnMoKVxuXG4gICAgaWYgKCB2YXJzLmNvbnRhaW5lci5pZC5pbmRleE9mKFwiZGVmYXVsdFwiKSA9PT0gMCAmJiB2YWx1ZSApIHtcbiAgICAgIHZhciBpZCA9IGQzcGx1cy5zdHJpbmcuc3RyaXAodmFsdWUpLnRvTG93ZXJDYXNlKClcbiAgICAgIHZhcnMuc2VsZi5jb250YWluZXIoe1wiaWRcIjogaWR9KVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZVxuXG4gIH0sXG4gIFwidmFsdWVcIiAgICA6IGZhbHNlXG59XG4iLCJkM3BsdXMubWV0aG9kLnRvb2x0aXAgPSB7XG4gIFwiYWNjZXB0ZWRcIiAgIDogWyBmYWxzZSAsIEFycmF5ICwgRnVuY3Rpb24gLCBPYmplY3QgLCBTdHJpbmcgXSxcbiAgXCJkZXByZWNhdGVzXCIgOiBcInRvb2x0aXBfaW5mb1wiLFxuICBcImh0bWxcIiAgICAgICA6IHtcbiAgICBcImFjY2VwdGVkXCIgICA6IFsgZmFsc2UgLCBGdW5jdGlvbiAsIFN0cmluZyBdLFxuICAgIFwiZGVwcmVjYXRlc1wiIDogXCJjbGlja19mdW5jdGlvblwiLFxuICAgIFwidmFsdWVcIiAgICAgIDogZmFsc2VcbiAgfSxcbiAgXCJ2YWx1ZVwiICAgICAgOiBmYWxzZVxufVxuIiwiZDNwbHVzLm1ldGhvZC50b3RhbCA9IHtcbiAgXCJhY2NlcHRlZFwiOiBbIGZhbHNlICwgQXJyYXkgLCBGdW5jdGlvbiAsIE9iamVjdCAsIFN0cmluZyBdLFxuICBcImRlcHJlY2F0ZXNcIjogWyBcInRvdGFsX3ZhclwiIF0sXG4gIFwibXV0ZVwiOiBkM3BsdXMubWV0aG9kLmZpbHRlcih0cnVlKSxcbiAgXCJzb2xvXCI6IGQzcGx1cy5tZXRob2QuZmlsdGVyKHRydWUpLFxuICBcInZhbHVlXCI6IGZhbHNlXG59XG4iLCJkM3BsdXMubWV0aG9kLnR5cGUgPSB7XG4gIFwiYWNjZXB0ZWRcIiA6IGZ1bmN0aW9uKCB2YXJzICkge1xuICAgIHJldHVybiBkMy5rZXlzKHZhcnMudHlwZXMpXG4gIH0sXG4gIFwiaW5pdFwiICAgICA6IGZ1bmN0aW9uICggdmFycyApIHtcblxuICAgIHZhciBzaGVsbCA9IHZhcnMuc2hlbGxcblxuICAgIGlmICggc2hlbGwgPT09IFwidml6XCIgKSB7XG4gICAgICByZXR1cm4gXCJ0cmVlX21hcFwiXG4gICAgfVxuICAgIGVsc2UgaWYgKCBzaGVsbCA9PT0gXCJmb3JtXCIgKSB7XG4gICAgICByZXR1cm4gXCJhdXRvXCJcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gIH0sXG4gIFwibW9kZVwiICAgICA6IHtcbiAgICBcImFjY2VwdGVkXCIgOiBmdW5jdGlvbih2YXJzKXtcbiAgICAgIHJldHVybiB2YXJzLnR5cGVzW3ZhcnMudHlwZS52YWx1ZV0ubW9kZXMgfHwgWyBmYWxzZSBdXG4gICAgfSxcbiAgICBcInZhbHVlXCIgICAgOiBmYWxzZVxuICB9XG59XG4iLCJkM3BsdXMubWV0aG9kLnVpID0ge1xuICBcImFjY2VwdGVkXCIgOiBbIEFycmF5ICwgQm9vbGVhbiBdLFxuICBcInZhbHVlXCIgICAgOiBmYWxzZVxufVxuIiwiZDNwbHVzLm1ldGhvZC53aWR0aCA9IHtcbiAgXCJhY2NlcHRlZFwiICA6IFsgZmFsc2UgLCBOdW1iZXIgXSxcbiAgXCJzZWNvbmRhcnlcIiA6IGZhbHNlLFxuICBcInZhbHVlXCIgICAgIDogZmFsc2Vcbn1cbiIsImQzcGx1cy5tZXRob2QueCA9IGQzcGx1cy5tZXRob2QuYXhpcyhcInhcIilcbiIsImQzcGx1cy5tZXRob2QueSA9IGQzcGx1cy5tZXRob2QuYXhpcyhcInlcIilcbiIsImQzcGx1cy5tZXRob2Quem9vbSA9IHtcbiAgXCJhY2NlcHRlZFwiICAgOiBbIEJvb2xlYW4gXSxcbiAgXCJiZWhhdmlvclwiICAgOiBkMy5iZWhhdmlvci56b29tKCkuc2NhbGVFeHRlbnQoWyAxICwgMSBdKSxcbiAgXCJjbGlja1wiICAgICAgOiB7XG4gICAgXCJhY2NlcHRlZFwiIDogWyBCb29sZWFuIF0sXG4gICAgXCJ2YWx1ZVwiICAgIDogdHJ1ZVxuICB9LFxuICBcImRpcmVjdGlvblwiICA6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG4gICAgdmFyIHZhcnMgICAgICAgICAgPSB0aGlzLmdldFZhcnMoKVxuICAgICAgLCBtYXhfZGVwdGggICAgID0gdmFycy5pZC5uZXN0aW5nLmxlbmd0aC0xXG4gICAgICAsIGN1cnJlbnRfZGVwdGggPSB2YXJzLmRlcHRoLnZhbHVlXG4gICAgICAsIHJlc3RyaWN0ZWQgICAgPSB2YXJzLnR5cGVzW3ZhcnMudHlwZS52YWx1ZV0ubmVzdGluZyA9PT0gZmFsc2VcblxuICAgIGlmIChyZXN0cmljdGVkKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgICBlbHNlIGlmICggZGF0YS5kM3BsdXMubWVyZ2VkIHx8IGN1cnJlbnRfZGVwdGggPCBtYXhfZGVwdGhcbiAgICAgICAgICAgICAgJiYgKCAhZGF0YSB8fCB2YXJzLmlkLm5lc3RpbmdbdmFycy5kZXB0aC52YWx1ZSsxXSBpbiBkYXRhICkgKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cbiAgICBlbHNlIGlmICggKCBjdXJyZW50X2RlcHRoID09PSBtYXhfZGVwdGggfHwgKCBkYXRhICYmICEodmFycy5pZC5uZXN0aW5nW3ZhcnMuZGVwdGgudmFsdWUrMV0gaW4gZGF0YSkgKSApXG4gICAgICAgICAgICAgICYmICggdmFycy5zbWFsbCB8fCAhdmFycy50b29sdGlwLmh0bWwudmFsdWUgKSApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIHJldHVybiAwXG5cbiAgfSxcbiAgXCJwYW5cIiAgICAgICAgOiB7XG4gICAgXCJhY2NlcHRlZFwiIDogWyBCb29sZWFuIF0sXG4gICAgXCJ2YWx1ZVwiICAgIDogdHJ1ZVxuICB9LFxuICBcInNjcm9sbFwiICAgICA6IHtcbiAgICBcImFjY2VwdGVkXCIgICA6IFsgQm9vbGVhbiBdLFxuICAgIFwiZGVwcmVjYXRlc1wiIDogXCJzY3JvbGxfem9vbVwiLFxuICAgIFwidmFsdWVcIiAgICAgIDogdHJ1ZVxuICB9LFxuICBcInRvdWNoRXZlbnRcIiA6IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHZhcnMgICAgID0gdGhpcy5nZXRWYXJzKClcbiAgICAgICwgem9vbWVkICAgPSB2YXJzLnpvb20uc2NhbGUgPiB2YXJzLnpvb20uYmVoYXZpb3Iuc2NhbGVFeHRlbnQoKVswXVxuICAgICAgLCBlbmFibGVkICA9IHZhcnMudHlwZXNbdmFycy50eXBlLnZhbHVlXS56b29tXG4gICAgICAgICAgICAgICAgICYmIHZhcnMuem9vbS52YWx1ZSAmJiB2YXJzLnpvb20uc2Nyb2xsLnZhbHVlXG4gICAgICAsIHpvb21hYmxlID0gZDMuZXZlbnQudG91Y2hlcy5sZW5ndGggPiAxICYmIGVuYWJsZWRcblxuICAgIGlmICghem9vbWFibGUgJiYgIXpvb21lZCkge1xuICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICB9XG5cbiAgfSxcbiAgXCJ2YWx1ZVwiICAgICAgOiB0cnVlXG59XG4iLCIjXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4jIENvbW11bml0eSBkZXRlY3Rpb24gYWxnb3JpdGhtIChncmFwaCBjbHVzdGVyaW5nL3BhcnRpdGlvbmluZylcbiMgQmFzZWQgb24gdGhlIHBhcGVyOlxuIyBGaW5kaW5nIGNvbW11bml0eSBzdHJ1Y3R1cmUgaW4gdmVyeSBsYXJnZSBuZXR3b3JrcywgQSBDbGF1c2V0LCBNRUogTmV3bWFuLCBDIE1vb3JlIC0gUGh5c2ljYWwgcmV2aWV3IEUsIDIwMDRcbiMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuIyBlZGdlczsgYSBsaXN0IG9mIGVkZ2Ugb2JqZWN0c1xuXG4jIG9wdGlvbnM7IGEgZGljdGlvbmFyeSBvZiBvcHRpb25zIHdpdGggYXR0cmlidXRlc1xuICAgICMgZGlzdGFuY2U7IGl0IGNhbiBiZTpcbiAgICAgICMgdW5kZWZpbmVkOyBldmVyeSBlZGdlIGhhcyBkZWZhdWx0IGRpc3RhbmNlIG9mIDFcbiAgICAgICMgY29uc3RhbnQ7IGV2ZXJ5IGVkZ2UgaGFzIHRoZSBzYW1lIGRpc3RhbmNlXG4gICAgICAjIHN0cmluZzsgdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSBpbiBlZGdlIHRoYXQgZGVzY3JpYmVzIHRoZSBkaXN0YW5jZSBvZiB0aGF0IGVkZ2VcbiAgICAgICMgYXJyYXk7IGVhY2ggdmFsdWUgY29ycmVzcG9uZHMgdG8gdGhlIGRpc3RhbmNlIG9mIHRoZSByZXNwZWN0aXZlIGVkZ2UgaW4gdGhlIGVkZ2VzIGFycmF5XG4gICAgICAjIGZ1bmN0aW9uOyBnaXZlbiBlZGdlLCByZXR1cm5zIHRoZSBkaXN0YW5jZVxuXG4gICAgIyBub2RlaWQ7IGl0IGNhbiBiZTpcbiAgICAgICMgdW5kZWZpbmVkOyB0aGVuIHdlIGFzc3VtZSB0aGF0IGVhY2ggbm9kZSBvYnRhaW5lZCBieSBnZXR0aW5nIHRoZSBlbmRwb2ludHMgb2YgYW4gZWRnZSBpcyBhIHN0cmluZy9udW1iZXIgZGVzY3JpYmluZyB0aGUgaWQgb2YgdGhlIG5vZGVcbiAgICAgICMgc3RyaW5nOyB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIGluIG5vZGUgdGhhdCBkZXNjcmliZXMgdGhlIGlkIG9mIHRoZSBub2RlLlxuICAgICAgIyBmdW5jdGlvbjsgZ2l2ZW4gdGhlIG5vZGUsIHJldHVybnMgdGhlIGlkLlxuXG4gICAgIyBzdGFydHBvaW50OyBpdCBjYW4gYmU6XG4gICAgICAjIHVuZGVmaW5lZDsgaXQgaXMgYXNzdW1lZCB0aGF0IGVkZ2Uuc291cmNlIHBvaW50cyB0byB0aGUgc291cmNlIG5vZGUgb2YgdGhlIGVkZ2VcbiAgICAgICMgc3RyaW5nOyB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIGluIGVkZ2UgcG9pbnRpbmcgdG8gdGhlIHNvdXJjZSBub2RlIG9mIHRoZSBlZGdlXG4gICAgICAjIGZ1bmN0aW9uOyBnaXZlbiBhbiBlZGdlIHJldHVybnMgdGhlIHNvdXJjZSBub2RlIG9mIHRoYXQgZWRnZVxuXG4gICAgIyBlbmRwb2ludDsgaXQgY2FuIGJlOlxuICAgICAgIyB1bmRlZmluZWQ7IGl0IGlzIGFzc3VtZWQgdGhhdCBlZGdlLnRhcmdldCBwb2ludHMgdG8gdGhlIHRhcmdldCBvZiB0aGUgZWRnZVxuICAgICAgIyBzdHJpbmc7IHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgaW4gZWRnZSBwb2ludGluZyB0byB0aGUgdGFyZ2V0IG9mIHRoZSBlZGdlXG4gICAgICAjIGZ1bmN0aW9uOyBnaXZlbiBhbiBlZGdlIHJldHVybnMgdGhlIHRhcmdldCBub2RlIG9mIHRoYXQgZWRnZVxuXG4gICAgIyBub2RlczsgaWYgZGVmaW5lZCwgdGhlIGlucHV0IGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCBhbmQgbm9kZXMgaXMgYXNzdW1lZCB0byBiZSBhIGRpY3Rpb25hcnlcbiAgICAjIHRoYXQgbWFwcyBub2RlIGlkIHRvIHRoZSBvdXRlZGdlcyBvZiB0aGUgbm9kZVxuXG4jIHJldHVybnMgYW4gYXJyYXkgb2YgY29tbXVuaXRpZXMsIHdoZXJlIGVhY2ggY29tbXVuaXR5IGlzIGFuIGFycmF5IG9mIG5vZGUgaWRzIGJlbG9uZ2luZyB0byB0aGF0IGNvbW11bml0eS5cblxuZDNwbHVzLm5ldHdvcmsuY2x1c3RlciA9IChlZGdlcywgb3B0aW9ucykgLT5cbiAgICAjIyBGb3IgdmlzdWFsaXphdGlvbiBkZWJ1Z2dpbmcgcHVycG9zZXMgIyNcbiAgICBldmVudHMgPSBbXVxuICBcbiAgICAjIyMjIyMjIyMgVXNlcidzIG9wdGlvbnMgbm9ybWFsaXphdGlvbiAjIyMjIyMjIyMjIyNcbiAgICBpZiBub3Qgb3B0aW9ucz8gdGhlbiBvcHRpb25zID0ge31cbiAgICBpZiBub3Qgb3B0aW9ucy5ub2Rlcz8gb3IgdHlwZW9mIG9wdGlvbnMubm9kZXMgaXNudCAnb2JqZWN0J1xuICAgICAgW2VkZ2VzLCBvcHRpb25zXSA9IGQzcGx1cy5uZXR3b3JrLm5vcm1hbGl6ZSBlZGdlcywgb3B0aW9uc1xuICAgICAgaWYgb3B0aW9ucyBpcyBudWxsIHRoZW4gcmV0dXJuIG51bGxcbiAgICAjIHVucGFjayBvcHRpb25zIG9iamVjdFxuICAgIHtkaXN0YW5jZSwgbm9kZWlkLCBzdGFydHBvaW50LCBlbmRwb2ludCwgbm9kZXN9ID0gb3B0aW9uc1xuICAgICMjIyMjIyMgRU5EIHVzZXIncyBpbnB1dCBub3JtYWxpemF0aW9uICMjIyMjIyMjI1xuXG4gICAgIyBidWlsZCB0aGUgbm9kZXMgbWFwLCB3aGljaCBzdG9yZXMgdGhlIGRlZ3JlZSBvZiBldmVyeSBub2RlXG4gICAgbm9kZXNNYXAgPSB7fVxuICAgIGZvciBpZCBvZiBub2Rlc1xuICAgICAgbm9kZXNNYXBbaWRdID0geyBub2RlOiBub2Rlc1tpZF0ubm9kZSwgZGVncmVlOjAgfVxuICAgIFxuICAgICMgYnVpbGQgdGhlIGxpbmtzIG1hcCwgd2hpY2ggc3RvcmVzIHRoZSBleHBlY3RlZCBudW1iZXIgb2YgbGlua3MgYmV0d2VlbiBldmVyeSBwYWlyIG9mIG5vZGVzXG4gICAgbSA9IDBcbiAgICBsaW5rc01hcCA9IHt9XG4gICAgZm9yIGVkZ2UgaW4gZWRnZXNcbiAgICAgIGEgPSBub2RlaWQgc3RhcnRwb2ludCBlZGdlXG4gICAgICBiID0gbm9kZWlkIGVuZHBvaW50IGVkZ2VcbiAgICAgIGxpbmtzTWFwW2FdID0ge30gaWYgYSBub3Qgb2YgbGlua3NNYXBcbiAgICAgIGxpbmtzTWFwW2JdID0ge30gaWYgYiBub3Qgb2YgbGlua3NNYXAgXG4gICAgICBcbiAgICAgIGlmIGIgbm90IG9mIGxpbmtzTWFwW2FdXG4gICAgICAgIGxpbmtzTWFwW2FdW2JdID0gMFxuICAgICAgICBsaW5rc01hcFtiXVthXSA9IDBcbiAgICAgICAgbSsrXG4gICAgICAgIG5vZGVzTWFwW2FdLmRlZ3JlZSs9MVxuICAgICAgICBub2Rlc01hcFtiXS5kZWdyZWUrPTFcbiAgICBcbiAgICBjb21tdW5pdGllcyA9IHt9XG4gICAgUSA9IDBcbiAgICBmb3IgaWQsIG5vZGUgb2Ygbm9kZXNNYXBcbiAgICAgIGNvbW11bml0aWVzW2lkXSA9IHtzY29yZTogbm9kZS5kZWdyZWUgLyAoMi4wKm0pLCBub2RlczpbaWRdfVxuICAgICAgXG4gICAgZm9yIGEgb2YgbGlua3NNYXBcbiAgICAgIGZvciBiIG9mIGxpbmtzTWFwW2FdXG4gICAgICAgIGxpbmtzTWFwW2FdW2JdID0gMS4wIC8gKDIqbSkgLSAobm9kZXNNYXBbYV0uZGVncmVlICogbm9kZXNNYXBbYl0uZGVncmVlKS8oNC4wKm0qbSlcblxuICAgIGl0ZXIgPSAwXG4gICAgd2hpbGUgaXRlciA8IDEwMDBcbiAgICAgICMjIGZpbmQgbGFyZ2VzdCBlbGVtZW50IG9mIGxpbmtzXG4gICAgICBkZWx0YVEgPSAtMVxuICAgICAgbWF4YSA9IHVuZGVmaW5lZFxuICAgICAgbWF4YiA9IHVuZGVmaW5lZFxuICAgICAgZm9yIGEgb2YgbGlua3NNYXBcbiAgICAgICAgZm9yIGIgb2YgbGlua3NNYXBbYV1cbiAgICAgICAgICBpZiBsaW5rc01hcFthXVtiXSA+IGRlbHRhUVxuICAgICAgICAgICAgZGVsdGFRID0gbGlua3NNYXBbYV1bYl1cbiAgICAgICAgICAgIG1heGEgPSBhXG4gICAgICAgICAgICBtYXhiID0gYlxuICAgICAgYnJlYWsgaWYgZGVsdGFRIDwgMFxuICAgICAgIyMgbWVyZ2UgbWF4YSBpbnRvIG1heGJcbiAgICAgIGZvciBrIG9mIGxpbmtzTWFwW21heGFdXG4gICAgICAgIGlmIGsgaXNudCBtYXhiXG4gICAgICAgICAgaWYgayBvZiBsaW5rc01hcFttYXhiXVxuICAgICAgICAgICAgIyMgayBpcyBjb25uZWN0ZWQgdG8gYm90aCBhIGFuZCBiXG4gICAgICAgICAgICBsaW5rc01hcFttYXhiXVtrXSArPSBsaW5rc01hcFttYXhhXVtrXVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICMjIGsgaXMgY29ubmVjdGVkIHRvIGEgYnV0IG5vdCBiXG4gICAgICAgICAgICBsaW5rc01hcFttYXhiXVtrXSA9IGxpbmtzTWFwW21heGFdW2tdIC0gMipjb21tdW5pdGllc1ttYXhiXS5zY29yZSpjb21tdW5pdGllc1trXS5zY29yZVxuICAgICAgICAgIGxpbmtzTWFwW2tdW21heGJdID0gbGlua3NNYXBbbWF4Yl1ba11cbiAgICAgICAgZGVsZXRlIGxpbmtzTWFwW2tdW21heGFdXG4gICAgICBmb3IgayBvZiBsaW5rc01hcFttYXhiXVxuICAgICAgICBpZiBrIG5vdCBvZiBsaW5rc01hcFttYXhhXSBhbmQgayBpc250IG1heGJcbiAgICAgICAgICAjIyBrIGlzIGNvbm5lY3RlZCB0byBiIGJ1dCBub3QgYVxuICAgICAgICAgIGxpbmtzTWFwW21heGJdW2tdIC09IDIqY29tbXVuaXRpZXNbbWF4YV0uc2NvcmUqY29tbXVuaXRpZXNba10uc2NvcmVcbiAgICAgICAgICBsaW5rc01hcFtrXVttYXhiXSA9IGxpbmtzTWFwW21heGJdW2tdXG4gICAgICBcbiAgICAgIGZvciBub2RlIGluIGNvbW11bml0aWVzW21heGFdLm5vZGVzXG4gICAgICAgIGNvbW11bml0aWVzW21heGJdLm5vZGVzLnB1c2ggbm9kZVxuICAgICAgY29tbXVuaXRpZXNbbWF4Yl0uc2NvcmUgKz0gY29tbXVuaXRpZXNbbWF4YV0uc2NvcmVcbiAgICAgIGlmIG9wdGlvbnMudmRlYnVnIHRoZW4gZXZlbnRzLnB1c2ggdHlwZTogJ21lcmdlJywgZmF0aGVyOiBtYXhiLCBjaGlsZDogbWF4YSwgbm9kZXM6IGNvbW11bml0aWVzW21heGJdLm5vZGVzXG4gICAgICBkZWxldGUgY29tbXVuaXRpZXNbbWF4YV1cbiAgICAgIGRlbGV0ZSBsaW5rc01hcFttYXhhXVxuICAgICAgUSArPSBkZWx0YVFcbiAgICAgIGl0ZXIrK1xuXG4gICAgIyMgc29ydCBjb21tdW5pdGllcyBieSBzaXplXG4gICAgY29tbVNpemVzID0gKFtjaWQsIGNvbW11bml0eS5ub2Rlcy5sZW5ndGhdIGZvciBjaWQsIGNvbW11bml0eSBvZiBjb21tdW5pdGllcylcbiAgICBjb21tU2l6ZXMuc29ydCAoYSxiKSAtPiBiWzFdIC0gYVsxXVxuICAgIHJlc3VsdCA9IChjb21tdW5pdGllc1tjb21tU2l6ZVswXV0ubm9kZXMgZm9yIGNvbW1TaXplIGluIGNvbW1TaXplcylcbiAgICByZXR1cm4gW3Jlc3VsdCwgZXZlbnRzXVxuIiwiI15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuIyBOb3JtYWxpemVzIHRoZSBncmFwaCBpbnB1dCBhbmQgY2hlY2tzIGlmIGl0IGlzIHZhbGlkXG4jLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmQzcGx1cy5uZXR3b3JrLm5vcm1hbGl6ZSA9IChlZGdlcywgb3B0aW9ucykgLT5cbiAgIyB1bnBhY2sgb3B0aW9uc1xuICB7c291cmNlLCB0YXJnZXQsIGRpcmVjdGVkLCBkaXN0YW5jZSwgbm9kZWlkLCBzdGFydHBvaW50LCBlbmRwb2ludCwgSywgdmRlYnVnfSA9IG9wdGlvbnNcbiAgaWYgbm90IGRpcmVjdGVkIHRoZW4gZGlyZWN0ZWQgPSBmYWxzZVxuICBpZiBub3QgSz8gdGhlbiBLID0gMVxuICBpZiBub3Qgbm9kZWlkPyB0aGVuIG5vZGVpZCA9IChub2RlKSAtPiByZXR1cm4gbm9kZVxuICBlbHNlIGlmIHR5cGVvZiBub2RlaWQgaXMgJ3N0cmluZycgdGhlbiBub2RlaWQgPSBkbyAobm9kZWlkKSAtPiAobm9kZSkgLT4gcmV0dXJuIG5vZGVbbm9kZWlkXVxuICBpZiBzb3VyY2U/IGFuZCB0eXBlb2Ygc291cmNlIGlzICdvYmplY3QnIHRoZW4gc291cmNlID0gbm9kZWlkIHNvdXJjZVxuICBpZiB0YXJnZXQ/IGFuZCB0eXBlb2YgdGFyZ2V0IGlzICdvYmplY3QnIHRoZW4gdGFyZ2V0ID0gbm9kZWlkIHRhcmdldFxuICBcbiAgaWYgbm90IHN0YXJ0cG9pbnQ/IHRoZW4gc3RhcnRwb2ludCA9IChlZGdlKSAtPiByZXR1cm4gZWRnZS5zb3VyY2VcbiAgZWxzZSBpZiB0eXBlb2Ygc3RhcnRwb2ludCBpcyAnc3RyaW5nJyB0aGVuIHN0YXJ0cG9pbnQgPSBkbyAoc3RhcnRwb2ludCkgLT4gKGVkZ2UpIC0+IHJldHVybiBlZGdlW3N0YXJ0cG9pbnRdXG5cbiAgaWYgbm90IGVuZHBvaW50PyB0aGVuIGVuZHBvaW50ID0gKGVkZ2UpIC0+IHJldHVybiBlZGdlLnRhcmdldFxuICBlbHNlIGlmIHR5cGVvZiBlbmRwb2ludCBpcyAnc3RyaW5nJyB0aGVuIGVuZHBvaW50ID0gZG8gKGVuZHBvaW50KSAtPiAoZWRnZSkgLT4gcmV0dXJuIGVkZ2VbZW5kcG9pbnRdXG5cbiAgaWYgbm90IGRpc3RhbmNlPyB0aGVuIGRpc3RhbmNlID0gKGVkZ2UpIC0+IHJldHVybiAxXG4gIGVsc2UgaWYgdHlwZW9mIGRpc3RhbmNlIGlzICdudW1iZXInIHRoZW4gZGlzdGFuY2UgPSBkbyAoZGlzdGFuY2UpIC0+IChlZGdlKSAtPiByZXR1cm4gZGlzdGFuY2VcbiAgZWxzZSBpZiB0eXBlb2YgZGlzdGFuY2UgaXMgJ3N0cmluZycgdGhlbiBkaXN0YW5jZSA9IGRvIChkaXN0YW5jZSkgLT4gKGVkZ2UpIC0+IHJldHVybiBlZGdlW2Rpc3RhbmNlXVxuICBlbHNlIGlmIGRpc3RhbmNlIGluc3RhbmNlb2YgQXJyYXlcbiAgICBlZGdlMmRpc3RhbmNlID0ge31cbiAgICBmb3IgZWRnZSwgaSBpbiBlZGdlc1xuICAgICAgYSA9IG5vZGVpZCBzdGFydHBvaW50IGVkZ2VcbiAgICAgIGIgPSBub2RlaWQgZW5kcG9pbnQgZWRnZVxuICAgICAgZWRnZTJkaXN0YW5jZVthICsgJ18nICsgYl0gPSBkaXN0YW5jZVtpXVxuICAgIGRpc3RhbmNlID0gKGVkZ2UpIC0+XG4gICAgICBhID0gbm9kZWlkIHN0YXJ0cG9pbnQgZWRnZVxuICAgICAgYiA9IG5vZGVpZCBlbmRwb2ludCBlZGdlXG4gICAgICByZXR1cm4gZWRnZTJkaXN0YW5jZVthICsgJ18nICsgYl1cbiAgXG4gICMgY3JlYXRlIHRoZSBub2RlcyBleHBsaWNpdGx5IGJ5IGdvaW5nIHRocm91Z2ggdGhlIGVkZ2VzXG4gICMgYW5kIGFzc2lnbiBzb21lIGJvb2trZWVwaW5nIHZhcmlhYmxlcyB0byB0aGVtXG4gIG5vZGVzID0ge31cbiAgZm9yIGVkZ2UgaW4gZWRnZXNcbiAgICBub2RlQSA9IHN0YXJ0cG9pbnQgZWRnZVxuICAgIG5vZGVCID0gZW5kcG9pbnQgZWRnZVxuICAgIGlkQSA9IG5vZGVpZCBub2RlQVxuICAgIGlkQiA9IG5vZGVpZCBub2RlQlxuICAgIGZvciBub2RlIGluIFtub2RlQSwgbm9kZUJdXG4gICAgICBpZCA9IG5vZGVpZCBub2RlXG4gICAgICBpZiBpZCBub3Qgb2Ygbm9kZXMgdGhlbiBub2Rlc1tpZF0gPSB7bm9kZTogbm9kZSwgb3V0ZWRnZXM6W119XG4gICAgbm9kZXNbaWRBXS5vdXRlZGdlcy5wdXNoIGVkZ2VcbiAgICBpZiBub3QgZGlyZWN0ZWQgdGhlbiBub2Rlc1tpZEJdLm91dGVkZ2VzLnB1c2ggZWRnZVxuXG4gICMgY2hlY2sgaW5wdXQgdmFsaWRpdHlcbiAgZXJyb3Jtc2cgPSBudWxsXG4gIGlmIGVkZ2VzLmxlbmd0aCBpcyAwIHRoZW4gZXJyb3Jtc2cgPSAnVGhlIGxlbmd0aCBvZiBlZGdlcyBpcyAwJ1xuICBlbHNlIGlmIEsgPCAwIHRoZW4gZXJyb3Jtc2cgPSAnSyBjYW4gbm90IGhhdmUgbmVnYXRpdmUgdmFsdWUnXG4gIGVsc2UgaWYgbm90IGRpc3RhbmNlKGVkZ2VzWzBdKT8gdGhlbiBlcnJvcm1zZyA9ICdDaGVjayB0aGUgZGlzdGFuY2UgZnVuY3Rpb24vYXR0cmlidXRlJ1xuICBlbHNlIGlmIG5vdCBzdGFydHBvaW50KGVkZ2VzWzBdKT8gdGhlbiBlcnJvcm1zZyA9ICdDaGVjayB0aGUgc3RhcnRwb2ludCBmdW5jdGlvbi9hdHRyaWJ1dGUnXG4gIGVsc2UgaWYgbm90IGVuZHBvaW50KGVkZ2VzWzBdKT8gdGhlbiBlcnJvcm1zZyA9ICdDaGVjayB0aGUgZW5kcG9pbnQgZnVuY3Rpb24vYXR0cmlidXRlJ1xuICBlbHNlXG4gICAgaWQxID0gbm9kZWlkKHN0YXJ0cG9pbnQoZWRnZXNbMF0pKVxuICAgIGlmIG5vdCBpZDE/IG9yIHR5cGVvZiBpZDEgbm90IGluIFsnc3RyaW5nJywnbnVtYmVyJ10gdGhlbiBlcnJvcm1zZyA9ICdDaGVjayB0aGUgbm9kZWlkIGZ1bmN0aW9uL2F0dHJpYnV0ZSdcbiAgICBlbHNlIGlmIHNvdXJjZT8gYW5kIHNvdXJjZSBub3Qgb2Ygbm9kZXMgdGhlbiBlcnJvcm1zZyA9ICdUaGUgc291cmNlIGlzIG5vdCBpbiB0aGUgZ3JhcGgnXG4gICAgZWxzZSBpZiB0YXJnZXQ/IGFuZCB0YXJnZXQgbm90IG9mIG5vZGVzIHRoZW4gZXJyb3Jtc2cgPSAnVGhlIHRhcmdldCBpcyBub3QgaW4gdGhlIGdyYXBoJ1xuICBcbiAgaWYgZXJyb3Jtc2c/XG4gICAgZDNwbHVzLmNvbnNvbGUuZXJyb3IgZXJyb3Jtc2dcbiAgICByZXR1cm4gbnVsbFxuICBcbiAgcmV0dXJuIFtlZGdlcywge3NvdXJjZSwgdGFyZ2V0LCBkaXJlY3RlZCwgZGlzdGFuY2UsIG5vZGVpZCwgc3RhcnRwb2ludCwgZW5kcG9pbnQsIEssIG5vZGVzLCB2ZGVidWd9XSIsIkhlYXAgPSByZXF1aXJlICdoZWFwJ1xuI15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuIyBGaW5kcyB0aGUgc2hvcnRlc3QgcGF0aHMgaW4gdGhlIGdyYXBoXG4jLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiMgZWRnZXM7IGEgbGlzdCBvZiBlZGdlIG9iamVjdHNcblxuIyBzb3VyY2U7IGl0IGNhbiBiZSBhOlxuICAjIHBvaW50ZXIgdG8gdGhlIHNvdXJjZSBub2RlIG9yIGl0cyBpZFxuICAjIHN0cmluZyBkZW5vdGluZyB0aGUgaWQgb2YgdGhlIHNvdXJjZSBub2RlXG5cbiMgb3B0aW9uczsgYSBkaWN0aW9uYXJ5IG9mIG9wdGlvbnMgd2l0aCBhdHRyaWJ1dGVzXG4gICAgIyB0YXJnZXQ7IGl0IGNhbiBiZSBhOlxuICAgICAgIyB1bmRlZmluZWQ7IHRoZW4gdGhlIGFsZ29yaXRobSByZXR1cm5zIHRoZSBjbG9zZXN0IG5vZGVzIHRvIHRoZSBzb3VyY2VcbiAgICAgICMgcG9pbnRlciB0byB0aGUgdGFyZ2V0IG5vZGUgb3IgaXRzIGlkXG4gICAgICAjIHN0cmluZyBkZW5vdGluZyB0aGUgaWQgb2YgdGhlIHRhcmdldCBub2RlXG5cbiAgICAjZGlyZWN0ZWQ7IHNwZWNpZmllcyB3aGV0aGVyIHRoZSBncmFwaCBpcyBkaXJlY3RlZC4gRGVmYXVsdCBpcyBmYWxzZVxuXG4gICAgIyBkaXN0YW5jZTsgaXQgY2FuIGJlOlxuICAgICAgIyB1bmRlZmluZWQ7IGV2ZXJ5IGVkZ2UgaGFzIGRlZmF1bHQgZGlzdGFuY2Ugb2YgMVxuICAgICAgIyBjb25zdGFudDsgZXZlcnkgZWRnZSBoYXMgdGhlIHNhbWUgZGlzdGFuY2VcbiAgICAgICMgc3RyaW5nOyB0aGUgbmFtZSBvZiB0aGUgYXRycmlidXRlIGluIGVkZ2UgdGhhdCBkZXNjcmliZXMgdGhlIGRpc3RhbmNlIG9mIHRoYXQgZWRnZVxuICAgICAgIyBhcnJheTsgZWFjaCB2YWx1ZSBjb3JyZXNwb25kcyB0byB0aGUgZGlzdGFuY2Ugb2YgdGhlIHJlc3BlY3RpdmUgZWRnZSBpbiB0aGUgZWRnZXMgYXJyYXlcbiAgICAgICMgZnVuY3Rpb247IGdpdmVuIGVkZ2UsIHJldHVybnMgdGhlIGRpc3RhbmNlXG5cbiAgICAjIG5vZGVpZDsgaXQgY2FuIGJlOlxuICAgICAgIyB1bmRlZmluZWQ7IHRoZW4gd2UgYXNzdW1lIHRoYXQgZWFjaCBub2RlIG9idGFpbmVkIGJ5IGdldHRpbmcgdGhlIGVuZHBvaW50cyBvZiBhbiBlZGdlIGlzIGEgc3RyaW5nL251bWJlciBkZXNjcmliaW5nIHRoZSBpZCBvZiB0aGUgbm9kZVxuICAgICAgIyBzdHJpbmc7IHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgaW4gbm9kZSB0aGF0IGRlc2NyaWJlcyB0aGUgaWQgb2YgdGhlIG5vZGUuXG4gICAgICAjIGZ1bmN0aW9uOyBnaXZlbiB0aGUgbm9kZSwgcmV0dXJucyB0aGUgaWQuXG5cbiAgICAjIHN0YXJ0cG9pbnQ7IGl0IGNhbiBiZTpcbiAgICAgICMgdW5kZWZpbmVkOyBpdCBpcyBhc3N1bWVkIHRoYXQgZWRnZS5zb3VyY2UgcG9pbnRzIHRvIHRoZSBzb3VyY2Ugb2YgdGhlIGVkZ2VcbiAgICAgICMgc3RyaW5nOyB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIGluIGVkZ2UgcG9pbnRpbmcgdG8gdGhlIHNvdXJjZSBvZiB0aGUgZWRnZVxuICAgICAgIyBmdW5jdGlvbjsgZ2l2ZW4gYW4gZWRnZSByZXR1cm5zIHRoZSBzb3VyY2Ugbm9kZSBvZiB0aGF0IGVkZ2VcblxuICAgICMgZW5kcG9pbnQ7IGl0IGNhbiBiZTpcbiAgICAgICMgdW5kZWZpbmVkOyBpdCBpcyBhc3N1bWVkIHRoYXQgZWRnZS50YXJnZXQgcG9pbnRzIHRvIHRoZSB0YXJnZXQgb2YgdGhlIGVkZ2VcbiAgICAgICMgc3RyaW5nOyB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIGluIGVkZ2UgcG9pbnRpbmcgdG8gdGhlIHRhcmdldCBvZiB0aGUgZWRnZVxuICAgICAgIyBmdW5jdGlvbjsgZ2l2ZW4gYW4gZWRnZSByZXR1cm5zIHRoZSB0YXJnZXQgbm9kZSBvZiB0aGF0IGVkZ2VcblxuICAgICMgSzsgcmV0dXJucyB0aGUgdG9wIEsgcmVzdWx0cyAoZGVmYXVsdHMgdG8gMSkuIERlcGVuZGluZyBvbiB0aGUgdGFyZ2V0LCBpdCBtZWFuczpcbiAgICAgICMgaWYgdGFyZ2V0IGlzIHNwZWNpZmllZCwgcmV0dXJucyB0aGUgdG9wIEsgc2hvcnRlc3QgcGF0aHMgdG8gdGhlIGdpdmVuIHRhcmdldFxuICAgICAgIyBpZiB0YXJnZXQgaXMgdW5kZWZpbmVkLCByZXR1cm5zIHRoZSB0b3AgSyBjbG9zZXN0IG5vZGVzIHRvIHRoZSBnaXZlbiBzb3VyY2VcblxuICAgICMgbm9kZXM7IGlmIGRlZmluZWQsIHRoZSBpbnB1dCBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgYW5kIG5vZGVzIGlzIGFzc3VtZWQgdG8gYmUgYSBkaWN0aW9uYXJ5XG4gICAgIyB0aGF0IG1hcHMgbm9kZSBpZCB0byB0aGUgb3V0ZWRnZXMgb2YgdGhlIG5vZGVcblxuIyByZXR1cm5zIHRoZSB0b3AgSyBzaG9ydGVzdCBwYXRocyBmcm9tIHRoZSBzb3VyY2UgdG8gdGhlIGdpdmVuIHRhcmdldCwgb3IgdGhlIHRvcCBLIGNsb3Nlc3Qgbm9kZXMgdG8gdGhlIHNvdXJjZVxuZDNwbHVzLm5ldHdvcmsuc2hvcnRlc3RQYXRoID0gKGVkZ2VzLCBzb3VyY2UsIG9wdGlvbnMpIC0+XG4gICMjIyMjIyMjIyBVc2VyJ3Mgb3B0aW9ucyBub3JtYWxpemF0aW9uICMjIyMjIyMjIyMjI1xuICBpZiBub3Qgb3B0aW9ucz8gdGhlbiBvcHRpb25zID0ge31cbiAgb3B0aW9ucy5zb3VyY2UgPSBzb3VyY2VcbiAgaWYgbm90IG9wdGlvbnMubm9kZXM/IG9yIHR5cGVvZiBvcHRpb25zLm5vZGVzIGlzbnQgJ29iamVjdCdcbiAgICBbZWRnZXMsIG9wdGlvbnNdID0gZDNwbHVzLm5ldHdvcmsubm9ybWFsaXplIGVkZ2VzLCBvcHRpb25zXG4gICAgaWYgb3B0aW9ucyBpcyBudWxsIHRoZW4gcmV0dXJuIG51bGxcbiAgIyB1bnBhY2sgb3B0aW9ucyBvYmplY3RcbiAge3NvdXJjZSwgdGFyZ2V0LCBkaXJlY3RlZCwgZGlzdGFuY2UsIG5vZGVpZCwgc3RhcnRwb2ludCwgZW5kcG9pbnQsIEssIG5vZGVzfSA9IG9wdGlvbnNcbiAgIyMjIyMjIyBFTkQgdXNlcidzIGlucHV0IG5vcm1hbGl6YXRpb24gIyMjIyMjIyMjICBcblxuICAjYm9vay1rZWVwaW5nXG4gIG5vZGUuY291bnQgPSAwIGZvciBpZCwgbm9kZSBvZiBub2Rlc1xuICBcbiAgaGVhcCA9IG5ldyBIZWFwIChhLGIpIC0+IHJldHVybiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZVxuICB2aXNpdGVkID0ge31cbiAgaWYgbm90IHRhcmdldD8gdGhlbiB2aXNpdGVkW3NvdXJjZV0gPSB0cnVlXG4gIGhlYXAucHVzaCB7ZWRnZTogbnVsbCwgdGFyZ2V0OiBzb3VyY2UsIGRpc3RhbmNlOiAwfVxuICBcbiAgIyBpdGVyYXRpdmUgYnkgcG9wcGluZyB0aGUgbm9kZSB3aXRoIG1pbmltdW0gZGlzdGFuY2UgZnJvbSB0aGUgZ3JhcGhcbiAgbWF4c2l6ZSA9IDBcbiAgcmVzdWx0ID0gW11cbiAgd2hpbGUgbm90IGhlYXAuZW1wdHkoKVxuICAgIG1heHNpemUgPSBNYXRoLm1heCBtYXhzaXplLCBoZWFwLnNpemUoKVxuICAgIHBhdGggPSBoZWFwLnBvcCgpXG4gICAgdSA9IHBhdGgudGFyZ2V0XG4gICAgbm9kZXNbdV0uY291bnQrK1xuICAgIGlmIG5vdCB0YXJnZXQ/IHRoZW4gcmVzdWx0LnB1c2ggcGF0aFxuICAgIGVsc2UgaWYgdSBpcyB0YXJnZXQgdGhlbiByZXN1bHQucHVzaCBwYXRoXG4gICAgYnJlYWsgaWYgcmVzdWx0Lmxlbmd0aCBpcyBLXG4gICAgaWYgbm9kZXNbdV0uY291bnQgPD0gS1xuICAgICAgZm9yIGVkZ2UgaW4gbm9kZXNbdV0ub3V0ZWRnZXNcbiAgICAgICAgYSA9IG5vZGVpZCBzdGFydHBvaW50IGVkZ2VcbiAgICAgICAgYiA9IG5vZGVpZCBlbmRwb2ludCBlZGdlXG4gICAgICAgIGlmIG5vdCBkaXJlY3RlZCBhbmQgYiBpcyB1IHRoZW4gW2EsIGJdID0gW2IsIGFdXG4gICAgICAgIGlmIG5vdCB0YXJnZXQ/XG4gICAgICAgICAgY29udGludWUgaWYgdmlzaXRlZFtiXVxuICAgICAgICAgIHZpc2l0ZWRbYl0gPSB0cnVlXG4gICAgICAgIGFsdCA9IHBhdGguZGlzdGFuY2UgKyBkaXN0YW5jZSBlZGdlXG4gICAgICAgIGhlYXAucHVzaCB7ZWRnZTogZWRnZSwgcHJldmlvdXM6IHBhdGgsIHRhcmdldDogYiwgZGlzdGFuY2U6IGFsdH1cbiAgXG4gICMgZXhwYW5kIHRoZSBwYXRoIGluZm9ybWF0aW9uIGluIHRoZSByZXN1bHQgb2JqZWN0XG4gIGdldFBhdGggPSAocGF0aCkgLT5cbiAgICAjIHBhdGggc2hvdWxkIGJlIGEgY29tYmluYXRpb24gb2YgZWRnZXNcbiAgICBlZGdlcyA9IFtdXG4gICAgd2hpbGUgcGF0aC5lZGdlP1xuICAgICAgZWRnZXMucHVzaCBwYXRoLmVkZ2VcbiAgICAgIHBhdGggPSBwYXRoLnByZXZpb3VzXG4gICAgcmV0dXJuIGVkZ2VzLnJldmVyc2UoKVxuXG4gIGZvciByZXMgaW4gcmVzdWx0XG4gICAgaWYgdGFyZ2V0P1xuICAgICAgZGVsZXRlIHJlcy50YXJnZXRcbiAgICAgIHJlcy5lZGdlcyA9IGdldFBhdGggcmVzXG4gICAgZGVsZXRlIHJlcy5lZGdlXG4gICAgZGVsZXRlIHJlcy5wcmV2aW91c1xuICByZXR1cm4gcmVzdWx0XG5cbm1vZHVsZS5leHBvcnRzID0gZDNwbHVzLm5ldHdvcmsuc2hvcnRlc3RQYXRoXG4iLCIjXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4jIFJldHVybnMgYSBzdWJncmFwaCBvZiBkaXN0YW5jZSBLIGF3YXkgZnJvbSB0aGUgc291cmNlIG5vZGVcbiMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuIyBlZGdlczsgYSBsaXN0IG9mIGVkZ2Ugb2JqZWN0c1xuXG4jIHNvdXJjZTsgaXQgY2FuIGJlIGE6XG4gICMgcG9pbnRlciB0byB0aGUgc291cmNlIG5vZGUgb3IgaXRzIGlkXG4gICMgc3RyaW5nIGRlbm90aW5nIHRoZSBpZCBvZiB0aGUgc291cmNlIG5vZGVcblxuIyBvcHRpb25zOyBhIGRpY3Rpb25hcnkgb2Ygb3B0aW9ucyB3aXRoIGF0dHJpYnV0ZXNcbiAgICAjIEs7IHJldHVybnMgdGhlIHN1YmdyYXBoIG9mIG5vZGVzIHRoYXQgYXJlIGF0IG1vc3QgZGlzdGFuY2UgSyBmcm9tIHRoZSBzb3VyY2UuIERlZmF1bHQgaXMgMS5cblxuICAgICMgZGlyZWN0ZWQ7IHdoZXRoZXIgdGhlIGdyYXBoIGlzIGRpcmVjdGVkLiBEZWZhdWx0IGlzIGZhbHNlLlxuXG4gICAgIyBkaXN0YW5jZTsgaXQgY2FuIGJlOlxuICAgICAgIyB1bmRlZmluZWQ7IGV2ZXJ5IGVkZ2UgaGFzIGRlZmF1bHQgZGlzdGFuY2Ugb2YgMVxuICAgICAgIyBjb25zdGFudDsgZXZlcnkgZWRnZSBoYXMgdGhlIHNhbWUgZGlzdGFuY2VcbiAgICAgICMgc3RyaW5nOyB0aGUgbmFtZSBvZiB0aGUgYXRycmlidXRlIGluIGVkZ2UgdGhhdCBkZXNjcmliZXMgdGhlIGRpc3RhbmNlIG9mIHRoYXQgZWRnZVxuICAgICAgIyBhcnJheTsgZWFjaCB2YWx1ZSBjb3JyZXNwb25kcyB0byB0aGUgZGlzdGFuY2Ugb2YgdGhlIHJlc3BlY3RpdmUgZWRnZSBpbiB0aGUgZWRnZXMgYXJyYXlcbiAgICAgICMgZnVuY3Rpb247IGdpdmVuIGVkZ2UsIHJldHVybnMgdGhlIGRpc3RhbmNlXG5cbiAgICAjIG5vZGVpZDsgaXQgY2FuIGJlOlxuICAgICAgIyB1bmRlZmluZWQ7IHRoZW4gd2UgYXNzdW1lIHRoYXQgZWFjaCBub2RlIG9idGFpbmVkIGJ5IGdldHRpbmcgdGhlIGVuZHBvaW50cyBvZiBhbiBlZGdlIGlzIGEgc3RyaW5nL251bWJlciBkZXNjcmliaW5nIHRoZSBpZCBvZiB0aGUgbm9kZVxuICAgICAgIyBzdHJpbmc7IHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgaW4gbm9kZSB0aGF0IGRlc2NyaWJlcyB0aGUgaWQgb2YgdGhlIG5vZGUuXG4gICAgICAjIGZ1bmN0aW9uOyBnaXZlbiB0aGUgbm9kZSwgcmV0dXJucyB0aGUgaWQuXG5cbiAgICAjIHN0YXJ0cG9pbnQ7IGl0IGNhbiBiZTpcbiAgICAgICMgdW5kZWZpbmVkOyBpdCBpcyBhc3N1bWVkIHRoYXQgZWRnZS5zb3VyY2UgcG9pbnRzIHRvIHRoZSBzb3VyY2Ugb2YgdGhlIGVkZ2VcbiAgICAgICMgc3RyaW5nOyB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIGluIGVkZ2UgcG9pbnRpbmcgdG8gdGhlIHNvdXJjZSBvZiB0aGUgZWRnZVxuICAgICAgIyBmdW5jdGlvbjsgZ2l2ZW4gYW4gZWRnZSByZXR1cm5zIHRoZSBzb3VyY2Ugbm9kZSBvZiB0aGF0IGVkZ2VcblxuICAgICMgZW5kcG9pbnQ7IGl0IGNhbiBiZTpcbiAgICAgICMgdW5kZWZpbmVkOyBpdCBpcyBhc3N1bWVkIHRoYXQgZWRnZS50YXJnZXQgcG9pbnRzIHRvIHRoZSB0YXJnZXQgb2YgdGhlIGVkZ2VcbiAgICAgICMgc3RyaW5nOyB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIGluIGVkZ2UgcG9pbnRpbmcgdG8gdGhlIHRhcmdldCBvZiB0aGUgZWRnZVxuICAgICAgIyBmdW5jdGlvbjsgZ2l2ZW4gYW4gZWRnZSByZXR1cm5zIHRoZSB0YXJnZXQgbm9kZSBvZiB0aGF0IGVkZ2VcblxuICAgICMgbm9kZXM7IGlmIGRlZmluZWQsIHRoZSBpbnB1dCBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgYW5kIG5vZGVzIGlzIGFzc3VtZWQgdG8gYmUgYSBkaWN0aW9uYXJ5XG4gICAgIyB0aGF0IG1hcHMgbm9kZSBpZCB0byB0aGUgb3V0ZWRnZXMgb2YgdGhlIG5vZGVcblxuIyByZXR1cm5zIGEgZ3JhcGggb2JqZWN0IGNvbXBvc2VkIG9mIG5vZGVzIG9mIGRpc3RhbmNlIEsgYXdheSBmcm9tIHRoZSBzb3VyY2Ugbm9kZSBhbmQgdGhlIGxpbmtzIGJldHdlZW4gdGhlbS5cbmQzcGx1cy5uZXR3b3JrLnN1YmdyYXBoID0gKGVkZ2VzLCBzb3VyY2UsIG9wdGlvbnMpIC0+XG4gICMjIyMjIyMjIyBVc2VyJ3MgaW5wdXQgbm9ybWFsaXphdGlvbiAjIyMjIyMjIyMjIyNcbiAgaWYgbm90IG9wdGlvbnM/IHRoZW4gb3B0aW9ucyA9IHt9XG4gIG9wdGlvbnMuc291cmNlID0gc291cmNlXG4gIGlmIG5vdCBvcHRpb25zLm5vZGVzPyBvciB0eXBlb2Ygb3B0aW9ucy5ub2RlcyBpc250ICdvYmplY3QnXG4gICAgW2VkZ2VzLCBvcHRpb25zXSA9IGQzcGx1cy5uZXR3b3JrLm5vcm1hbGl6ZSBlZGdlcywgb3B0aW9uc1xuICAgIGlmIG9wdGlvbnMgaXMgbnVsbCB0aGVuIHJldHVybiBudWxsXG4gICMgdW5wYWNrIG9wdGlvbnMgb2JqZWN0XG4gIHtzb3VyY2UsIGRpcmVjdGVkLCBkaXN0YW5jZSwgbm9kZWlkLCBzdGFydHBvaW50LCBlbmRwb2ludCwgSywgbm9kZXN9ID0gb3B0aW9uc1xuICAjIyMjIyMjIEVORCB1c2VyJ3MgaW5wdXQgbm9ybWFsaXphdGlvbiAjIyMjIyMjIyNcbiAgXG4gICMgc3RhcnQgZXhwYW5kaW5nIGZyb20gdGhlIHNvdXJjZSBub2RlIHRvIGdldCB0aGUgc3ViZ3JhcGggaW4gREZTIGZhc2hpb25cbiAgIyB0byBmaW5kIGFsbCB0aGUgbm9kZXMgdGhhdCBhcmUgd2l0aGluIGRpc3RhbmNlIEsgYXdheSBmcm9tIHRoZSBzb3VyY2Ugbm9kZVxuICB2aXNpdGVkID0ge31cbiAgdmlzaXRlZFtzb3VyY2VdID0gdHJ1ZVxuICBkZnMgPSAob3JpZ2luLCBjdXJyX2Rpc3RhbmNlKSAtPlxuICAgIGZvciBlZGdlIGluIG5vZGVzW29yaWdpbl0ub3V0ZWRnZXNcbiAgICAgICAgYSA9IG5vZGVpZCBzdGFydHBvaW50IGVkZ2VcbiAgICAgICAgYiA9IG5vZGVpZCBlbmRwb2ludCBlZGdlXG4gICAgICAgIGlmIG5vdCBkaXJlY3RlZCBhbmQgYiBpcyBvcmlnaW4gdGhlbiBbYSwgYl0gPSBbYiwgYV1cbiAgICAgICAgaWYgYiBub3Qgb2YgdmlzaXRlZFxuICAgICAgICAgIG5ld19kaXN0YW5jZSA9IGN1cnJfZGlzdGFuY2UgKyBkaXN0YW5jZShlZGdlKVxuICAgICAgICAgIGlmIG5ld19kaXN0YW5jZSA8PSBLXG4gICAgICAgICAgICB2aXNpdGVkW2JdID0gdHJ1ZVxuICAgICAgICAgICAgZGZzIGIsIG5ld19kaXN0YW5jZVxuICBkZnMgc291cmNlLCAwXG5cbiAgIyBmaW5kIGFsbCB0aGUgZWRnZXMgZm9yIHRoZXNlIG5vZGVzXG4gIHJldHVybiB7XG4gICAgbm9kZXM6IG5vZGVzW2lkXS5ub2RlIGZvciBpZCBvZiB2aXNpdGVkXG4gICAgZWRnZXM6IGVkZ2UgZm9yIGVkZ2UgaW4gZWRnZXMgd2hlbiBub2RlaWQoc3RhcnRwb2ludChlZGdlKSkgb2YgdmlzaXRlZCBhbmQgbm9kZWlkKGVuZHBvaW50KGVkZ2UpKSBvZiB2aXNpdGVkXG4gIH1cbiIsIi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBGb3JtYXRzIG51bWJlcnMgdG8gbG9vayBcInByZXR0eVwiXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZDNwbHVzLm51bWJlci5mb3JtYXQgPSBmdW5jdGlvbiggbnVtYmVyICwga2V5ICwgdmFycyApIHtcblxuICBpZiAoICF2YXJzICYmIFwiZ2V0VmFyc1wiIGluIHRoaXMpIHtcbiAgICB2YXIgdmFycyA9IHRoaXMuZ2V0VmFycygpXG4gIH1cblxuICBpZiAoIHZhcnMgJiYga2V5ICYmIChcbiAgICAgICAoIGtleSA9PT0gdmFycy54LnZhbHVlICYmIHZhcnMueC5zY2FsZS52YWx1ZSA9PT0gXCJsb2dcIiApIHx8XG4gICAgICAgKCBrZXkgPT09IHZhcnMueS52YWx1ZSAmJiB2YXJzLnkuc2NhbGUudmFsdWUgPT09IFwibG9nXCIgKSApICkge1xuXG4gICAgdmFyIHN1cGVyc2NyaXB0ID0gXCLigbDCucKywrPigbTigbXigbbigbfigbjigblcIlxuICAgICAgLCBmb3JtYXRQb3dlciA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICByZXR1cm4gKGQgKyBcIlwiKS5zcGxpdChcIlwiKS5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyc2NyaXB0W2NdXG4gICAgICAgICAgfSkuam9pbihcIlwiKVxuICAgICAgICB9XG5cbiAgICByZXR1cm4gMTAgKyBcIuKAilwiICsgZm9ybWF0UG93ZXIoIE1hdGgucm91bmQoTWF0aC5sb2cobnVtYmVyKSAvIE1hdGguTE4xMCkgKVxuXG4gIH1cblxuICBpZiAoIFwibG9jYWxlXCIgaW4gdGhpcyApIHtcbiAgICB2YXIgbG9jYWxlID0gdGhpcy5sb2NhbGUudmFsdWVcbiAgICAgICwgdGltZSA9IGxvY2FsZS50aW1lXG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGxvY2FsZSA9IGQzcGx1cy5sb2NhbGUuZW5fVVNcbiAgICAgICwgdGltZSA9IGxvY2FsZS50aW1lXG4gIH1cblxuICBpZiAoIHZhcnMgJiYgdHlwZW9mIHZhcnMudGltZS52YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRpbWUucHVzaCh2YXJzLnRpbWUudmFsdWUpXG4gIH1cblxuICBpZiAoa2V5ICYmIHRpbWUuaW5kZXhPZihrZXkudG9Mb3dlckNhc2UoKSkgPj0gMCkge1xuICAgIHJldHVybiBudW1iZXJcbiAgfVxuICBlbHNlIGlmIChudW1iZXIgPCAxMCAmJiBudW1iZXIgPiAtMTApIHtcbiAgICByZXR1cm4gZDMucm91bmQobnVtYmVyLDIpXG4gIH1cbiAgZWxzZSBpZiAobnVtYmVyLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzBdLmxlbmd0aCA+IDQpIHtcbiAgICB2YXIgc3ltYm9sID0gZDMuZm9ybWF0UHJlZml4KG51bWJlcikuc3ltYm9sXG4gICAgc3ltYm9sID0gc3ltYm9sLnJlcGxhY2UoXCJHXCIsIFwiQlwiKSAvLyBkMyB1c2VzIEcgZm9yIGdpZ2FcblxuICAgIC8vIEZvcm1hdCBudW1iZXIgdG8gcHJlY2lzaW9uIGxldmVsIHVzaW5nIHByb3BlciBzY2FsZVxuICAgIG51bWJlciA9IGQzLmZvcm1hdFByZWZpeChudW1iZXIpLnNjYWxlKG51bWJlcilcbiAgICBudW1iZXIgPSBwYXJzZUZsb2F0KGQzLmZvcm1hdChcIi4zZ1wiKShudW1iZXIpKVxuICAgIHJldHVybiBudW1iZXIgKyBzeW1ib2w7XG4gIH1cbiAgZWxzZSBpZiAoa2V5ID09IFwic2hhcmVcIikge1xuICAgIHJldHVybiBkMy5mb3JtYXQoXCIuMmZcIikobnVtYmVyKVxuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBkMy5mb3JtYXQoXCIsZlwiKShudW1iZXIpXG4gIH1cblxufVxuIiwiZDNzZWxlY3Rpb24gPSByZXF1aXJlIFwiLi4vdXRpbC9kM3NlbGVjdGlvbi5qc1wiXG5cbiMjIypcbiAqIE1lcmdlIHR3byBvYmplY3RzIHRvIGNyZWF0ZSBhIG5ldyBvbmUgd2l0aCB0aGUgcHJvcGVydGllcyBvZiBib3RoXG4gIyMjXG5kM3BsdXMub2JqZWN0Lm1lcmdlID0gKG9iajEsIG9iajIpIC0+XG5cbiAgY29weU9iamVjdCA9IChvYmosIHJldCkgLT5cbiAgICBmb3IgYSBvZiBvYmpcbiAgICAgIHVubGVzcyB0eXBlb2Ygb2JqW2FdIGlzIFwidW5kZWZpbmVkXCJcbiAgICAgICAgaWYgZDNwbHVzLm9iamVjdC52YWxpZGF0ZShvYmpbYV0pXG4gICAgICAgICAgcmV0W2FdID0ge30gIGlmIHR5cGVvZiByZXRbYV0gaXNudCBcIm9iamVjdFwiXG4gICAgICAgICAgY29weU9iamVjdCBvYmpbYV0sIHJldFthXVxuICAgICAgICBlbHNlIGlmIG5vdCBkM3NlbGVjdGlvbihvYmpbYV0pIGFuZCBvYmpbYV0gaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgIHJldFthXSA9IG9ialthXS5zbGljZSgwKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0W2FdID0gb2JqW2FdXG5cbiAgb2JqMyA9IHt9XG5cbiAgY29weU9iamVjdCBvYmoxLCBvYmozIGlmIG9iajFcbiAgY29weU9iamVjdCBvYmoyLCBvYmozIGlmIG9iajJcblxuICBvYmozXG5cbm1vZHVsZS5leHBvcnRzID0gZDNwbHVzLm9iamVjdC5tZXJnZVxuIiwiIyMjKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgcGFzc2VkIG9iamVjdCBoYXMga2V5cyBhbmQgaXMgbm90IGFuIGFycmF5LlxuICMjI1xuZDNwbHVzLm9iamVjdC52YWxpZGF0ZSA9IChvYmopIC0+XG4gIG9iaiBpc250IG51bGwgYW5kIHR5cGVvZiBvYmogaXMgXCJvYmplY3RcIiBhbmQgKG9iaiBub3QgaW5zdGFuY2VvZiBBcnJheSlcblxubW9kdWxlLmV4cG9ydHMgPSBkM3BsdXMub2JqZWN0LnZhbGlkYXRlXG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gRm9ybWF0cyBhIHN0cmluZyBzaW1pbGFyIHRvIFB5dGhvbidzIFwiZm9ybWF0XCJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kM3BsdXMuc3RyaW5nLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgICwgc3RyID0gYXJncy5zaGlmdCgpXG5cbiAgc3RyLnVua2V5ZWRfaW5kZXggPSAwO1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xceyhcXHcqKVxcfS9nLCBmdW5jdGlvbihtYXRjaCwga2V5KSB7XG4gICAgICBpZiAoa2V5ID09PSAnJykge1xuICAgICAgICAgIGtleSA9IHN0ci51bmtleWVkX2luZGV4O1xuICAgICAgICAgIHN0ci51bmtleWVkX2luZGV4KytcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT0gK2tleSkge1xuICAgICAgICAgIHJldHVybiBhcmdzW2tleV0gIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgID8gYXJnc1trZXldXG4gICAgICAgICAgICAgIDogbWF0Y2g7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbaV0gPT09ICdvYmplY3QnICYmIHR5cGVvZiBhcmdzW2ldW2tleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1tpXVtrZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH1cbiAgfS5iaW5kKHN0cikpO1xuXG59XG4iLCIjIyMqXG4gKiBDb252ZXJ0cyBhbiBhcnJheSBvZiBzdHJpbmdzIGludG8gYSBzdHJpbmcgbGlzdCB1c2luZyBjb21tYXMgYW5kIFwiYW5kXCIuXG4gIyMjXG5kM3BsdXMuc3RyaW5nLmxpc3QgPSAobGlzdCwgYW5kVGV4dCwgbWF4LCBtb3JlVGV4dCkgLT5cbiAgdW5sZXNzIGxpc3QgaW5zdGFuY2VvZiBBcnJheVxuICAgIHJldHVybiBsaXN0XG4gIGVsc2VcbiAgICBsaXN0ID0gbGlzdC5zbGljZSgwKVxuICBhbmRUZXh0ID0gZDNwbHVzLmxvY2FsZS5lbl9VUy51aS5hbmQgIHVubGVzcyBhbmRUZXh0XG4gIG1vcmVUZXh0ID0gZDNwbHVzLmxvY2FsZS5lbl9VUy51aS5tb3JlVGV4dCAgdW5sZXNzIG1vcmVUZXh0XG4gIGlmIGxpc3QubGVuZ3RoIGlzIDJcbiAgICBsaXN0LmpvaW4gXCIgXCIgKyBhbmRUZXh0ICsgXCIgXCJcbiAgZWxzZVxuICAgIGlmIG1heCBhbmQgbGlzdC5sZW5ndGggPiBtYXhcbiAgICAgIGFtb3VudCA9IGxpc3QubGVuZ3RoIC0gbWF4ICsgMVxuICAgICAgbGlzdCA9IGxpc3Quc2xpY2UoMCwgbWF4IC0gMSlcbiAgICAgIGxpc3RbbWF4IC0gMV0gPSBkM3BsdXMuc3RyaW5nLmZvcm1hdChtb3JlVGV4dCwgYW1vdW50KVxuICAgIGxpc3RbbGlzdC5sZW5ndGggLSAxXSA9IGFuZFRleHQgKyBcIiBcIiArIGxpc3RbbGlzdC5sZW5ndGggLSAxXSAgaWYgbGlzdC5sZW5ndGggPiAxXG4gICAgbGlzdC5qb2luIFwiLCBcIlxuIiwiLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIFJlbW92ZXMgYWxsIG5vbiBBU0NJSSBjaGFyYWN0ZXJzXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZDNwbHVzLnN0cmluZy5zdHJpcCA9IGZ1bmN0aW9uKHN0cikge1xuXG4gIHZhciByZW1vdmVkID0gWyBcIiFcIixcIkBcIixcIiNcIixcIiRcIixcIiVcIixcIl5cIixcIiZcIixcIipcIixcIihcIixcIilcIixcbiAgICAgICAgICAgICAgICAgIFwiW1wiLFwiXVwiLFwie1wiLFwifVwiLFwiLlwiLFwiLFwiLFwiL1wiLFwiXFxcXFwiLFwifFwiLFxuICAgICAgICAgICAgICAgICAgXCInXCIsXCJcXFwiXCIsXCI7XCIsXCI6XCIsXCI8XCIsXCI+XCIsXCI/XCIsXCI9XCIsXCIrXCJdXG4gIHN0ciArPSBcIlwiXG5cbiAgcmV0dXJuIFwiXCIrc3RyLnJlcGxhY2UoL1teQS1aYS16MC05XFwtX10vZywgZnVuY3Rpb24oY2hyKSB7XG5cbiAgICBpZiAoXCIgXCIgPT0gY2hyKSB7XG4gICAgICByZXR1cm4gXCJfXCJcbiAgICB9XG4gICAgZWxzZSBpZiAocmVtb3ZlZC5pbmRleE9mKGNocikgPj0gMCkge1xuICAgICAgcmV0dXJuIFwiXCJcbiAgICB9XG5cbiAgICB2YXIgZGlhY3JpdGljcyA9IFtcbiAgICAgICAgWy9bXFwzMDAtXFwzMDZdL2csIFwiQVwiXSxcbiAgICAgICAgWy9bXFwzNDAtXFwzNDZdL2csIFwiYVwiXSxcbiAgICAgICAgWy9bXFwzMTAtXFwzMTNdL2csIFwiRVwiXSxcbiAgICAgICAgWy9bXFwzNTAtXFwzNTNdL2csIFwiZVwiXSxcbiAgICAgICAgWy9bXFwzMTQtXFwzMTddL2csIFwiSVwiXSxcbiAgICAgICAgWy9bXFwzNTQtXFwzNTddL2csIFwiaVwiXSxcbiAgICAgICAgWy9bXFwzMjItXFwzMzBdL2csIFwiT1wiXSxcbiAgICAgICAgWy9bXFwzNjItXFwzNzBdL2csIFwib1wiXSxcbiAgICAgICAgWy9bXFwzMzEtXFwzMzRdL2csIFwiVVwiXSxcbiAgICAgICAgWy9bXFwzNzEtXFwzNzRdL2csIFwidVwiXSxcbiAgICAgICAgWy9bXFwzMjFdL2csIFwiTlwiXSxcbiAgICAgICAgWy9bXFwzNjFdL2csIFwiblwiXSxcbiAgICAgICAgWy9bXFwzMDddL2csIFwiQ1wiXSxcbiAgICAgICAgWy9bXFwzNDddL2csIFwiY1wiXSxcbiAgICBdO1xuXG4gICAgdmFyIHJldCA9IFwiXCJcblxuICAgIGZvciAoIHZhciBkIGluIGRpYWNyaXRpY3MgKSB7XG5cbiAgICAgIGlmIChkaWFjcml0aWNzW2RdWzBdLnRlc3QoY2hyKSkge1xuICAgICAgICByZXQgPSBkaWFjcml0aWNzW2RdWzFdXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcblxuICB9KTtcblxufVxuIiwiIyMjKlxuICogRm9ybWF0cyBudW1iZXJzIHRvIGxvb2sgXCJwcmV0dHlcIlxuICMjI1xuZDNwbHVzLnN0cmluZy50aXRsZSA9ICh0ZXh0LCBrZXksIHZhcnMpIC0+XG5cbiAgcmV0dXJuIFwiXCIgdW5sZXNzIHRleHRcblxuICBpZiBcImxvY2FsZVwiIG9mIHRoaXNcbiAgICBsb2NhbGUgPSBAbG9jYWxlLnZhbHVlXG4gICAgbG9jYWxlID0gKGlmIGxvY2FsZSBvZiBkM3BsdXMubG9jYWxlIHRoZW4gZDNwbHVzLmxvY2FsZVtsb2NhbGVdIGVsc2UgZDNwbHVzLmxvY2FsZS5lbl9VUykgaWYgdHlwZW9mIGxvY2FsZSBpcyBcInN0cmluZ1wiXG4gIGVsc2VcbiAgICBsb2NhbGUgPSBkM3BsdXMubG9jYWxlLmVuX1VTXG5cbiAgIyBJZiBpdCdzIGEgc2VudGVuY2UsIGp1c3QgY2FwaXRhbGl6ZSB0aGUgZmlyc3QgbGV0dGVyLlxuICByZXR1cm4gdGV4dC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleHQuc3Vic3RyKDEpICBpZiB0ZXh0LmNoYXJBdCh0ZXh0Lmxlbmd0aCAtIDEpIGlzIFwiLlwiXG5cbiAgc21hbGxzID0gbG9jYWxlLmxvd2VyY2FzZVxuICBiaWdzICAgPSBsb2NhbGUudXBwZXJjYXNlXG5cbiAgdGV4dC5yZXBsYWNlIC9cXFMqL2csICh0eHQsIGkpIC0+XG4gICAgaWYgYmlncy5pbmRleE9mKHR4dC50b0xvd2VyQ2FzZSgpKSA+PSAwXG4gICAgICByZXR1cm4gdHh0LnRvVXBwZXJDYXNlKClcbiAgICBlbHNlIHJldHVybiB0eHQudG9Mb3dlckNhc2UoKSBpZiBzbWFsbHMuaW5kZXhPZih0eHQudG9Mb3dlckNhc2UoKSkgPj0gMCBhbmQgaSBpc250IDAgYW5kIGkgaXNudCB0ZXh0Lmxlbmd0aCAtIDFcbiAgICB0eHQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0eHQuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKClcbiIsIi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBEM3BsdXMgRGVmYXVsdCBDb2xvciBTY2hlbWVcbi8vIENyZWF0ZWQgYnkgRGF2ZSBMYW5kcnlcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kM3BsdXMuc3R5bGUuZGVmYXVsdCA9IHt9XG5cbmQzcGx1cy5zdHlsZS5kZWZhdWx0LmZvbnRGYW1pbHkgPSBbIFwiSGVsdmV0aWNhIE5ldWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgXCJIZWx2ZXRpY2FOZXVlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIFwiSGVsdmV0aWNhXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIFwiQXJpYWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgXCJzYW5zLXNlcmlmXCIgXVxuIiwiZDNwbHVzLnN0eWxlLmRlZmF1bHQuYXhlcyA9IHtcbiAgXCJ0aWNrc1wiIDoge1xuICAgIFwiY29sb3JcIiA6IFwiI2NjY1wiLFxuICAgIFwiZm9udFwiICA6IHtcbiAgICAgIFwiY29sb3JcIiAgICAgIDogXCIjODg4XCIsXG4gICAgICBcImRlY29yYXRpb25cIiA6IHtcbiAgICAgICAgXCJhY2NlcHRlZFwiOiBbIFwibGluZS10aHJvdWdoXCIgLCBcIm5vbmVcIiAsIFwib3ZlcmxpbmVcIiAsIFwidW5kZXJsaW5lXCIgXSxcbiAgICAgICAgXCJ2YWx1ZVwiOiBcIm5vbmVcIlxuICAgICAgfSxcbiAgICAgIFwiZmFtaWx5XCIgICAgIDogZDNwbHVzLnN0eWxlLmZvbnRGYW1pbHkoZDNwbHVzLnN0eWxlLmRlZmF1bHQuZm9udEZhbWlseSksXG4gICAgICBcInNpemVcIiAgICAgICA6IDEwLFxuICAgICAgXCJ0cmFuc2Zvcm1cIiAgOiB7XG4gICAgICAgIFwiYWNjZXB0ZWRcIiA6IFsgXCJjYXBpdGFsaXplXCIgLCBcImxvd2VyY2FzZVwiICwgXCJub25lXCIgLCBcInVwcGVyY2FzZVwiIF0sXG4gICAgICAgIFwidmFsdWVcIiAgICA6IFwibm9uZVwiXG4gICAgICB9LFxuICAgICAgXCJ3ZWlnaHRcIiAgICAgOiAyMDBcbiAgICB9LFxuICAgIFwic2l6ZVwiICA6IDEwLFxuICAgIFwid2lkdGhcIiA6IDFcbiAgfVxufVxuIiwiZDNwbHVzLnN0eWxlLmRlZmF1bHQuYmFja2dyb3VuZCA9IHtcbiAgXCJhY2NlcHRlZFwiIDogWyBTdHJpbmcgXSxcbiAgXCJ2YWx1ZVwiICAgIDogXCIjZmZmZmZmXCJcbn1cbiIsImQzcGx1cy5zdHlsZS5kZWZhdWx0LmNvbG9yID0ge1xuICBcImhlYXRtYXBcIiAgIDogWyBcIiMyNzM2NmNcIiAsIFwiIzdiOTFkM1wiICwgXCIjOWVkM2UzXCJcbiAgICAgICAgICAgICAgICAsIFwiI2YzZDI2MVwiICwgXCIjYzk4NTNhXCIgLCBcIiNkNzRiMDNcIiBdLFxuICBcImZvY3VzXCIgICAgIDogXCIjNDQ0NDQ0XCIsXG4gIFwibWlzc2luZ1wiICAgOiBcIiNlZWVlZWVcIixcbiAgXCJwcmltYXJ5XCIgICA6IFwiI2Q3NGIwM1wiLFxuICBcInJhbmdlXCIgICAgIDogWyBcIiNkNzRiMDNcIiAsIFwiI2VlZWVlZVwiICwgXCIjOTRiMTUzXCIgXSxcbiAgXCJzY2FsZVwiICAgICA6IHtcbiAgICBcImFjY2VwdGVkXCI6IFsgQXJyYXksIFwiZDNwbHVzXCIsIFwiY2F0ZWdvcnkxMFwiLCBcImNhdGVnb3J5MjBcIiwgXCJjYXRlZ29yeTIwYlwiLCBcImNhdGVnb3J5MjBjXCIgXSxcbiAgICBcInByb2Nlc3NcIjogZnVuY3Rpb24odmFsdWUpIHtcblxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5yYW5nZSh2YWx1ZSlcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodmFsdWUgPT09IFwiZDNwbHVzXCIpIHtcbiAgICAgICAgICByZXR1cm4gZDNwbHVzLmNvbG9yLnNjYWxlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJIZXJlIVwiKVxuICAgICAgICAgIHJldHVybiBkMy5zY2FsZVt2YWx1ZV0oKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9LFxuICAgIFwidmFsdWVcIjogXCJkM3BsdXNcIlxuICB9LFxuICBcInNlY29uZGFyeVwiIDogXCIjZTViM2JiXCJcbn1cbiIsImQzcGx1cy5zdHlsZS5kZWZhdWx0LmNvb3JkcyA9IHtcbiAgXCJjZW50ZXJcIiAgICAgOiBbIDAgLCAwIF0sXG4gIFwiZml0XCIgICAgICAgIDoge1xuICAgIFwiYWNjZXB0ZWRcIiA6IFsgXCJhdXRvXCIgLCBcImhlaWdodFwiICwgXCJ3aWR0aFwiIF0sXG4gICAgXCJ2YWx1ZVwiICAgIDogXCJhdXRvXCJcbiAgfSxcbiAgXCJwYWRkaW5nXCIgICAgOiAyMCxcbiAgXCJwcm9qZWN0aW9uXCIgOiB7XG4gICAgXCJhY2NlcHRlZFwiIDogWyBcIm1lcmNhdG9yXCIgLCBcImVxdWlyZWN0YW5ndWxhclwiIF0sXG4gICAgXCJ2YWx1ZVwiICAgIDogXCJtZXJjYXRvclwiXG4gIH0sXG4gIFwidGhyZXNob2xkXCIgIDogMC4xXG59XG4iLCJkM3BsdXMuc3R5bGUuZGVmYXVsdC5kYXRhID0ge1xuICBcImRvbnV0XCIgICA6IHtcbiAgICBcInNpemVcIiA6IDAuMzVcbiAgfSxcbiAgXCJsYXJnZVwiICAgOiA0MDAsXG4gIFwib3BhY2l0eVwiIDogMC45LFxuICBcInN0cm9rZVwiICA6IHtcbiAgICBcIndpZHRoXCIgOiAxXG4gIH1cbn1cbiIsImQzcGx1cy5zdHlsZS5kZWZhdWx0LmVkZ2VzID0ge1xuICBcImFycm93c1wiICA6IHtcbiAgICBcImFjY2VwdGVkXCIgIDogWyBCb29sZWFuICwgTnVtYmVyIF0sXG4gICAgXCJkaXJlY3Rpb25cIiA6IHtcbiAgICAgIFwiYWNjZXB0ZWRcIiA6IFsgXCJzb3VyY2VcIiAsIFwidGFyZ2V0XCIgXSxcbiAgICAgIFwidmFsdWVcIiAgICA6IFwidGFyZ2V0XCJcbiAgICB9LFxuICAgIFwidmFsdWVcIiAgICAgOiBmYWxzZVxuICB9LFxuICBcImNvbG9yXCIgICA6IFwiI2QwZDBkMFwiLFxuICBcImxhcmdlXCIgICAgICAgOiAxMDAsXG4gIFwibGltaXRcIiAgICAgICA6IGZhbHNlLFxuICBcIm9wYWNpdHlcIiA6IDEsXG4gIFwid2lkdGhcIiAgIDogMVxufVxuIiwiZDNwbHVzLnN0eWxlLmRlZmF1bHQuZm9udCA9IHtcbiAgXCJhbGlnblwiICAgICAgOiB7XG4gICAgXCJhY2NlcHRlZFwiIDogWyBcImxlZnRcIiAsIFwiY2VudGVyXCIgLCBcInJpZ2h0XCIgXSxcbiAgICBcInByb2Nlc3NcIiAgOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgICByZXR1cm4gZDNwbHVzLnJ0bCA/IHZhbHVlID09PSBcImxlZnRcIiA/IFwicmlnaHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZSA9PT0gXCJyaWdodFwiID8gXCJsZWZ0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWUgOiB2YWx1ZVxuXG4gICAgfSxcbiAgICBcInZhbHVlXCIgICAgOiBcImxlZnRcIlxuICB9LFxuICBcImNvbG9yXCIgICAgICA6IFwiIzQ0NDQ0NFwiLFxuICBcImRlY29yYXRpb25cIiA6IHtcbiAgICBcImFjY2VwdGVkXCIgOiBbIFwibGluZS10aHJvdWdoXCIgLCBcIm5vbmVcIiAsIFwib3ZlcmxpbmVcIiAsIFwidW5kZXJsaW5lXCIgXSxcbiAgICBcInZhbHVlXCIgICAgOiBcIm5vbmVcIlxuICB9LFxuICBcImZhbWlseVwiICAgICA6IGQzcGx1cy5zdHlsZS5mb250RmFtaWx5KGQzcGx1cy5zdHlsZS5kZWZhdWx0LmZvbnRGYW1pbHkpLFxuICBcInNlY29uZGFyeVwiICA6IHtcbiAgICBcImFsaWduXCIgICAgICA6IHtcbiAgICAgIFwiYWNjZXB0ZWRcIiA6IFsgXCJsZWZ0XCIgLCBcImNlbnRlclwiICwgXCJyaWdodFwiIF0sXG4gICAgICBcInByb2Nlc3NcIiAgOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgICAgIHJldHVybiBkM3BsdXMucnRsID8gdmFsdWUgPT09IFwibGVmdFwiID8gXCJyaWdodFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWUgPT09IFwicmlnaHRcIiA/IFwibGVmdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWUgOiB2YWx1ZVxuXG4gICAgICB9LFxuICAgICAgXCJ2YWx1ZVwiICAgIDogXCJsZWZ0XCJcbiAgICB9LFxuICAgIFwiY29sb3JcIiAgICAgIDogXCIjNDQ0NDQ0XCIsXG4gICAgXCJkZWNvcmF0aW9uXCIgOiB7XG4gICAgICBcImFjY2VwdGVkXCIgOiBbIFwibGluZS10aHJvdWdoXCIgLCBcIm5vbmVcIiAsIFwib3ZlcmxpbmVcIiAsIFwidW5kZXJsaW5lXCIgXSxcbiAgICAgIFwidmFsdWVcIiAgICA6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcImZhbWlseVwiICAgICA6IGQzcGx1cy5zdHlsZS5mb250RmFtaWx5KGQzcGx1cy5zdHlsZS5kZWZhdWx0LmZvbnRGYW1pbHkpLFxuICAgIFwic2l6ZVwiICAgICAgIDogMTIsXG4gICAgXCJzcGFjaW5nXCIgICAgOiAwLFxuICAgIFwidHJhbnNmb3JtXCIgIDoge1xuICAgICAgXCJhY2NlcHRlZFwiIDogWyBcImNhcGl0YWxpemVcIiAsIFwibG93ZXJjYXNlXCIgLCBcIm5vbmVcIiAsIFwidXBwZXJjYXNlXCIgXSxcbiAgICAgIFwidmFsdWVcIiAgICA6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcIndlaWdodFwiICAgICA6IDIwMFxuICB9LFxuICBcInNpemVcIiAgICAgICA6IDEyLFxuICBcInNwYWNpbmdcIiAgICA6IDAsXG4gIFwidHJhbnNmb3JtXCIgIDoge1xuICAgIFwiYWNjZXB0ZWRcIiA6IFsgXCJjYXBpdGFsaXplXCIgLCBcImxvd2VyY2FzZVwiICwgXCJub25lXCIgLCBcInVwcGVyY2FzZVwiIF0sXG4gICAgXCJ2YWx1ZVwiICAgIDogXCJub25lXCJcbiAgfSxcbiAgXCJ3ZWlnaHRcIiAgICAgOiAyMDBcbn1cbiIsImQzcGx1cy5zdHlsZS5kZWZhdWx0LmZvb3RlciA9IHtcbiAgXCJmb250XCIgICAgIDoge1xuICAgIFwiYWxpZ25cIiAgICAgIDogXCJjZW50ZXJcIixcbiAgICBcImNvbG9yXCIgICAgICA6IFwiIzQ0NFwiLFxuICAgIFwiZGVjb3JhdGlvblwiIDoge1xuICAgICAgXCJhY2NlcHRlZFwiIDogWyBcImxpbmUtdGhyb3VnaFwiICwgXCJub25lXCIgLCBcIm92ZXJsaW5lXCIgLCBcInVuZGVybGluZVwiIF0sXG4gICAgICBcInZhbHVlXCIgICAgOiBcIm5vbmVcIlxuICAgIH0sXG4gICAgXCJmYW1pbHlcIiAgICAgOiBkM3BsdXMuc3R5bGUuZm9udEZhbWlseShkM3BsdXMuc3R5bGUuZGVmYXVsdC5mb250RmFtaWx5KSxcbiAgICBcInNpemVcIiAgICAgICA6IDExLFxuICAgIFwidHJhbnNmb3JtXCIgIDoge1xuICAgICAgXCJhY2NlcHRlZFwiIDogWyBcImNhcGl0YWxpemVcIiAsIFwibG93ZXJjYXNlXCIgLCBcIm5vbmVcIiAsIFwidXBwZXJjYXNlXCIgXSxcbiAgICAgIFwidmFsdWVcIiAgICA6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcIndlaWdodFwiICAgICA6IDIwMFxuICB9LFxuICBcInBhZGRpbmdcIiAgOiAwLFxuICBcInBvc2l0aW9uXCIgOiBcImJvdHRvbVwiXG59XG4iLCJkM3BsdXMuc3R5bGUuZGVmYXVsdC5oZWlnaHQgPSB7XG4gIFwic21hbGxcIiA6IDMwMCxcbiAgXCJtYXhcIiAgIDogNjAwXG59XG4iLCJkM3BsdXMuc3R5bGUuZGVmYXVsdC5pY29uID0ge1xuICBcImJhY2tcIiAgIDoge1xuICAgIFwiYWNjZXB0ZWRcIiA6IFsgZmFsc2UgLCBTdHJpbmcgXSxcbiAgICBcImZhbGxiYWNrXCIgOiBcIiYjeDI3NmU7XCIsXG4gICAgXCJvcGFjaXR5XCIgIDogMSxcbiAgICBcInByb2Nlc3NcIiAgOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgICB2YXIgZmFsbGJhY2sgPSB0aGlzLmZhbGxiYWNrXG4gICAgICByZXR1cm4gZDNwbHVzLnN0eWxlLmRlZmF1bHQuaWNvbi5mb250Q2hlY2soIHZhbHVlICwgZmFsbGJhY2sgKVxuXG4gICAgfSxcbiAgICBcInJvdGF0ZVwiICAgOiAwLFxuICAgIFwidmFsdWVcIiAgICA6IFwiZmEtYW5nbGUtbGVmdFwiXG4gIH0sXG4gIFwiYnV0dG9uXCIgOiB7XG4gICAgXCJhY2NlcHRlZFwiIDogWyBmYWxzZSAsIFN0cmluZyBdLFxuICAgIFwiZmFsbGJhY2tcIiA6IGZhbHNlLFxuICAgIFwib3BhY2l0eVwiICA6IDEsXG4gICAgXCJwcm9jZXNzXCIgIDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgICAgdmFyIGZhbGxiYWNrID0gdGhpcy5mYWxsYmFja1xuICAgICAgcmV0dXJuIGQzcGx1cy5zdHlsZS5kZWZhdWx0Lmljb24uZm9udENoZWNrKCB2YWx1ZSAsIGZhbGxiYWNrIClcblxuICAgIH0sXG4gICAgXCJyb3RhdGVcIiAgIDogMCxcbiAgICBcInZhbHVlXCIgICAgOiBmYWxzZVxuICB9LFxuICBcImRyb3BcIiAgIDoge1xuICAgIFwiYWNjZXB0ZWRcIiA6IFsgZmFsc2UgLCBTdHJpbmcgXSxcbiAgICBcImZhbGxiYWNrXCIgOiBcIiYjeDI3NmY7XCIsXG4gICAgXCJvcGFjaXR5XCIgIDogMSxcbiAgICBcInByb2Nlc3NcIiAgOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgICB2YXIgZmFsbGJhY2sgPSB0aGlzLmZhbGxiYWNrXG4gICAgICByZXR1cm4gZDNwbHVzLnN0eWxlLmRlZmF1bHQuaWNvbi5mb250Q2hlY2soIHZhbHVlICwgZmFsbGJhY2sgKVxuXG4gICAgfSxcbiAgICBcInJvdGF0ZVwiICAgOiAwLFxuICAgIFwidmFsdWVcIiAgICA6IFwiZmEtYW5nbGUtZG93blwiXG4gIH0sXG4gIFwiZm9udENoZWNrXCI6IGZ1bmN0aW9uICggdmFsdWUgLCBmYWxsYmFjayApIHtcblxuICAgIGlmICggdmFsdWUgPT09IGZhbHNlXG4gICAgICAgICB8fCAoIHZhbHVlLmluZGV4T2YoXCJmYS1cIikgPT09IDAgJiYgZDNwbHVzLmZvbnQuYXdlc29tZSApXG4gICAgICAgICB8fCB2YWx1ZS5pbmRleE9mKFwiZmEtXCIpIDwgMCApIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxsYmFja1xuICAgIH1cblxuICB9LFxuICBcIm5leHRcIiAgIDoge1xuICAgIFwiYWNjZXB0ZWRcIiA6IFsgZmFsc2UgLCBTdHJpbmcgXSxcbiAgICBcImZhbGxiYWNrXCIgOiBcIiYjeDI3NmY7XCIsXG4gICAgXCJvcGFjaXR5XCIgIDogMSxcbiAgICBcInByb2Nlc3NcIiAgOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgICB2YXIgZmFsbGJhY2sgPSB0aGlzLmZhbGxiYWNrXG4gICAgICByZXR1cm4gZDNwbHVzLnN0eWxlLmRlZmF1bHQuaWNvbi5mb250Q2hlY2soIHZhbHVlICwgZmFsbGJhY2sgKVxuXG4gICAgfSxcbiAgICBcInJvdGF0ZVwiICAgOiAwLFxuICAgIFwidmFsdWVcIiAgICA6IFwiZmEtYW5nbGUtcmlnaHRcIlxuICB9LFxuICBcInNlbGVjdFwiIDoge1xuICAgIFwiYWNjZXB0ZWRcIiA6IFsgZmFsc2UgLCBTdHJpbmcgXSxcbiAgICBcImZhbGxiYWNrXCIgOiBcIiYjeDI3MTM7XCIsXG4gICAgXCJvcGFjaXR5XCIgIDogMSxcbiAgICBcInByb2Nlc3NcIiAgOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgICB2YXIgZmFsbGJhY2sgPSB0aGlzLmZhbGxiYWNrXG4gICAgICByZXR1cm4gZDNwbHVzLnN0eWxlLmRlZmF1bHQuaWNvbi5mb250Q2hlY2soIHZhbHVlICwgZmFsbGJhY2sgKVxuXG4gICAgfSxcbiAgICBcInJvdGF0ZVwiICAgOiAwLFxuICAgIFwidmFsdWVcIiAgICA6IFwiZmEtY2hlY2tcIlxuICB9XG59XG4iLCJkM3BsdXMuc3R5bGUuZGVmYXVsdC5sYWJlbHMgPSB7XG4gIFwiYWxpZ25cIiAgICA6IFwibWlkZGxlXCIsXG4gIFwiZm9udFwiICAgICA6IHtcbiAgICBcImRlY29yYXRpb25cIiA6IHtcbiAgICAgIFwiYWNjZXB0ZWRcIiA6IFsgXCJsaW5lLXRocm91Z2hcIiAsIFwibm9uZVwiICwgXCJvdmVybGluZVwiICwgXCJ1bmRlcmxpbmVcIiBdLFxuICAgICAgXCJ2YWx1ZVwiICAgIDogXCJub25lXCJcbiAgICB9LFxuICAgIFwiZmFtaWx5XCIgICAgIDogZDNwbHVzLnN0eWxlLmZvbnRGYW1pbHkoZDNwbHVzLnN0eWxlLmRlZmF1bHQuZm9udEZhbWlseSksXG4gICAgXCJzaXplXCIgICAgICAgOiAxMSxcbiAgICBcInRyYW5zZm9ybVwiICA6IHtcbiAgICAgIFwiYWNjZXB0ZWRcIiA6IFsgXCJjYXBpdGFsaXplXCIgLCBcImxvd2VyY2FzZVwiICwgXCJub25lXCIgLCBcInVwcGVyY2FzZVwiIF0sXG4gICAgICBcInZhbHVlXCIgICAgOiBcIm5vbmVcIlxuICAgIH0sXG4gICAgXCJ3ZWlnaHRcIiAgICAgOiAyMDBcbiAgfSxcbiAgXCJwYWRkaW5nXCIgIDogNyxcbiAgXCJzZWdtZW50c1wiIDogMlxufVxuIiwiZDNwbHVzLnN0eWxlLmRlZmF1bHQubGVnZW5kID0ge1xuICBcImFsaWduXCIgICAgOiBcIm1pZGRsZVwiLFxuICBcImZvbnRcIiAgICAgOiB7XG4gICAgXCJhbGlnblwiICA6IFwibWlkZGxlXCIsXG4gICAgXCJjb2xvclwiICA6IFwiIzQ0NDQ0NFwiLFxuICAgIFwiZmFtaWx5XCIgOiBkM3BsdXMuc3R5bGUuZm9udEZhbWlseShkM3BsdXMuc3R5bGUuZGVmYXVsdC5mb250RmFtaWx5KSxcbiAgICBcInNpemVcIiAgIDogMTAsXG4gICAgXCJ3ZWlnaHRcIiA6IDIwMFxuICB9LFxuICBcImdyYWRpZW50XCIgOiB7XG4gICAgXCJoZWlnaHRcIiA6IDEwXG4gIH0sXG4gIFwib3JkZXJcIiAgICA6IHtcbiAgICBcImFjY2VwdGVkXCIgOiBbIFwiY29sb3JcIiAsIFwiaWRcIiAsIFwic2l6ZVwiICwgXCJ0ZXh0XCIgXSxcbiAgICBcInNvcnRcIiAgICAgOiB7XG4gICAgICBcImFjY2VwdGVkXCIgOiBbIFwiYXNjXCIgLCBcImRlc2NcIiBdLFxuICAgICAgXCJ2YWx1ZVwiICAgIDogXCJhc2NcIlxuICAgIH0sXG4gICAgXCJ2YWx1ZVwiICAgIDogXCJjb2xvclwiXG4gIH0sXG4gIFwic2l6ZVwiICAgICA6IFsgOCAsIDMwIF1cbn1cbiIsImQzcGx1cy5zdHlsZS5kZWZhdWx0LmxpbmtzID0ge1xuICBcImZvbnRcIiAgOiB7XG4gICAgXCJjb2xvclwiICAgICAgOiBcIiM0NDQ0NDRcIixcbiAgICBcImRlY29yYXRpb25cIiA6IHtcbiAgICAgIFwiYWNjZXB0ZWRcIiA6IFsgXCJsaW5lLXRocm91Z2hcIiAsIFwibm9uZVwiICwgXCJvdmVybGluZVwiICwgXCJ1bmRlcmxpbmVcIiBdLFxuICAgICAgXCJ2YWx1ZVwiICAgIDogXCJub25lXCJcbiAgICB9LFxuICAgIFwiZmFtaWx5XCIgICAgIDogZDNwbHVzLnN0eWxlLmZvbnRGYW1pbHkoZDNwbHVzLnN0eWxlLmRlZmF1bHQuZm9udEZhbWlseSksXG4gICAgXCJ0cmFuc2Zvcm1cIiAgOiB7XG4gICAgICBcImFjY2VwdGVkXCIgOiBbIFwiY2FwaXRhbGl6ZVwiICwgXCJsb3dlcmNhc2VcIiAsIFwibm9uZVwiICwgXCJ1cHBlcmNhc2VcIiBdLFxuICAgICAgXCJ2YWx1ZVwiICAgIDogXCJub25lXCJcbiAgICB9LFxuICAgIFwid2VpZ2h0XCIgICAgIDogMjAwXG4gIH0sXG4gIFwiaG92ZXJcIiA6IHtcbiAgICBcImNvbG9yXCIgICAgICA6IFwiIzQ0NDQ0NFwiLFxuICAgIFwiZGVjb3JhdGlvblwiIDoge1xuICAgICAgXCJhY2NlcHRlZFwiIDogWyBcImxpbmUtdGhyb3VnaFwiICwgXCJub25lXCIgLCBcIm92ZXJsaW5lXCIgLCBcInVuZGVybGluZVwiIF0sXG4gICAgICBcInZhbHVlXCIgICAgOiBcInVuZGVybGluZVwiXG4gICAgfSxcbiAgICBcImZhbWlseVwiICAgICA6IGQzcGx1cy5zdHlsZS5mb250RmFtaWx5KGQzcGx1cy5zdHlsZS5kZWZhdWx0LmZvbnRGYW1pbHkpLFxuICAgIFwidHJhbnNmb3JtXCIgIDoge1xuICAgICAgXCJhY2NlcHRlZFwiIDogWyBcImNhcGl0YWxpemVcIiAsIFwibG93ZXJjYXNlXCIgLCBcIm5vbmVcIiAsIFwidXBwZXJjYXNlXCIgXSxcbiAgICAgIFwidmFsdWVcIiAgICA6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcIndlaWdodFwiICAgICA6IDIwMFxuICB9XG59XG4iLCJkM3BsdXMuc3R5bGUuZGVmYXVsdC5tZXNzYWdlcyA9IHtcbiAgXCJmb250XCIgOiB7XG4gICAgXCJjb2xvclwiICAgICAgOiBcIiM0NDRcIixcbiAgICBcImRlY29yYXRpb25cIiA6IHtcbiAgICAgIFwiYWNjZXB0ZWRcIiA6IFsgXCJsaW5lLXRocm91Z2hcIiAsIFwibm9uZVwiICwgXCJvdmVybGluZVwiICwgXCJ1bmRlcmxpbmVcIiBdLFxuICAgICAgXCJ2YWx1ZVwiICAgIDogXCJub25lXCJcbiAgICB9LFxuICAgIFwiZmFtaWx5XCIgICAgIDogZDNwbHVzLnN0eWxlLmZvbnRGYW1pbHkoZDNwbHVzLnN0eWxlLmRlZmF1bHQuZm9udEZhbWlseSksXG4gICAgXCJzaXplXCIgICAgICAgOiAxNixcbiAgICBcInRyYW5zZm9ybVwiICA6IHtcbiAgICAgIFwiYWNjZXB0ZWRcIiA6IFsgXCJjYXBpdGFsaXplXCIgLCBcImxvd2VyY2FzZVwiICwgXCJub25lXCIgLCBcInVwcGVyY2FzZVwiIF0sXG4gICAgICBcInZhbHVlXCIgICAgOiBcIm5vbmVcIlxuICAgIH0sXG4gICAgXCJ3ZWlnaHRcIiAgICAgOiAyMDBcbiAgfSxcbiAgXCJwYWRkaW5nXCI6IDVcbn1cbiIsImQzcGx1cy5zdHlsZS5kZWZhdWx0Lm5vZGVzID0ge1xuICBcIm92ZXJsYXBcIiA6IDAuNlxufVxuIiwiZDNwbHVzLnN0eWxlLmRlZmF1bHQuc2hhcGUgPSB7XG4gIFwiaW50ZXJwb2xhdGVcIiA6IHtcbiAgICBcImFjY2VwdGVkXCIgICA6IFsgXCJiYXNpc1wiICwgXCJiYXNpcy1vcGVuXCIgLCBcImNhcmRpbmFsXCJcbiAgICAgICAgICAgICAgICAgICAsIFwiY2FyZGluYWwtb3BlblwiICwgXCJsaW5lYXJcIiAsIFwibW9ub3RvbmVcIlxuICAgICAgICAgICAgICAgICAgICwgXCJzdGVwXCIgLCBcInN0ZXAtYmVmb3JlXCIgLCBcInN0ZXAtYWZ0ZXJcIiBdLFxuICAgIFwiZGVwcmVjYXRlc1wiIDogXCJzdGFja190eXBlXCIsXG4gICAgXCJ2YWx1ZVwiICAgICAgOiBcImxpbmVhclwiXG4gIH0sXG4gIFwicmVuZGVyaW5nXCIgICA6IHtcbiAgICBcImFjY2VwdGVkXCIgOiBbIFwiYXV0b1wiICwgXCJvcHRpbWl6ZVNwZWVkXCIgLCBcImNyaXNwRWRnZXNcIiAsIFwiZ2VvbWV0cmljUHJlY2lzaW9uXCIgXSxcbiAgICBcInZhbHVlXCIgICAgOiBcImF1dG9cIlxuICB9XG59XG4iLCJkM3BsdXMuc3R5bGUuZGVmYXVsdC50aW1lbGluZSA9IHtcbiAgXCJhbGlnblwiICAgICAgOiBcIm1pZGRsZVwiLFxuICBcImhvdmVyXCI6IHtcbiAgICBcImFjY2VwdGVkXCI6IFsgXCJhbGwtc2Nyb2xsXCIsIFwiY29sLXJlc2l6ZVwiLCBcImNyb3NzaGFpclwiLCBcImRlZmF1bHRcIiwgXCJncmFiXCIsIFwiZ3JhYmJpbmdcIiwgXCJtb3ZlXCIsIFwicG9pbnRlclwiIF0sXG4gICAgXCJ2YWx1ZVwiOiBcInBvaW50ZXJcIlxuICB9LFxuICBcImhhbmRsZXNcIiAgICA6IHtcbiAgICBcImFjY2VwdGVkXCIgOiBbIEJvb2xlYW4gXSxcbiAgICBcImNvbG9yXCIgICAgOiBcIiNlNWU1ZTVcIixcbiAgICBcImhvdmVyXCIgICAgOiBcIiNjY2NjY2NcIixcbiAgICBcIm9wYWNpdHlcIiAgOiAxLFxuICAgIFwic2l6ZVwiICAgICA6IDIsXG4gICAgXCJzdHJva2VcIiAgIDogXCIjODE4MTgxXCIsXG4gICAgXCJ2YWx1ZVwiICAgIDogdHJ1ZVxuICB9LFxuICBcImhlaWdodFwiICAgIDoge1xuICAgIFwiYWNjZXB0ZWRcIjogWyBOdW1iZXIgXSxcbiAgICBcInZhbHVlXCI6IDIzXG4gIH0sXG4gIFwidGlja1wiICAgICAgOiBcIiM4MTgxODFcIlxufVxuIiwiZDNwbHVzLnN0eWxlLmRlZmF1bHQudGltaW5nID0ge1xuICBcIm1vdXNlZXZlbnRzXCIgOiA2MCxcbiAgXCJ0cmFuc2l0aW9uc1wiIDogNjAwLFxuICBcInVpXCIgICAgICAgICAgOiAyMDBcbn1cbiIsImQzcGx1cy5zdHlsZS5kZWZhdWx0LnRpdGxlID0ge1xuICBcImZvbnRcIiAgICAgOiB7XG4gICAgXCJhbGlnblwiICAgICAgOiBcImNlbnRlclwiLFxuICAgIFwiY29sb3JcIiAgICAgIDogXCIjNDQ0NDQ0XCIsXG4gICAgXCJkZWNvcmF0aW9uXCIgOiB7XG4gICAgICBcImFjY2VwdGVkXCIgOiBbIFwibGluZS10aHJvdWdoXCIgLCBcIm5vbmVcIiAsIFwib3ZlcmxpbmVcIiAsIFwidW5kZXJsaW5lXCIgXSxcbiAgICAgIFwidmFsdWVcIiAgICA6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcImZhbWlseVwiICAgICA6IGQzcGx1cy5zdHlsZS5mb250RmFtaWx5KGQzcGx1cy5zdHlsZS5kZWZhdWx0LmZvbnRGYW1pbHkpLFxuICAgIFwic2l6ZVwiICAgICAgIDogMTYsXG4gICAgXCJ0cmFuc2Zvcm1cIiAgOiB7XG4gICAgICBcImFjY2VwdGVkXCIgOiBbIFwiY2FwaXRhbGl6ZVwiICwgXCJsb3dlcmNhc2VcIiAsIFwibm9uZVwiICwgXCJ1cHBlcmNhc2VcIiBdLFxuICAgICAgXCJ2YWx1ZVwiICAgIDogXCJub25lXCJcbiAgICB9LFxuICAgIFwid2VpZ2h0XCIgICAgIDogNDAwXG4gIH0sXG4gIFwiaGVpZ2h0XCIgICA6IGZhbHNlLFxuICBcInBhZGRpbmdcIiAgOiAyLFxuICBcInBvc2l0aW9uXCIgOiBcInRvcFwiLFxuICBcInN1YlwiICAgICAgOiB7XG4gICAgXCJmb250XCIgICAgIDoge1xuICAgICAgXCJhbGlnblwiICAgICAgOiBcImNlbnRlclwiLFxuICAgICAgXCJjb2xvclwiICAgICAgOiBcIiM0NDQ0NDRcIixcbiAgICAgIFwiZGVjb3JhdGlvblwiIDoge1xuICAgICAgICBcImFjY2VwdGVkXCIgOiBbIFwibGluZS10aHJvdWdoXCIgLCBcIm5vbmVcIiAsIFwib3ZlcmxpbmVcIiAsIFwidW5kZXJsaW5lXCIgXSxcbiAgICAgICAgXCJ2YWx1ZVwiICAgIDogXCJub25lXCJcbiAgICAgIH0sXG4gICAgICBcImZhbWlseVwiICAgICA6IGQzcGx1cy5zdHlsZS5mb250RmFtaWx5KGQzcGx1cy5zdHlsZS5kZWZhdWx0LmZvbnRGYW1pbHkpLFxuICAgICAgXCJzaXplXCIgICAgICAgOiAxMixcbiAgICAgIFwidHJhbnNmb3JtXCIgIDoge1xuICAgICAgICBcImFjY2VwdGVkXCIgOiBbIFwiY2FwaXRhbGl6ZVwiICwgXCJsb3dlcmNhc2VcIiAsIFwibm9uZVwiICwgXCJ1cHBlcmNhc2VcIiBdLFxuICAgICAgICBcInZhbHVlXCIgICAgOiBcIm5vbmVcIlxuICAgICAgfSxcbiAgICAgIFwid2VpZ2h0XCIgICAgIDogMjAwXG4gICAgfSxcbiAgICBcInBhZGRpbmdcIiAgOiAxLFxuICAgIFwicG9zaXRpb25cIiA6IFwidG9wXCJcbiAgfSxcbiAgXCJ0b3RhbFwiICAgIDoge1xuICAgIFwiZm9udFwiICAgICA6IHtcbiAgICAgIFwiYWxpZ25cIiAgICAgIDogXCJjZW50ZXJcIixcbiAgICAgIFwiY29sb3JcIiAgICAgIDogXCIjNDQ0NDQ0XCIsXG4gICAgICBcImRlY29yYXRpb25cIiA6IHtcbiAgICAgICAgXCJhY2NlcHRlZFwiIDogWyBcImxpbmUtdGhyb3VnaFwiICwgXCJub25lXCIgLCBcIm92ZXJsaW5lXCIgLCBcInVuZGVybGluZVwiIF0sXG4gICAgICAgIFwidmFsdWVcIiAgICA6IFwibm9uZVwiXG4gICAgICB9LFxuICAgICAgXCJmYW1pbHlcIiAgICAgOiBkM3BsdXMuc3R5bGUuZm9udEZhbWlseShkM3BsdXMuc3R5bGUuZGVmYXVsdC5mb250RmFtaWx5KSxcbiAgICAgIFwic2l6ZVwiICAgICAgIDogMTIsXG4gICAgICBcInRyYW5zZm9ybVwiICA6IHtcbiAgICAgICAgXCJhY2NlcHRlZFwiIDogWyBcImNhcGl0YWxpemVcIiAsIFwibG93ZXJjYXNlXCIgLCBcIm5vbmVcIiAsIFwidXBwZXJjYXNlXCIgXSxcbiAgICAgICAgXCJ2YWx1ZVwiICAgIDogXCJub25lXCJcbiAgICAgIH0sXG4gICAgICBcIndlaWdodFwiICAgICA6IDIwMFxuICAgIH0sXG4gICAgXCJwYWRkaW5nXCIgIDogMSxcbiAgICBcInBvc2l0aW9uXCIgOiBcInRvcFwiXG4gIH0sXG4gIFwid2lkdGhcIiAgICA6IGZhbHNlXG59XG4iLCJkM3BsdXMuc3R5bGUuZGVmYXVsdC50b29sdGlwID0ge1xuICBcImFuY2hvclwiICAgICAgOiBcInRvcCBjZW50ZXJcIixcbiAgXCJiYWNrZ3JvdW5kXCIgIDogXCIjZmZmZmZmXCIsXG4gIFwiY2hpbGRyZW5cIiAgICA6IHtcbiAgICBcImFjY2VwdGVkXCIgOiBbIEJvb2xlYW4gXSxcbiAgICBcInZhbHVlXCIgICAgOiB0cnVlXG4gIH0sXG4gIFwiY29ubmVjdGlvbnNcIiA6IHtcbiAgICBcImFjY2VwdGVkXCIgOiBbIEJvb2xlYW4gXSxcbiAgICBcInZhbHVlXCIgICAgOiB0cnVlXG4gIH0sXG4gIFwiY3VydGFpblwiICAgICA6IHtcbiAgICBcImNvbG9yXCIgICA6IFwiI2ZmZmZmZlwiLFxuICAgIFwib3BhY2l0eVwiIDogMC44XG4gIH0sXG4gIFwiZm9udFwiICAgICAgICA6IHtcbiAgICBcImNvbG9yXCIgICAgIDogXCIjNDQ0XCIsXG4gICAgXCJmYW1pbHlcIiAgICA6IGQzcGx1cy5zdHlsZS5mb250RmFtaWx5KGQzcGx1cy5zdHlsZS5kZWZhdWx0LmZvbnRGYW1pbHkpLFxuICAgIFwic2l6ZVwiICAgICAgOiAxMixcbiAgICBcInRyYW5zZm9ybVwiIDoge1xuICAgICAgXCJhY2NlcHRlZFwiIDogWyBcImNhcGl0YWxpemVcIiAsIFwibG93ZXJjYXNlXCIgLCBcIm5vbmVcIiAsIFwidXBwZXJjYXNlXCIgXSxcbiAgICAgIFwidmFsdWVcIiAgICA6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcIndlaWdodFwiICAgIDogMjAwXG4gIH0sXG4gIFwibGFyZ2VcIiAgICAgICA6IDI1MCxcbiAgXCJzaGFyZVwiICAgICAgIDoge1xuICAgIFwiYWNjZXB0ZWRcIiA6IFsgQm9vbGVhbiBdLFxuICAgIFwidmFsdWVcIiAgICA6IHRydWVcbiAgfSxcbiAgXCJzaXplXCIgICAgICAgIDoge1xuICAgIFwiYWNjZXB0ZWRcIiA6IFsgQm9vbGVhbiBdLFxuICAgIFwidmFsdWVcIiAgICA6IHRydWVcbiAgfSxcbiAgXCJzbWFsbFwiICAgICAgOiAyMjVcbn1cbiIsImQzcGx1cy5zdHlsZS5kZWZhdWx0LnVpID0ge1xuICBcImFsaWduXCIgICAgOiB7XG4gICAgXCJhY2NlcHRlZFwiIDogWyBcImxlZnRcIiAsIFwiY2VudGVyXCIgLCBcInJpZ2h0XCIgXSxcbiAgICBcInByb2Nlc3NcIiAgOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgICByZXR1cm4gZDNwbHVzLnJ0bCA/IHZhbHVlID09PSBcImxlZnRcIiA/IFwicmlnaHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZSA9PT0gXCJyaWdodFwiID8gXCJsZWZ0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWUgOiB2YWx1ZVxuXG4gICAgfSxcbiAgICBcInZhbHVlXCIgICAgOiBcImNlbnRlclwiXG4gIH0sXG4gIFwiYm9yZGVyXCIgICA6IDEsXG4gIFwiY29sb3JcIiAgICA6IHtcbiAgICBcInByaW1hcnlcIiAgIDoge1xuICAgICAgXCJwcm9jZXNzXCIgOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgICAgIHZhciB2YXJzID0gdGhpcy5nZXRWYXJzKClcbiAgICAgICAgICAsIHByaW1hcnkgPSB0aGlzLnZhbHVlXG4gICAgICAgICAgLCBzZWNvbmRhcnkgPSB2YXJzLnVpLmNvbG9yLnNlY29uZGFyeS52YWx1ZVxuXG4gICAgICAgIGlmICggIXNlY29uZGFyeSB8fCBzZWNvbmRhcnkgPT09IGQzLnJnYihwcmltYXJ5KS5kYXJrZXIoMikudG9TdHJpbmcoKSApIHtcbiAgICAgICAgICB2YXJzLnVpLmNvbG9yLnNlY29uZGFyeS52YWx1ZSA9IGQzLnJnYih2YWx1ZSkuZGFya2VyKDIpLnRvU3RyaW5nKClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuXG4gICAgICB9LFxuICAgICAgXCJ2YWx1ZVwiICAgOiBcIiNmZmZmZmZcIlxuICAgIH0sXG4gICAgXCJzZWNvbmRhcnlcIiA6IHtcbiAgICAgIFwidmFsdWVcIiA6IGZhbHNlXG4gICAgfVxuICB9LFxuICBcImRpc3BsYXlcIiAgOiB7XG4gICAgXCJhY2NlcGVkXCIgOiBbIFwiYmxvY2tcIiAsIFwiaW5saW5lLWJsb2NrXCIgXSxcbiAgICBcInZhbHVlXCIgICA6IFwiaW5saW5lLWJsb2NrXCJcbiAgfSxcbiAgXCJmb250XCIgICAgIDoge1xuICAgIFwiYWxpZ25cIiAgICAgIDogXCJjZW50ZXJcIixcbiAgICBcImNvbG9yXCIgICAgICA6IFwiIzQ0NFwiLFxuICAgIFwiZGVjb3JhdGlvblwiIDoge1xuICAgICAgXCJhY2NlcHRlZFwiIDogWyBcImxpbmUtdGhyb3VnaFwiICwgXCJub25lXCIgLCBcIm92ZXJsaW5lXCIgLCBcInVuZGVybGluZVwiIF0sXG4gICAgICBcInZhbHVlXCIgICAgOiBcIm5vbmVcIlxuICAgIH0sXG4gICAgXCJmYW1pbHlcIiAgICAgOiBkM3BsdXMuc3R5bGUuZm9udEZhbWlseShkM3BsdXMuc3R5bGUuZGVmYXVsdC5mb250RmFtaWx5KSxcbiAgICBcInNpemVcIjogMTEsXG4gICAgXCJ0cmFuc2Zvcm1cIiAgOiB7XG4gICAgICBcImFjY2VwdGVkXCIgOiBbIFwiY2FwaXRhbGl6ZVwiICwgXCJsb3dlcmNhc2VcIiAsIFwibm9uZVwiICwgXCJ1cHBlcmNhc2VcIiBdLFxuICAgICAgXCJ2YWx1ZVwiICAgIDogXCJub25lXCJcbiAgICB9LFxuICAgIFwid2VpZ2h0XCIgICAgIDogMjAwXG4gIH0sXG4gIFwibWFyZ2luXCIgICA6IDUsXG4gIFwicGFkZGluZ1wiICA6IDUsXG4gIFwicG9zaXRpb25cIiA6IHtcbiAgICBcImFjY2VwdGVkXCIgOiBbIFwidG9wXCIgLCBcInJpZ2h0XCIgLCBcImJvdHRvbVwiICwgXCJsZWZ0XCIgXSxcbiAgICBcInZhbHVlXCIgICAgOiBcImJvdHRvbVwiXG4gIH1cbn1cbiIsImQzcGx1cy5zdHlsZS5kZWZhdWx0LndpZHRoID0ge1xuICBcInNtYWxsXCIgOiA0MDBcbn1cbiIsIi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBDb25zdHJ1Y3RzIGZvbnQgZmFtaWx5IHByb3BlcnR5IHVzaW5nIHRoZSB2YWxpZGF0ZSBmdW5jdGlvblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmQzcGx1cy5zdHlsZS5mb250RmFtaWx5ID0gZnVuY3Rpb24oIGZhbWlseSApIHtcblxuICByZXR1cm4ge1xuICAgIFwicHJvY2Vzc1wiOiBkM3BsdXMuZm9udC52YWxpZGF0ZSxcbiAgICBcInZhbHVlXCI6IGZhbWlseVxuICB9XG5cbn1cbiIsIiNeXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiMgQ2hlY2tzIHRvIHNlZSBpZiBhIHN0eWxlc2hlZXQgaXMgbG9hZGVkXG4jLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kM3BsdXMuc3R5bGUuc2hlZXQgPSAobmFtZSkgLT5cbiAgaSA9IDBcbiAgcmV0dXJuQm9vbGVhbiA9IGZhbHNlXG4gIHdoaWxlIGkgPCBkb2N1bWVudC5zdHlsZVNoZWV0cy5sZW5ndGhcbiAgICBzaGVldCA9IGRvY3VtZW50LnN0eWxlU2hlZXRzW2ldXG4gICAgaWYgc2hlZXQuaHJlZiBhbmQgc2hlZXQuaHJlZi5pbmRleE9mKG5hbWUpID49IDBcbiAgICAgIHJldHVybkJvb2xlYW4gPSB0cnVlXG4gICAgICBicmVha1xuICAgIGkrK1xuICByZXR1cm5Cb29sZWFuXG5cbm1vZHVsZS5leHBvcnRzID0gZDNwbHVzLnN0eWxlLnNoZWV0XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gRmxvd3MgdGhlIHRleHQgaW50byB0aGUgY29udGFpbmVyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZDNwbHVzLnRleHR3cmFwLmZsb3cgPSBmdW5jdGlvbiggdmFycyApIHtcblxuICBpZiAoIHZhcnMudGV4dC5odG1sLnZhbHVlICkge1xuICAgIHRoaXMuZm9yZWlnbiggdmFycyApXG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy50c3BhbiggdmFycyApXG4gIH1cblxufVxuIiwiLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIEZsb3dzIHRoZSB0ZXh0IGFzIGEgZm9yZWlnbiBlbGVtZW50LlxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmQzcGx1cy50ZXh0d3JhcC5mb3JlaWduID0gZnVuY3Rpb24oIHZhcnMgKSB7XG5cbiAgdmFyIHRleHQgPSB2YXJzLmNvbnRhaW5lci52YWx1ZVxuICAgICwgZmFtaWx5ID0gdGV4dC5hdHRyKCBcImZvbnQtZmFtaWx5XCIgKSB8fCB0ZXh0LnN0eWxlKCBcImZvbnQtZmFtaWx5XCIgKVxuICAgICwgYW5jaG9yID0gdGV4dC5hdHRyKCBcInRleHQtYW5jaG9yXCIgKSB8fCB0ZXh0LnN0eWxlKCBcInRleHQtYW5jaG9yXCIgKVxuICAgICwgY29sb3IgPSB0ZXh0LmF0dHIoIFwiZmlsbFwiICkgfHwgdGV4dC5zdHlsZSggXCJmaWxsXCIgKVxuICAgICwgb3BhY2l0eSA9IHRleHQuYXR0ciggXCJvcGFjaXR5XCIgKSB8fCB0ZXh0LnN0eWxlKCBcIm9wYWNpdHlcIiApXG5cbiAgYW5jaG9yID0gYW5jaG9yID09PSBcImVuZFwiICAgID8gXCJyaWdodFwiXG4gICAgICAgICA6IGFuY2hvciA9PT0gXCJtaWRkbGVcIiA/IFwiY2VudGVyXCJcbiAgICAgICAgIDogXCJsZWZ0XCJcblxuICBkMy5zZWxlY3QoIHRleHQubm9kZSgpLnBhcmVudE5vZGUgKS5hcHBlbmQoIFwiZm9yZWlnbk9iamVjdFwiIClcbiAgICAuYXR0ciggXCJ3aWR0aFwiICAsIHZhcnMud2lkdGgudmFsdWUgKyBcInB4XCIgKVxuICAgIC5hdHRyKCBcImhlaWdodFwiICwgdmFycy5oZWlnaHQudmFsdWUgKyBcInB4XCIgKVxuICAgIC5hdHRyKCBcInhcIiAgICAgICwgXCIwcHhcIiApXG4gICAgLmF0dHIoIFwieVwiICAgICAgLCBcIjBweFwiIClcbiAgICAuYXBwZW5kKCBcInhodG1sOmRpdlwiIClcbiAgICAgIC5zdHlsZSggXCJmb250LWZhbWlseVwiICwgZmFtaWx5IClcbiAgICAgIC5zdHlsZSggXCJmb250LXNpemVcIiAgICwgdmFycy5zaXplLnZhbHVlWzFdIClcbiAgICAgIC5zdHlsZSggXCJjb2xvclwiICwgY29sb3IgKVxuICAgICAgLnN0eWxlKCBcInRleHQtYWxpZ25cIiAsIGFuY2hvciApXG4gICAgICAuc3R5bGUoIFwib3BhY2l0eVwiICwgb3BhY2l0eSApXG4gICAgICAudGV4dCggdmFycy50ZXh0LmN1cnJlbnQgKVxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gQ2hlY2tzIHdpZHRoIGFuZCBoZWlnaHQsIGFuZCBnZXRzIGl0IGlmIG5lZWRlZC5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kM3BsdXMudGV4dHdyYXAuZ2V0RGltZW5zaW9ucyA9IGZ1bmN0aW9uKCB2YXJzICkge1xuXG4gIGlmICggIXZhcnMud2lkdGgudmFsdWUgfHwgIXZhcnMuaGVpZ2h0LnZhbHVlICkge1xuXG4gICAgdmFyIHBhcmVudCA9IGQzLnNlbGVjdCh2YXJzLmNvbnRhaW5lci52YWx1ZS5ub2RlKCkucGFyZW50Tm9kZSlcbiAgICAgICwgcmVjdCAgID0gcGFyZW50LnNlbGVjdChcInJlY3RcIilcbiAgICAgICwgY2lyY2xlID0gcGFyZW50LnNlbGVjdChcImNpcmNsZVwiKVxuXG4gICAgaWYgKCAhcmVjdC5lbXB0eSgpICkge1xuXG4gICAgICBpZiAoICF2YXJzLndpZHRoLnZhbHVlICkge1xuICAgICAgICB2YXIgd2lkdGggPSByZWN0LmF0dHIoXCJ3aWR0aFwiKSB8fCByZWN0LnN0eWxlKFwid2lkdGhcIilcbiAgICAgICAgdmFycy5zZWxmLndpZHRoKCBwYXJzZUZsb2F0KCB3aWR0aCAsIDEwICkgKVxuICAgICAgfVxuICAgICAgaWYgKCAhdmFycy5oZWlnaHQudmFsdWUgKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSByZWN0LmF0dHIoXCJoZWlnaHRcIikgfHwgcmVjdC5zdHlsZShcImhlaWdodFwiKVxuICAgICAgICB2YXJzLnNlbGYuaGVpZ2h0KCBwYXJzZUZsb2F0KCBoZWlnaHQgLCAxMCApIClcbiAgICAgIH1cblxuICAgIH1cbiAgICBlbHNlIGlmICggIWNpcmNsZS5lbXB0eSgpICkge1xuXG4gICAgICB2YXIgcmFkaXVzID0gY2lyY2xlLmF0dHIoXCJyXCIpXG5cbiAgICAgIGlmICggIXZhcnMud2lkdGgudmFsdWUgKSB7XG4gICAgICAgIHZhcnMuc2VsZi53aWR0aCggcGFyc2VGbG9hdCggcmFkaXVzICogMiAsIDEwICkgKVxuICAgICAgfVxuICAgICAgaWYgKCAhdmFycy5oZWlnaHQudmFsdWUgKSB7XG4gICAgICAgIHZhcnMuc2VsZi5oZWlnaHQoIHBhcnNlRmxvYXQoIHJhZGl1cyAqIDIgLCAxMCApIClcbiAgICAgIH1cblxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgaWYgKCAhdmFycy53aWR0aC52YWx1ZSApIHtcbiAgICAgICAgdmFycy5zZWxmLndpZHRoKDUwMClcbiAgICAgIH1cbiAgICAgIGlmICggIXZhcnMuaGVpZ2h0LnZhbHVlICkge1xuICAgICAgICB2YXJzLnNlbGYuaGVpZ2h0KDUwMClcbiAgICAgIH1cblxuICAgIH1cbiAgfVxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gRmV0Y2hlcyB0ZXh0IGlmIG5vdCBzcGVjaWZpZWQsIGFuZCBmb3JtYXRzIHRleHQgdG8gYXJyYXkuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZDNwbHVzLnRleHR3cmFwLmdldFNpemUgPSBmdW5jdGlvbiggdmFycyApIHtcblxuICB2YXIgc2l6ZSA9IHZhcnMuY29udGFpbmVyLnZhbHVlLmF0dHIoXCJmb250LXNpemVcIilcbiAgICAgICAgICAgICB8fCB2YXJzLmNvbnRhaW5lci52YWx1ZS5zdHlsZShcImZvbnQtc2l6ZVwiKVxuXG4gIGlmICggIXZhcnMuc2l6ZS52YWx1ZSApIHtcblxuICAgIHNpemUgPSBwYXJzZUZsb2F0KCBzaXplICwgMTAgKVxuXG4gICAgaWYgKCB2YXJzLnJlc2l6ZS52YWx1ZSApIHtcbiAgICAgIHZhcnMuc2VsZi5zaXplKCBbIHNpemUgLCBzaXplKjIgXSApXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFycy5zZWxmLnNpemUoIFsgc2l6ZS8yICwgc2l6ZSBdIClcbiAgICB9XG5cbiAgfVxuXG4gIHZhcnMuY29udGFpbmVyLmZvbnRTaXplID0gc2l6ZVxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gRmV0Y2hlcyB0ZXh0IGlmIG5vdCBzcGVjaWZpZWQsIGFuZCBmb3JtYXRzIHRleHQgdG8gYXJyYXkuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZDNwbHVzLnRleHR3cmFwLmdldFRleHQgPSBmdW5jdGlvbiggdmFycyApIHtcblxuICBpZiAoICF2YXJzLnRleHQudmFsdWUgKSB7XG5cbiAgICB2YXIgdGV4dCA9IHZhcnMuY29udGFpbmVyLnZhbHVlLnRleHQoKVxuXG4gICAgaWYgKHRleHQpIHtcblxuICAgICAgaWYgKCB0ZXh0LmluZGV4T2YoXCJ0c3BhblwiKSA+PSAwICkge1xuICAgICAgICB0ZXh0LnJlcGxhY2UoL1xcPFxcL3RzcGFuXFw+XFw8dHNwYW5cXD4vZyxcIiBcIilcbiAgICAgICAgdGV4dC5yZXBsYWNlKC9cXDxcXC90c3BhblxcPi9nLFwiXCIpXG4gICAgICAgIHRleHQucmVwbGFjZSgvXFw8dHNwYW5cXD4vZyxcIlwiKVxuICAgICAgfVxuXG4gICAgICB2YXJzLnNlbGYudGV4dCggdGV4dCApXG5cbiAgICB9XG5cbiAgfVxuXG4gIGlmICggdmFycy50ZXh0LnZhbHVlIGluc3RhbmNlb2YgQXJyYXkgKSB7XG4gICAgdmFycy50ZXh0LnBocmFzZXMgPSB2YXJzLnRleHQudmFsdWUuZmlsdGVyKGZ1bmN0aW9uKHQpe1xuICAgICAgcmV0dXJuIFsgXCJzdHJpbmdcIiAsIFwibnVtYmVyXCIgXS5pbmRleE9mKHR5cGVvZiB0KSA+PSAwXG4gICAgfSlcbiAgfVxuICBlbHNlIHtcbiAgICB2YXJzLnRleHQucGhyYXNlcyA9IFsgdmFycy50ZXh0LnZhbHVlICsgXCJcIiBdXG4gIH1cblxuICB2YXJzLmNvbnRhaW5lci52YWx1ZS50ZXh0KFwiXCIpXG5cbn1cbiIsIi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBMb2dpYyB0byBkZXRlcm1pbmUgdGhlIGJlc3Qgc2l6ZSBmb3IgdGV4dFxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmQzcGx1cy50ZXh0d3JhcC5yZXNpemUgPSBmdW5jdGlvbiggdmFycyAsIGxpbmUgKSB7XG5cbiAgaWYgKCB2YXJzLnJlc2l6ZS52YWx1ZSApIHtcblxuICAgIHZhciB3b3JkcyA9IFtdXG4gICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IHZhcnMudGV4dC53b3Jkcy5sZW5ndGggOyBpKysgKSB7XG4gICAgICB2YXIgYWRkb24gPSBpID09PSB2YXJzLnRleHQud29yZHMubGVuZ3RoIC0gMSA/IFwiXCIgOiBcIiBcIlxuICAgICAgd29yZHMucHVzaCggdmFycy50ZXh0LndvcmRzW2ldICsgYWRkb24gKVxuICAgIH1cblxuICAgIC8vIFN0YXJ0IGJ5IHRyeWluZyB0aGUgbGFyZ2VzdCBmb250IHNpemVcbiAgICB2YXIgc2l6ZU1heCAgID0gTWF0aC5mbG9vciggdmFycy5zaXplLnZhbHVlWzFdIClcbiAgICAgICwgbGluZVdpZHRoID0gdmFycy5zaGFwZS52YWx1ZSA9PT0gXCJjaXJjbGVcIiA/IHZhcnMud2lkdGgudmFsdWUgKiAwLjc4NVxuICAgICAgICAgICAgICAgICAgOiB2YXJzLndpZHRoLnZhbHVlXG4gICAgICAsIHNpemVzICAgICA9IGQzcGx1cy5mb250LnNpemVzKCB3b3Jkc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgeyBcImZvbnQtc2l6ZVwiIDogc2l6ZU1heCArIFwicHhcIiB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCB2YXJzLmNvbnRhaW5lci52YWx1ZSApXG4gICAgICAsIG1heFdpZHRoICA9IGQzLm1heCggc2l6ZXMgLCBmdW5jdGlvbihkKXsgcmV0dXJuIGQud2lkdGggfSApXG4gICAgICAsIGFyZWFNb2QgICA9IDEuMTY1ICsgKHZhcnMud2lkdGgudmFsdWUvdmFycy5oZWlnaHQudmFsdWUqMC4wMzcpXG4gICAgICAsIHRleHRBcmVhICA9IGQzLnN1bSggc2l6ZXMgLCBmdW5jdGlvbihkKXsgcmV0dXJuIGQud2lkdGggKiBkLmhlaWdodCB9ICkgKiBhcmVhTW9kXG4gICAgICAsIGJveEFyZWEgICA9IHZhcnMuc2hhcGUudmFsdWUgPT09IFwiY2lyY2xlXCJcbiAgICAgICAgICAgICAgICAgID8gTWF0aC5QSSAqIE1hdGgucG93KCB2YXJzLndpZHRoLnZhbHVlIC8gMiAsIDIgKVxuICAgICAgICAgICAgICAgICAgOiBsaW5lV2lkdGggKiB2YXJzLmhlaWdodC52YWx1ZVxuXG4gICAgaWYgKCBtYXhXaWR0aCA+IGxpbmVXaWR0aCB8fCB0ZXh0QXJlYSA+IGJveEFyZWEgKSB7XG5cbiAgICAgIHZhciBhcmVhUmF0aW8gID0gTWF0aC5zcXJ0KCBib3hBcmVhIC8gdGV4dEFyZWEgKVxuICAgICAgICAsIHdpZHRoUmF0aW8gPSBsaW5lV2lkdGggLyBtYXhXaWR0aFxuICAgICAgICAsIHNpemVSYXRpbyAgPSBkMy5taW4oWyBhcmVhUmF0aW8gLCB3aWR0aFJhdGlvIF0pXG5cbiAgICAgIHNpemVNYXggPSBkMy5tYXgoWyB2YXJzLnNpemUudmFsdWVbMF0gLCBNYXRoLmZsb29yKCBzaXplTWF4ICogc2l6ZVJhdGlvICkgXSlcblxuICAgIH1cblxuICAgIHZhciBoZWlnaHRNYXggPSBNYXRoLmZsb29yKHZhcnMuaGVpZ2h0LnZhbHVlICogMC44KVxuXG4gICAgaWYgKCBzaXplTWF4ID4gaGVpZ2h0TWF4ICkge1xuICAgICAgc2l6ZU1heCA9IGhlaWdodE1heFxuICAgIH1cblxuICAgIGlmICggbWF4V2lkdGggKiAoc2l6ZU1heC92YXJzLnNpemUudmFsdWVbMV0pIDw9IGxpbmVXaWR0aCApIHtcblxuICAgICAgaWYgKCBzaXplTWF4ICE9PSB2YXJzLnNpemUudmFsdWVbMV0gKSB7XG4gICAgICAgIHZhcnMuc2VsZi5zaXplKFsgdmFycy5zaXplLnZhbHVlWzBdICwgc2l6ZU1heCBdKVxuICAgICAgfVxuXG4gICAgICB2YXJzLmNvbnRhaW5lci52YWx1ZS5hdHRyKCBcImZvbnQtc2l6ZVwiICwgdmFycy5zaXplLnZhbHVlWzFdK1wicHhcIiApXG4gICAgICB0aGlzLmZsb3coIHZhcnMgKVxuXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy53cmFwKCB2YXJzIClcbiAgICB9XG5cbiAgfVxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gRmxvd3MgdGhlIHRleHQgaW50byB0c3BhbnNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kM3BsdXMudGV4dHdyYXAudHNwYW4gPSBmdW5jdGlvbiggdmFycyApIHtcblxuICB2YXIgeFBvc2l0aW9uICA9IHZhcnMuY29udGFpbmVyLnZhbHVlLmF0dHIoXCJ4XCIpIHx8IFwiMHB4XCJcbiAgICAsIHdvcmRzICAgICAgPSB2YXJzLnRleHQud29yZHMuc2xpY2UoMClcbiAgICAsIHRzcGFucyAgICAgPSBmYWxzZVxuICAgICwgZm9udFNpemUgICA9IHZhcnMucmVzaXplLnZhbHVlID8gdmFycy5zaXplLnZhbHVlWzFdIDogdmFycy5jb250YWluZXIuZm9udFNpemUgfHwgdmFycy5zaXplLnZhbHVlWzBdXG4gICAgLCB0ZXh0Qm94ICAgID0gdmFycy5jb250YWluZXIudmFsdWUuYXBwZW5kKFwidHNwYW5cIikudGV4dCggd29yZHNbMF0gKVxuICAgICAgICAgICAgICAgICAgICAgLmF0dHIoIFwiZHlcIiAsIGZvbnRTaXplICsgXCJweFwiIClcbiAgICAsIHRleHRIZWlnaHQgPSB0ZXh0Qm94Lm5vZGUoKS5vZmZzZXRIZWlnaHQgfHwgdGV4dEJveC5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gICAgLCBsaW5lICAgICAgID0gMVxuICAgICwgbmV3TGluZSAgICA9IGZ1bmN0aW9uKCApIHtcbiAgICAgIHJldHVybiB2YXJzLmNvbnRhaW5lci52YWx1ZS5hcHBlbmQoXCJ0c3BhblwiKVxuICAgICAgICAgICAgICAuYXR0ciggXCJ4XCIgLCB4UG9zaXRpb24gKVxuICAgICAgICAgICAgICAuYXR0ciggXCJkeVwiICwgZm9udFNpemUgKyBcInB4XCIgKVxuICAgIH1cbiAgICAsIHRydW5jYXRlICAgPSBmdW5jdGlvbiggKSB7XG5cbiAgICAgIGlmICggIXRleHRCb3guZW1wdHkoKSApIHtcblxuICAgICAgICB3b3JkcyA9IHRleHRCb3gudGV4dCgpLm1hdGNoKC9bXlxccy1dKy0/L2cpXG5cbiAgICAgICAgZWxsaXBzaXMoKVxuXG4gICAgICB9XG5cbiAgICB9XG4gICAgLCBlbGxpcHNpcyAgID0gZnVuY3Rpb24oICkge1xuXG4gICAgICBpZiAoIHdvcmRzICYmIHdvcmRzLmxlbmd0aCApIHtcblxuICAgICAgICB2YXIgbGFzdFdvcmQgPSB3b3Jkcy5wb3AoKVxuICAgICAgICAgICwgbGFzdENoYXIgPSBsYXN0V29yZC5jaGFyQXQoIGxhc3RXb3JkLmxlbmd0aC0xIClcblxuICAgICAgICBpZiAoIGxhc3RXb3JkLmxlbmd0aCA9PT0gMVxuICAgICAgICAmJiB2YXJzLnRleHQuc3BsaXQuaW5kZXhPZiggbGFzdFdvcmQgKSA+PSAwICkge1xuICAgICAgICAgIGVsbGlwc2lzKClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgIGlmICggdmFycy50ZXh0LnNwbGl0LmluZGV4T2YoIGxhc3RDaGFyICkgPj0gMCApIHtcbiAgICAgICAgICAgIGxhc3RXb3JkID0gbGFzdFdvcmQuc3Vic3RyKCAwICwgbGFzdFdvcmQubGVuZ3RoIC0gMSApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGV4dEJveC50ZXh0KCB3b3Jkcy5qb2luKFwiIFwiKSArIFwiIFwiICsgbGFzdFdvcmQgKyBcIiAuLi5cIiApXG5cbiAgICAgICAgICB2YXIgYmFzZWxpbmUgPSAobGluZS0xKSAqIHRleHRIZWlnaHRcbiAgICAgICAgICAgICwgbGluZVdpZHRoID0gdmFycy5zaGFwZS52YWx1ZSA9PT0gXCJjaXJjbGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyAyKk1hdGguc3FydCggYmFzZWxpbmUqKCAoMioodmFycy53aWR0aC52YWx1ZS8yKSktYmFzZWxpbmUgKSApXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHZhcnMud2lkdGgudmFsdWVcblxuICAgICAgICAgIGlmICggdGV4dEJveC5ub2RlKCkuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCkgPiBsaW5lV2lkdGggKSB7XG4gICAgICAgICAgICBlbGxpcHNpcygpXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuICAgICAgZWxzZSB7XG5cbiAgICAgICAgdGV4dEJveC5yZW1vdmUoKVxuICAgICAgICB0ZXh0Qm94ID0gZDMuc2VsZWN0KCB2YXJzLmNvbnRhaW5lci52YWx1ZS5ub2RlKCkubGFzdENoaWxkIClcbiAgICAgICAgaWYgKCAhdGV4dEJveC5lbXB0eSgpICkge1xuICAgICAgICAgIGxpbmUtLVxuICAgICAgICAgIHRydW5jYXRlKClcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgaWYgKCB2YXJzLnNoYXBlLnZhbHVlID09PSBcImNpcmNsZVwiICkge1xuICAgIHZhcnMuY29udGFpbmVyLnZhbHVlLmF0dHIoIFwidGV4dC1hbmNob3JcIiAsIFwibWlkZGxlXCIgKVxuICB9XG5cbiAgZm9yICggdmFyIGkgPSAxIDsgaSA8IHdvcmRzLmxlbmd0aCA7IGkrKyApIHtcblxuICAgIGlmICggbGluZSAqIHRleHRIZWlnaHQgPiB2YXJzLmhlaWdodC52YWx1ZSApIHtcbiAgICAgIHRleHRCb3gucmVtb3ZlKClcbiAgICAgIGlmICggaSAhPT0gMSApIHtcbiAgICAgICAgdGV4dEJveCA9IGQzLnNlbGVjdCggdmFycy5jb250YWluZXIudmFsdWUubm9kZSgpLmxhc3RDaGlsZCApXG4gICAgICAgIGlmICggIXRleHRCb3guZW1wdHkoKSApIHRydW5jYXRlKClcbiAgICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICB9XG5cbiAgICB2YXIgY3VycmVudCAgID0gdGV4dEJveC50ZXh0KClcbiAgICAgICwgbGFzdENoYXIgPSBjdXJyZW50LnNsaWNlKC0xKVxuICAgICAgLCBuZXh0X2NoYXIgPSB2YXJzLnRleHQuY3VycmVudC5jaGFyQXQoIHZhcnMudGV4dC5jdXJyZW50LmluZGV4T2YoY3VycmVudCkgKyBjdXJyZW50Lmxlbmd0aCApXG4gICAgICAsIGpvaW5lciAgICA9IG5leHRfY2hhciA9PSBcIiBcIiA/IFwiIFwiIDogXCJcIlxuXG4gICAgdGV4dEJveC50ZXh0KCBjdXJyZW50ICsgam9pbmVyICsgd29yZHNbaV0gKVxuXG5cbiAgICB2YXIgYmFzZWxpbmUgPSAobGluZS0xKSAqIHRleHRIZWlnaHRcbiAgICAgICwgbGluZVdpZHRoID0gdmFycy5zaGFwZS52YWx1ZSA9PT0gXCJjaXJjbGVcIlxuICAgICAgICAgICAgICAgICAgPyAyKk1hdGguc3FydCggYmFzZWxpbmUqKCAoMioodmFycy53aWR0aC52YWx1ZS8yKSktYmFzZWxpbmUgKSApXG4gICAgICAgICAgICAgICAgICA6IHZhcnMud2lkdGgudmFsdWVcblxuICAgIGlmICggdGV4dEJveC5ub2RlKCkuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCkgPiBsaW5lV2lkdGggKSB7XG5cbiAgICAgIGlmICggIXRzcGFucyApIHtcbiAgICAgICAgdGV4dEJveC50ZXh0KFwiXCIpXG4gICAgICAgIHRleHRCb3ggPSBuZXdMaW5lKClcbiAgICAgIH1cblxuICAgICAgdGV4dEJveC50ZXh0KCBjdXJyZW50IClcblxuICAgICAgdGV4dEJveCA9IG5ld0xpbmUoKVxuICAgICAgdGV4dEJveC50ZXh0KCB3b3Jkc1tpXSApXG5cbiAgICAgIGxpbmUrK1xuXG4gICAgfVxuXG4gIH1cblxufVxuIiwiLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIEZsb3dzIHRoZSB0ZXh0IGludG8gdGhlIGNvbnRhaW5lclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmQzcGx1cy50ZXh0d3JhcC53cmFwID0gZnVuY3Rpb24oIHZhcnMgKSB7XG5cbiAgaWYgKCB2YXJzLnRleHQucGhyYXNlcy5sZW5ndGggKSB7XG5cbiAgICB2YXJzLnRleHQuY3VycmVudCA9IHZhcnMudGV4dC5waHJhc2VzLnNoaWZ0KCkgKyBcIlwiXG4gICAgdmFycy50ZXh0LndvcmRzICAgPSB2YXJzLnRleHQuY3VycmVudC5tYXRjaCh2YXJzLnRleHQuYnJlYWspXG5cbiAgICBpZiAoIHZhcnMucmVzaXplLnZhbHVlICkge1xuICAgICAgdGhpcy5yZXNpemUoIHZhcnMgKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuZmxvdyggdmFycyApXG4gICAgfVxuXG4gIH1cblxufVxuIiwiLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIFdvcmQgd3JhcHMgU1ZHIHRleHRcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kM3BsdXMudGV4dHdyYXAgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgdmFycyA9IHsgXCJzaGVsbFwiIDogXCJ0ZXh0d3JhcFwiIH1cblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gTWFpbiBkcmF3aW5nIGZ1bmN0aW9uXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXJzLnNlbGYgPSBmdW5jdGlvbihzZWxlY3Rpb24pIHtcblxuICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKCkge1xuXG4gICAgICBkM3BsdXMudGV4dHdyYXAuZ2V0RGltZW5zaW9ucyggdmFycyApXG4gICAgICBkM3BsdXMudGV4dHdyYXAuZ2V0U2l6ZSggdmFycyApXG5cbiAgICAgIGlmICggdmFycy5zaXplLnZhbHVlWzBdIDw9IHZhcnMuaGVpZ2h0LnZhbHVlICkge1xuICAgICAgICBkM3BsdXMudGV4dHdyYXAuZ2V0VGV4dCggdmFycyApXG4gICAgICAgIGQzcGx1cy50ZXh0d3JhcC53cmFwKCB2YXJzIClcbiAgICAgIH1cblxuICAgIH0pXG5cbiAgICByZXR1cm4gdmFycy5zZWxmXG4gIH1cblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gRGVmaW5lIG1ldGhvZHMgYW5kIGV4cG9zZSBwdWJsaWMgdmFyaWFibGVzLlxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgdmFyIG1ldGhvZHMgPSBbIFwiY29udGFpbmVyXCIgLCBcImRldlwiICwgXCJkcmF3XCIgLCBcImZvcm1hdFwiICwgXCJoZWlnaHRcIlxuICAgICAgICAgICAgICAgICwgXCJyZXNpemVcIiAsIFwidGV4dFwiICwgXCJzaGFwZVwiICwgXCJzaXplXCIgLCBcIndpZHRoXCIgXVxuICBkM3BsdXMubWV0aG9kKCB2YXJzICwgbWV0aG9kcyApXG5cbiAgcmV0dXJuIHZhcnMuc2VsZlxuXG59XG4iLCJ2YXIgZmV0Y2hWYWx1ZSA9IHJlcXVpcmUoXCIuLi9jb3JlL2ZldGNoL3ZhbHVlLmpzXCIpLFxuICAgIGZldGNoQ29sb3IgPSByZXF1aXJlKFwiLi4vY29yZS9mZXRjaC9jb2xvci5qc1wiKSxcbiAgICBmZXRjaFRleHQgID0gcmVxdWlyZShcIi4uL2NvcmUvZmV0Y2gvdGV4dC5qc1wiKVxuLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBDcmVhdGVzIGNvcnJlY3RseSBmb3JtYXR0ZWQgdG9vbHRpcCBmb3IgQXBwc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kM3BsdXMudG9vbHRpcC5hcHAgPSBmdW5jdGlvbihwYXJhbXMpIHtcblxuICBpZiAoICEoIFwiZDNwbHVzXCIgaW4gcGFyYW1zLmRhdGEgKSApIHtcbiAgICBwYXJhbXMuZGF0YS5kM3BsdXMgPSB7fVxuICB9XG5cbiAgdmFyIHZhcnMgPSBwYXJhbXMudmFycyxcbiAgICAgIGQgPSBwYXJhbXMuZGF0YSxcbiAgICAgIGRhdGFEZXB0aCA9IFwiZDNwbHVzXCIgaW4gZCAmJiBcImRlcHRoXCIgaW4gZC5kM3BsdXMgPyBkLmQzcGx1cy5kZXB0aCA6IHZhcnMuZGVwdGgudmFsdWUsXG4gICAgICBleCA9IHBhcmFtcy5leCxcbiAgICAgIG1vdXNlID0gcGFyYW1zLm1vdXNlZXZlbnRzID8gcGFyYW1zLm1vdXNlZXZlbnRzIDogZmFsc2UsXG4gICAgICBhcnJvdyA9IFwiYXJyb3dcIiBpbiBwYXJhbXMgPyBwYXJhbXMuYXJyb3cgOiB0cnVlLFxuICAgICAgaWQgPSBmZXRjaFZhbHVlKHZhcnMsZCx2YXJzLmlkLnZhbHVlKSxcbiAgICAgIHRvb2x0aXBfaWQgPSBwYXJhbXMuaWQgfHwgdmFycy50eXBlLnZhbHVlXG5cbiAgaWYgKChkMy5ldmVudCAmJiBkMy5ldmVudC50eXBlID09IFwiY2xpY2tcIikgJiYgKHZhcnMudG9vbHRpcC5odG1sLnZhbHVlIHx8IHZhcnMudG9vbHRpcC52YWx1ZS5sb25nKSAmJiAhKFwiZnVsbHNjcmVlblwiIGluIHBhcmFtcykpIHtcbiAgICB2YXIgZnVsbHNjcmVlbiA9IHRydWUsXG4gICAgICAgIGFycm93ID0gZmFsc2UsXG4gICAgICAgIG1vdXNlID0gdHJ1ZSxcbiAgICAgICAgbGVuZ3RoID0gXCJsb25nXCIsXG4gICAgICAgIGZvb3RlciA9IHZhcnMuZm9vdGVyLnZhbHVlXG5cbiAgICB2YXJzLmNvdmVyZWQgPSB0cnVlXG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGZ1bGxzY3JlZW4gPSBmYWxzZSxcbiAgICAgICAgYWxpZ24gPSBwYXJhbXMuYW5jaG9yIHx8IHZhcnMudG9vbHRpcC5hbmNob3IsXG4gICAgICAgIGxlbmd0aCA9IHBhcmFtcy5sZW5ndGggfHwgXCJzaG9ydFwiLFxuICAgICAgICB6b29tID0gdmFycy56b29tLmRpcmVjdGlvbihkKVxuXG4gICAgaWYgKHpvb20gPT09IC0xKSB7XG4gICAgICB2YXIga2V5ID0gdmFycy5pZC5uZXN0aW5nW2RhdGFEZXB0aC0xXSxcbiAgICAgICAgICBwYXJlbnQgPSBmZXRjaFZhbHVlKHZhcnMsaWQsa2V5KVxuICAgIH1cblxuICAgIGlmICh6b29tID09PSAxICYmIHZhcnMuem9vbS52YWx1ZSkge1xuICAgICAgdmFyIHRleHQgPSB2YXJzLmZvcm1hdC52YWx1ZSh2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUudWkuZXhwYW5kKVxuICAgIH1cbiAgICBlbHNlIGlmICh6b29tID09PSAtMSAmJiB2YXJzLnpvb20udmFsdWUgJiYgdmFycy5oaXN0b3J5LnN0YXRlcy5sZW5ndGgpIHtcbiAgICAgIHZhciB0ZXh0ID0gdmFycy5mb3JtYXQudmFsdWUodmFycy5mb3JtYXQubG9jYWxlLnZhbHVlLnVpLmNvbGxhcHNlKVxuICAgIH1cbiAgICBlbHNlIGlmICghdmFycy5zbWFsbCAmJiBsZW5ndGggPT0gXCJzaG9ydFwiICYmICh2YXJzLnRvb2x0aXAuaHRtbC52YWx1ZSB8fCB2YXJzLnRvb2x0aXAudmFsdWUubG9uZykgJiYgKHZhcnMuZm9jdXMudmFsdWUubGVuZ3RoICE9PSAxIHx8IHZhcnMuZm9jdXMudmFsdWVbMF0gIT0gaWQpKSB7XG4gICAgICB2YXIgdGV4dCA9IHZhcnMuZm9ybWF0LmxvY2FsZS52YWx1ZS51aS5tb3JlSW5mb1xuICAgIH1cbiAgICBlbHNlIGlmIChsZW5ndGggPT0gXCJsb25nXCIpIHtcbiAgICAgIHZhciB0ZXh0ID0gdmFycy5mb290ZXIudmFsdWUgfHwgXCJcIlxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciB0ZXh0ID0gXCJcIlxuICAgIH1cblxuICAgIHZhciBmb290ZXIgPSB0ZXh0Lmxlbmd0aCA/IHZhcnMuZm9ybWF0LnZhbHVlKHRleHQsXCJmb290ZXJcIikgOiBmYWxzZVxuXG4gIH1cblxuICBpZiAoXCJ4XCIgaW4gcGFyYW1zKSB7XG4gICAgdmFyIHggPSBwYXJhbXMueFxuICB9XG4gIGVsc2UgaWYgKHZhcnMudHlwZXNbdmFycy50eXBlLnZhbHVlXS50b29sdGlwID09IFwiZm9sbG93XCIpIHtcbiAgICB2YXIgeCA9IGQzLm1vdXNlKHZhcnMuY29udGFpbmVyLnZhbHVlLm5vZGUoKSlbMF1cbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgeCA9IGQuZDNwbHVzLnhcbiAgICBpZiAodmFycy56b29tLnRyYW5zbGF0ZSAmJiB2YXJzLnpvb20uc2NhbGUpIHtcbiAgICAgIHggPSB2YXJzLnpvb20udHJhbnNsYXRlWzBdK3gqdmFycy56b29tLnNjYWxlXG4gICAgfVxuICAgIHggKz0gdmFycy5tYXJnaW4ubGVmdFxuICB9XG5cbiAgaWYgKFwieVwiIGluIHBhcmFtcykge1xuICAgIHZhciB5ID0gcGFyYW1zLnlcbiAgfVxuICBlbHNlIGlmICh2YXJzLnR5cGVzW3ZhcnMudHlwZS52YWx1ZV0udG9vbHRpcCA9PSBcImZvbGxvd1wiKSB7XG4gICAgdmFyIHkgPSBkMy5tb3VzZSh2YXJzLmNvbnRhaW5lci52YWx1ZS5ub2RlKCkpWzFdXG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIHkgPSBkLmQzcGx1cy55XG4gICAgaWYgKHZhcnMuem9vbS50cmFuc2xhdGUgJiYgdmFycy56b29tLnNjYWxlKSB7XG4gICAgICB5ID0gdmFycy56b29tLnRyYW5zbGF0ZVsxXSt5KnZhcnMuem9vbS5zY2FsZVxuICAgIH1cbiAgICB5ICs9IHZhcnMubWFyZ2luLnRvcFxuICB9XG5cbiAgaWYgKFwib2Zmc2V0XCIgaW4gcGFyYW1zKSB7XG4gICAgdmFyIG9mZnNldCA9IHBhcmFtcy5vZmZzZXRcbiAgfVxuICBlbHNlIGlmICh2YXJzLnR5cGVzW3ZhcnMudHlwZS52YWx1ZV0udG9vbHRpcCA9PSBcImZvbGxvd1wiKSB7XG4gICAgdmFyIG9mZnNldCA9IDNcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgb2Zmc2V0ID0gZC5kM3BsdXMuciA/IGQuZDNwbHVzLnIgOiBkLmQzcGx1cy5oZWlnaHQvMlxuICAgIGlmICh2YXJzLnpvb20uc2NhbGUpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCAqIHZhcnMuem9vbS5zY2FsZVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VfdG9vbHRpcChodG1sKSB7XG5cbiAgICB2YXIgZXggPSB7fVxuICAgICAgLCBjaGlsZHJlbiA9IHt9XG4gICAgICAsIGRlcHRoICAgICA9IHZhcnMuaWQubmVzdGluZ1tkYXRhRGVwdGgrMV0gaW4gZCA/IGRhdGFEZXB0aCsxIDogZGF0YURlcHRoXG4gICAgICAsIG5lc3RLZXkgICA9IHZhcnMuaWQubmVzdGluZ1tkZXB0aF1cbiAgICAgICwgbmFtZUxpc3QgID0gXCJtZXJnZWRcIiBpbiBkLmQzcGx1cyA/IGQuZDNwbHVzLm1lcmdlZCA6IGRbbmVzdEtleV1cbiAgICAgICwgZGF0YVZhbHVlID0gZmV0Y2hWYWx1ZSggdmFycyAsIGQgLCB2YXJzLnNpemUudmFsdWUgKVxuICAgICAgLCBzYW1lID0gKCEobmFtZUxpc3QgaW5zdGFuY2VvZiBBcnJheSkgfHwgKG5hbWVMaXN0IGluc3RhbmNlb2YgQXJyYXkgJiYgbmFtZUxpc3QubGVuZ3RoID09PSAxKSkgJiYgZGVwdGggPT09IHZhcnMuZGVwdGgudmFsdWVcblxuICAgIGlmICggIXNhbWUgJiYgdmFycy50b29sdGlwLmNoaWxkcmVuLnZhbHVlICkge1xuXG4gICAgICBpZiAoIG5hbWVMaXN0IGluc3RhbmNlb2YgQXJyYXkgKSB7XG5cbiAgICAgICAgbmFtZUxpc3QgPSBuYW1lTGlzdC5zbGljZSgwKVxuXG4gICAgICAgIGlmICh2YXJzLnNpemUudmFsdWUgJiYgZDNwbHVzLm9iamVjdC52YWxpZGF0ZShuYW1lTGlzdFswXSkpIHtcblxuICAgICAgICAgIHZhciBuYW1lc1dpdGhWYWx1ZXMgPSBuYW1lTGlzdC5maWx0ZXIoZnVuY3Rpb24obil7XG4gICAgICAgICAgICByZXR1cm4gdmFycy5zaXplLnZhbHVlIGluIG5cbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgdmFyIG5hbWVzTm9WYWx1ZXMgPSBuYW1lTGlzdC5maWx0ZXIoZnVuY3Rpb24obil7XG4gICAgICAgICAgICByZXR1cm4gISh2YXJzLnNpemUudmFsdWUgaW4gbilcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgZDNwbHVzLmFycmF5LnNvcnQoIG5hbWVzV2l0aFZhbHVlcyAsIHZhcnMuc2l6ZS52YWx1ZSAsIFwiZGVzY1wiICwgW10gLCB2YXJzIClcblxuICAgICAgICAgIG5hbWVMaXN0ID0gbmFtZXNXaXRoVmFsdWVzLmNvbmNhdChuYW1lc05vVmFsdWVzKVxuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGltaXQgPSBsZW5ndGggPT09IFwic2hvcnRcIiA/IDMgOiB2YXJzLmRhdGEubGFyZ2VcbiAgICAgICAgICAsIG1heCAgID0gZDMubWluKFtuYW1lTGlzdC5sZW5ndGggLCBsaW1pdF0pXG4gICAgICAgICAgLCBvYmpzICA9IFtdXG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IG1heCA7IGkrKyApIHtcblxuICAgICAgICAgIHZhciBpZCAgICA9IG5hbWVMaXN0W2ldXG4gICAgICAgICAgICAsIG5hbWUgID0gZmV0Y2hUZXh0KCB2YXJzICwgaWQgLCBkZXB0aCApWzBdXG4gICAgICAgICAgICAsIHZhbHVlID0gZmV0Y2hWYWx1ZSggdmFycyAsIGlkICwgdmFycy5zaXplLnZhbHVlICwgbmVzdEtleSApXG4gICAgICAgICAgICAsIGNvbG9yID0gZmV0Y2hDb2xvciggdmFycyAsIGlkICwgbmVzdEtleSApXG5cbiAgICAgICAgICBjaGlsZHJlbltuYW1lXSA9IHZhbHVlID8gdmFycy5mb3JtYXQudmFsdWUoIHZhbHVlICwgdmFycy5zaXplLnZhbHVlICkgOiBcIlwiXG5cbiAgICAgICAgICBpZiAoIGNvbG9yICkge1xuICAgICAgICAgICAgaWYgKCAhY2hpbGRyZW4uZDNwbHVzX2NvbG9ycyApIGNoaWxkcmVuLmQzcGx1c19jb2xvcnMgPSB7fVxuICAgICAgICAgICAgY2hpbGRyZW4uZDNwbHVzX2NvbG9yc1tuYW1lXSA9IGNvbG9yXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG5hbWVMaXN0Lmxlbmd0aCA+IG1heCApIHtcbiAgICAgICAgICBjaGlsZHJlbi5kM3BsdXNNb3JlID0gbmFtZUxpc3QubGVuZ3RoIC0gbWF4XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIG5hbWVMaXN0ICYmIG5hbWVMaXN0ICE9PSBcIm51bGxcIiApIHtcblxuICAgICAgICB2YXIgbmFtZSAgPSBmZXRjaFRleHQoIHZhcnMgLCBuYW1lTGlzdCAsIGRlcHRoIClbMF1cbiAgICAgICAgY2hpbGRyZW5bbmFtZV0gPSBkYXRhVmFsdWUgPyB2YXJzLmZvcm1hdC52YWx1ZSggZGF0YVZhbHVlICwgdmFycy5zaXplLnZhbHVlICkgOiBcIlwiXG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmICggdmFycy5zaXplLnZhbHVlICYmIHZhcnMudG9vbHRpcC5zaXplLnZhbHVlICYmIGRhdGFWYWx1ZSAmJiAoIHNhbWUgfHwgIW5hbWVMaXN0IHx8IG5hbWVMaXN0IGluc3RhbmNlb2YgQXJyYXkgKSApIHtcbiAgICAgIGV4W3ZhcnMuc2l6ZS52YWx1ZV0gPSBkYXRhVmFsdWVcbiAgICB9XG5cbiAgICB2YXIgYWN0aXZlID0gdmFycy5hY3RpdmUudmFsdWUgPyBmZXRjaFZhbHVlKHZhcnMsZCx2YXJzLmFjdGl2ZS52YWx1ZSkgOiBkLmQzcGx1cy5hY3RpdmUsXG4gICAgICAgIHRlbXAgPSB2YXJzLnRlbXAudmFsdWUgPyBmZXRjaFZhbHVlKHZhcnMsZCx2YXJzLnRlbXAudmFsdWUpIDogZC5kM3BsdXMudGVtcCxcbiAgICAgICAgdG90YWwgPSB2YXJzLnRvdGFsLnZhbHVlID8gZmV0Y2hWYWx1ZSh2YXJzLGQsdmFycy50b3RhbC52YWx1ZSkgOiBkLmQzcGx1cy50b3RhbFxuXG4gICAgaWYgKHR5cGVvZiBhY3RpdmUgPT0gXCJudW1iZXJcIiAmJiBhY3RpdmUgPiAwICYmIHRvdGFsKSB7XG4gICAgICB2YXIgbGFiZWwgPSB2YXJzLmFjdGl2ZS52YWx1ZSB8fCBcImFjdGl2ZVwiXG4gICAgICBleFtsYWJlbF0gPSBhY3RpdmUrXCIvXCIrdG90YWwrXCIgKFwiK3ZhcnMuZm9ybWF0LnZhbHVlKChhY3RpdmUvdG90YWwpKjEwMCxcInNoYXJlXCIpK1wiJSlcIlxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGVtcCA9PSBcIm51bWJlclwiICYmIHRlbXAgPiAwICYmIHRvdGFsKSB7XG4gICAgICB2YXIgbGFiZWwgPSB2YXJzLnRlbXAudmFsdWUgfHwgXCJ0ZW1wXCJcbiAgICAgIGV4W2xhYmVsXSA9IHRlbXArXCIvXCIrdG90YWwrXCIgKFwiK3ZhcnMuZm9ybWF0LnZhbHVlKCh0ZW1wL3RvdGFsKSoxMDAsXCJzaGFyZVwiKStcIiUpXCJcbiAgICB9XG5cbiAgICBpZiAoIHZhcnMudG9vbHRpcC5zaGFyZS52YWx1ZSAmJiBkLmQzcGx1cy5zaGFyZSApIHtcbiAgICAgIGV4LnNoYXJlID0gdmFycy5mb3JtYXQudmFsdWUoZC5kM3BsdXMuc2hhcmUqMTAwLFwic2hhcmVcIikrXCIlXCJcbiAgICB9XG5cbiAgICB2YXIgZGVwdGggPSBcImRlcHRoXCIgaW4gcGFyYW1zID8gcGFyYW1zLmRlcHRoIDogZGF0YURlcHRoLFxuICAgICAgICB0aXRsZSA9IHBhcmFtcy50aXRsZSB8fCBmZXRjaFRleHQodmFycyxkLGRlcHRoKVswXSxcbiAgICAgICAgaWNvbiA9IGZldGNoVmFsdWUodmFycyxkLHZhcnMuaWNvbi52YWx1ZSx2YXJzLmlkLm5lc3RpbmdbZGVwdGhdKSxcbiAgICAgICAgdG9vbHRpcF9kYXRhID0gZDNwbHVzLnRvb2x0aXAuZGF0YSh2YXJzLGQsbGVuZ3RoLGV4LGNoaWxkcmVuLGRlcHRoKVxuXG4gICAgaWYgKGljb24gPT09IFwibnVsbFwiKSBpY29uID0gZmFsc2VcblxuICAgIGlmICgodG9vbHRpcF9kYXRhLmxlbmd0aCA+IDAgfHwgZm9vdGVyKSB8fCAoKCFkLmQzcGx1c19sYWJlbCAmJiBsZW5ndGggPT0gXCJzaG9ydFwiICYmIHRpdGxlKSB8fCAoZC5kM3BsdXNfbGFiZWwgJiYgKCEoXCJ2aXNpYmxlXCIgaW4gZC5kM3BsdXNfbGFiZWwpIHx8IChcInZpc2libGVcIiBpbiBkLmQzcGx1c19sYWJlbCAmJiBkLmQzcGx1c19sYWJlbC52aXNpYmxlID09PSBmYWxzZSkpKSkpIHtcblxuICAgICAgaWYgKCF0aXRsZSkge1xuICAgICAgICB0aXRsZSA9IGlkXG4gICAgICB9XG5cbiAgICAgIHZhciBkZXB0aCA9IFwiZDNwbHVzXCIgaW4gZCAmJiBcIm1lcmdlZFwiIGluIGQuZDNwbHVzID8gZGF0YURlcHRoIC0gMSA6IGRhdGFEZXB0aFxuXG4gICAgICBpZiAoZGVwdGggPCAwKSBkZXB0aCA9IDBcblxuICAgICAgZGVwdGggPSB2YXJzLmlkLm5lc3RpbmdbZGVwdGhdXG5cbiAgICAgIGlmICh0eXBlb2YgdmFycy5pY29uLnN0eWxlLnZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFyIGljb25fc3R5bGUgPSB2YXJzLmljb24uc3R5bGUudmFsdWVcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YXJzLmljb24uc3R5bGUudmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YXJzLmljb24uc3R5bGUudmFsdWVbZGVwdGhdKSB7XG4gICAgICAgIHZhciBpY29uX3N0eWxlID0gdmFycy5pY29uLnN0eWxlLnZhbHVlW2RlcHRoXVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBpY29uX3N0eWxlID0gXCJkZWZhdWx0XCJcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy53aWR0aCkge1xuICAgICAgICB2YXIgd2lkdGggPSBwYXJhbXMud2lkdGhcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFmdWxsc2NyZWVuICYmIHRvb2x0aXBfZGF0YS5sZW5ndGggPT0gMCkge1xuICAgICAgICB2YXIgd2lkdGggPSBcImF1dG9cIlxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciB3aWR0aCA9IHZhcnMudG9vbHRpcC5zbWFsbFxuICAgICAgfVxuXG4gICAgICBkM3BsdXMudG9vbHRpcC5jcmVhdGUoe1xuICAgICAgICBcImFsaWduXCI6IGFsaWduLFxuICAgICAgICBcImFycm93XCI6IGFycm93LFxuICAgICAgICBcImxvY2FsZVwiOiB2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUsXG4gICAgICAgIFwiYmFja2dyb3VuZFwiOiB2YXJzLnRvb2x0aXAuYmFja2dyb3VuZCxcbiAgICAgICAgXCJjdXJ0YWluXCI6IHZhcnMudG9vbHRpcC5jdXJ0YWluLmNvbG9yLFxuICAgICAgICBcImN1cnRhaW5vcGFjaXR5XCI6IHZhcnMudG9vbHRpcC5jdXJ0YWluLm9wYWNpdHksXG4gICAgICAgIFwiZm9udGNvbG9yXCI6IHZhcnMudG9vbHRpcC5mb250LmNvbG9yLFxuICAgICAgICBcImZvbnRmYW1pbHlcIjogdmFycy50b29sdGlwLmZvbnQuZmFtaWx5LnZhbHVlLFxuICAgICAgICBcImZvbnRzaXplXCI6IHZhcnMudG9vbHRpcC5mb250LnNpemUsXG4gICAgICAgIFwiZm9udHdlaWdodFwiOiB2YXJzLnRvb2x0aXAuZm9udC53ZWlnaHQsXG4gICAgICAgIFwiZGF0YVwiOiB0b29sdGlwX2RhdGEsXG4gICAgICAgIFwiY29sb3JcIjogZmV0Y2hDb2xvcih2YXJzLGQpLFxuICAgICAgICBcImFsbENvbG9yc1wiOiB0cnVlLFxuICAgICAgICBcImZvb3RlclwiOiBwYXJhbXMuZm9vdGVyID09PSBmYWxzZSA/IHBhcmFtcy5mb290ZXIgOiBmb290ZXIsXG4gICAgICAgIFwiZnVsbHNjcmVlblwiOiBmdWxsc2NyZWVuLFxuICAgICAgICBcImh0bWxcIjogaHRtbCxcbiAgICAgICAgXCJpY29uXCI6IGljb24sXG4gICAgICAgIFwiaWRcIjogdG9vbHRpcF9pZCxcbiAgICAgICAgXCJtYXhfaGVpZ2h0XCI6IHBhcmFtcy5tYXhoZWlnaHQsXG4gICAgICAgIFwibWF4X3dpZHRoXCI6IHZhcnMudG9vbHRpcC5zbWFsbCxcbiAgICAgICAgXCJtb3VzZWV2ZW50c1wiOiBtb3VzZSxcbiAgICAgICAgXCJvZmZzZXRcIjogb2Zmc2V0LFxuICAgICAgICBcInBhcmVudFwiOiB2YXJzLmNvbnRhaW5lci52YWx1ZSxcbiAgICAgICAgXCJzdHlsZVwiOiBpY29uX3N0eWxlLFxuICAgICAgICBcInRpdGxlXCI6IHRpdGxlLFxuICAgICAgICBcIndpZHRoXCI6IHdpZHRoLFxuICAgICAgICBcInhcIjogeCxcbiAgICAgICAgXCJ5XCI6IHlcbiAgICAgIH0pXG5cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBkM3BsdXMudG9vbHRpcC5yZW1vdmUodG9vbHRpcF9pZClcbiAgICB9XG5cbiAgfVxuXG4gIGlmIChmdWxsc2NyZWVuKSB7XG5cbiAgICBpZiAodHlwZW9mIHZhcnMudG9vbHRpcC5odG1sLnZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICAgIG1ha2VfdG9vbHRpcCh2YXJzLnRvb2x0aXAuaHRtbC52YWx1ZSlcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhcnMudG9vbHRpcC5odG1sLnZhbHVlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgbWFrZV90b29sdGlwKHZhcnMudG9vbHRpcC5odG1sLnZhbHVlKGlkKSlcbiAgICB9XG4gICAgZWxzZSBpZiAodmFycy50b29sdGlwLmh0bWwudmFsdWUgJiYgdHlwZW9mIHZhcnMudG9vbHRpcC5odG1sLnZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFycy50b29sdGlwLmh0bWwudmFsdWUudXJsKSB7XG4gICAgICBkMy5qc29uKHZhcnMudG9vbHRpcC5odG1sLnZhbHVlLnVybCxmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgdmFyIGh0bWwgPSB2YXJzLnRvb2x0aXAuaHRtbC52YWx1ZS5jYWxsYmFjayA/IHZhcnMudG9vbHRpcC5odG1sLnZhbHVlLmNhbGxiYWNrKGRhdGEpIDogZGF0YVxuICAgICAgICBtYWtlX3Rvb2x0aXAoaHRtbClcbiAgICAgIH0pXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbWFrZV90b29sdGlwKFwiXCIpXG4gICAgfVxuXG4gIH1cbiAgZWxzZSB7XG4gICAgbWFrZV90b29sdGlwKFwiXCIpXG4gIH1cblxufVxuIiwiLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBDb3JyZWN0bHkgcG9zaXRpb25zIHRoZSB0b29sdGlwJ3MgYXJyb3dcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZDNwbHVzLnRvb2x0aXAuYXJyb3cgPSBmdW5jdGlvbihhcnJvdykge1xuICBhcnJvd1xuICAgIC5zdHlsZShcImJvdHRvbVwiLCBmdW5jdGlvbihkKXtcbiAgICAgIGlmIChkLmFuY2hvci55ICE9IFwiY2VudGVyXCIgJiYgIWQuZmxpcCkgcmV0dXJuIFwiLTVweFwiXG4gICAgICBlbHNlIHJldHVybiBcImF1dG9cIlxuICAgIH0pXG4gICAgLnN0eWxlKFwidG9wXCIsIGZ1bmN0aW9uKGQpe1xuICAgICAgaWYgKGQuYW5jaG9yLnkgIT0gXCJjZW50ZXJcIiAmJiBkLmZsaXApIHJldHVybiBcIi01cHhcIlxuICAgICAgZWxzZSBpZiAoZC5hbmNob3IueSA9PSBcImNlbnRlclwiKSByZXR1cm4gXCI1MCVcIlxuICAgICAgZWxzZSByZXR1cm4gXCJhdXRvXCJcbiAgICB9KVxuICAgIC5zdHlsZShcImxlZnRcIiwgZnVuY3Rpb24oZCl7XG4gICAgICBpZiAoZC5hbmNob3IueSA9PSBcImNlbnRlclwiICYmIGQuZmxpcCkgcmV0dXJuIFwiLTVweFwiXG4gICAgICBlbHNlIGlmIChkLmFuY2hvci55ICE9IFwiY2VudGVyXCIpIHJldHVybiBcIjUwJVwiXG4gICAgICBlbHNlIHJldHVybiBcImF1dG9cIlxuICAgIH0pXG4gICAgLnN0eWxlKFwicmlnaHRcIiwgZnVuY3Rpb24oZCl7XG4gICAgICBpZiAoZC5hbmNob3IueSA9PSBcImNlbnRlclwiICYmICFkLmZsaXApIHJldHVybiBcIi01cHhcIlxuICAgICAgZWxzZSByZXR1cm4gXCJhdXRvXCJcbiAgICB9KVxuICAgIC5zdHlsZShcIm1hcmdpbi1sZWZ0XCIsIGZ1bmN0aW9uKGQpe1xuICAgICAgaWYgKGQuYW5jaG9yLnkgPT0gXCJjZW50ZXJcIikge1xuICAgICAgICByZXR1cm4gXCJhdXRvXCJcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoZC5hbmNob3IueCA9PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICB2YXIgYXJyb3dfeCA9IC1kLndpZHRoLzIrZC5hcnJvd19vZmZzZXQvMlxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGQuYW5jaG9yLnggPT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgICB2YXIgYXJyb3dfeCA9IGQud2lkdGgvMi1kLmFycm93X29mZnNldCoyIC0gNVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBhcnJvd194ID0gLTVcbiAgICAgICAgfVxuICAgICAgICBpZiAoZC5jeC1kLndpZHRoLzItNSA8IGFycm93X3gpIHtcbiAgICAgICAgICBhcnJvd194ID0gZC5jeC1kLndpZHRoLzItNVxuICAgICAgICAgIGlmIChhcnJvd194IDwgMi1kLndpZHRoLzIpIGFycm93X3ggPSAyLWQud2lkdGgvMlxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC0oZC5saW1pdFswXS1kLmN4LWQud2lkdGgvMis1KSA+IGFycm93X3gpIHtcbiAgICAgICAgICB2YXIgYXJyb3dfeCA9IC0oZC5saW1pdFswXS1kLmN4LWQud2lkdGgvMis1KVxuICAgICAgICAgIGlmIChhcnJvd194ID4gZC53aWR0aC8yLTExKSBhcnJvd194ID0gZC53aWR0aC8yLTExXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycm93X3grXCJweFwiXG4gICAgICB9XG4gICAgfSlcbiAgICAuc3R5bGUoXCJtYXJnaW4tdG9wXCIsIGZ1bmN0aW9uKGQpe1xuICAgICAgaWYgKGQuYW5jaG9yLnkgIT0gXCJjZW50ZXJcIikge1xuICAgICAgICByZXR1cm4gXCJhdXRvXCJcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoZC5hbmNob3IueSA9PSBcImJvdHRvbVwiKSB7XG4gICAgICAgICAgdmFyIGFycm93X3kgPSAtZC5oZWlnaHQvMitkLmFycm93X29mZnNldC8yIC0gMVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGQuYW5jaG9yLnkgPT0gXCJ0b3BcIikge1xuICAgICAgICAgIHZhciBhcnJvd195ID0gZC5oZWlnaHQvMi1kLmFycm93X29mZnNldCoyIC0gMlxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBhcnJvd195ID0gLTlcbiAgICAgICAgfVxuICAgICAgICBpZiAoZC5jeS1kLmhlaWdodC8yLWQuYXJyb3dfb2Zmc2V0IDwgYXJyb3dfeSkge1xuICAgICAgICAgIGFycm93X3kgPSBkLmN5LWQuaGVpZ2h0LzItZC5hcnJvd19vZmZzZXRcbiAgICAgICAgICBpZiAoYXJyb3dfeSA8IDQtZC5oZWlnaHQvMikgYXJyb3dfeSA9IDQtZC5oZWlnaHQvMlxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC0oZC5saW1pdFsxXS1kLmN5LWQuaGVpZ2h0LzIrZC5hcnJvd19vZmZzZXQpID4gYXJyb3dfeSkge1xuICAgICAgICAgIHZhciBhcnJvd195ID0gLShkLmxpbWl0WzFdLWQuY3ktZC5oZWlnaHQvMitkLmFycm93X29mZnNldClcbiAgICAgICAgICBpZiAoYXJyb3dfeSA+IGQuaGVpZ2h0LzItMjIpIGFycm93X3kgPSBkLmhlaWdodC8yLTIyXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycm93X3krXCJweFwiXG4gICAgICB9XG4gICAgfSlcbn0iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIENyZWF0ZSBhIFRvb2x0aXBcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZDNwbHVzLnRvb2x0aXAuY3JlYXRlID0gZnVuY3Rpb24ocGFyYW1zKSB7XG5cbiAgdmFyIGRlZmF1bHRfd2lkdGggPSBwYXJhbXMuZnVsbHNjcmVlbiA/IDI1MCA6IDIwMFxuICAgICwgdmVuZG9yID0gZDNwbHVzLnByZWZpeCgpXG4gIHBhcmFtcy53aWR0aCA9IHBhcmFtcy53aWR0aCB8fCBkZWZhdWx0X3dpZHRoXG4gIHBhcmFtcy5tYXhfd2lkdGggPSBwYXJhbXMubWF4X3dpZHRoIHx8IDM4NlxuICBwYXJhbXMuaWQgPSBwYXJhbXMuaWQgfHwgXCJkZWZhdWx0XCJcbiAgcGFyYW1zLnNpemUgPSBwYXJhbXMuZnVsbHNjcmVlbiB8fCBwYXJhbXMuaHRtbCA/IFwibGFyZ2VcIiA6IFwic21hbGxcIlxuICBwYXJhbXMub2Zmc2V0ID0gcGFyYW1zLm9mZnNldCB8fCAwXG4gIHBhcmFtcy5hcnJvd19vZmZzZXQgPSBwYXJhbXMuYXJyb3cgPyA4IDogMFxuICBwYXJhbXMueCA9IHBhcmFtcy54IHx8IDBcbiAgcGFyYW1zLnkgPSBwYXJhbXMueSB8fCAwXG4gIHBhcmFtcy5wYXJlbnQgPSBwYXJhbXMucGFyZW50IHx8IGQzLnNlbGVjdChcImJvZHlcIilcbiAgcGFyYW1zLmN1cnRhaW4gPSBwYXJhbXMuY3VydGFpbiB8fCBcIiNmZmZcIlxuICBwYXJhbXMuY3VydGFpbm9wYWNpdHkgPSBwYXJhbXMuY3VydGFpbm9wYWNpdHkgfHwgMC44XG4gIHBhcmFtcy5iYWNrZ3JvdW5kID0gcGFyYW1zLmJhY2tncm91bmQgfHwgXCIjZmZmXCJcbiAgcGFyYW1zLmZvbnRjb2xvciA9IHBhcmFtcy5mb250Y29sb3IgfHwgXCIjNDQ0XCJcbiAgcGFyYW1zLmZvbnRmYW1pbHkgPSBwYXJhbXMuZm9udGZhbWlseSB8fCBcInNhbnMtc2VyaWZcIlxuICBwYXJhbXMuZm9udHdlaWdodCA9IHBhcmFtcy5mb250d2VpZ2h0IHx8IFwibm9ybWFsXCJcbiAgcGFyYW1zLmZvbnRzaXplID0gcGFyYW1zLmZvbnRzaXplIHx8IFwiMTJweFwiXG4gIHBhcmFtcy5zdHlsZSA9IHBhcmFtcy5zdHlsZSB8fCBcImRlZmF1bHRcIlxuICBwYXJhbXMuemluZGV4ID0gcGFyYW1zLnNpemUgPT0gXCJzbWFsbFwiID8gMjAwMCA6IDUwMFxuICBwYXJhbXMubG9jYWxlID0gcGFyYW1zLmxvY2FsZSB8fCBkM3BsdXMubG9jYWxlLmVuX1VTXG5cblxuICB2YXIgcGFyZW50SGVpZ2h0ID0gcGFyYW1zLnBhcmVudCA/IHBhcmFtcy5wYXJlbnQubm9kZSgpLm9mZnNldEhlaWdodFxuICAgICAgICAgICAgICAgICAgfHwgcGFyYW1zLnBhcmVudC5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IDogMFxuXG4gIGlmICghcGFyYW1zLmljb25zaXplKSB7XG4gICAgcGFyYW1zLmljb25zaXplID0gcGFyYW1zLnNpemUgPT0gXCJzbWFsbFwiID8gMjIgOiA1MFxuICB9XG5cbiAgcGFyYW1zLmxpbWl0ID0gW1xuICAgIHBhcnNlRmxvYXQocGFyYW1zLnBhcmVudC5zdHlsZShcIndpZHRoXCIpLDEwKSxcbiAgICBwYXJzZUZsb2F0KHBhcmFtcy5wYXJlbnQuc3R5bGUoXCJoZWlnaHRcIiksMTApXG4gIF1cblxuICBpZiAoIHBhcmFtcy50aXRsZSBpbnN0YW5jZW9mIEFycmF5ICkge1xuXG4gICAgdmFyIGFuZCA9IHBhcmFtcy5sb2NhbGUudWkuYW5kXG4gICAgICAsIG1vcmUgPSBwYXJhbXMubG9jYWxlLnVpLm1vcmVcblxuICAgIHBhcmFtcy50aXRsZSA9IGQzcGx1cy5zdHJpbmcubGlzdCggcGFyYW1zLnRpdGxlICwgYW5kICwgMyAsIG1vcmUgKVxuXG4gIH1cblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gRnVuY3Rpb24gdGhhdCBjbG9zZXMgQUxMIERlc2NyaXB0aW9uc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgdmFyIGNsb3NlX2Rlc2NyaXB0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgIGQzLnNlbGVjdEFsbChcImRpdi5kM3BsdXNfdG9vbHRpcF9kYXRhX2Rlc2NcIikuc3R5bGUoXCJoZWlnaHRcIixcIjBweFwiKVxuICAgIGQzLnNlbGVjdEFsbChcImRpdi5kM3BsdXNfdG9vbHRpcF9kYXRhX2hlbHBcIikuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsXCIjY2NjXCIpXG4gIH1cblxuICBkM3BsdXMudG9vbHRpcC5yZW1vdmUocGFyYW1zLmlkKVxuXG4gIHBhcmFtcy5hbmNob3IgPSB7fVxuICBpZiAocGFyYW1zLmZ1bGxzY3JlZW4pIHtcbiAgICBwYXJhbXMuYW5jaG9yLnggPSBcImNlbnRlclwiXG4gICAgcGFyYW1zLmFuY2hvci55ID0gXCJjZW50ZXJcIlxuICAgIHBhcmFtcy54ID0gcGFyYW1zLnBhcmVudCA/IHBhcmFtcy5wYXJlbnQubm9kZSgpLm9mZnNldFdpZHRoLzIgOiB3aW5kb3cuaW5uZXJXaWR0aC8yXG4gICAgcGFyYW1zLnkgPSBwYXJhbXMucGFyZW50ID8gcGFyZW50SGVpZ2h0LzIgOiB3aW5kb3cuaW5uZXJIZWlnaHQvMlxuICB9XG4gIGVsc2UgaWYgKHBhcmFtcy5hbGlnbikge1xuICAgIHZhciBhID0gcGFyYW1zLmFsaWduLnNwbGl0KFwiIFwiKVxuICAgIHBhcmFtcy5hbmNob3IueSA9IGFbMF1cbiAgICBpZiAoYVsxXSkgcGFyYW1zLmFuY2hvci54ID0gYVsxXVxuICAgIGVsc2UgcGFyYW1zLmFuY2hvci54ID0gXCJjZW50ZXJcIlxuICB9XG4gIGVsc2Uge1xuICAgIHBhcmFtcy5hbmNob3IueCA9IFwiY2VudGVyXCJcbiAgICBwYXJhbXMuYW5jaG9yLnkgPSBcInRvcFwiXG4gIH1cblxuICB2YXIgdGl0bGVfd2lkdGggPSBwYXJhbXMud2lkdGggLSAzMFxuXG4gIGlmIChwYXJhbXMuZnVsbHNjcmVlbikge1xuICAgIHZhciBjdXJ0YWluID0gcGFyYW1zLnBhcmVudC5hcHBlbmQoXCJkaXZcIilcbiAgICAgIC5hdHRyKFwiaWRcIixcImQzcGx1c190b29sdGlwX2N1cnRhaW5fXCIrcGFyYW1zLmlkKVxuICAgICAgLmF0dHIoXCJjbGFzc1wiLFwiZDNwbHVzX3Rvb2x0aXBfY3VydGFpblwiKVxuICAgICAgLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLHBhcmFtcy5jdXJ0YWluKVxuICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLHBhcmFtcy5jdXJ0YWlub3BhY2l0eSlcbiAgICAgIC5zdHlsZShcInBvc2l0aW9uXCIsXCJhYnNvbHV0ZVwiKVxuICAgICAgLnN0eWxlKFwiei1pbmRleFwiLDQ5OSlcbiAgICAgIC5zdHlsZShcInRvcFwiLFwiMHB4XCIpXG4gICAgICAuc3R5bGUoXCJyaWdodFwiLFwiMHB4XCIpXG4gICAgICAuc3R5bGUoXCJib3R0b21cIixcIjBweFwiKVxuICAgICAgLnN0eWxlKFwibGVmdFwiLFwiMHB4XCIpXG4gICAgICAub24oZDNwbHVzLmV2dC5jbGljayxmdW5jdGlvbigpe1xuICAgICAgICBkM3BsdXMudG9vbHRpcC5yZW1vdmUocGFyYW1zLmlkKVxuICAgICAgfSlcbiAgfVxuXG4gIHZhciB0b29sdGlwID0gcGFyYW1zLnBhcmVudC5hcHBlbmQoXCJkaXZcIilcbiAgICAuZGF0dW0ocGFyYW1zKVxuICAgIC5hdHRyKFwiaWRcIixcImQzcGx1c190b29sdGlwX2lkX1wiK3BhcmFtcy5pZClcbiAgICAuYXR0cihcImNsYXNzXCIsXCJkM3BsdXNfdG9vbHRpcCBkM3BsdXNfdG9vbHRpcF9cIitwYXJhbXMuc2l6ZSlcbiAgICAuc3R5bGUoXCJjb2xvclwiLHBhcmFtcy5mb250Y29sb3IpXG4gICAgLnN0eWxlKFwiZm9udC1mYW1pbHlcIixwYXJhbXMuZm9udGZhbWlseSlcbiAgICAuc3R5bGUoXCJmb250LXdlaWdodFwiLHBhcmFtcy5mb250d2VpZ2h0KVxuICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLHBhcmFtcy5mb250c2l6ZStcInB4XCIpXG4gICAgLnN0eWxlKHZlbmRvcitcImJveC1zaGFkb3dcIixcIjBweCAxcHggM3B4IHJnYmEoMCwgMCwgMCwgMC4yNSlcIilcbiAgICAuc3R5bGUoXCJwb3NpdGlvblwiLFwiYWJzb2x1dGVcIilcbiAgICAuc3R5bGUoXCJ6LWluZGV4XCIscGFyYW1zLnppbmRleClcbiAgICAub24oZDNwbHVzLmV2dC5vdXQsZnVuY3Rpb24oKXtcbiAgICAgIGNsb3NlX2Rlc2NyaXB0aW9ucygpXG4gICAgfSlcblxuICBpZiAocGFyYW1zLm1heF9oZWlnaHQpIHtcbiAgICB0b29sdGlwLnN0eWxlKFwibWF4LWhlaWdodFwiLHBhcmFtcy5tYXhfaGVpZ2h0K1wicHhcIilcbiAgfVxuXG4gIGlmIChwYXJhbXMuZml4ZWQpIHtcbiAgICB0b29sdGlwLnN0eWxlKFwiei1pbmRleFwiLDUwMClcbiAgICBwYXJhbXMubW91c2VldmVudHMgPSB0cnVlXG4gIH1cbiAgZWxzZSB7XG4gICAgdG9vbHRpcC5zdHlsZShcInotaW5kZXhcIiwyMDAwKVxuICB9XG5cbiAgdmFyIGNvbnRhaW5lciA9IHRvb2x0aXAuYXBwZW5kKFwiZGl2XCIpXG4gICAgLmRhdHVtKHBhcmFtcylcbiAgICAuYXR0cihcImNsYXNzXCIsXCJkM3BsdXNfdG9vbHRpcF9jb250YWluZXJcIilcbiAgICAuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIscGFyYW1zLmJhY2tncm91bmQpXG4gICAgLnN0eWxlKFwicGFkZGluZ1wiLFwiNnB4XCIpXG5cbiAgaWYgKHBhcmFtcy5mdWxsc2NyZWVuICYmIHBhcmFtcy5odG1sKSB7XG5cbiAgICB3ID0gcGFyYW1zLnBhcmVudCA/IHBhcmFtcy5wYXJlbnQubm9kZSgpLm9mZnNldFdpZHRoKjAuNzUgOiB3aW5kb3cuaW5uZXJXaWR0aCowLjc1XG4gICAgaCA9IHBhcmFtcy5wYXJlbnQgPyBwYXJlbnRIZWlnaHQqMC43NSA6IHdpbmRvdy5pbm5lckhlaWdodCowLjc1XG5cbiAgICBjb250YWluZXJcbiAgICAgIC5zdHlsZShcIndpZHRoXCIsdytcInB4XCIpXG4gICAgICAuc3R5bGUoXCJoZWlnaHRcIixoK1wicHhcIilcblxuICAgIHZhciBib2R5ID0gY29udGFpbmVyLmFwcGVuZChcImRpdlwiKVxuICAgICAgLmF0dHIoXCJjbGFzc1wiLFwiZDNwbHVzX3Rvb2x0aXBfYm9keVwiKVxuICAgICAgLnN0eWxlKFwicGFkZGluZy1yaWdodFwiLFwiNnB4XCIpXG4gICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsXCJpbmxpbmUtYmxvY2tcIilcbiAgICAgIC5zdHlsZShcInotaW5kZXhcIiwxKVxuICAgICAgLnN0eWxlKFwid2lkdGhcIixwYXJhbXMud2lkdGgrXCJweFwiKVxuXG4gIH1cbiAgZWxzZSB7XG5cbiAgICBpZiAocGFyYW1zLndpZHRoID09IFwiYXV0b1wiKSB7XG4gICAgICB2YXIgdyA9IFwiYXV0b1wiXG4gICAgICBjb250YWluZXIuc3R5bGUoXCJtYXgtd2lkdGhcIixwYXJhbXMubWF4X3dpZHRoK1wicHhcIilcbiAgICB9XG4gICAgZWxzZSB2YXIgdyA9IHBhcmFtcy53aWR0aC0xNCtcInB4XCJcblxuICAgIHZhciBib2R5ID0gY29udGFpbmVyXG4gICAgICAuc3R5bGUoXCJ3aWR0aFwiLHcpXG5cbiAgfVxuXG4gIGlmIChwYXJhbXMudGl0bGUgfHwgcGFyYW1zLmljb24pIHtcbiAgICB2YXIgaGVhZGVyID0gYm9keS5hcHBlbmQoXCJkaXZcIilcbiAgICAgIC5hdHRyKFwiY2xhc3NcIixcImQzcGx1c190b29sdGlwX2hlYWRlclwiKVxuICAgICAgLnN0eWxlKFwicG9zaXRpb25cIixcInJlbGF0aXZlXCIpXG4gICAgICAuc3R5bGUoXCJ6LWluZGV4XCIsMSlcbiAgfVxuXG4gIGlmIChwYXJhbXMuZnVsbHNjcmVlbikge1xuICAgIHZhciBjbG9zZSA9IHRvb2x0aXAuYXBwZW5kKFwiZGl2XCIpXG4gICAgICAuYXR0cihcImNsYXNzXCIsXCJkM3BsdXNfdG9vbHRpcF9jbG9zZVwiKVxuICAgICAgLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLHBhcmFtcy5jb2xvcilcbiAgICAgIC5zdHlsZShcImNvbG9yXCIsZDNwbHVzLmNvbG9yLnRleHQocGFyYW1zLmNvbG9yKSlcbiAgICAgIC5zdHlsZShcInBvc2l0aW9uXCIsXCJhYnNvbHV0ZVwiKVxuICAgICAgLnN0eWxlKHZlbmRvcitcImJveC1zaGFkb3dcIixcIjAgMXB4IDNweCByZ2JhKDAsIDAsIDAsIDAuMjUpXCIpXG4gICAgICAuc3R5bGUoXCJmb250LXNpemVcIixcIjIwcHhcIilcbiAgICAgIC5zdHlsZShcImhlaWdodFwiLFwiMThweFwiKVxuICAgICAgLnN0eWxlKFwibGluZS1oZWlnaHRcIixcIjE0cHhcIilcbiAgICAgIC5zdHlsZShcInRleHQtYWxpZ25cIixcImNlbnRlclwiKVxuICAgICAgLnN0eWxlKFwicmlnaHRcIixcIjE2cHhcIilcbiAgICAgIC5zdHlsZShcInRvcFwiLFwiLTEwcHhcIilcbiAgICAgIC5zdHlsZShcIndpZHRoXCIsXCIxOHB4XCIpXG4gICAgICAuc3R5bGUoXCJ6LWluZGV4XCIsMTApXG4gICAgICAuaHRtbChcIlxcJnRpbWVzO1wiKVxuICAgICAgLm9uKGQzcGx1cy5ldnQub3ZlcixmdW5jdGlvbigpe1xuICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAuc3R5bGUoXCJjdXJzb3JcIixcInBvaW50ZXJcIilcbiAgICAgICAgICAuc3R5bGUodmVuZG9yK1wiYm94LXNoYWRvd1wiLFwiMCAxcHggM3B4IHJnYmEoMCwgMCwgMCwgMC41KVwiKVxuICAgICAgfSlcbiAgICAgIC5vbihkM3BsdXMuZXZ0Lm91dCxmdW5jdGlvbigpe1xuICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAuc3R5bGUoXCJjdXJzb3JcIixcImF1dG9cIilcbiAgICAgICAgICAuc3R5bGUodmVuZG9yK1wiYm94LXNoYWRvd1wiLFwiMCAxcHggM3B4IHJnYmEoMCwgMCwgMCwgMC4yNSlcIilcbiAgICAgIH0pXG4gICAgICAub24oZDNwbHVzLmV2dC5jbGljayxmdW5jdGlvbigpe1xuICAgICAgICBkM3BsdXMudG9vbHRpcC5yZW1vdmUocGFyYW1zLmlkKVxuICAgICAgfSlcbiAgfVxuXG4gIGlmICghcGFyYW1zLm1vdXNlZXZlbnRzKSB7XG4gICAgdG9vbHRpcC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsXCJub25lXCIpXG4gIH1cbiAgZWxzZSBpZiAocGFyYW1zLm1vdXNlZXZlbnRzICE9PSB0cnVlKSB7XG5cbiAgICB2YXIgb2xkb3V0ID0gZDMuc2VsZWN0KHBhcmFtcy5tb3VzZWV2ZW50cykub24oZDNwbHVzLmV2dC5vdXQpXG5cbiAgICB2YXIgbmV3b3V0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciB0YXJnZXQgPSBkMy5ldmVudC50b0VsZW1lbnQgfHwgZDMuZXZlbnQucmVsYXRlZFRhcmdldFxuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICB2YXIgYyA9IHR5cGVvZiB0YXJnZXQuY2xhc3NOYW1lID09IFwic3RyaW5nXCIgPyB0YXJnZXQuY2xhc3NOYW1lIDogdGFyZ2V0LmNsYXNzTmFtZS5iYXNlVmFsXG4gICAgICAgIHZhciBpc3Rvb2x0aXAgPSBjLmluZGV4T2YoXCJkM3BsdXNfdG9vbHRpcFwiKSA9PSAwXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGlzdG9vbHRpcCA9IGZhbHNlXG4gICAgICB9XG4gICAgICBpZiAoIXRhcmdldCB8fCAoIWlzY2hpbGQodG9vbHRpcC5ub2RlKCksdGFyZ2V0KSAmJiAhaXNjaGlsZChwYXJhbXMubW91c2VldmVudHMsdGFyZ2V0KSAmJiAhaXN0b29sdGlwKSkge1xuICAgICAgICBvbGRvdXQoZDMuc2VsZWN0KHBhcmFtcy5tb3VzZWV2ZW50cykuZGF0dW0oKSlcbiAgICAgICAgY2xvc2VfZGVzY3JpcHRpb25zKClcbiAgICAgICAgZDMuc2VsZWN0KHBhcmFtcy5tb3VzZWV2ZW50cykub24oZDNwbHVzLmV2dC5vdXQsb2xkb3V0KVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc2NoaWxkID0gZnVuY3Rpb24ocGFyZW50LCBjaGlsZCkge1xuICAgICAgIHZhciBub2RlID0gY2hpbGQucGFyZW50Tm9kZTtcbiAgICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgaWYgKG5vZGUgPT0gcGFyZW50KSB7XG4gICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgfVxuICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICB9XG4gICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGQzLnNlbGVjdChwYXJhbXMubW91c2VldmVudHMpLm9uKGQzcGx1cy5ldnQub3V0LG5ld291dClcbiAgICB0b29sdGlwLm9uKGQzcGx1cy5ldnQub3V0LG5ld291dClcblxuICAgIHZhciBtb3ZlX2V2ZW50ID0gZDMuc2VsZWN0KHBhcmFtcy5tb3VzZWV2ZW50cykub24oZDNwbHVzLmV2dC5tb3ZlKVxuICAgIGlmIChtb3ZlX2V2ZW50KSB7XG4gICAgICB0b29sdGlwLm9uKGQzcGx1cy5ldnQubW92ZSxtb3ZlX2V2ZW50KVxuICAgIH1cblxuICB9XG5cbiAgaWYgKHBhcmFtcy5hcnJvdykge1xuICAgIHZhciBhcnJvdyA9IHRvb2x0aXAuYXBwZW5kKFwiZGl2XCIpXG4gICAgICAuYXR0cihcImNsYXNzXCIsXCJkM3BsdXNfdG9vbHRpcF9hcnJvd1wiKVxuICAgICAgLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLHBhcmFtcy5iYWNrZ3JvdW5kKVxuICAgICAgLnN0eWxlKHZlbmRvcitcImJveC1zaGFkb3dcIixcIjBweCAxcHggM3B4IHJnYmEoMCwgMCwgMCwgMC4yNSlcIilcbiAgICAgIC5zdHlsZShcInBvc2l0aW9uXCIsXCJhYnNvbHV0ZVwiKVxuICAgICAgLnN0eWxlKFwiYm90dG9tXCIsXCItNXB4XCIpXG4gICAgICAuc3R5bGUoXCJoZWlnaHRcIixcIjEwcHhcIilcbiAgICAgIC5zdHlsZShcImxlZnRcIixcIjUwJVwiKVxuICAgICAgLnN0eWxlKFwibWFyZ2luLWxlZnRcIixcIi01cHhcIilcbiAgICAgIC5zdHlsZShcIndpZHRoXCIsXCIxMHB4XCIpXG4gICAgICAuc3R5bGUodmVuZG9yK1widHJhbnNmb3JtXCIsXCJyb3RhdGUoNDVkZWcpXCIpXG4gICAgICAuc3R5bGUoXCJ6LWluZGV4XCIsLTEpXG4gIH1cblxuICBpZiAocGFyYW1zLmljb24pIHtcblxuICAgIHZhciB0aXRsZV9pY29uID0gaGVhZGVyLmFwcGVuZChcImRpdlwiKVxuICAgICAgLmF0dHIoXCJjbGFzc1wiLFwiZDNwbHVzX3Rvb2x0aXBfaWNvblwiKVxuICAgICAgLnN0eWxlKFwid2lkdGhcIixwYXJhbXMuaWNvbnNpemUrXCJweFwiKVxuICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIscGFyYW1zLmljb25zaXplK1wicHhcIilcbiAgICAgIC5zdHlsZShcInotaW5kZXhcIiwxKVxuICAgICAgLnN0eWxlKFwiYmFja2dyb3VuZC1wb3NpdGlvblwiLFwiNTAlXCIpXG4gICAgICAuc3R5bGUoXCJiYWNrZ3JvdW5kLXNpemVcIixcIjEwMCVcIilcbiAgICAgIC5zdHlsZShcImJhY2tncm91bmQtaW1hZ2VcIixcInVybChcIitwYXJhbXMuaWNvbitcIilcIilcbiAgICAgIC5zdHlsZShcImRpc3BsYXlcIixcImlubGluZS1ibG9ja1wiKVxuICAgICAgLnN0eWxlKFwibWFyZ2luXCIsXCIwcHggM3B4IDNweCAwcHhcIilcblxuICAgIGlmIChwYXJhbXMuc3R5bGUgPT0gXCJrbm9ja291dFwiKSB7XG4gICAgICB0aXRsZV9pY29uLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLHBhcmFtcy5jb2xvcilcbiAgICB9XG5cbiAgICB0aXRsZV93aWR0aCAtPSB0aXRsZV9pY29uLm5vZGUoKS5vZmZzZXRXaWR0aFxuICB9XG5cbiAgaWYgKHBhcmFtcy50aXRsZSkge1xuICAgIHZhciBtdyA9IHBhcmFtcy5tYXhfd2lkdGgtNlxuICAgIGlmICggcGFyYW1zLmljb24gKSBtdyAtPSAocGFyYW1zLmljb25zaXplKzYpXG4gICAgbXcgKz0gXCJweFwiXG5cbiAgICB2YXIgdGl0bGUgPSBoZWFkZXIuYXBwZW5kKFwiZGl2XCIpXG4gICAgICAuYXR0cihcImNsYXNzXCIsXCJkM3BsdXNfdG9vbHRpcF90aXRsZVwiKVxuICAgICAgLnN0eWxlKFwibWF4LXdpZHRoXCIsbXcpXG4gICAgICAuc3R5bGUoXCJjb2xvclwiLCFwYXJhbXMuaWNvbiA/IGQzcGx1cy5jb2xvci5sZWdpYmxlKHBhcmFtcy5jb2xvcikgOiBwYXJhbXMuZm9udGNvbG9yKVxuICAgICAgLnN0eWxlKFwidmVydGljYWwtYWxpZ25cIixcInRvcFwiKVxuICAgICAgLnN0eWxlKFwid2lkdGhcIix0aXRsZV93aWR0aCtcInB4XCIpXG4gICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsXCJpbmxpbmUtYmxvY2tcIilcbiAgICAgIC5zdHlsZShcIm92ZXJmbG93XCIsXCJoaWRkZW5cIilcbiAgICAgIC5zdHlsZShcInRleHQtb3ZlcmZsb3dcIixcImVsbGlwc2lzXCIpXG4gICAgICAuc3R5bGUoXCJ3b3JkLXdyYXBcIixcImJyZWFrLXdvcmRcIilcbiAgICAgIC5zdHlsZShcInotaW5kZXhcIiwxKVxuICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIscGFyYW1zLnNpemUgPT09IFwibGFyZ2VcIiA/IFwiMThweFwiIDogXCIxNnB4XCIpXG4gICAgICAuc3R5bGUoXCJsaW5lLWhlaWdodFwiLHBhcmFtcy5zaXplID09PSBcImxhcmdlXCIgPyBcIjIwcHhcIiA6IFwiMTdweFwiKVxuICAgICAgLnN0eWxlKFwicGFkZGluZ1wiLHBhcmFtcy5zaXplID09PSBcImxhcmdlXCIgPyBcIjNweCA2cHhcIiA6IFwiM3B4XCIpXG4gICAgICAudGV4dChwYXJhbXMudGl0bGUpXG4gIH1cblxuICBpZiAocGFyYW1zLmRlc2NyaXB0aW9uKSB7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gYm9keS5hcHBlbmQoXCJkaXZcIilcbiAgICAgIC5hdHRyKFwiY2xhc3NcIixcImQzcGx1c190b29sdGlwX2Rlc2NyaXB0aW9uXCIpXG4gICAgICAuc3R5bGUoXCJmb250LXNpemVcIixcIjEycHhcIilcbiAgICAgIC5zdHlsZShcInBhZGRpbmdcIixcIjZweFwiKVxuICAgICAgLnRleHQocGFyYW1zLmRlc2NyaXB0aW9uKVxuICB9XG5cbiAgaWYgKHBhcmFtcy5kYXRhIHx8IHBhcmFtcy5odG1sICYmICFwYXJhbXMuZnVsbHNjcmVlbikge1xuXG4gICAgdmFyIGRhdGFfY29udGFpbmVyID0gYm9keS5hcHBlbmQoXCJkaXZcIilcbiAgICAgIC5hdHRyKFwiY2xhc3NcIixcImQzcGx1c190b29sdGlwX2RhdGFfY29udGFpbmVyXCIpXG4gICAgICAuc3R5bGUoXCJvdmVyZmxvdy15XCIsXCJhdXRvXCIpXG4gICAgICAuc3R5bGUoXCJ6LWluZGV4XCIsLTEpXG4gIH1cblxuICBpZiAocGFyYW1zLmRhdGEpIHtcblxuICAgIHZhciB2YWxfd2lkdGggPSAwLCB2YWxfaGVpZ2h0cyA9IHt9XG5cbiAgICB2YXIgbGFzdF9ncm91cCA9IG51bGxcbiAgICBwYXJhbXMuZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQsaSl7XG5cbiAgICAgIGlmIChkLmdyb3VwKSB7XG4gICAgICAgIGlmIChsYXN0X2dyb3VwICE9IGQuZ3JvdXApIHtcbiAgICAgICAgICBsYXN0X2dyb3VwID0gZC5ncm91cFxuICAgICAgICAgIGRhdGFfY29udGFpbmVyLmFwcGVuZChcImRpdlwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLFwiZDNwbHVzX3Rvb2x0aXBfZGF0YV90aXRsZVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsXCIxMnB4XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmb250LXdlaWdodFwiLFwiYm9sZFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwicGFkZGluZ1wiLFwiNnB4IDNweCAwcHggM3B4XCIpXG4gICAgICAgICAgICAudGV4dChkLmdyb3VwKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBibG9jayA9IGRhdGFfY29udGFpbmVyLmFwcGVuZChcImRpdlwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsXCJkM3BsdXNfdG9vbHRpcF9kYXRhX2Jsb2NrXCIpXG4gICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLFwiMTJweFwiKVxuICAgICAgICAuc3R5bGUoXCJwYWRkaW5nXCIsXCIzcHggNnB4XCIpXG4gICAgICAgIC5zdHlsZShcInBvc2l0aW9uXCIsXCJyZWxhdGl2ZVwiKVxuICAgICAgICAuZGF0dW0oZClcblxuICAgICAgaWYgKCBkLmhpZ2hsaWdodCA9PT0gdHJ1ZSApIHtcbiAgICAgICAgYmxvY2suc3R5bGUoXCJjb2xvclwiLGQzcGx1cy5jb2xvci5sZWdpYmxlKHBhcmFtcy5jb2xvcikpXG4gICAgICB9XG4gICAgICBlbHNlIGlmICggZC5hbGxDb2xvcnMgfHwgZC5oaWdobGlnaHQgIT09IHBhcmFtcy5jb2xvciApIHtcbiAgICAgICAgYmxvY2suc3R5bGUoXCJjb2xvclwiLGQzcGx1cy5jb2xvci5sZWdpYmxlKGQuaGlnaGxpZ2h0KSlcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSBibG9jay5hcHBlbmQoXCJkaXZcIilcbiAgICAgICAgICAuYXR0cihcImNsYXNzXCIsXCJkM3BsdXNfdG9vbHRpcF9kYXRhX25hbWVcIilcbiAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsXCJpbmxpbmUtYmxvY2tcIilcbiAgICAgICAgICAuaHRtbChkLm5hbWUpXG4gICAgICAgICAgLm9uKGQzcGx1cy5ldnQub3V0LGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgIH0pXG5cbiAgICAgIGlmICggZC52YWx1ZSBpbnN0YW5jZW9mIEFycmF5ICkge1xuXG4gICAgICAgIHZhciBhbmQgPSBwYXJhbXMubG9jYWxlLnVpLmFuZFxuICAgICAgICAgICwgbW9yZSA9IHBhcmFtcy5sb2NhbGUudWkubW9yZVxuXG4gICAgICAgIGQudmFsdWUgPSBkM3BsdXMuc3RyaW5nLmxpc3QoIGQudmFsdWUgLCBhbmQgLCAzICwgbW9yZSApXG5cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbCA9IGJsb2NrLmFwcGVuZChcImRpdlwiKVxuICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIixcImQzcGx1c190b29sdGlwX2RhdGFfdmFsdWVcIilcbiAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsXCJibG9ja1wiKVxuICAgICAgICAgIC5zdHlsZShcInBvc2l0aW9uXCIsXCJhYnNvbHV0ZVwiKVxuICAgICAgICAgIC5zdHlsZShcInRleHQtYWxpZ25cIixcInJpZ2h0XCIpXG4gICAgICAgICAgLnN0eWxlKFwidG9wXCIsXCIzcHhcIilcbiAgICAgICAgICAudGV4dChkLnZhbHVlKVxuICAgICAgICAgIC5vbihkM3BsdXMuZXZ0Lm91dCxmdW5jdGlvbigpe1xuICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICB9KVxuXG4gICAgICBpZiAoZDNwbHVzLnJ0bCkge1xuICAgICAgICB2YWwuc3R5bGUoXCJsZWZ0XCIsXCI2cHhcIilcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YWwuc3R5bGUoXCJyaWdodFwiLFwiNnB4XCIpXG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMubW91c2VldmVudHMgJiYgZC5kZXNjKSB7XG4gICAgICAgIHZhciBkZXNjID0gYmxvY2suYXBwZW5kKFwiZGl2XCIpXG4gICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLFwiZDNwbHVzX3Rvb2x0aXBfZGF0YV9kZXNjXCIpXG4gICAgICAgICAgLnN0eWxlKFwiY29sb3JcIixcIiM4ODhcIilcbiAgICAgICAgICAuc3R5bGUoXCJvdmVyZmxvd1wiLFwiaGlkZGVuXCIpXG4gICAgICAgICAgLnN0eWxlKHZlbmRvcitcInRyYW5zaXRpb25cIixcImhlaWdodCAwLjVzXCIpXG4gICAgICAgICAgLnN0eWxlKFwid2lkdGhcIixcIjg1JVwiKVxuICAgICAgICAgIC50ZXh0KGQuZGVzYylcbiAgICAgICAgICAub24oZDNwbHVzLmV2dC5vdXQsZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgfSlcblxuICAgICAgICB2YXIgZGggPSBkZXNjLm5vZGUoKS5vZmZzZXRIZWlnaHQgfHwgZGVzYy5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG5cbiAgICAgICAgZGVzYy5zdHlsZShcImhlaWdodFwiLFwiMHB4XCIpXG5cbiAgICAgICAgdmFyIGhlbHAgPSBuYW1lLmFwcGVuZChcImRpdlwiKVxuICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIixcImQzcGx1c190b29sdGlwX2RhdGFfaGVscFwiKVxuICAgICAgICAgIC5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIixcIiNjY2NcIilcbiAgICAgICAgICAuc3R5bGUodmVuZG9yK1wiYm9yZGVyLXJhZGl1c1wiLFwiNXB4XCIpXG4gICAgICAgICAgLnN0eWxlKFwiY29sb3JcIixcIiNmZmZcIilcbiAgICAgICAgICAuc3R5bGUoXCJjdXJzb3JcIixcInBvaW50ZXJcIilcbiAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsXCJpbmxpbmUtYmxvY2tcIilcbiAgICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIixcIjhweFwiKVxuICAgICAgICAgIC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsXCJib2xkXCIpXG4gICAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsXCIxMHB4XCIpXG4gICAgICAgICAgLnN0eWxlKFwibWFyZ2luXCIsXCIzcHggMHB4IDBweCAzcHhcIilcbiAgICAgICAgICAuc3R5bGUoXCJwYWRkaW5nLXJpZ2h0XCIsXCIxcHhcIilcbiAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFsaWduXCIsXCJjZW50ZXJcIilcbiAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLFwiMTBweFwiKVxuICAgICAgICAgIC5zdHlsZShcInZlcnRpY2FsLWFsaWduXCIsXCJ0b3BcIilcbiAgICAgICAgICAuc3R5bGUocHJlZml4K1widHJhbnNpdGlvblwiLFwiYmFja2dyb3VuZC1jb2xvciAwLjVzXCIpXG4gICAgICAgICAgLnRleHQoXCI/XCIpXG4gICAgICAgICAgLm9uKGQzcGx1cy5ldnQub3ZlcixmdW5jdGlvbigpe1xuICAgICAgICAgICAgdmFyIGMgPSBkMy5zZWxlY3QodGhpcy5wYXJlbnROb2RlLnBhcmVudE5vZGUpLnN0eWxlKFwiY29sb3JcIilcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIixjKVxuICAgICAgICAgICAgZGVzYy5zdHlsZShcImhlaWdodFwiLGRoK1wicHhcIilcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vbihkM3BsdXMuZXZ0Lm91dCxmdW5jdGlvbigpe1xuICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICB9KVxuXG4gICAgICAgIG5hbWVcbiAgICAgICAgICAuc3R5bGUoXCJjdXJzb3JcIixcInBvaW50ZXJcIilcbiAgICAgICAgICAub24oZDNwbHVzLmV2dC5vdmVyLGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBjbG9zZV9kZXNjcmlwdGlvbnMoKVxuICAgICAgICAgICAgdmFyIGMgPSBkMy5zZWxlY3QodGhpcy5wYXJlbnROb2RlKS5zdHlsZShcImNvbG9yXCIpXG4gICAgICAgICAgICBoZWxwLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLGMpXG4gICAgICAgICAgICBkZXNjLnN0eWxlKFwiaGVpZ2h0XCIsZGgrXCJweFwiKVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgYmxvY2sub24oZDNwbHVzLmV2dC5vdXQsZnVuY3Rpb24oKXtcbiAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgIGNsb3NlX2Rlc2NyaXB0aW9ucygpXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHZhciB3ID0gcGFyc2VGbG9hdCh2YWwuc3R5bGUoXCJ3aWR0aFwiKSwxMClcbiAgICAgIGlmICh3ID4gcGFyYW1zLndpZHRoLzIpIHcgPSBwYXJhbXMud2lkdGgvMlxuICAgICAgaWYgKHcgPiB2YWxfd2lkdGgpIHZhbF93aWR0aCA9IHdcblxuICAgICAgaWYgKGkgIT0gcGFyYW1zLmRhdGEubGVuZ3RoLTEpIHtcbiAgICAgICAgaWYgKChkLmdyb3VwICYmIGQuZ3JvdXAgPT0gcGFyYW1zLmRhdGFbaSsxXS5ncm91cCkgfHwgIWQuZ3JvdXAgJiYgIXBhcmFtcy5kYXRhW2krMV0uZ3JvdXApXG4gICAgICAgIGRhdGFfY29udGFpbmVyLmFwcGVuZChcImRpdlwiKVxuICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIixcImQzcGx1c190b29sdGlwX2RhdGFfc2VwZXJhdG9yXCIpXG4gICAgICAgICAgLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLFwiI2RkZFwiKVxuICAgICAgICAgIC5zdHlsZShcImRpc3BsYXlcIixcImJsb2NrXCIpXG4gICAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsXCIxcHhcIilcbiAgICAgICAgICAuc3R5bGUoXCJtYXJnaW5cIixcIjBweCAzcHhcIilcbiAgICAgIH1cblxuICAgIH0pXG5cbiAgICBkYXRhX2NvbnRhaW5lci5zZWxlY3RBbGwoXCIuZDNwbHVzX3Rvb2x0aXBfZGF0YV9uYW1lXCIpXG4gICAgICAuc3R5bGUoXCJ3aWR0aFwiLGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB3ID0gcGFyc2VGbG9hdChkMy5zZWxlY3QodGhpcy5wYXJlbnROb2RlKS5zdHlsZShcIndpZHRoXCIpLDEwKVxuICAgICAgICByZXR1cm4gKHctdmFsX3dpZHRoLTMwKStcInB4XCJcbiAgICAgIH0pXG5cbiAgICBkYXRhX2NvbnRhaW5lci5zZWxlY3RBbGwoXCIuZDNwbHVzX3Rvb2x0aXBfZGF0YV92YWx1ZVwiKVxuICAgICAgLnN0eWxlKFwid2lkdGhcIix2YWxfd2lkdGgrXCJweFwiKVxuICAgICAgLmVhY2goZnVuY3Rpb24oZCl7XG4gICAgICAgIHZhciBoID0gcGFyc2VGbG9hdChkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJoZWlnaHRcIiksMTApXG4gICAgICAgIHZhbF9oZWlnaHRzW2QubmFtZV0gPSBoXG4gICAgICB9KVxuXG4gICAgZGF0YV9jb250YWluZXIuc2VsZWN0QWxsKFwiLmQzcGx1c190b29sdGlwX2RhdGFfbmFtZVwiKVxuICAgICAgLnN0eWxlKFwibWluLWhlaWdodFwiLGZ1bmN0aW9uKGQpe1xuICAgICAgICByZXR1cm4gdmFsX2hlaWdodHNbZC5uYW1lXStcInB4XCJcbiAgICAgIH0pXG5cbiAgfVxuXG4gIGlmIChwYXJhbXMuaHRtbCAmJiAhcGFyYW1zLmZ1bGxzY3JlZW4pIHtcbiAgICBkYXRhX2NvbnRhaW5lci5hcHBlbmQoXCJkaXZcIilcbiAgICAgIC5odG1sKHBhcmFtcy5odG1sKVxuICB9XG5cbiAgdmFyIGZvb3RlciA9IGJvZHkuYXBwZW5kKFwiZGl2XCIpXG4gICAgLmF0dHIoXCJjbGFzc1wiLFwiZDNwbHVzX3Rvb2x0aXBfZm9vdGVyXCIpXG4gICAgLnN0eWxlKFwiZm9udC1zaXplXCIsXCIxMHB4XCIpXG4gICAgLnN0eWxlKFwicG9zaXRpb25cIixcInJlbGF0aXZlXCIpXG4gICAgLnN0eWxlKFwidGV4dC1hbGlnblwiLFwiY2VudGVyXCIpXG5cbiAgaWYgKHBhcmFtcy5mb290ZXIpIHtcbiAgICBmb290ZXIuaHRtbChwYXJhbXMuZm9vdGVyKVxuICB9XG5cbiAgcGFyYW1zLmhlaWdodCA9IHRvb2x0aXAubm9kZSgpLm9mZnNldEhlaWdodCB8fCB0b29sdGlwLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcblxuICBpZiAocGFyYW1zLmh0bWwgJiYgcGFyYW1zLmZ1bGxzY3JlZW4pIHtcbiAgICB2YXIgaCA9IHBhcmFtcy5oZWlnaHQtMTJcbiAgICB2YXIgdyA9IHRvb2x0aXAubm9kZSgpLm9mZnNldFdpZHRoLXBhcmFtcy53aWR0aC00NFxuICAgIGNvbnRhaW5lci5hcHBlbmQoXCJkaXZcIilcbiAgICAgIC5hdHRyKFwiY2xhc3NcIixcImQzcGx1c190b29sdGlwX2h0bWxcIilcbiAgICAgIC5zdHlsZShcIndpZHRoXCIsdytcInB4XCIpXG4gICAgICAuc3R5bGUoXCJoZWlnaHRcIixoK1wicHhcIilcbiAgICAgIC5zdHlsZShcImRpc3BsYXlcIixcImlubGluZS1ibG9ja1wiKVxuICAgICAgLnN0eWxlKFwidmVydGljYWwtYWxpZ25cIixcInRvcFwiKVxuICAgICAgLnN0eWxlKFwib3ZlcmZsb3cteVwiLFwiYXV0b1wiKVxuICAgICAgLnN0eWxlKFwicGFkZGluZ1wiLFwiMHB4IDEycHhcIilcbiAgICAgIC5zdHlsZShcInBvc2l0aW9uXCIsXCJhYnNvbHV0ZVwiKVxuICAgICAgLmh0bWwocGFyYW1zLmh0bWwpXG4gIH1cblxuICBwYXJhbXMud2lkdGggPSB0b29sdGlwLm5vZGUoKS5vZmZzZXRXaWR0aFxuXG4gIGlmIChwYXJhbXMuYW5jaG9yLnkgIT0gXCJjZW50ZXJcIikgcGFyYW1zLmhlaWdodCArPSBwYXJhbXMuYXJyb3dfb2Zmc2V0XG4gIGVsc2UgcGFyYW1zLndpZHRoICs9IHBhcmFtcy5hcnJvd19vZmZzZXRcblxuICBpZiAocGFyYW1zLmRhdGEgfHwgKCFwYXJhbXMuZnVsbHNjcmVlbiAmJiBwYXJhbXMuaHRtbCkpIHtcblxuICAgIGlmICghcGFyYW1zLmZ1bGxzY3JlZW4pIHtcbiAgICAgIHZhciBsaW1pdCA9IHBhcmFtcy5maXhlZCA/IHBhcmVudEhlaWdodC1wYXJhbXMueS0xMCA6IHBhcmVudEhlaWdodC0xMFxuICAgICAgdmFyIGggPSBwYXJhbXMuaGVpZ2h0IDwgbGltaXQgPyBwYXJhbXMuaGVpZ2h0IDogbGltaXRcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgaCA9IHBhcmFtcy5oZWlnaHRcbiAgICB9XG4gICAgaCAtPSBwYXJzZUZsb2F0KGNvbnRhaW5lci5zdHlsZShcInBhZGRpbmctdG9wXCIpLDEwKVxuICAgIGggLT0gcGFyc2VGbG9hdChjb250YWluZXIuc3R5bGUoXCJwYWRkaW5nLWJvdHRvbVwiKSwxMClcbiAgICBpZiAoaGVhZGVyKSB7XG4gICAgICBoIC09IGhlYWRlci5ub2RlKCkub2Zmc2V0SGVpZ2h0IHx8IGhlYWRlci5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gICAgICBoIC09IHBhcnNlRmxvYXQoaGVhZGVyLnN0eWxlKFwicGFkZGluZy10b3BcIiksMTApXG4gICAgICBoIC09IHBhcnNlRmxvYXQoaGVhZGVyLnN0eWxlKFwicGFkZGluZy1ib3R0b21cIiksMTApXG4gICAgfVxuICAgIGlmIChmb290ZXIpIHtcbiAgICAgIGggLT0gZm9vdGVyLm5vZGUoKS5vZmZzZXRIZWlnaHQgfHwgZm9vdGVyLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcbiAgICAgIGggLT0gcGFyc2VGbG9hdChmb290ZXIuc3R5bGUoXCJwYWRkaW5nLXRvcFwiKSwxMClcbiAgICAgIGggLT0gcGFyc2VGbG9hdChmb290ZXIuc3R5bGUoXCJwYWRkaW5nLWJvdHRvbVwiKSwxMClcbiAgICB9XG5cbiAgICBkYXRhX2NvbnRhaW5lclxuICAgICAgLnN0eWxlKFwibWF4LWhlaWdodFwiLGgrXCJweFwiKVxuICB9XG5cbiAgcGFyYW1zLmhlaWdodCA9IHRvb2x0aXAubm9kZSgpLm9mZnNldEhlaWdodCB8fCB0b29sdGlwLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcblxuICBkM3BsdXMudG9vbHRpcC5tb3ZlKHBhcmFtcy54LHBhcmFtcy55LHBhcmFtcy5pZCk7XG5cbn1cbiIsInZhciBmZXRjaFZhbHVlID0gcmVxdWlyZShcIi4uL2NvcmUvZmV0Y2gvdmFsdWUuanNcIiksXG4gICAgZmV0Y2hDb2xvciA9IHJlcXVpcmUoXCIuLi9jb3JlL2ZldGNoL2NvbG9yLmpzXCIpLFxuICAgIGZldGNoVGV4dCAgPSByZXF1aXJlKFwiLi4vY29yZS9mZXRjaC90ZXh0LmpzXCIpXG4vL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gQ3JlYXRlcyBhIGRhdGEgb2JqZWN0IGZvciB0aGUgVG9vbHRpcFxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmQzcGx1cy50b29sdGlwLmRhdGEgPSBmdW5jdGlvbih2YXJzLGlkLGxlbmd0aCxleHRyYXMsY2hpbGRyZW4sZGVwdGgpIHtcblxuICBpZiAodmFycy5zbWFsbCkge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgaWYgKCFsZW5ndGgpIHZhciBsZW5ndGggPSBcImxvbmdcIlxuICBpZiAobGVuZ3RoID09IFwibG9uZ1wiKSB7XG4gICAgdmFyIG90aGVyX2xlbmd0aCA9IFwic2hvcnRcIlxuICB9XG4gIGVsc2Uge1xuICAgIHZhciBvdGhlcl9sZW5ndGggPSBcImxvbmdcIlxuICB9XG5cbiAgdmFyIGV4dHJhX2RhdGEgPSB7fVxuICBpZiAoZXh0cmFzICYmIHR5cGVvZiBleHRyYXMgPT0gXCJzdHJpbmdcIikgZXh0cmFzID0gW2V4dHJhc11cbiAgZWxzZSBpZiAoZXh0cmFzICYmIHR5cGVvZiBleHRyYXMgPT0gXCJvYmplY3RcIikge1xuICAgIGV4dHJhX2RhdGEgPSBkM3BsdXMub2JqZWN0Lm1lcmdlKGV4dHJhX2RhdGEsZXh0cmFzKVxuICAgIHZhciBleHRyYXMgPSBbXVxuICAgIGZvciAoIHZhciBrIGluIGV4dHJhX2RhdGEgKSB7XG4gICAgICBleHRyYXMucHVzaChrKVxuICAgIH1cbiAgfVxuICBlbHNlIGlmICghZXh0cmFzKSB2YXIgZXh0cmFzID0gW11cblxuICB2YXIgdG9vbHRpcF9oaWdobGlnaHRzID0gW11cblxuICBpZiAodmFycy50b29sdGlwLnZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICB2YXIgYSA9IHZhcnMudG9vbHRpcC52YWx1ZVxuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiB2YXJzLnRvb2x0aXAudmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgIHZhciBhID0gW3ZhcnMudG9vbHRpcC52YWx1ZV1cbiAgfVxuICBlbHNlIHtcblxuICAgIGlmICh2YXJzLnRvb2x0aXAudmFsdWVbdmFycy5pZC5uZXN0aW5nW2RlcHRoXV0pIHtcbiAgICAgIHZhciBhID0gdmFycy50b29sdGlwLnZhbHVlW3ZhcnMuaWQubmVzdGluZ1tkZXB0aF1dXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGEgPSB2YXJzLnRvb2x0aXAudmFsdWVcbiAgICB9XG5cbiAgICBpZiAoIShhIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cbiAgICAgIGlmIChhW2xlbmd0aF0pIHtcbiAgICAgICAgYSA9IGFbbGVuZ3RoXVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYVtvdGhlcl9sZW5ndGhdKSB7XG4gICAgICAgIGEgPSBbXVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGEgPSBkM3BsdXMub2JqZWN0Lm1lcmdlKHtcIlwiOltdfSxhKVxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGEgPSBbYV1cbiAgICB9XG4gICAgZWxzZSBpZiAoIShhIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICBhID0gZDNwbHVzLm9iamVjdC5tZXJnZSh7XCJcIjpbXX0sYSlcbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdF9rZXkoa2V5LGdyb3VwKSB7XG5cbiAgICBpZiAodmFycy5hdHRycy52YWx1ZVtncm91cF0pIHZhciBpZF92YXIgPSBncm91cFxuICAgIGVsc2UgdmFyIGlkX3ZhciA9IG51bGxcblxuICAgIGlmIChncm91cCkgZ3JvdXAgPSB2YXJzLmZvcm1hdC52YWx1ZShncm91cClcblxuICAgIHZhciB2YWx1ZSA9IGV4dHJhX2RhdGFba2V5XSB8fCBmZXRjaFZhbHVlKHZhcnMsaWQsa2V5LGlkX3ZhcilcblxuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9IFwidW5kZWZpbmVkXCIgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSAmJiAoKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5pbmRleE9mKFwiZDNwbHVzX290aGVyXCIpIDwgMCkgfHwgISh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUudWlba2V5XVxuICAgICAgICAgICAgICAgPyB2YXJzLmZvcm1hdC52YWx1ZSh2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUudWlba2V5XSlcbiAgICAgICAgICAgICAgIDogdmFycy5mb3JtYXQudmFsdWUoa2V5KSxcbiAgICAgICAgICBoID0gdG9vbHRpcF9oaWdobGlnaHRzLmluZGV4T2Yoa2V5KSA+PSAwXG5cbiAgICAgIGlmICggdmFsdWUgaW5zdGFuY2VvZiBBcnJheSApIHtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbih2KXtcbiAgICAgICAgICB2ID0gdmFycy5mb3JtYXQudmFsdWUodixrZXkpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSB2YXJzLmZvcm1hdC52YWx1ZSh2YWx1ZSxrZXkpXG4gICAgICB9XG5cbiAgICAgIHZhciBvYmogPSB7XCJuYW1lXCI6IG5hbWUsIFwidmFsdWVcIjogdmFsdWUsIFwiaGlnaGxpZ2h0XCI6IGgsIFwiZ3JvdXBcIjogZ3JvdXB9XG5cbiAgICAgIGlmICggdmFycy5kZXNjcy52YWx1ZSApIHtcblxuICAgICAgICBpZiAoIHR5cGVvZiB2YXJzLmRlc2NzLnZhbHVlID09PSBcImZ1bmN0aW9uXCIgKSB7XG4gICAgICAgICAgdmFyIGRlc2NSZXR1cm4gPSB2YXJzLmRlc2NzLnZhbHVlKCBrZXkgKVxuICAgICAgICAgIGlmICggdHlwZW9mIGRlc2NSZXR1cm4gPT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICBvYmouZGVzYyA9IGRlc2NSZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIGtleSBpbiB2YXJzLmRlc2NzLnZhbHVlICkge1xuICAgICAgICAgIG9iai5kZXNjID0gdmFycy5kZXNjcy52YWx1ZVtrZXldXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICB0b29sdGlwX2RhdGEucHVzaChvYmopXG5cbiAgICB9XG5cbiAgfVxuXG4gIHZhciB0b29sdGlwX2RhdGEgPSBbXVxuICBpZiAoYSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cbiAgICBleHRyYXMuZm9yRWFjaChmdW5jdGlvbihlKXtcbiAgICAgIGlmIChhLmluZGV4T2YoZSkgPCAwKSBhLnB1c2goZSlcbiAgICB9KVxuXG4gICAgYS5mb3JFYWNoKGZ1bmN0aW9uKHQpe1xuICAgICAgZm9ybWF0X2tleSh0KVxuICAgIH0pXG5cbiAgfVxuICBlbHNlIHtcblxuICAgIGlmICh2YXJzLmlkLm5lc3RpbmcubGVuZ3RoICYmIGRlcHRoIDwgdmFycy5pZC5uZXN0aW5nLmxlbmd0aC0xKSB7XG4gICAgICB2YXIgYSA9IGQzcGx1cy51dGlsLmNvcHkoYSlcbiAgICAgIHZhcnMuaWQubmVzdGluZy5mb3JFYWNoKGZ1bmN0aW9uKG4saSl7XG4gICAgICAgIGlmIChpID4gZGVwdGggJiYgYVtuXSkgZGVsZXRlIGFbbl1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHZhcnMudG9vbHRpcC52YWx1ZS5sb25nICYmIHR5cGVvZiB2YXJzLnRvb2x0aXAudmFsdWUubG9uZyA9PSBcIm9iamVjdFwiKSB7XG4gICAgICB2YXIgcGxhY2VkID0gW11cbiAgICAgIGZvciAoIHZhciBncm91cCBpbiB2YXJzLnRvb2x0aXAudmFsdWUubG9uZyApIHtcblxuICAgICAgICBleHRyYXMuZm9yRWFjaChmdW5jdGlvbihlKXtcbiAgICAgICAgICBpZiAodmFycy50b29sdGlwLnZhbHVlLmxvbmdbZ3JvdXBdLmluZGV4T2YoZSkgPj0gMCAmJiAoKGFbZ3JvdXBdICYmIGFbZ3JvdXBdLmluZGV4T2YoZSkgPCAwKSB8fCAhYVtncm91cF0pKSB7XG4gICAgICAgICAgICBpZiAoIWFbZ3JvdXBdKSBhW2dyb3VwXSA9IFtdXG4gICAgICAgICAgICBhW2dyb3VwXS5wdXNoKGUpXG4gICAgICAgICAgICBwbGFjZWQucHVzaChlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChhW2dyb3VwXSAmJiBhW2dyb3VwXS5pbmRleE9mKGUpID49IDApIHtcbiAgICAgICAgICAgIHBsYWNlZC5wdXNoKGUpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgZXh0cmFzLmZvckVhY2goZnVuY3Rpb24oZSl7XG4gICAgICAgIGlmIChwbGFjZWQuaW5kZXhPZihlKSA8IDApIHtcbiAgICAgICAgICBpZiAoIWFbXCJcIl0pIGFbXCJcIl0gPSBbXVxuICAgICAgICAgIGFbXCJcIl0ucHVzaChlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgdmFyIHByZXNlbnQgPSBbXVxuXG4gICAgICBmb3IgKCB2YXIgZ3JvdXAgaW4gYSApIHtcbiAgICAgICAgZXh0cmFzLmZvckVhY2goZnVuY3Rpb24oZSl7XG4gICAgICAgICAgaWYgKGFbZ3JvdXBdIGluc3RhbmNlb2YgQXJyYXkgJiYgYVtncm91cF0uaW5kZXhPZihlKSA+PSAwKSB7XG4gICAgICAgICAgICBwcmVzZW50LnB1c2goZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFbZ3JvdXBdID09IFwic3RyaW5nXCIgJiYgYVtncm91cF0gPT0gZSkge1xuICAgICAgICAgICAgcHJlc2VudC5wdXNoKGUpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZiAocHJlc2VudC5sZW5ndGggIT0gZXh0cmFzLmxlbmd0aCkge1xuICAgICAgICBpZiAoIWFbXCJcIl0pIGFbXCJcIl0gPSBbXVxuICAgICAgICBleHRyYXMuZm9yRWFjaChmdW5jdGlvbihlKXtcbiAgICAgICAgICBpZiAocHJlc2VudC5pbmRleE9mKGUpIDwgMCkge1xuICAgICAgICAgICAgYVtcIlwiXS5wdXNoKGUpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKGFbXCJcIl0pIHtcbiAgICAgIGFbXCJcIl0uZm9yRWFjaChmdW5jdGlvbih0KXtcbiAgICAgICAgZm9ybWF0X2tleSh0LFwiXCIpXG4gICAgICB9KVxuICAgICAgZGVsZXRlIGFbXCJcIl1cbiAgICB9XG5cbiAgICBmb3IgKCB2YXIgZ3JvdXAgaW4gYSApIHtcbiAgICAgIGlmIChhW2dyb3VwXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGFbZ3JvdXBdLmZvckVhY2goZnVuY3Rpb24odCl7XG4gICAgICAgICAgZm9ybWF0X2tleSh0LGdyb3VwKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIGFbZ3JvdXBdID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZm9ybWF0X2tleShhW2dyb3VwXSxncm91cClcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIGlmICggY2hpbGRyZW4gKSB7XG5cbiAgICB2YXIgdGl0bGUgID0gdmFycy5mb3JtYXQubG9jYWxlLnZhbHVlLnVpLmluY2x1ZGluZ1xuICAgICAgLCBjb2xvcnMgPSBjaGlsZHJlbi5kM3BsdXNfY29sb3JzXG5cbiAgICBmb3IgKCB2YXIgY2hpbGQgaW4gY2hpbGRyZW4gKSB7XG5cbiAgICAgIGlmICggY2hpbGQgIT09IFwiZDNwbHVzX2NvbG9yc1wiICkge1xuXG4gICAgICAgIGlmICggY2hpbGQgPT09IFwiZDNwbHVzTW9yZVwiICkge1xuXG4gICAgICAgICAgdmFyIG1vcmUgPSB2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUudWkubW9yZVxuICAgICAgICAgICAgLCBuYW1lID0gZDNwbHVzLnN0cmluZy5mb3JtYXQobW9yZSxjaGlsZHJlbltjaGlsZF0pXG4gICAgICAgICAgICAsIGhpZ2hsaWdodCA9IHRydWVcbiAgICAgICAgICBjaGlsZHJlbltjaGlsZF0gPSBcIlwiXG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IGNoaWxkXG4gICAgICAgICAgICAsIGhpZ2hsaWdodCA9IGNvbG9ycyAmJiBjb2xvcnNbbmFtZV0gPyBjb2xvcnNbbmFtZV0gOiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgdG9vbHRpcF9kYXRhLnB1c2goe1xuICAgICAgICAgIFwiZ3JvdXBcIjogdmFycy5mb3JtYXQudmFsdWUodGl0bGUpLFxuICAgICAgICAgIFwiaGlnaGxpZ2h0XCI6IGhpZ2hsaWdodCxcbiAgICAgICAgICBcIm5hbWVcIjogbmFtZSxcbiAgICAgICAgICBcInZhbHVlXCI6IGNoaWxkcmVuW2NoaWxkXVxuICAgICAgICB9KVxuXG4gICAgICB9XG5cbiAgICB9XG4gIH1cblxuICBpZiAoIHZhcnMudG9vbHRpcC5jb25uZWN0aW9ucy52YWx1ZSAmJiBsZW5ndGggPT09IFwibG9uZ1wiICkge1xuXG4gICAgdmFyIGNvbm5lY3Rpb25zID0gdmFycy5lZGdlcy5jb25uZWN0aW9ucyggaWRbdmFycy5pZC52YWx1ZV0gLCB2YXJzLmlkLnZhbHVlICwgdHJ1ZSApXG5cbiAgICBpZiAoIGNvbm5lY3Rpb25zLmxlbmd0aCApIHtcbiAgICAgIGNvbm5lY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oYyl7XG5cbiAgICAgICAgdmFyIG5hbWUgPSBmZXRjaFRleHQodmFycyxjKVswXSxcbiAgICAgICAgICAgIGNvbG9yID0gZmV0Y2hDb2xvcih2YXJzLGMpLFxuICAgICAgICAgICAgc2l6ZSA9IHZhcnMudG9vbHRpcC5mb250LnNpemUsXG4gICAgICAgICAgICByYWRpdXMgPSB2YXJzLnNoYXBlLnZhbHVlID09IFwic3F1YXJlXCIgPyAwIDogc2l6ZVxuICAgICAgICAgICAgc3R5bGVzID0gW1xuICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3I6IFwiK2NvbG9yLFxuICAgICAgICAgICAgICBcImJvcmRlci1jb2xvcjogXCIrZDNwbHVzLmNvbG9yLmxlZ2libGUoY29sb3IpLFxuICAgICAgICAgICAgICBcImJvcmRlci1zdHlsZTogc29saWRcIixcbiAgICAgICAgICAgICAgXCJib3JkZXItd2lkdGg6IFwiK3ZhcnMuZGF0YS5zdHJva2Uud2lkdGgrXCJweFwiLFxuICAgICAgICAgICAgICBcImRpc3BsYXk6IGlubGluZS1ibG9ja1wiLFxuICAgICAgICAgICAgICBcImhlaWdodDogXCIrc2l6ZStcInB4XCIsXG4gICAgICAgICAgICAgIFwibGVmdDogMHB4XCIsXG4gICAgICAgICAgICAgIFwicG9zaXRpb246IGFic29sdXRlXCIsXG4gICAgICAgICAgICAgIFwid2lkdGg6IFwiK3NpemUrXCJweFwiLFxuICAgICAgICAgICAgICBcInRvcDogMHB4XCIsXG4gICAgICAgICAgICAgIGQzcGx1cy5wcmVmaXgoKStcImJvcmRlci1yYWRpdXM6IFwiK3JhZGl1cytcInB4XCIsXG4gICAgICAgICAgICBdXG4gICAgICAgICAgICBub2RlID0gXCI8ZGl2IHN0eWxlPSdcIitzdHlsZXMuam9pbihcIjsgXCIpK1wiOyc+PC9kaXY+XCJcblxuICAgICAgICB0b29sdGlwX2RhdGEucHVzaCh7XG4gICAgICAgICAgXCJncm91cFwiOiB2YXJzLmZvcm1hdC52YWx1ZSh2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUudWkucHJpbWFyeSksXG4gICAgICAgICAgXCJoaWdobGlnaHRcIjogZmFsc2UsXG4gICAgICAgICAgXCJuYW1lXCI6IFwiPGRpdiBzdHlsZT0ncG9zaXRpb246cmVsYXRpdmU7cGFkZGluZy1sZWZ0OlwiK3NpemUqMS41K1wicHg7Jz5cIitub2RlK25hbWUrXCI8L2Rpdj5cIixcbiAgICAgICAgICBcInZhbHVlXCI6IFwiXCJcbiAgICAgICAgfSlcblxuICAgICAgfSlcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiB0b29sdGlwX2RhdGFcblxufVxuIiwiLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBTZXQgWCBhbmQgWSBwb3NpdGlvbiBmb3IgVG9vbHRpcFxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmQzcGx1cy50b29sdGlwLm1vdmUgPSBmdW5jdGlvbih4LHksaWQpIHtcbiAgXG4gIGlmICghaWQpIHZhciB0b29sdGlwID0gZDMuc2VsZWN0KFwiZGl2I2QzcGx1c190b29sdGlwX2lkX2RlZmF1bHRcIilcbiAgZWxzZSB2YXIgdG9vbHRpcCA9IGQzLnNlbGVjdChcImRpdiNkM3BsdXNfdG9vbHRpcF9pZF9cIitpZClcbiAgXG4gIGlmICh0b29sdGlwLm5vZGUoKSkge1xuICAgIFxuICAgIHZhciBkID0gdG9vbHRpcC5kYXR1bSgpXG4gIFxuICAgIGQuY3ggPSB4XG4gICAgZC5jeSA9IHlcbiAgICBcbiAgICBpZiAoIWQuZml4ZWQpIHtcblxuICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzLCBiYXNlZCBvZmYgb2YgYW5jaG9yXG4gICAgICBpZiAoZC5hbmNob3IueSAhPSBcImNlbnRlclwiKSB7XG5cbiAgICAgICAgaWYgKGQuYW5jaG9yLnggPT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgZC54ID0gZC5jeCAtIGQuYXJyb3dfb2Zmc2V0IC0gNFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGQuYW5jaG9yLnggPT0gXCJjZW50ZXJcIikge1xuICAgICAgICAgIGQueCA9IGQuY3ggLSBkLndpZHRoLzJcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkLmFuY2hvci54ID09IFwibGVmdFwiKSB7XG4gICAgICAgICAgZC54ID0gZC5jeCAtIGQud2lkdGggKyBkLmFycm93X29mZnNldCArIDJcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0byBmbGlwIHRoZSB0b29sdGlwXG4gICAgICAgIGlmIChkLmFuY2hvci55ID09IFwiYm90dG9tXCIpIHtcbiAgICAgICAgICBkLmZsaXAgPSBkLmN5ICsgZC5oZWlnaHQgKyBkLm9mZnNldCA8PSBkLmxpbWl0WzFdXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZC5hbmNob3IueSA9PSBcInRvcFwiKSB7XG4gICAgICAgICAgZC5mbGlwID0gZC5jeSAtIGQuaGVpZ2h0IC0gZC5vZmZzZXQgPCAwXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChkLmZsaXApIHtcbiAgICAgICAgICBkLnkgPSBkLmN5ICsgZC5vZmZzZXQgKyBkLmFycm93X29mZnNldFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGQueSA9IGQuY3kgLSBkLmhlaWdodCAtIGQub2Zmc2V0IC0gZC5hcnJvd19vZmZzZXRcbiAgICAgICAgfVxuICAgIFxuICAgICAgfVxuICAgICAgZWxzZSB7XG5cbiAgICAgICAgZC55ID0gZC5jeSAtIGQuaGVpZ2h0LzJcbiAgICAgICAgXG4gICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0byBmbGlwIHRoZSB0b29sdGlwXG4gICAgICAgIGlmIChkLmFuY2hvci54ID09IFwicmlnaHRcIikge1xuICAgICAgICAgIGQuZmxpcCA9IGQuY3ggKyBkLndpZHRoICsgZC5vZmZzZXQgPD0gZC5saW1pdFswXVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGQuYW5jaG9yLnggPT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgICBkLmZsaXAgPSBkLmN4IC0gZC53aWR0aCAtIGQub2Zmc2V0IDwgMFxuICAgICAgICB9XG4gICAgXG4gICAgICAgIGlmIChkLmFuY2hvci54ID09IFwiY2VudGVyXCIpIHtcbiAgICAgICAgICBkLmZsaXAgPSBmYWxzZVxuICAgICAgICAgIGQueCA9IGQuY3ggLSBkLndpZHRoLzJcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkLmZsaXApIHtcbiAgICAgICAgICBkLnggPSBkLmN4ICsgZC5vZmZzZXQgKyBkLmFycm93X29mZnNldFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGQueCA9IGQuY3ggLSBkLndpZHRoIC0gZC5vZmZzZXRcbiAgICAgICAgfVxuICAgICAgfVxuICBcbiAgICAgIC8vIExpbWl0IFggdG8gdGhlIGJvdW5kcyBvZiB0aGUgc2NyZWVuXG4gICAgICBpZiAoZC54IDwgMCkge1xuICAgICAgICBkLnggPSAwXG4gICAgICB9XG4gICAgICBlbHNlIGlmIChkLnggKyBkLndpZHRoID4gZC5saW1pdFswXSkge1xuICAgICAgICBkLnggPSBkLmxpbWl0WzBdIC0gZC53aWR0aFxuICAgICAgfVxuICBcbiAgICAgIC8vIExpbWl0IFkgdG8gdGhlIGJvdW5kcyBvZiB0aGUgc2NyZWVuXG4gICAgICBpZiAoZC55IDwgMCkge1xuICAgICAgICBkLnkgPSAwXG4gICAgICB9XG4gICAgICBlbHNlIGlmIChkLnkgKyBkLmhlaWdodCA+IGQubGltaXRbMV0pIHtcbiAgICAgICAgZC55ID0gZC5saW1pdFsxXSAtIGQuaGVpZ2h0XG4gICAgICB9XG4gICAgICBcbiAgICB9XG4gICAgXG4gICAgdG9vbHRpcFxuICAgICAgLnN0eWxlKFwidG9wXCIsZC55K1wicHhcIilcbiAgICAgIC5zdHlsZShcImxlZnRcIixkLngrXCJweFwiKVxuICBcbiAgICBpZiAoZC5hcnJvdykge1xuICAgICAgdG9vbHRpcC5zZWxlY3RBbGwoXCIuZDNwbHVzX3Rvb2x0aXBfYXJyb3dcIilcbiAgICAgICAgLmNhbGwoZDNwbHVzLnRvb2x0aXAuYXJyb3cpXG4gICAgfVxuICAgIFxuICB9XG4gICAgXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIERlc3Ryb3kgVG9vbHRpcHNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5kM3BsdXMudG9vbHRpcC5yZW1vdmUgPSBmdW5jdGlvbihpZCkge1xuXG4gIC8vIElmIGFuIElEIGlzIHNwZWNpZmllZCwgb25seSByZW1vdmUgdGhhdCB0b29sdGlwXG4gIGlmIChpZCkge1xuICAgIFxuICAgIC8vIEZpcnN0IHJlbW92ZSB0aGUgYmFja2dyb3VuZCBjdXJ0YWluLCBpZiB0aGUgdG9vbHRpcCBoYXMgb25lXG4gICAgZDMuc2VsZWN0QWxsKFwiZGl2I2QzcGx1c190b29sdGlwX2N1cnRhaW5fXCIraWQpLnJlbW92ZSgpXG4gICAgLy8gRmluYWxseSwgcmVtb3ZlIHRoZSB0b29sdGlwIGl0c2VsZlxuICAgIGQzLnNlbGVjdEFsbChcImRpdiNkM3BsdXNfdG9vbHRpcF9pZF9cIitpZCkucmVtb3ZlKClcbiAgICBcbiAgfVxuICAvLyBJZiBubyBJRCBpcyBnaXZlbiwgcmVtb3ZlIEFMTCBkM3BsdXMgdG9vbHRpcHNcbiAgZWxzZSB7XG4gICAgXG4gICAgLy8gRmlyc3QgcmVtb3ZlIGFsbCBiYWNrZ3JvdW5kIGN1cnRhaW5zIG9uIHRoZSBwYWdlXG4gICAgZDMuc2VsZWN0QWxsKFwiZGl2I2QzcGx1c190b29sdGlwX2N1cnRhaW5cIikucmVtb3ZlKClcbiAgICAvLyBGaW5hbGx5LCByZW1vdmUgYWxsIHRvb2x0aXBcbiAgICBkMy5zZWxlY3RBbGwoXCJkaXYuZDNwbHVzX3Rvb2x0aXBcIikucmVtb3ZlKClcbiAgICBcbiAgfVxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gRXhwYW5kcyBhIG1pbi9tYXggaW50byBhIHNwZWNpZmllZCBudW1iZXIgb2YgYnVja2V0c1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmQzcGx1cy51dGlsLmJ1Y2tldHMgPSBmdW5jdGlvbihhcnIsIGJ1Y2tldHMpIHtcbiAgdmFyIHJldHVybl9hcnIgPSBbXSwgc3RlcCA9IDEvKGJ1Y2tldHMtMSkqKGFyclsxXS1hcnJbMF0pLCBpID0gc3RlcFxuXG4gIGZvciAodmFyIGkgPSBhcnJbMF07IGkgPD0gYXJyWzFdOyBpID0gaSArIHN0ZXApIHtcbiAgICByZXR1cm5fYXJyLnB1c2goaSlcbiAgfVxuICBpZiAocmV0dXJuX2Fyci5sZW5ndGggPCBidWNrZXRzKSB7XG4gICAgcmV0dXJuX2FycltidWNrZXRzLTFdID0gYXJyWzFdXG4gIH1cbiAgaWYgKHJldHVybl9hcnJbcmV0dXJuX2Fyci5sZW5ndGgtMV0gPCBhcnJbMV0pIHtcbiAgICByZXR1cm5fYXJyW3JldHVybl9hcnIubGVuZ3RoLTFdID0gYXJyWzFdXG4gIH1cbiAgcmV0dXJuIHJldHVybl9hcnJcbn1cbiIsImQzc2VsZWN0aW9uID0gcmVxdWlyZSBcIi4vZDNzZWxlY3Rpb24uanNcIlxuIyMjKlxuICogQ2hlY2tzIHRvIHNlZSBpZiBlbGVtZW50IGlzIGluc2lkZSBvZiBhbm90aGVyIGVsZW1lbnRcbiAjIyNcbmQzcGx1cy51dGlsLmNoaWxkID0gKHBhcmVudCwgY2hpbGQpIC0+XG5cbiAgcmV0dXJuIGZhbHNlIGlmIG5vdCBwYXJlbnQgb3Igbm90IGNoaWxkXG5cbiAgcGFyZW50ID0gcGFyZW50Lm5vZGUoKSBpZiBkM3NlbGVjdGlvbihwYXJlbnQpXG4gIGNoaWxkID0gY2hpbGQubm9kZSgpIGlmIGQzc2VsZWN0aW9uKHBhcmVudClcbiAgbm9kZSA9IGNoaWxkLnBhcmVudE5vZGVcblxuICB3aGlsZSBub2RlIGlzbnQgbnVsbFxuICAgIHJldHVybiB0cnVlIGlmIG5vZGUgaXMgcGFyZW50XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZVxuXG4gIGZhbHNlXG4iLCIjIyMqXG4gKiBGaW5kcyBjbG9zZXN0IG51bWVyaWMgdmFsdWUgaW4gYXJyYXlcbiAjIyNcbmQzcGx1cy51dGlsLmNsb3Nlc3QgPSAoYXJyLCB2YWx1ZSkgLT5cblxuICBjbG9zZXN0ID0gYXJyWzBdXG5cbiAgYXJyLmZvckVhY2ggKHApIC0+XG4gICAgY2xvc2VzdCA9IHAgaWYgTWF0aC5hYnModmFsdWUgLSBwKSA8IE1hdGguYWJzKHZhbHVlIC0gY2xvc2VzdClcblxuICBjbG9zZXN0XG4iLCJvYmplY3RNZXJnZSAgICA9IHJlcXVpcmUgXCIuLi9vYmplY3QvbWVyZ2UuY29mZmVlXCJcbm9iamVjdFZhbGlkYXRlID0gcmVxdWlyZSBcIi4uL29iamVjdC92YWxpZGF0ZS5jb2ZmZWVcIlxuI15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuIyBDbG9uZXMgYSB2YXJpYWJsZVxuIy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZDNwbHVzLnV0aWwuY29weSA9ICh2YXJpYWJsZSkgLT5cblxuICAjIE9iamVjdCBMb2dpY1xuICBpZiBvYmplY3RWYWxpZGF0ZSh2YXJpYWJsZSlcbiAgICBvYmplY3RNZXJnZSB2YXJpYWJsZVxuXG4gICMgQXJyYXkgTG9naWNcbiAgZWxzZSBpZiB2YXJpYWJsZSBpbnN0YW5jZW9mIEFycmF5XG4gICAgcmV0ID0gW11cbiAgICB2YXJpYWJsZS5mb3JFYWNoIChvKSAtPlxuICAgICAgcmV0LnB1c2ggZDNwbHVzLnV0aWwuY29weShvKVxuICAgIHJldFxuXG4gICMgRXZlcnl0aGluZyBlbHNlIGp1c3QgcmV0dXJucyBpdHNlbGZcbiAgZWxzZVxuICAgIHZhcmlhYmxlXG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gQ3Jvc3MtYnJvd3NlciBkZXRlY3QgZm9yIEQzIGVsZW1lbnRcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kM3BsdXMudXRpbC5kM3NlbGVjdGlvbiA9IGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuICByZXR1cm4gZDNwbHVzLmllID9cbiAgICB0eXBlb2Ygc2VsZWN0aW9uID09IFwib2JqZWN0XCIgJiYgc2VsZWN0aW9uIGluc3RhbmNlb2YgQXJyYXlcbiAgICA6IHNlbGVjdGlvbiBpbnN0YW5jZW9mIGQzLnNlbGVjdGlvblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGQzcGx1cy51dGlsLmQzc2VsZWN0aW9uXG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gQ3JlYXRlcyBhIEJhc2UtNjQgRGF0YSBVUkwgZnJvbSBhbmQgSW1hZ2UgVVJMXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZDNwbHVzLnV0aWwuZGF0YXVybCA9IGZ1bmN0aW9uKHVybCxjYWxsYmFjaykge1xuXG4gIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgaW1nLnNyYyA9IHVybDtcbiAgaW1nLmNyb3NzT3JpZ2luID0gXCJBbm9ueW1vdXNcIjtcbiAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgY3R4LmRyYXdJbWFnZSh0aGlzLCAwLCAwKTtcblxuICAgIGNhbGxiYWNrLmNhbGwodGhpcyxjYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpKVxuXG4gICAgY2FudmFzID0gbnVsbFxuXG4gIH1cblxufVxuIiwiIyMjKlxuICogUmV0dXJucyBkaXN0YW5jZXMgb2YgYWxsIG9iamVjdHMgaW4gYXJyYXlcbiAjIyNcbmQzcGx1cy51dGlsLmRpc3RhbmNlcyA9IChhcnIsIGFjY2Vzc29yKSAtPlxuXG4gIGRpc3RhbmNlcyA9IFtdXG4gIGNoZWNrZWQgPSBbXVxuXG4gIGFyci5mb3JFYWNoIChub2RlMSkgLT5cbiAgICBuMSA9IChpZiBhY2Nlc3NvciB0aGVuIGFjY2Vzc29yKG5vZGUxKSBlbHNlIFsgbm9kZTEueCwgbm9kZTEueSBdKVxuICAgIGNoZWNrZWQucHVzaCBub2RlMVxuICAgIGFyci5mb3JFYWNoIChub2RlMikgLT5cbiAgICAgIGlmIGNoZWNrZWQuaW5kZXhPZihub2RlMikgPCAwXG4gICAgICAgIG4yID0gKGlmIGFjY2Vzc29yIHRoZW4gYWNjZXNzb3Iobm9kZTIpIGVsc2UgWyBub2RlMi54LCBub2RlMi55IF0pXG4gICAgICAgIHh4ID0gTWF0aC5hYnMobjFbMF0gLSBuMlswXSlcbiAgICAgICAgeXkgPSBNYXRoLmFicyhuMVsxXSAtIG4yWzFdKVxuICAgICAgICBkaXN0YW5jZXMucHVzaCBNYXRoLnNxcnQoKHh4ICogeHgpICsgKHl5ICogeXkpKVxuXG4gIGRpc3RhbmNlcy5zb3J0IChhLCBiKSAtPiBhIC0gYlxuXG4gIGRpc3RhbmNlc1xuIiwiIyMjXG4gKiBHaXZlcyBYIGFuZCBZIG9mZnNldCBiYXNlZCBvZmYgYW5nbGUgYW5kIHNoYXBlXG4gIyMjXG5kM3BsdXMudXRpbC5vZmZzZXQgPSAocmFkaWFucywgZGlzdGFuY2UsIHNoYXBlKSAtPlxuXG4gIGNvb3JkcyA9XG4gICAgeDogMFxuICAgIHk6IDBcblxuICByYWRpYW5zID0gTWF0aC5QSSAqIDIgKyByYWRpYW5zIGlmIHJhZGlhbnMgPCAwXG5cbiAgaWYgc2hhcGUgaXMgXCJzcXVhcmVcIlxuICAgIGRpYWdvbmFsID0gNDUgKiAoTWF0aC5QSSAvIDE4MClcbiAgICBpZiByYWRpYW5zIDw9IE1hdGguUElcbiAgICAgIGlmIHJhZGlhbnMgPCAoTWF0aC5QSSAvIDIpXG4gICAgICAgIGlmIHJhZGlhbnMgPCBkaWFnb25hbFxuICAgICAgICAgIGNvb3Jkcy54ICs9IGRpc3RhbmNlXG4gICAgICAgICAgb3Bwb3NpdGVMZWdMZW5ndGggPSBNYXRoLnRhbihyYWRpYW5zKSAqIGRpc3RhbmNlXG4gICAgICAgICAgY29vcmRzLnkgKz0gb3Bwb3NpdGVMZWdMZW5ndGhcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGNvb3Jkcy55ICs9IGRpc3RhbmNlXG4gICAgICAgICAgYWRqYWNlbnRMZWdMZW5ndGggPSBkaXN0YW5jZSAvIE1hdGgudGFuKHJhZGlhbnMpXG4gICAgICAgICAgY29vcmRzLnggKz0gYWRqYWNlbnRMZWdMZW5ndGhcbiAgICAgIGVsc2VcbiAgICAgICAgaWYgcmFkaWFucyA8IChNYXRoLlBJIC0gZGlhZ29uYWwpXG4gICAgICAgICAgY29vcmRzLnkgKz0gZGlzdGFuY2VcbiAgICAgICAgICBhZGphY2VudExlZ0xlbmd0aCA9IGRpc3RhbmNlIC8gTWF0aC50YW4oTWF0aC5QSSAtIHJhZGlhbnMpXG4gICAgICAgICAgY29vcmRzLnggLT0gYWRqYWNlbnRMZWdMZW5ndGhcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGNvb3Jkcy54IC09IGRpc3RhbmNlXG4gICAgICAgICAgb3Bwb3NpdGVMZWdMZW5ndGggPSBNYXRoLnRhbihNYXRoLlBJIC0gcmFkaWFucykgKiBkaXN0YW5jZVxuICAgICAgICAgIGNvb3Jkcy55ICs9IG9wcG9zaXRlTGVnTGVuZ3RoXG4gICAgZWxzZVxuICAgICAgaWYgcmFkaWFucyA8ICgzICogTWF0aC5QSSAvIDIpXG4gICAgICAgIGlmIHJhZGlhbnMgPCAoZGlhZ29uYWwgKyBNYXRoLlBJKVxuICAgICAgICAgIGNvb3Jkcy54IC09IGRpc3RhbmNlXG4gICAgICAgICAgb3Bwb3NpdGVMZWdMZW5ndGggPSBNYXRoLnRhbihyYWRpYW5zIC0gTWF0aC5QSSkgKiBkaXN0YW5jZVxuICAgICAgICAgIGNvb3Jkcy55IC09IG9wcG9zaXRlTGVnTGVuZ3RoXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBjb29yZHMueSAtPSBkaXN0YW5jZVxuICAgICAgICAgIGFkamFjZW50TGVnTGVuZ3RoID0gZGlzdGFuY2UgLyBNYXRoLnRhbihyYWRpYW5zIC0gTWF0aC5QSSlcbiAgICAgICAgICBjb29yZHMueCAtPSBhZGphY2VudExlZ0xlbmd0aFxuICAgICAgZWxzZVxuICAgICAgICBpZiByYWRpYW5zIDwgKDIgKiBNYXRoLlBJIC0gZGlhZ29uYWwpXG4gICAgICAgICAgY29vcmRzLnkgLT0gZGlzdGFuY2VcbiAgICAgICAgICBhZGphY2VudExlZ0xlbmd0aCA9IGRpc3RhbmNlIC8gTWF0aC50YW4oMiAqIE1hdGguUEkgLSByYWRpYW5zKVxuICAgICAgICAgIGNvb3Jkcy54ICs9IGFkamFjZW50TGVnTGVuZ3RoXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBjb29yZHMueCArPSBkaXN0YW5jZVxuICAgICAgICAgIG9wcG9zaXRlTGVnTGVuZ3RoID0gTWF0aC50YW4oMiAqIE1hdGguUEkgLSByYWRpYW5zKSAqIGRpc3RhbmNlXG4gICAgICAgICAgY29vcmRzLnkgLT0gb3Bwb3NpdGVMZWdMZW5ndGhcbiAgZWxzZVxuICAgIGNvb3Jkcy54ICs9IGRpc3RhbmNlICogTWF0aC5jb3MocmFkaWFucylcbiAgICBjb29yZHMueSArPSBkaXN0YW5jZSAqIE1hdGguc2luKHJhZGlhbnMpXG5cbiAgY29vcmRzXG4iLCJvYmplY3RWYWxpZGF0ZSA9IHJlcXVpcmUgXCIuLi9vYmplY3QvdmFsaWRhdGUuY29mZmVlXCJcbiMjIypcbiAqIFJldHVybnMgbGlzdCBvZiB1bmlxdWUgdmFsdWVzXG4gIyMjXG5kM3BsdXMudXRpbC51bmlxdWVzID0gKGRhdGEsIHZhbHVlKSAtPlxuXG4gIHJldHVybiBbXSBpZiBkYXRhIGlzIGB1bmRlZmluZWRgIG9yIHZhbHVlIGlzIGB1bmRlZmluZWRgXG5cbiAgZGF0YSA9IFsgZGF0YSBdIHVubGVzcyBkYXRhIGluc3RhbmNlb2YgQXJyYXlcbiAgdmFscyA9IFtdXG4gIGxvb2t1cHMgPSBbXVxuXG4gIGZvciBkIGluIGRhdGFcbiAgICBpZiBvYmplY3RWYWxpZGF0ZSBkXG4gICAgICB2YWwgPSBpZiB0eXBlb2YgdmFsdWUgaXMgXCJmdW5jdGlvblwiIHRoZW4gdmFsdWUgZCBlbHNlIGRbdmFsdWVdXG4gICAgICBsb29rdXAgPSBpZiBbIFwibnVtYmVyXCIsIFwic3RyaW5nXCIgXS5pbmRleE9mKHR5cGVvZiB2YWwpID49IDAgdGhlbiB2YWwgZWxzZSBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICAgICBpZiBsb29rdXBzLmluZGV4T2YobG9va3VwKSA8IDBcbiAgICAgICAgdmFscy5wdXNoIHZhbFxuICAgICAgICBsb29rdXBzLnB1c2ggbG9va3VwXG5cbiAgdmFscy5zb3J0IChhLCBiKSAtPiBhIC0gYlxuIiwiLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIE1pc2NlbGxhbmVvdXMgRXJyb3IgQ2hlY2tzXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZDNwbHVzLmRyYXcuYXBwID0gZnVuY3Rpb24odmFycykge1xuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBEcmF3IHRoZSBzcGVjaWZpZWQgYXBwXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBTZXQgdmFycy5ncm91cCB0byB0aGUgYXBwJ3Mgc3BlY2lmaWMgZ3JvdXAgZWxlbWVudFxuICB2YXJzLmdyb3VwID0gdmFycy5nLmFwcHNbdmFycy50eXBlLnZhbHVlXVxuICAvLyBSZXNldCBtb3VzZSBldmVudHMgZm9yIHRoZSBhcHAgdG8gdXNlXG4gIHZhcnMubW91c2UgPSB7fVxuXG4gIGlmICghdmFycy5pbnRlcm5hbF9lcnJvcikge1xuXG4gICAgdmFyIGFwcCA9IHZhcnMuZm9ybWF0LmxvY2FsZS52YWx1ZS52aXN1YWxpemF0aW9uW3ZhcnMudHlwZS52YWx1ZV1cbiAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZShcInJ1bm5pbmcgXCIrIGFwcClcbiAgICB2YXIgcmV0dXJuZWQgPSB2YXJzLnR5cGVzW3ZhcnMudHlwZS52YWx1ZV0odmFycylcbiAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZUVuZChcInJ1bm5pbmcgXCIrIGFwcClcblxuICB9XG4gIGVsc2Uge1xuICAgIHZhciByZXR1cm5lZCA9IG51bGxcbiAgfVxuXG4gIHZhcnMucmV0dXJuZWQgPSB7XG4gICAgICBcIm5vZGVzXCI6IFtdLFxuICAgICAgXCJlZGdlc1wiOiBudWxsXG4gICAgfVxuXG4gIGlmIChyZXR1cm5lZCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgdmFycy5yZXR1cm5lZC5ub2RlcyA9IHJldHVybmVkXG4gIH1cbiAgZWxzZSBpZiAocmV0dXJuZWQpIHtcbiAgICBpZiAocmV0dXJuZWQubm9kZXMpIHtcbiAgICAgIHZhcnMucmV0dXJuZWQubm9kZXMgPSByZXR1cm5lZC5ub2Rlc1xuICAgIH1cbiAgICBpZiAocmV0dXJuZWQuZWRnZXMpIHtcbiAgICAgIHZhcnMucmV0dXJuZWQuZWRnZXMgPSByZXR1cm5lZC5lZGdlc1xuICAgIH1cbiAgfVxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gSWYgcGxhY2luZyBpbnRvIGEgbmV3IGNvbnRhaW5lciwgcmVtb3ZlIGl0J3MgY29udGVudHNcbi8vIGFuZCBjaGVjayB0ZXh0IGRpcmVjdGlvbi5cbi8vXG4vLyBBbHNvIGluaXRpYWxpemVkIGFwcCB3aWR0aCBhbmQgaGVpZ2h0LlxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmQzcGx1cy5kcmF3LmNvbnRhaW5lciA9IGZ1bmN0aW9uKHZhcnMpIHtcblxuICBpZiAodmFycy5jb250YWluZXIuY2hhbmdlZCkge1xuXG4gICAgdmFycy5jb250YWluZXIudmFsdWVcbiAgICAgIC5zdHlsZShcInBvc2l0aW9uXCIsZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJwb3NpdGlvblwiKSxcbiAgICAgICAgICAgIHJlbWFpbiA9IFtcImFic29sdXRlXCIsXCJmaXhlZFwiXS5pbmRleE9mKGN1cnJlbnQpID49IDBcbiAgICAgICAgcmV0dXJuIHJlbWFpbiA/IGN1cnJlbnQgOiBcInJlbGF0aXZlXCI7XG4gICAgICB9KVxuICAgICAgLmh0bWwoXCJcIilcblxuICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAvLyBHZXQgb3ZlcmFsbCB3aWR0aCBhbmQgaGVpZ2h0LCBpZiBub3QgZGVmaW5lZFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgc2l6ZXMgPSBbXCJ3aWR0aFwiLFwiaGVpZ2h0XCJdXG4gICAgc2l6ZXMuZm9yRWFjaChmdW5jdGlvbihzKXtcbiAgICAgIGlmICghdmFyc1tzXS52YWx1ZSkge1xuXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrX3BhcmVudChlbGVtZW50KSB7XG5cbiAgICAgICAgICBpZiAoZWxlbWVudC50YWdOYW1lID09PSB1bmRlZmluZWQgfHwgW1wiQk9EWVwiLFwiSFRNTFwiXS5pbmRleE9mKGVsZW1lbnQudGFnTmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IHdpbmRvd1tcImlubmVyXCIrcy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStzLnNsaWNlKDEpXVxuICAgICAgICAgICAgICAsIGVsZW0gPSBkb2N1bWVudCAhPSBlbGVtZW50ID8gZDMuc2VsZWN0KGVsZW1lbnQpIDogbnVsbFxuICAgICAgICAgICAgaWYgKGVsZW0gJiYgcyA9PSBcIndpZHRoXCIpIHtcbiAgICAgICAgICAgICAgdmFsIC09IHBhcnNlRmxvYXQoZWxlbS5zdHlsZShcIm1hcmdpbi1sZWZ0XCIpLDEwKVxuICAgICAgICAgICAgICB2YWwgLT0gcGFyc2VGbG9hdChlbGVtLnN0eWxlKFwibWFyZ2luLXJpZ2h0XCIpLDEwKVxuICAgICAgICAgICAgICB2YWwgLT0gcGFyc2VGbG9hdChlbGVtLnN0eWxlKFwicGFkZGluZy1sZWZ0XCIpLDEwKVxuICAgICAgICAgICAgICB2YWwgLT0gcGFyc2VGbG9hdChlbGVtLnN0eWxlKFwicGFkZGluZy1yaWdodFwiKSwxMClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVsZW0gJiYgcyA9PSBcImhlaWdodFwiKSB7XG4gICAgICAgICAgICAgIHZhbCAtPSBwYXJzZUZsb2F0KGVsZW0uc3R5bGUoXCJtYXJnaW4tdG9wXCIpLDEwKVxuICAgICAgICAgICAgICB2YWwgLT0gcGFyc2VGbG9hdChlbGVtLnN0eWxlKFwibWFyZ2luLWJvdHRvbVwiKSwxMClcbiAgICAgICAgICAgICAgdmFsIC09IHBhcnNlRmxvYXQoZWxlbS5zdHlsZShcInBhZGRpbmctdG9wXCIpLDEwKVxuICAgICAgICAgICAgICB2YWwgLT0gcGFyc2VGbG9hdChlbGVtLnN0eWxlKFwicGFkZGluZy1ib3R0b21cIiksMTApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZDMuc2VsZWN0QWxsKFwiYm9keSA+ICo6bm90KHNjcmlwdClcIikuc2l6ZSgpID09IDEpIHtcbiAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiYm9keVwiKS5zdHlsZShcIm92ZXJmbG93XCIsXCJoaWRkZW5cIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwgPD0gMjApIHtcbiAgICAgICAgICAgICAgdmFsID0gdmFyc1tzXS5zbWFsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyc1tzXS52YWx1ZSA9IHZhbFxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgdmFyIHZhbCA9IHBhcnNlRmxvYXQoZDMuc2VsZWN0KGVsZW1lbnQpLnN0eWxlKHMpLDEwKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT0gXCJudW1iZXJcIiAmJiB2YWwgPiAwKSB7XG4gICAgICAgICAgICAgIHZhcnNbc10udmFsdWUgPSB2YWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVsZW1lbnQudGFnTmFtZSAhPSBcIkJPRFlcIikge1xuICAgICAgICAgICAgICBjaGVja19wYXJlbnQoZWxlbWVudC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBjaGVja19wYXJlbnQodmFycy5jb250YWluZXIudmFsdWUubm9kZSgpKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB2YXJzLmNvbnRhaW5lci52YWx1ZVxuICAgICAgLnN0eWxlKFwid2lkdGhcIix2YXJzLndpZHRoLnZhbHVlK1wicHhcIilcbiAgICAgIC5zdHlsZShcImhlaWdodFwiLHZhcnMuaGVpZ2h0LnZhbHVlK1wicHhcIilcblxuICB9XG5cbiAgdmFycy53aWR0aC52aXogPSB2YXJzLndpZHRoLnZhbHVlO1xuICB2YXJzLmhlaWdodC52aXogPSB2YXJzLmhlaWdodC52YWx1ZTtcblxufVxuIiwiLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIEVudGVyIEVsZW1lbnRzXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZDNwbHVzLmRyYXcuZW50ZXIgPSBmdW5jdGlvbih2YXJzKSB7XG5cbiAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWUoXCJjcmVhdGluZyBTVkcgZWxlbWVudHNcIilcblxuICAvLyBFbnRlciBTVkdcbiAgdmFycy5zdmcgPSB2YXJzLmNvbnRhaW5lci52YWx1ZS5zZWxlY3RBbGwoXCJzdmcjZDNwbHVzXCIpLmRhdGEoWzBdKTtcbiAgdmFycy5zdmcuZW50ZXIoKS5pbnNlcnQoXCJzdmdcIixcIiNkM3BsdXNfbWVzc2FnZVwiKVxuICAgIC5hdHRyKFwiaWRcIixcImQzcGx1c1wiKVxuICAgIC5hdHRyKFwid2lkdGhcIix2YXJzLndpZHRoLnZhbHVlKVxuICAgIC5hdHRyKFwiaGVpZ2h0XCIsdmFycy5oZWlnaHQudmFsdWUpXG4gICAgLmF0dHIoXCJ4bWxuc1wiLFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIilcbiAgICAuYXR0cihcInhtbG5zOnhtbG5zOnhsaW5rXCIsXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIpXG5cbiAgLy8gRW50ZXIgQkcgUmVjdGFuZ2xlXG4gIHZhcnMuZy5iZyA9IHZhcnMuc3ZnLnNlbGVjdEFsbChcInJlY3QjYmdcIikuZGF0YShbXCJiZ1wiXSk7XG4gIHZhcnMuZy5iZy5lbnRlcigpLmFwcGVuZChcInJlY3RcIilcbiAgICAuYXR0cihcImlkXCIsXCJiZ1wiKVxuICAgIC5hdHRyKFwiZmlsbFwiLHZhcnMuYmFja2dyb3VuZC52YWx1ZSlcbiAgICAuYXR0cihcIndpZHRoXCIsdmFycy53aWR0aC52YWx1ZSlcbiAgICAuYXR0cihcImhlaWdodFwiLHZhcnMuaGVpZ2h0LnZhbHVlKVxuXG4gIC8vIEVudGVyIFRpbWVsaW5lIEdyb3VwXG4gIHZhcnMuZy50aW1lbGluZSA9IHZhcnMuc3ZnLnNlbGVjdEFsbChcImcjdGltZWxpbmVcIikuZGF0YShbXCJ0aW1lbGluZVwiXSlcbiAgdmFycy5nLnRpbWVsaW5lLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgIC5hdHRyKFwiaWRcIixcInRpbWVsaW5lXCIpXG4gICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZSgwLFwiK3ZhcnMuaGVpZ2h0LnZhbHVlK1wiKVwiKVxuXG4gIC8vIEVudGVyIEtleSBHcm91cFxuICB2YXJzLmcubGVnZW5kID0gdmFycy5zdmcuc2VsZWN0QWxsKFwiZyNrZXlcIikuZGF0YShbXCJrZXlcIl0pXG4gIHZhcnMuZy5sZWdlbmQuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgLmF0dHIoXCJpZFwiLFwia2V5XCIpXG4gICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZSgwLFwiK3ZhcnMuaGVpZ2h0LnZhbHVlK1wiKVwiKVxuXG4gIC8vIEVudGVyIEZvb3RlciBHcm91cFxuICB2YXJzLmcuZm9vdGVyID0gdmFycy5zdmcuc2VsZWN0QWxsKFwiZyNmb290ZXJcIikuZGF0YShbXCJmb290ZXJcIl0pXG4gIHZhcnMuZy5mb290ZXIuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgLmF0dHIoXCJpZFwiLFwiZm9vdGVyXCIpXG4gICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZSgwLFwiK3ZhcnMuaGVpZ2h0LnZhbHVlK1wiKVwiKVxuXG4gIC8vIEVudGVyIEFwcCBDbGlwcGluZyBNYXNrXG4gIHZhcnMuZy5jbGlwcGluZyA9IHZhcnMuc3ZnLnNlbGVjdEFsbChcIiNjbGlwcGluZ1wiKS5kYXRhKFtcImNsaXBwaW5nXCJdKVxuICB2YXJzLmcuY2xpcHBpbmcuZW50ZXIoKS5hcHBlbmQoXCJjbGlwUGF0aFwiKVxuICAgIC5hdHRyKFwiaWRcIixcImNsaXBwaW5nXCIpXG4gICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgIC5hdHRyKFwid2lkdGhcIix2YXJzLndpZHRoLnZpeilcbiAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsdmFycy5oZWlnaHQudml6KVxuXG4gIC8vIEVudGVyIENvbnRhaW5lciBHcm91cFxuICB2YXJzLmcuY29udGFpbmVyID0gdmFycy5zdmcuc2VsZWN0QWxsKFwiZyNjb250YWluZXJcIikuZGF0YShbXCJjb250YWluZXJcIl0pXG4gIHZhcnMuZy5jb250YWluZXIuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgLmF0dHIoXCJpZFwiLFwiY29udGFpbmVyXCIpXG4gICAgLmF0dHIoXCJjbGlwLXBhdGhcIixcInVybCgjY2xpcHBpbmcpXCIpXG4gICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZShcIit2YXJzLm1hcmdpbi5sZWZ0K1wiLFwiK3ZhcnMubWFyZ2luLnRvcCtcIilcIilcblxuICAvLyBFbnRlciBab29tIEdyb3VwXG4gIHZhcnMuZy56b29tID0gdmFycy5nLmNvbnRhaW5lci5zZWxlY3RBbGwoXCJnI3pvb21cIikuZGF0YShbXCJ6b29tXCJdKVxuICB2YXJzLmcuem9vbS5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAuYXR0cihcImlkXCIsXCJ6b29tXCIpXG5cbiAgLy8gRW50ZXIgQXBwIEJhY2tncm91bmQgR3JvdXBcbiAgdmFycy5nLnZpeiA9IHZhcnMuZy56b29tLnNlbGVjdEFsbChcImcjZDNwbHVzX3ZpelwiKS5kYXRhKFtcImQzcGx1c192aXpcIl0pXG4gIHZhcnMuZy52aXouZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgLmF0dHIoXCJpZFwiLFwiZDNwbHVzX3ZpelwiKVxuXG4gIC8vIEVudGVyIEFwcCBPdmVybGF5IFJlY3RcbiAgdmFycy5nLm92ZXJsYXkgPSB2YXJzLmcudml6LnNlbGVjdEFsbChcInJlY3QjZDNwbHVzX292ZXJsYXlcIikuZGF0YShbe1wiaWRcIjpcImQzcGx1c19vdmVybGF5XCJ9XSlcbiAgdmFycy5nLm92ZXJsYXkuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpXG4gICAgLmF0dHIoXCJpZFwiLFwiZDNwbHVzX292ZXJsYXlcIilcbiAgICAuYXR0cihcIndpZHRoXCIsdmFycy53aWR0aC52YWx1ZSlcbiAgICAuYXR0cihcImhlaWdodFwiLHZhcnMuaGVpZ2h0LnZhbHVlKVxuICAgIC5hdHRyKFwib3BhY2l0eVwiLDApXG5cbiAgaWYgKCFkM3BsdXMudG91Y2gpIHtcblxuICAgIHZhcnMuZy5vdmVybGF5XG4gICAgICAub24oZDNwbHVzLmV2dC5tb3ZlLGZ1bmN0aW9uKGQpe1xuXG4gICAgICAgIGlmIChkLmRyYWdnaW5nKSB7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YXJzLnR5cGVzW3ZhcnMudHlwZS52YWx1ZV0uem9vbSAmJiB2YXJzLnpvb20ucGFuLnZhbHVlICYmXG4gICAgICAgICAgdmFycy56b29tLmJlaGF2aW9yLnNjYWxlRXh0ZW50KClbMF0gPCB2YXJzLnpvb20uc2NhbGUpIHtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJjdXJzb3JcIixkM3BsdXMucHJlZml4KCkrXCJncmFiXCIpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiY3Vyc29yXCIsXCJhdXRvXCIpXG4gICAgICAgIH1cblxuICAgICAgfSlcbiAgICAgIC5vbihkM3BsdXMuZXZ0LnVwLGZ1bmN0aW9uKGQpe1xuXG4gICAgICAgIGlmICh2YXJzLnR5cGVzW3ZhcnMudHlwZS52YWx1ZV0uem9vbSAmJiB2YXJzLnpvb20ucGFuLnZhbHVlICYmXG4gICAgICAgICAgdmFycy56b29tLmJlaGF2aW9yLnNjYWxlRXh0ZW50KClbMF0gPCB2YXJzLnpvb20uc2NhbGUpIHtcbiAgICAgICAgICBkLmRyYWdnaW5nID0gZmFsc2VcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJjdXJzb3JcIixkM3BsdXMucHJlZml4KCkrXCJncmFiXCIpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiY3Vyc29yXCIsXCJhdXRvXCIpXG4gICAgICAgIH1cblxuICAgICAgfSlcbiAgICAgIC5vbihkM3BsdXMuZXZ0LmRvd24sZnVuY3Rpb24oZCl7XG5cbiAgICAgICAgaWYgKHZhcnMudHlwZXNbdmFycy50eXBlLnZhbHVlXS56b29tICYmIHZhcnMuem9vbS5wYW4udmFsdWUgJiZcbiAgICAgICAgICB2YXJzLnpvb20uYmVoYXZpb3Iuc2NhbGVFeHRlbnQoKVswXSA8IHZhcnMuem9vbS5zY2FsZSkge1xuICAgICAgICAgIGQuZHJhZ2dpbmcgPSB0cnVlXG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiY3Vyc29yXCIsZDNwbHVzLnByZWZpeCgpK1wiZ3JhYmJpbmdcIilcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJjdXJzb3JcIixcImF1dG9cIilcbiAgICAgICAgfVxuXG4gICAgICB9KVxuXG4gIH1cbiAgZWxzZSB7XG5cbiAgICB2YXJzLmcub3ZlcmxheVxuICAgICAgLm9uKGQzcGx1cy5ldnQub3Zlcix2YXJzLnpvb20udG91Y2hFdmVudClcbiAgICAgIC5vbihkM3BsdXMuZXZ0Lm1vdmUsdmFycy56b29tLnRvdWNoRXZlbnQpXG4gICAgICAub24oZDNwbHVzLmV2dC5vdXQsdmFycy56b29tLnRvdWNoRXZlbnQpXG5cbiAgfVxuXG4gIC8vIEVudGVyIEFwcCBCYWNrZ3JvdW5kIEdyb3VwXG4gIHZhcnMuZy5hcHAgPSB2YXJzLmcudml6LnNlbGVjdEFsbChcImcjYXBwXCIpLmRhdGEoW1wiYXBwXCJdKVxuICB2YXJzLmcuYXBwLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgIC5hdHRyKFwiaWRcIixcImFwcFwiKVxuXG4gIC8vIEVudGVyIEVkZ2VzIEdyb3VwXG4gIHZhcnMuZy5lZGdlcyA9IHZhcnMuZy52aXouc2VsZWN0QWxsKFwiZyNlZGdlc1wiKS5kYXRhKFtcImVkZ2VzXCJdKVxuICB2YXJzLmcuZWRnZXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgLmF0dHIoXCJpZFwiLFwiZWRnZXNcIilcbiAgICAuYXR0cihcIm9wYWNpdHlcIiwwKVxuXG4gIC8vIEVudGVyIEVkZ2UgRm9jdXMgR3JvdXBcbiAgdmFycy5nLmVkZ2VfZm9jdXMgPSB2YXJzLmcudml6LnNlbGVjdEFsbChcImcjZm9jdXNcIikuZGF0YShbXCJmb2N1c1wiXSlcbiAgdmFycy5nLmVkZ2VfZm9jdXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgLmF0dHIoXCJpZFwiLFwiZm9jdXNcIilcblxuICAvLyBFbnRlciBFZGdlIEhvdmVyIEdyb3VwXG4gIHZhcnMuZy5lZGdlX2hvdmVyID0gdmFycy5nLnZpei5zZWxlY3RBbGwoXCJnI2VkZ2VfaG92ZXJcIikuZGF0YShbXCJlZGdlX2hvdmVyXCJdKVxuICB2YXJzLmcuZWRnZV9ob3Zlci5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAuYXR0cihcImlkXCIsXCJlZGdlX2hvdmVyXCIpXG4gICAgLmF0dHIoXCJvcGFjaXR5XCIsMClcblxuICAvLyBFbnRlciBBcHAgRGF0YSBHcm91cFxuICB2YXJzLmcuZGF0YSA9IHZhcnMuZy52aXouc2VsZWN0QWxsKFwiZyNkYXRhXCIpLmRhdGEoW1wiZGF0YVwiXSlcbiAgdmFycy5nLmRhdGEuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgLmF0dHIoXCJpZFwiLFwiZGF0YVwiKVxuICAgIC5hdHRyKFwib3BhY2l0eVwiLDApXG5cbiAgLy8gRW50ZXIgRGF0YSBGb2N1cyBHcm91cFxuICB2YXJzLmcuZGF0YV9mb2N1cyA9IHZhcnMuZy52aXouc2VsZWN0QWxsKFwiZyNkYXRhX2ZvY3VzXCIpLmRhdGEoW1wiZGF0YV9mb2N1c1wiXSlcbiAgdmFycy5nLmRhdGFfZm9jdXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgLmF0dHIoXCJpZFwiLFwiZGF0YV9mb2N1c1wiKVxuXG4gIC8vIEVudGVyIFRvcCBMYWJlbCBHcm91cFxuICB2YXJzLmcubGFiZWxzID0gdmFycy5nLnZpei5zZWxlY3RBbGwoXCJnI2QzcGx1c19sYWJlbHNcIikuZGF0YShbXCJkM3BsdXNfbGFiZWxzXCJdKVxuICB2YXJzLmcubGFiZWxzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgIC5hdHRyKFwiaWRcIixcImQzcGx1c19sYWJlbHNcIilcblxuICB2YXJzLmRlZnMgPSB2YXJzLnN2Zy5zZWxlY3RBbGwoXCJkZWZzXCIpLmRhdGEoW1wiZGVmc1wiXSlcbiAgdmFycy5kZWZzLmVudGVyKCkuYXBwZW5kKFwiZGVmc1wiKVxuXG4gIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lRW5kKFwiY3JlYXRpbmcgU1ZHIGVsZW1lbnRzXCIpXG5cbn1cbiIsInZhciBmZXRjaFRleHQgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9mZXRjaC90ZXh0LmpzXCIpXG4vL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gTWlzY2VsbGFuZW91cyBFcnJvciBDaGVja3Ncbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kM3BsdXMuZHJhdy5lcnJvcnMgPSBmdW5jdGlvbih2YXJzKSB7XG5cbiAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWUoXCJjaGVja2luZyBmb3IgZXJyb3JzXCIpXG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGFsbCByZXF1aXJlZCB2YXJpYWJsZXMgc2V0XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXIgcmVxcyA9IFtcImlkXCJdXG4gICAgLCBhcHBfcmVxcyA9IHZhcnMudHlwZXNbdmFycy50eXBlLnZhbHVlXS5yZXF1aXJlbWVudHNcbiAgaWYgKGFwcF9yZXFzKSB7XG4gICAgaWYgKCEoYXBwX3JlcXMgaW5zdGFuY2VvZiBBcnJheSkpIHJlcXMucHVzaChhcHBfcmVxcylcbiAgICBlbHNlIHJlcXMgPSByZXFzLmNvbmNhdCh2YXJzLnR5cGVzW3ZhcnMudHlwZS52YWx1ZV0ucmVxdWlyZW1lbnRzKVxuICB9XG5cbiAgdmFyIG1pc3NpbmcgPSBbXVxuICByZXFzLmZvckVhY2goZnVuY3Rpb24ocil7XG4gICAgaWYgKHR5cGVvZiByID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoIXZhcnNbcl0udmFsdWUpIG1pc3NpbmcucHVzaChcIlxcXCJcIityK1wiXFxcIlwiKVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB2YXIgcmVxUmV0dXJuID0gcih2YXJzKVxuICAgICAgaWYgKCFyZXFSZXR1cm4uc3RhdHVzICYmIHJlcVJldHVybi50ZXh0KSB7XG4gICAgICAgIG1pc3NpbmcucHVzaChcIlxcXCJcIityZXFSZXR1cm4udGV4dCtcIlxcXCJcIilcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgaWYgKCBtaXNzaW5nLmxlbmd0aCA+IDEgKSB7XG4gICAgdmFyIHN0ciA9IHZhcnMuZm9ybWF0LmxvY2FsZS52YWx1ZS5lcnJvci5tZXRob2RzXG4gICAgICAsIGFwcCA9IHZhcnMuZm9ybWF0LmxvY2FsZS52YWx1ZS52aXN1YWxpemF0aW9uW3ZhcnMudHlwZS52YWx1ZV0gfHwgdmFycy50eXBlLnZhbHVlXG4gICAgICAsIGFuZCA9IHZhcnMuZm9ybWF0LmxvY2FsZS52YWx1ZS51aS5hbmRcbiAgICBtaXNzaW5nID0gZDNwbHVzLnN0cmluZy5saXN0KG1pc3NpbmcsYW5kKVxuICAgIHZhcnMuaW50ZXJuYWxfZXJyb3IgPSBkM3BsdXMuc3RyaW5nLmZvcm1hdChzdHIsYXBwLG1pc3NpbmcpXG4gIH1cbiAgZWxzZSBpZiAoIG1pc3NpbmcubGVuZ3RoID09PSAxICkge1xuICAgIHZhciBzdHIgPSB2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUuZXJyb3IubWV0aG9kXG4gICAgICAsIGFwcCA9IHZhcnMuZm9ybWF0LmxvY2FsZS52YWx1ZS52aXN1YWxpemF0aW9uW3ZhcnMudHlwZS52YWx1ZV0gfHwgdmFycy50eXBlLnZhbHVlXG4gICAgdmFycy5pbnRlcm5hbF9lcnJvciA9IGQzcGx1cy5zdHJpbmcuZm9ybWF0KHN0cixhcHAsbWlzc2luZ1swXSlcbiAgfVxuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBmb2N1cyBjb25uZWN0aW9ucywgaWYgbmVlZGVkXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBpZiAoIXZhcnMuaW50ZXJuYWxfZXJyb3IgJiYgcmVxcy5pbmRleE9mKFwiZWRnZXNcIikgPj0gMCAmJiByZXFzLmluZGV4T2YoXCJmb2N1c1wiKSA+PSAwKSB7XG4gICAgdmFyIGNvbm5lY3Rpb25zID0gdmFycy5lZGdlcy5jb25uZWN0aW9ucyh2YXJzLmZvY3VzLnZhbHVlWzBdLHZhcnMuaWQudmFsdWUpXG4gICAgaWYgKGNvbm5lY3Rpb25zLmxlbmd0aCA9PSAwKSB7XG4gICAgICB2YXIgbmFtZSA9IGZldGNoVGV4dCh2YXJzLHZhcnMuZm9jdXMudmFsdWVbMF0sdmFycy5kZXB0aC52YWx1ZSlcbiAgICAgICAgLCBzdHIgPSB2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUuZXJyb3IuY29ubmVjdGlvbnNcbiAgICAgIHZhcnMuaW50ZXJuYWxfZXJyb3IgPSBkM3BsdXMuc3RyaW5nLmZvcm1hdChzdHIsXCJcXFwiXCIrbmFtZStcIlxcXCJcIilcbiAgICB9XG4gIH1cblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYWxsIHJlcXVpcmVkIGxpYnJhcmllc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgdmFyIHJlcXMgPSBbXCJkM1wiXVxuICBpZiAodmFycy50eXBlc1t2YXJzLnR5cGUudmFsdWVdLmxpYnMpIHtcbiAgICByZXFzID0gcmVxcy5jb25jYXQodmFycy50eXBlc1t2YXJzLnR5cGUudmFsdWVdLmxpYnMpXG4gIH1cbiAgdmFyIG1pc3NpbmcgPSBbXVxuICByZXFzLmZvckVhY2goZnVuY3Rpb24ocil7XG4gICAgaWYgKCF3aW5kb3dbcl0pIG1pc3NpbmcucHVzaChcIlxcXCJcIityK1wiXFxcIlwiKVxuICB9KVxuXG4gIGlmICggbWlzc2luZy5sZW5ndGggPiAxICkge1xuICAgIHZhciBzdHIgPSB2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUuZXJyb3IubGlic1xuICAgICAgLCBhcHAgPSB2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUudmlzdWFsaXphdGlvblt2YXJzLnR5cGUudmFsdWVdXG4gICAgICAsIGFuZCA9IHZhcnMuZm9ybWF0LmxvY2FsZS52YWx1ZS51aS5hbmRcbiAgICBtaXNzaW5nID0gZDNwbHVzLnN0cmluZy5saXN0KG1pc3NpbmcsYW5kKVxuICAgIHZhcnMuaW50ZXJuYWxfZXJyb3IgPSBkM3BsdXMuc3RyaW5nLmZvcm1hdChzdHIsYXBwLG1pc3NpbmcpXG4gIH1cbiAgZWxzZSBpZiAoIG1pc3NpbmcubGVuZ3RoID09PSAxICkge1xuICAgIHZhciBzdHIgPSB2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUuZXJyb3IubGliXG4gICAgICAsIGFwcCA9IHZhcnMuZm9ybWF0LmxvY2FsZS52YWx1ZS52aXN1YWxpemF0aW9uW3ZhcnMudHlwZS52YWx1ZV1cbiAgICB2YXJzLmludGVybmFsX2Vycm9yID0gZDNwbHVzLnN0cmluZy5mb3JtYXQoc3RyLGFwcCxtaXNzaW5nWzBdKVxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgcmVxdWVzdGVkIGFwcCBzdXBwb3J0cyB0aGUgc2V0IHNoYXBlXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXIgc2hhcGVzID0gdmFycy50eXBlc1t2YXJzLnR5cGUudmFsdWVdLnNoYXBlcyB8fCBbXCJjaXJjbGVcIl1cbiAgaWYgKCEoc2hhcGVzIGluc3RhbmNlb2YgQXJyYXkpKSBzaGFwZXMgPSBbc2hhcGVzXVxuXG4gIGlmICghdmFycy5zaGFwZS52YWx1ZSkge1xuICAgIHZhcnMuc2VsZi5zaGFwZShzaGFwZXMubGVuZ3RoID8gc2hhcGVzWzBdIDogXCJjaXJjbGVcIilcbiAgfVxuICBlbHNlIGlmIChzaGFwZXMuaW5kZXhPZih2YXJzLnNoYXBlLnZhbHVlKSA8IDApIHtcbiAgICB2YXIgc2hhcGVzID0gdmFycy50eXBlc1t2YXJzLnR5cGUudmFsdWVdLnNoYXBlcy5qb2luKFwiXFxcIiwgXFxcIlwiKVxuICAgICAgLCBzdHIgPSB2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUuZXJyb3IuYWNjZXB0ZWRcbiAgICAgICwgc2hhcGUgPSBcIlxcXCJcIit2YXJzLnNoYXBlLnZhbHVlK1wiXFxcIlwiXG4gICAgICAsIHNoYXBlU3RyID0gdmFycy5mb3JtYXQubG9jYWxlLnZhbHVlLm1ldGhvZC5zaGFwZVxuICAgICAgLCBhcHAgPSB2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUudmlzdWFsaXphdGlvblt2YXJzLnR5cGUudmFsdWVdIHx8IHZhcnMudHlwZS52YWx1ZVxuICAgIGQzcGx1cy5jb25zb2xlLndhcm5pbmcoZDNwbHVzLnN0cmluZy5mb3JtYXQoc3RyLHNoYXBlLHNoYXBlU3RyLGFwcCxcIlxcXCJcIitzaGFwZXMrXCJcXFwiXCIpLFwic2hhcGVcIilcbiAgICB2YXJzLnNlbGYuc2hhcGUoc2hhcGVzLmxlbmd0aCA/IHNoYXBlc1swXSA6IFwiY2lyY2xlXCIpXG4gIH1cblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSByZXF1ZXN0ZWQgYXBwIHN1cHBvcnRzIHRoZSBzZXQgXCJtb2RlXCJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGlmIChcIm1vZGVzXCIgaW4gdmFycy50eXBlc1t2YXJzLnR5cGUudmFsdWVdKSB7XG4gICAgaWYgKCF2YXJzLnR5cGUubW9kZS52YWx1ZSkge1xuICAgICAgdmFycy5zZWxmLnR5cGUoe1wibW9kZVwiOiB2YXJzLnR5cGVzW3ZhcnMudHlwZS52YWx1ZV0ubW9kZXNbMF19KVxuICAgIH1cbiAgICBlbHNlIGlmICh2YXJzLnR5cGVzW3ZhcnMudHlwZS52YWx1ZV0ubW9kZXMuaW5kZXhPZih2YXJzLnR5cGUubW9kZS52YWx1ZSkgPCAwKSB7XG4gICAgICB2YXIgbW9kZXMgPSB2YXJzLnR5cGVzW3ZhcnMudHlwZS52YWx1ZV0ubW9kZXMuam9pbihcIlxcXCIsIFxcXCJcIilcbiAgICAgICAgLCBzdHIgPSB2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUuZXJyb3IuYWNjZXB0ZWRcbiAgICAgICAgLCBtb2RlID0gXCJcXFwiXCIrdmFycy50eXBlLm1vZGUudmFsdWUrXCJcXFwiXCJcbiAgICAgICAgLCBtb2RlU3RyID0gdmFycy5mb3JtYXQubG9jYWxlLnZhbHVlLm1ldGhvZC5tb2RlXG4gICAgICAgICwgYXBwID0gdmFycy5mb3JtYXQubG9jYWxlLnZhbHVlLnZpc3VhbGl6YXRpb25bdmFycy50eXBlLnZhbHVlXSB8fCB2YXJzLnR5cGUudmFsdWVcbiAgICAgIGQzcGx1cy5jb25zb2xlLndhcm5pbmcoZDNwbHVzLnN0cmluZy5mb3JtYXQoc3RyLG1vZGUsbW9kZVN0cixhcHAsXCJcXFwiXCIrbW9kZXMrXCJcXFwiXCIpKVxuICAgICAgdmFycy5zZWxmLnR5cGUoe1wibW9kZVwiOiB2YXJzLnR5cGVzW3ZhcnMudHlwZS52YWx1ZV0ubW9kZXNbMF19KVxuICAgIH1cbiAgfVxuXG4gIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lRW5kKFwiY2hlY2tpbmcgZm9yIGVycm9yc1wiKVxuXG59XG4iLCJ2YXIgbWV0aG9kUmVzZXQgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9tZXRob2QvcmVzZXQuanNcIilcbi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBGaW5hbGl6ZSBWaXN1YWxpemF0aW9uXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZDNwbHVzLmRyYXcuZmluaXNoID0gZnVuY3Rpb24odmFycykge1xuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBab29tIHRvIGZpdCBib3VuZHMsIGlmIGFwcGxpY2FibGVcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHZhciB6b29tID0gdmFycy56b29tLnZpZXdwb3J0IHx8IHZhcnMuem9vbS5ib3VuZHNcbiAgaWYgKHZhcnMudHlwZXNbdmFycy50eXBlLnZhbHVlXS56b29tICYmIHZhcnMuem9vbS52YWx1ZSAmJiB6b29tKSB7XG5cbiAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZShcImNhbGN1bGF0aW5nIHpvb21cIilcblxuICAgIGlmICh2YXJzLmRyYXcuZmlyc3QpIHtcbiAgICAgIGQzcGx1cy56b29tLmJvdW5kcyh2YXJzLHpvb20sMClcbiAgICB9XG4gICAgZWxzZSBpZiAodmFycy5mb2N1cy5jaGFuZ2VkIHx8IHZhcnMuaGVpZ2h0LmNoYW5nZWQgfHwgdmFycy53aWR0aC5jaGFuZ2VkIHx8IHZhcnMubm9kZXMuY2hhbmdlZCkge1xuICAgICAgZDNwbHVzLnpvb20uYm91bmRzKHZhcnMsem9vbSlcbiAgICB9XG5cbiAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZUVuZChcImNhbGN1bGF0aW5nIHpvb21cIilcblxuICB9XG4gIGVsc2Uge1xuICAgIHZhcnMuem9vbS5zY2FsZSA9IDFcbiAgfVxuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBSZXNpemUvUmVwb3NpdGlvbiBPdmVybGF5IFJlY3QgZm9yIE1vdXNlIGV2ZW50c1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgdmFyIHcgPSB2YXJzLnpvb20uc2l6ZSA/IHZhcnMuem9vbS5zaXplLndpZHRoIDogdmFycy53aWR0aC52aXosXG4gICAgICBoID0gdmFycy56b29tLnNpemUgPyB2YXJzLnpvb20uc2l6ZS5oZWlnaHQgOiB2YXJzLmhlaWdodC52aXosXG4gICAgICB4ID0gdmFycy56b29tLmJvdW5kcyA/IHZhcnMuem9vbS5ib3VuZHNbMF1bMF0gOiAwLFxuICAgICAgeSA9IHZhcnMuem9vbS5ib3VuZHMgPyB2YXJzLnpvb20uYm91bmRzWzBdWzFdIDogMFxuXG4gIHZhcnMuZy5vdmVybGF5XG4gICAgLmF0dHIoXCJ3aWR0aFwiLHcpXG4gICAgLmF0dHIoXCJoZWlnaHRcIixoKVxuICAgIC5hdHRyKFwieFwiLHgpXG4gICAgLmF0dHIoXCJ5XCIseSlcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gQ3JlYXRlIGxhYmVsc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgaWYgKHZhcnMuZHJhdy51cGRhdGUpIHtcbiAgICBkM3BsdXMuc2hhcGUuZWRnZXModmFycylcbiAgICBpZiAodmFycy5kcmF3LnRpbWluZyB8fCAoIXZhcnMudHlwZXNbdmFycy50eXBlLnZhbHVlXS56b29tICYmICF2YXJzLmRyYXcudGltaW5nKSkge1xuICAgICAgZDNwbHVzLnNoYXBlLmxhYmVscyggdmFycyAsIFwiZGF0YVwiIClcbiAgICAgIGlmICh2YXJzLmVkZ2VzLmxhYmVsKSB7XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgIGQzcGx1cy5zaGFwZS5sYWJlbHMoIHZhcnMgLCBcImVkZ2VzXCIgKVxuICAgICAgICB9LHZhcnMuZHJhdy50aW1pbmcrMjAwKVxuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKHZhcnMudHlwZXNbdmFycy50eXBlLnZhbHVlXS56b29tICYmIHZhcnMuem9vbS52YWx1ZSAmJiB2YXJzLmRyYXcudGltaW5nKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgZDNwbHVzLnpvb20ubGFiZWxzKHZhcnMpXG4gICAgfSx2YXJzLmRyYXcudGltaW5nKVxuICB9XG5cbiAgaWYgKHZhcnMudHlwZXNbdmFycy50eXBlLnZhbHVlXS56b29tICYmIHZhcnMuem9vbS52YWx1ZSAmJiB2YXJzLmZvY3VzLnZhbHVlLmxlbmd0aCAmJiAhdmFycy5kcmF3LnRpbWluZykge1xuICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lKFwiZm9jdXMgbGFiZWxzXCIpXG4gICAgZDNwbHVzLnNoYXBlLmxhYmVscyggdmFycyAsIFwiZGF0YV9mb2N1c1wiIClcbiAgICBpZiAodmFycy5lZGdlcy5sYWJlbCkge1xuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgIGQzcGx1cy5zaGFwZS5sYWJlbHMoIHZhcnMgLCBcImVkZ2VfZm9jdXNcIiApXG4gICAgICB9LHZhcnMuZHJhdy50aW1pbmcrMjAwKVxuXG4gICAgfVxuICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lRW5kKFwiZm9jdXMgbGFiZWxzXCIpXG4gIH1cblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gQ2hlY2sgZm9yIEVycm9yc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgdmFyIHJlcXMgPSB2YXJzLnR5cGVzW3ZhcnMudHlwZS52YWx1ZV0ucmVxdWlyZW1lbnRzIHx8IFtdXG4gIGlmICghKHJlcXMgaW5zdGFuY2VvZiBBcnJheSkpIHJlcXMgPSBbcmVxc11cbiAgdmFyIGRhdGFfcmVxID0gcmVxcy5pbmRleE9mKFwiZGF0YVwiKSA+PSAwXG4gIGlmICghdmFycy5pbnRlcm5hbF9lcnJvcikge1xuICAgIGlmICgoIXZhcnMuZGF0YS5hcHAgfHwgIXZhcnMucmV0dXJuZWQubm9kZXMubGVuZ3RoKSAmJiBkYXRhX3JlcSkge1xuICAgICAgdmFycy5pbnRlcm5hbF9lcnJvciA9IHZhcnMuZm9ybWF0LmxvY2FsZS52YWx1ZS5lcnJvci5kYXRhXG4gICAgfVxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIEhpZGUgdGhlIHByZXZpb3VzIGFwcCwgaWYgYXBwbGljYWJsZVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgdmFyIHByZXYgPSB2YXJzLnR5cGUucHJldmlvdXNcbiAgaWYgKHByZXYgJiYgdmFycy50eXBlLnZhbHVlICE9IHByZXYgJiYgdmFycy5nLmFwcHNbcHJldl0pIHtcbiAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZShcImhpZGluZyBcXFwiXCIgKyBwcmV2ICsgXCJcXFwiXCIpXG4gICAgaWYgKHZhcnMuZHJhdy50aW1pbmcpIHtcbiAgICAgIHZhcnMuZy5hcHBzW3ByZXZdLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwwKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhcnMuZy5hcHBzW3ByZXZdLmF0dHIoXCJvcGFjaXR5XCIsMClcbiAgICB9XG4gICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWVFbmQoKVxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIFNob3cgdGhlIGN1cnJlbnQgYXBwLCBkYXRhLCBhbmQgZWRnZXMgZ3JvdXBzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXIgbmV3X29wYWNpdHkgPSAoZGF0YV9yZXEgJiYgdmFycy5kYXRhLmFwcC5sZW5ndGggPT0gMCkgfHwgdmFycy5pbnRlcm5hbF9lcnJvclxuICAgICAgICA/IDAgOiB2YXJzLmZvY3VzLnZhbHVlLmxlbmd0aCAmJiB2YXJzLnR5cGVzW3ZhcnMudHlwZS52YWx1ZV0uem9vbSAmJiB2YXJzLnpvb20udmFsdWUgPyAwLjQgOiAxLFxuICAgICAgb2xkX29wYWNpdHkgPSB2YXJzLmdyb3VwLmF0dHIoXCJvcGFjaXR5XCIpXG5cbiAgaWYgKG5ld19vcGFjaXR5ICE9IG9sZF9vcGFjaXR5KSB7XG5cbiAgICB2YXIgdGltaW5nID0gdmFycy5kcmF3LnRpbWluZ1xuXG4gICAgdmFycy5ncm91cC50cmFuc2l0aW9uKCkuZHVyYXRpb24odGltaW5nKVxuICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsbmV3X29wYWNpdHkpXG4gICAgdmFycy5nLmRhdGEudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRpbWluZylcbiAgICAgIC5hdHRyKFwib3BhY2l0eVwiLG5ld19vcGFjaXR5KVxuICAgIHZhcnMuZy5lZGdlcy50cmFuc2l0aW9uKCkuZHVyYXRpb24odGltaW5nKVxuICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsbmV3X29wYWNpdHkpXG5cbiAgfVxuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBEaXNwbGF5IGFuZCByZXNldCBpbnRlcm5hbF9lcnJvciwgaWYgYXBwbGljYWJsZVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgaWYgKHZhcnMuaW50ZXJuYWxfZXJyb3IpIHtcbiAgICB2YXJzLmludGVybmFsX2Vycm9yID0gZDNwbHVzLnN0cmluZy50aXRsZSggdmFycy5pbnRlcm5hbF9lcnJvciApXG4gICAgZDNwbHVzLmNvbnNvbGUud2FybmluZyh2YXJzLmludGVybmFsX2Vycm9yKVxuICAgIGQzcGx1cy51aS5tZXNzYWdlKHZhcnMsdmFycy5pbnRlcm5hbF9lcnJvcilcbiAgICB2YXJzLmludGVybmFsX2Vycm9yID0gbnVsbFxuICB9XG4gIGVsc2Uge1xuICAgIGQzcGx1cy51aS5tZXNzYWdlKHZhcnMpXG4gIH1cblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gVW5mcmVlemUgY29udHJvbHMgYW5kIGFwcGx5IHpvb20gYmVoYXZpb3IsIGlmIGFwcGxpY2FibGVcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblxuICAgIG1ldGhvZFJlc2V0KCB2YXJzIClcblxuICAgIGlmICh2YXJzLnR5cGVzW3ZhcnMudHlwZS52YWx1ZV0uem9vbSAmJiB2YXJzLnpvb20udmFsdWUpIHtcbiAgICAgIHZhcnMuZy56b29tXG4gICAgICAgIC5kYXR1bSh2YXJzKVxuICAgICAgICAuY2FsbCh2YXJzLnpvb20uYmVoYXZpb3Iub24oXCJ6b29tXCIsZDNwbHVzLnpvb20ubW91c2UpKVxuICAgICAgaWYgKCF2YXJzLnpvb20uc2Nyb2xsLnZhbHVlKSB7XG4gICAgICAgIHZhcnMuZy56b29tLm9uKFwid2hlZWwuem9vbVwiLG51bGwpXG4gICAgICB9XG4gICAgICBpZiAoIXZhcnMuem9vbS5jbGljay52YWx1ZSkge1xuICAgICAgICB2YXJzLmcuem9vbS5vbihcImRibGNsaWNrLnpvb21cIixudWxsKVxuICAgICAgfVxuICAgICAgaWYgKCF2YXJzLnpvb20ucGFuLnZhbHVlKSB7XG4gICAgICAgIHZhcnMuZy56b29tLm9uKFwibW91c2Vtb3ZlLnpvb21cIixudWxsKVxuICAgICAgICB2YXJzLmcuem9vbS5vbihcIm1vdXNlZG93bi56b29tXCIsbnVsbClcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXJzLmcuem9vbVxuICAgICAgICAuY2FsbCh2YXJzLnpvb20uYmVoYXZpb3Iub24oXCJ6b29tXCIsbnVsbCkpXG4gICAgfVxuXG4gIH0sdmFycy5kcmF3LnRpbWluZylcblxufVxuIiwiLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIENyZWF0ZXMgZm9jdXMgZWxlbWVudHMsIGlmIGF2YWlsYWJsZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmQzcGx1cy5kcmF3LmZvY3VzID0gZnVuY3Rpb24odmFycykge1xuXG4gIHZhcnMuZy5lZGdlX2ZvY3VzXG4gICAgLnNlbGVjdEFsbChcImdcIilcbiAgICAucmVtb3ZlKClcblxuICB2YXJzLmcuZGF0YV9mb2N1c1xuICAgIC5zZWxlY3RBbGwoXCJnXCIpXG4gICAgLnJlbW92ZSgpXG5cbiAgaWYgKHZhcnMuZm9jdXMudmFsdWUubGVuZ3RoICYmIHZhcnMudHlwZXNbdmFycy50eXBlLnZhbHVlXS56b29tICYmIHZhcnMuem9vbS52YWx1ZSkge1xuXG4gICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWUoXCJkcmF3aW5nIGZvY3VzIGVsZW1lbnRzXCIpXG5cbiAgICB2YXIgZWRnZXMgPSB2YXJzLmcuZWRnZXMuc2VsZWN0QWxsKFwiZ1wiKVxuXG4gICAgaWYgKGVkZ2VzLnNpemUoKSA+IDApIHtcblxuICAgICAgZWRnZXMuZWFjaChmdW5jdGlvbihsKXtcblxuICAgICAgICAgIHZhciBzb3VyY2UgPSBsW3ZhcnMuZWRnZXMuc291cmNlXVt2YXJzLmlkLnZhbHVlXSxcbiAgICAgICAgICAgICAgdGFyZ2V0ID0gbFt2YXJzLmVkZ2VzLnRhcmdldF1bdmFycy5pZC52YWx1ZV1cblxuICAgICAgICAgIGlmIChzb3VyY2UgPT0gdmFycy5mb2N1cy52YWx1ZVswXSB8fCB0YXJnZXQgPT0gdmFycy5mb2N1cy52YWx1ZVswXSkge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSB2YXJzLmcuZWRnZV9mb2N1cy5ub2RlKCkuYXBwZW5kQ2hpbGQodGhpcy5jbG9uZU5vZGUodHJ1ZSkpXG4gICAgICAgICAgICBkMy5zZWxlY3QoZWxlbSkuZGF0dW0obCkuYXR0cihcIm9wYWNpdHlcIiwxKVxuICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwibGluZSwgcGF0aFwiKS5kYXR1bShsKVxuICAgICAgICAgIH1cblxuICAgICAgICB9KVxuXG5cbiAgICAgIHZhciBtYXJrZXIgPSB2YXJzLmVkZ2VzLmFycm93cy52YWx1ZVxuXG4gICAgICB2YXJzLmcuZWRnZV9mb2N1cy5zZWxlY3RBbGwoXCJsaW5lLCBwYXRoXCIpXG4gICAgICAgIC5hdHRyKFwidmVjdG9yLWVmZmVjdFwiLFwibm9uLXNjYWxpbmctc3Ryb2tlXCIpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZVwiLHZhcnMuY29sb3IuZm9jdXMpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLGZ1bmN0aW9uKCl7XG4gICAgICAgICAgcmV0dXJuIHZhcnMuZWRnZXMuc2l6ZSA/IGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcInN0cm9rZS13aWR0aFwiKVxuICAgICAgICAgICAgICAgOiB2YXJzLmRhdGEuc3Ryb2tlLndpZHRoKjJcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJtYXJrZXItc3RhcnRcIixmdW5jdGlvbihlKXtcblxuICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSB2YXJzLmVkZ2VzLmFycm93cy5kaXJlY3Rpb24udmFsdWVcblxuICAgICAgICAgIGlmIChcImJ1Y2tldFwiIGluIGUuZDNwbHVzKSB7XG4gICAgICAgICAgICB2YXIgZCA9IFwiX1wiK2UuZDNwbHVzLmJ1Y2tldFxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkID0gXCJcIlxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24gPT0gXCJzb3VyY2VcIiAmJiBtYXJrZXJcbiAgICAgICAgICAgICAgID8gXCJ1cmwoI2QzcGx1c19lZGdlX21hcmtlcl9mb2N1c1wiK2QrXCIpXCIgOiBcIm5vbmVcIlxuXG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwibWFya2VyLWVuZFwiLGZ1bmN0aW9uKGUpe1xuXG4gICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHZhcnMuZWRnZXMuYXJyb3dzLmRpcmVjdGlvbi52YWx1ZVxuXG4gICAgICAgICAgaWYgKFwiYnVja2V0XCIgaW4gZS5kM3BsdXMpIHtcbiAgICAgICAgICAgIHZhciBkID0gXCJfXCIrZS5kM3BsdXMuYnVja2V0XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGQgPSBcIlwiXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbiA9PSBcInRhcmdldFwiICYmIG1hcmtlclxuICAgICAgICAgICAgICAgPyBcInVybCgjZDNwbHVzX2VkZ2VfbWFya2VyX2ZvY3VzXCIrZCtcIilcIiA6IFwibm9uZVwiXG5cbiAgICAgICAgfSlcblxuICAgICAgdmFycy5nLmVkZ2VfZm9jdXMuc2VsZWN0QWxsKFwidGV4dFwiKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsdmFycy5jb2xvci5mb2N1cylcblxuICAgIH1cblxuICAgIHZhciBmb2NpaSA9IGQzcGx1cy51dGlsLnVuaXF1ZXModmFycy5lZGdlcy5jb25uZWN0aW9ucyh2YXJzLmZvY3VzLnZhbHVlWzBdLHZhcnMuaWQudmFsdWUsdHJ1ZSksdmFycy5pZC52YWx1ZSlcbiAgICBmb2NpaS5wdXNoKHZhcnMuZm9jdXMudmFsdWVbMF0pXG5cbiAgICB2YXIgeF9ib3VuZHMgPSBbXSwgeV9ib3VuZHMgPSBbXSwgeF9idWZmZXIgPSBbMF0sIHlfYnVmZmVyID0gWzBdXG5cbiAgICB2YXIgZ3JvdXBzID0gdmFycy5nLmRhdGEuc2VsZWN0QWxsKFwiZ1wiKVxuICAgICAgLmVhY2goZnVuY3Rpb24oZCl7XG4gICAgICAgIGlmIChmb2NpaS5pbmRleE9mKGRbdmFycy5pZC52YWx1ZV0pID49IDApIHtcbiAgICAgICAgICB2YXIgZWxlbSA9IHZhcnMuZy5kYXRhX2ZvY3VzLm5vZGUoKS5hcHBlbmRDaGlsZCh0aGlzLmNsb25lTm9kZSh0cnVlKSlcbiAgICAgICAgICB2YXIgZWxlbSA9IGQzLnNlbGVjdChlbGVtKS5kYXR1bShkKS5hdHRyKFwib3BhY2l0eVwiLDEpXG5cbiAgICAgICAgICBpZiAodmFycy5zaGFwZS52YWx1ZSA9PSBcImNvb3JkaW5hdGVzXCIpIHtcblxuICAgICAgICAgICAgdmFycy56b29tLnZpZXdwb3J0ID0gdmFycy5wYXRoLmJvdW5kcyh2YXJzLnpvb20uY29vcmRzW2QuZDNwbHVzLmlkXSlcblxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChcImQzcGx1c1wiIGluIGQpIHtcbiAgICAgICAgICAgIGlmIChcInhcIiBpbiBkLmQzcGx1cykge1xuICAgICAgICAgICAgICB4X2JvdW5kcy5wdXNoKGQuZDNwbHVzLngpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJ5XCIgaW4gZC5kM3BsdXMpIHtcbiAgICAgICAgICAgICAgeV9ib3VuZHMucHVzaChkLmQzcGx1cy55KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFwiclwiIGluIGQuZDNwbHVzKSB7XG4gICAgICAgICAgICAgIHhfYnVmZmVyLnB1c2goZC5kM3BsdXMucilcbiAgICAgICAgICAgICAgeV9idWZmZXIucHVzaChkLmQzcGx1cy5yKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChcIndpZHRoXCIgaW4gZC5kM3BsdXMpIHtcbiAgICAgICAgICAgICAgICB4X2J1ZmZlci5wdXNoKGQuZDNwbHVzLndpZHRoLzIpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKFwiaGVpZ2h0XCIgaW4gZC5kM3BsdXMpIHtcbiAgICAgICAgICAgICAgICB5X2J1ZmZlci5wdXNoKGQuZDNwbHVzLmhlaWdodC8yKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChlIGluIGQzcGx1cy5ldnQpIHtcbiAgICAgICAgICAgIHZhciBldnQgPSBkMy5zZWxlY3QodGhpcykub24oZDNwbHVzLmV2dFtlXSlcbiAgICAgICAgICAgIGlmIChldnQpIHtcbiAgICAgICAgICAgICAgZWxlbS5vbihkM3BsdXMuZXZ0W2VdLGV2dClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgIGlmICh4X2JvdW5kcy5sZW5ndGggJiYgeV9ib3VuZHMubGVuZ3RoKSB7XG5cbiAgICAgIHZhciB4Y29vcmRzID0gZDMuZXh0ZW50KHhfYm91bmRzKSxcbiAgICAgICAgICB5Y29vcmRzID0gZDMuZXh0ZW50KHlfYm91bmRzKSxcbiAgICAgICAgICB4bWF4ID0gZDMubWF4KHhfYnVmZmVyKSxcbiAgICAgICAgICB5bWF4ID0gZDMubWF4KHlfYnVmZmVyKVxuXG4gICAgICB2YXJzLnpvb20udmlld3BvcnQgPSBbXG4gICAgICAgIFt4Y29vcmRzWzBdLXhtYXgseWNvb3Jkc1swXS15bWF4XSxcbiAgICAgICAgW3hjb29yZHNbMV0reG1heCx5Y29vcmRzWzFdK3ltYXhdXG4gICAgICBdXG5cbiAgICB9XG5cbiAgICB2YXJzLmcuZGF0YV9mb2N1cy5zZWxlY3RBbGwoXCJwYXRoXCIpXG4gICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIix2YXJzLmRhdGEuc3Ryb2tlLndpZHRoKjIpXG5cbiAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZUVuZChcImRyYXdpbmcgZm9jdXMgZWxlbWVudHNcIilcblxuICB9XG4gIGVsc2Uge1xuICAgIHZhcnMuem9vbS52aWV3cG9ydCA9IGZhbHNlXG4gIH1cblxufVxuIiwidmFyIGRhdGFGb3JtYXQgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9kYXRhL2Zvcm1hdC5qc1wiKSxcbiAgICBkYXRhQ29sb3IgID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvZGF0YS9jb2xvci5qc1wiKSxcbiAgICBkYXRhS2V5cyAgID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvZGF0YS9rZXlzLmpzXCIpLFxuICAgIGRhdGFMb2FkICAgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9kYXRhL2xvYWQuY29mZmVlXCIpLFxuICAgIGZldGNoRGF0YSAgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9mZXRjaC9kYXRhLmpzXCIpLFxuICAgIHBhcnNlRWRnZXMgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9wYXJzZS9lZGdlcy5qc1wiKSxcbiAgICBwYXJzZU5vZGVzID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvcGFyc2Uvbm9kZXMuanNcIilcbi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBDYWxjdWxhdGUgc3RlcHMgbmVlZGVkIHRvIHJlZHJhdyB0aGUgdmlzdWFsaXphdGlvblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmQzcGx1cy5kcmF3LnN0ZXBzID0gZnVuY3Rpb24odmFycykge1xuXG4gIHZhciBzdGVwcyAgICAgICA9IFtdXG4gICAgLCBhcHBUeXBlICAgICA9IHZhcnMudHlwZS52YWx1ZVxuICAgICwgbG9jYWxlICAgICAgPSB2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWVcbiAgICAsIHVpTWVzc2FnZSAgID0gbG9jYWxlLm1lc3NhZ2UudWlcbiAgICAsIGRyYXdNZXNzYWdlID0gbG9jYWxlLm1lc3NhZ2UuZHJhd1xuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBDaGVjayB0byBzZWUgaWYgYW55IGRhdGEgbmVlZHMgdG8gYmUgbG9hZGVkIHdpdGggSlNPTlxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgdmFyIHVybExvYWRzID0gWyBcImRhdGFcIiAsIFwiYXR0cnNcIiAsIFwiY29vcmRzXCIgLCBcIm5vZGVzXCIgLCBcImVkZ2VzXCIgXVxuICB1cmxMb2Fkcy5mb3JFYWNoKGZ1bmN0aW9uKHUpe1xuXG4gICAgaWYgKCAhdmFyc1t1XS5sb2FkZWQgJiYgdmFyc1t1XS51cmwgKSB7XG5cbiAgICAgIHN0ZXBzLnB1c2goe1xuICAgICAgICBcImZ1bmN0aW9uXCI6IGZ1bmN0aW9uKCB2YXJzICwgbmV4dCApe1xuICAgICAgICAgIGRhdGFMb2FkKCB2YXJzICwgdSAsIG5leHQgKVxuICAgICAgICB9LFxuICAgICAgICBcIm1lc3NhZ2VcIjogbG9jYWxlLm1lc3NhZ2UubG9hZGluZyxcbiAgICAgICAgXCJ3YWl0XCI6IHRydWVcbiAgICAgIH0pXG5cbiAgICB9XG5cbiAgfSlcblxuICBpZiAodmFycy5kcmF3LnVwZGF0ZSkge1xuXG4gICAgdmFyIGFwcE5hbWUgICAgID0gbG9jYWxlLnZpc3VhbGl6YXRpb25bYXBwVHlwZV0gfHwgYXBwVHlwZVxuICAgICAgLCBhcHBTZXR1cCAgICA9IHZhcnMudHlwZXNbYXBwVHlwZV0uc2V0dXAgfHwgZmFsc2VcbiAgICAgICwgYXBwUmVxcyAgICAgPSB2YXJzLnR5cGVzW2FwcFR5cGVdLnJlcXVpcmVtZW50cyB8fCBbXVxuICAgICAgLCBhcHBNZXNzYWdlICA9IGQzcGx1cy5zdHJpbmcuZm9ybWF0KGxvY2FsZS5tZXNzYWdlLmluaXRpYWxpemluZyxhcHBOYW1lKVxuICAgICAgLCBkYXRhTWVzc2FnZSA9IGxvY2FsZS5tZXNzYWdlLmRhdGFcblxuICAgIGlmICghKGFwcFJlcXMgaW5zdGFuY2VvZiBBcnJheSkpIGFwcFJlcXMgPSBbYXBwUmVxc11cbiAgICBhcHBOYW1lID0gYXBwTmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgLy8gSWYgaXQgaGFzIG9uZSwgcnVuIHRoZSBjdXJyZW50IGFwcCdzIHNldHVwIGZ1bmN0aW9uLlxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBpZiAoIHR5cGVvZiBhcHBTZXR1cCA9PT0gXCJmdW5jdGlvblwiICkge1xuXG4gICAgICBzdGVwcy5wdXNoKHtcbiAgICAgICAgXCJmdW5jdGlvblwiOiBmdW5jdGlvbiggdmFycyApIHtcblxuICAgICAgICAgIGlmICggdmFycy5kZXYudmFsdWUgKSB7XG4gICAgICAgICAgICB2YXIgdGltZXJTdHJpbmcgPSBcInJ1bm5pbmcgXCIgKyBhcHBOYW1lICsgXCIgc2V0dXBcIlxuICAgICAgICAgICAgZDNwbHVzLmNvbnNvbGUudGltZSggdGltZXJTdHJpbmcgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGFwcFNldHVwKCB2YXJzIClcblxuICAgICAgICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lRW5kKCB0aW1lclN0cmluZyApXG5cbiAgICAgICAgfSxcbiAgICAgICAgXCJtZXNzYWdlXCI6IGFwcE1lc3NhZ2VcbiAgICAgIH0pXG5cbiAgICB9XG5cbiAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgLy8gQ3JlYXRlIFNWRyBncm91cCBlbGVtZW50cyBpZiB0aGUgY29udGFpbmVyIGlzIG5ldyBvciBoYXMgY2hhbmdlZFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBpZiAoIHZhcnMuY29udGFpbmVyLmNoYW5nZWQgKSB7XG5cbiAgICAgIHN0ZXBzLnB1c2goeyBcImZ1bmN0aW9uXCIgOiBkM3BsdXMuZHJhdy5lbnRlciAsIFwibWVzc2FnZVwiIDogYXBwTWVzc2FnZSB9KVxuXG4gICAgfVxuXG4gICAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAgIC8vIENyZWF0ZSBncm91cCBmb3IgY3VycmVudCBhcHAsIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGlmICggISggYXBwVHlwZSBpbiB2YXJzLmcuYXBwcyApICkge1xuXG4gICAgICBzdGVwcy5wdXNoKHtcbiAgICAgICAgXCJmdW5jdGlvblwiOiBmdW5jdGlvbiggdmFycyApIHtcblxuICAgICAgICAgIGlmICggdmFycy5kZXYudmFsdWUgKSB7XG4gICAgICAgICAgICB2YXIgdGltZXJTdHJpbmcgPSBcImNyZWF0aW5nIFwiICsgYXBwTmFtZSArIFwiIGdyb3VwXCJcbiAgICAgICAgICAgIGQzcGx1cy5jb25zb2xlLnRpbWUoIHRpbWVyU3RyaW5nIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXJzLmcuYXBwc1thcHBUeXBlXSA9IHZhcnMuZy5hcHBcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJnI1wiK2FwcFR5cGUpXG4gICAgICAgICAgICAuZGF0YShbYXBwVHlwZV0pXG5cbiAgICAgICAgICB2YXJzLmcuYXBwc1thcHBUeXBlXS5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIixhcHBUeXBlKVxuICAgICAgICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsMClcblxuICAgICAgICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lRW5kKCB0aW1lclN0cmluZyApXG5cbiAgICAgICAgfSxcbiAgICAgICAgXCJtZXNzYWdlXCI6IGFwcE1lc3NhZ2VcbiAgICAgIH0pXG5cbiAgICB9XG5cbiAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgLy8gSWYgbmV3IGRhdGEgaXMgZGV0ZWN0ZWQsIGFuYWx5emUgYW5kIHJlc2V0IGl0LlxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBpZiAoIHZhcnMuZGF0YS5jaGFuZ2VkICkge1xuXG4gICAgICBzdGVwcy5wdXNoKHtcbiAgICAgICAgXCJmdW5jdGlvblwiOiBmdW5jdGlvbih2YXJzKSB7XG4gICAgICAgICAgdmFycy5kYXRhLmNhY2hlID0ge31cbiAgICAgICAgICBkZWxldGUgdmFycy5ub2Rlcy5yZXN0cmljdGVkXG4gICAgICAgICAgZGVsZXRlIHZhcnMuZWRnZXMucmVzdHJpY3RlZFxuICAgICAgICAgIGRhdGFLZXlzKCB2YXJzICwgXCJkYXRhXCIgKVxuICAgICAgICB9LFxuICAgICAgICBcIm1lc3NhZ2VcIjogZGF0YU1lc3NhZ2VcbiAgICAgIH0pXG5cbiAgICB9XG5cbiAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgLy8gSWYgbmV3IGF0dHJpYnV0ZXMgYXJlIGRldGVjdGVkLCBhbmFseXplIHRoZW0uXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGlmICggdmFycy5hdHRycy5jaGFuZ2VkICkge1xuXG4gICAgICBzdGVwcy5wdXNoKHtcbiAgICAgICAgXCJmdW5jdGlvblwiOiBmdW5jdGlvbiggdmFycyApIHtcbiAgICAgICAgICBkYXRhS2V5cyggdmFycyAsIFwiYXR0cnNcIiApXG4gICAgICAgIH0sXG4gICAgICAgIFwibWVzc2FnZVwiOiBkYXRhTWVzc2FnZVxuICAgICAgfSlcblxuICAgIH1cblxuICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAvLyBEZXRlcm1pbmUgY29sb3IgdHlwZVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBzdGVwcy5wdXNoKHtcbiAgICAgIFwiZnVuY3Rpb25cIjogZnVuY3Rpb24odmFycykge1xuXG4gICAgICAgICAgaWYgKCB2YXJzLmNvbG9yLmNoYW5nZWQgJiYgdmFycy5jb2xvci52YWx1ZSApIHtcblxuICAgICAgICAgICAgdmFycy5jb2xvci52YWx1ZVNjYWxlID0gbnVsbFxuXG4gICAgICAgICAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkge1xuICAgICAgICAgICAgICB2YXIgdGltZXJTdHJpbmcgPSBcImRldGVybWluaW5nIGNvbG9yIHR5cGVcIlxuICAgICAgICAgICAgICBkM3BsdXMuY29uc29sZS50aW1lKCB0aW1lclN0cmluZyApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjb2xvcktleSA9IHZhcnMuY29sb3IudmFsdWVcblxuICAgICAgICAgICAgaWYgKCBkM3BsdXMub2JqZWN0LnZhbGlkYXRlKGNvbG9yS2V5KSApIHtcbiAgICAgICAgICAgICAgaWYgKGNvbG9yS2V5W3ZhcnMuaWQudmFsdWVdKSB7XG4gICAgICAgICAgICAgICAgY29sb3JLZXkgPSBjb2xvcktleVt2YXJzLmlkLnZhbHVlXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbG9yS2V5ID0gY29sb3JLZXlbZDMua2V5cyhjb2xvcktleSlbMF1dXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB2YXJzLmRhdGEua2V5cyAmJiBjb2xvcktleSBpbiB2YXJzLmRhdGEua2V5cyApIHtcbiAgICAgICAgICAgICAgdmFycy5jb2xvci50eXBlID0gdmFycy5kYXRhLmtleXNbY29sb3JLZXldXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICggdmFycy5hdHRycy5rZXlzICYmIGNvbG9yS2V5IGluIHZhcnMuYXR0cnMua2V5cyApIHtcbiAgICAgICAgICAgICAgdmFycy5jb2xvci50eXBlID0gdmFycy5hdHRycy5rZXlzW2NvbG9yS2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhcnMuY29sb3IudHlwZSA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZUVuZCggdGltZXJTdHJpbmcgKVxuXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKCF2YXJzLmNvbG9yLnZhbHVlKSB7XG4gICAgICAgICAgICB2YXJzLmNvbG9yLnR5cGUgPSBcImtleXNcIiBpbiB2YXJzLmRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHZhcnMuZGF0YS5rZXlzW3ZhcnMuaWQudmFsdWVdIDogZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgIH0sXG4gICAgICBcIm1lc3NhZ2VcIjogZGF0YU1lc3NhZ2VcbiAgICB9KVxuXG4gICAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAgIC8vIEZvcm1hdCBub2Rlcy9lZGdlcyBpZiBuZWVkZWRcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgaWYgKCBhcHBSZXFzLmluZGV4T2YoXCJlZGdlc1wiKSA+PSAwICYmIHZhcnMuZWRnZXMudmFsdWVcbiAgICAmJiAoICF2YXJzLmVkZ2VzLmxpbmtlZCB8fCB2YXJzLmVkZ2VzLmNoYW5nZWQgKSApIHtcbiAgICAgIHN0ZXBzLnB1c2goeyBcImZ1bmN0aW9uXCIgOiBwYXJzZUVkZ2VzLCBcIm1lc3NhZ2VcIiA6IGRhdGFNZXNzYWdlIH0pXG4gICAgfVxuXG4gICAgaWYgKCBhcHBSZXFzLmluZGV4T2YoXCJub2Rlc1wiKSA+PSAwICYmIHZhcnMuZWRnZXMudmFsdWVcbiAgICAmJiAoICF2YXJzLm5vZGVzLnBvc2l0aW9ucyB8fCB2YXJzLm5vZGVzLmNoYW5nZWQgKSApIHtcbiAgICAgIHN0ZXBzLnB1c2goeyBcImZ1bmN0aW9uXCIgOiBwYXJzZU5vZGVzICwgXCJtZXNzYWdlXCIgOiBkYXRhTWVzc2FnZSB9KVxuICAgIH1cblxuICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAvLyBHcm91cHMgZGF0YSBieSB0aW1lIGFuZCBuZXN0aW5nLlxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBpZiAoIHZhcnMuZGF0YS5jaGFuZ2VkIHx8IHZhcnMudGltZS5jaGFuZ2VkIHx8IHZhcnMuaWQuY2hhbmdlZCApIHtcbiAgICAgIHN0ZXBzLnB1c2goeyBcImZ1bmN0aW9uXCIgOiBkYXRhRm9ybWF0ICwgXCJtZXNzYWdlXCIgOiBkYXRhTWVzc2FnZSB9KVxuICAgIH1cblxuICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAvLyBGZXRjaGVzIGRhdGEgZm9yIGFwcCBhbmQgXCJwb29sXCJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgc3RlcHMucHVzaCh7XG4gICAgICBcImZ1bmN0aW9uXCI6IGZ1bmN0aW9uKHZhcnMpIHtcblxuICAgICAgICB2YXIgeWVhciA9ICF2YXJzLnRpbWUuZml4ZWQudmFsdWUgPyBbXCJhbGxcIl0gOiBudWxsXG4gICAgICAgIGlmICggdmFycy5kZXYudmFsdWUgKSB7XG4gICAgICAgICAgdmFyIHRpbWVyU3RyaW5nID0geWVhciA/IFwiZmV0Y2hpbmcgcG9vbCBkYXRhXCIgOiBcImZldGNoaW5nIGRhdGFcIlxuICAgICAgICAgIGQzcGx1cy5jb25zb2xlLnRpbWUoIHRpbWVyU3RyaW5nIClcbiAgICAgICAgfVxuICAgICAgICB2YXJzLmRhdGEucG9vbCA9IGZldGNoRGF0YSggdmFycyAsIHllYXIgKVxuICAgICAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZUVuZCggdGltZXJTdHJpbmcgKVxuICAgICAgICBpZiAoICF5ZWFyICkge1xuICAgICAgICAgIHZhcnMuZGF0YS5hcHAgPSB2YXJzLmRhdGEucG9vbFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lKFwiZmV0Y2hpbmcgZGF0YSBmb3IgY3VycmVudCB5ZWFyXCIpXG4gICAgICAgICAgdmFycy5kYXRhLmFwcCA9IGZldGNoRGF0YSggdmFycyApXG4gICAgICAgICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWVFbmQoXCJmZXRjaGluZyBkYXRhIGZvciBjdXJyZW50IHllYXJcIilcbiAgICAgICAgfVxuXG4gICAgICB9LFxuICAgICAgXCJtZXNzYWdlXCI6IGRhdGFNZXNzYWdlXG4gICAgfSlcblxuICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAvLyBDYWxjdWxhdGUgY29sb3Igc2NhbGUgaWYgdHlwZSBpcyBudW1iZXJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgc3RlcHMucHVzaCh7XG4gICAgICBcImNoZWNrXCI6IGZ1bmN0aW9uKHZhcnMpIHtcblxuICAgICAgICByZXR1cm4gdmFycy5jb2xvci52YWx1ZSAmJiB2YXJzLmNvbG9yLnR5cGUgPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgICAgICAgIHZhcnMuaWQubmVzdGluZy5pbmRleE9mKHZhcnMuY29sb3IudmFsdWUpIDwgMCAmJlxuICAgICAgICAgICAgICAgdmFycy5kYXRhLnZhbHVlICYmIHZhcnMuY29sb3IudmFsdWUgIT0gdmFycy5pZC52YWx1ZSAmJlxuICAgICAgICAgICAgICAgICAodmFycy5jb2xvci5jaGFuZ2VkIHx8IHZhcnMuZGF0YS5jaGFuZ2VkIHx8IHZhcnMuZGVwdGguY2hhbmdlZCB8fFxuICAgICAgICAgICAgICAgICAgICh2YXJzLnRpbWUuZml4ZWQudmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICh2YXJzLnRpbWUuc29sby5jaGFuZ2VkIHx8IHZhcnMudGltZS5tdXRlLmNoYW5nZWQpXG4gICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICApXG5cbiAgICAgIH0sXG4gICAgICBcImZ1bmN0aW9uXCI6IGRhdGFDb2xvcixcbiAgICAgIFwibWVzc2FnZVwiOiBkYXRhTWVzc2FnZVxuICAgIH0pXG5cbiAgfVxuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBSZW1vdmUgYW55IGxpbmdlcmluZyB0b29sdGlwcy5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHN0ZXBzLnB1c2goe1xuICAgIFwiZnVuY3Rpb25cIjogZnVuY3Rpb24odmFycykge1xuICAgICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIHtcbiAgICAgICAgdmFyIHN0ciA9IHZhcnMuZm9ybWF0LmxvY2FsZS52YWx1ZS5tZXNzYWdlLnRvb2x0aXBSZXNldFxuICAgICAgICBkM3BsdXMuY29uc29sZS50aW1lKHN0cilcbiAgICAgIH1cbiAgICAgIGlmICggdmFycy50eXBlLnByZXZpb3VzICYmIGFwcFR5cGUgIT09IHZhcnMudHlwZS5wcmV2aW91cyApIHtcbiAgICAgICAgZDNwbHVzLnRvb2x0aXAucmVtb3ZlKHZhcnMudHlwZS5wcmV2aW91cylcbiAgICAgIH1cbiAgICAgIGQzcGx1cy50b29sdGlwLnJlbW92ZShhcHBUeXBlKVxuICAgICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWVFbmQoc3RyKVxuICAgIH0sXG4gICAgXCJtZXNzYWdlXCI6IHVpTWVzc2FnZVxuICB9KVxuXG4gIHN0ZXBzLnB1c2goe1wiZnVuY3Rpb25cIjogZDNwbHVzLmRyYXcuZXJyb3JzLCBcIm1lc3NhZ2VcIjogdWlNZXNzYWdlfSlcblxuICBzdGVwcy5wdXNoKHtcbiAgICBcImZ1bmN0aW9uXCI6IGZ1bmN0aW9uKHZhcnMpIHtcblxuICAgICAgdmFycy5tYXJnaW4ucHJvY2VzcygpXG4gICAgICBkM3BsdXMudWkudGl0bGVzKHZhcnMpXG5cbiAgICAgIGlmICggdmFycy5kcmF3LnVwZGF0ZSApIHtcblxuICAgICAgICBkM3BsdXMudWkuZHJhd2VyKHZhcnMpXG4gICAgICAgIGQzcGx1cy51aS50aW1lbGluZSh2YXJzKVxuICAgICAgICBkM3BsdXMudWkubGVnZW5kKHZhcnMpXG5cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuXG4gICAgICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lKFwiY2FsY3VsYXRpbmcgbWFyZ2luc1wiKVxuXG4gICAgICAgIHZhciBkcmF3ZXIgPSB2YXJzLmNvbnRhaW5lci52YWx1ZS5zZWxlY3QoXCJkaXYjZDNwbHVzX2RyYXdlclwiKS5ub2RlKCkub2Zmc2V0SGVpZ2h0XG4gICAgICAgICAgICAgICAgICB8fCB2YXJzLmNvbnRhaW5lci52YWx1ZS5zZWxlY3QoXCJkaXYjZDNwbHVzX2RyYXdlclwiKS5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG5cbiAgICAgICAgdmFyIHRpbWVsaW5lID0gdmFycy5nLnRpbWVsaW5lLm5vZGUoKS5nZXRCQm94KClcbiAgICAgICAgdGltZWxpbmUgPSB2YXJzLnRpbWVsaW5lLnZhbHVlID8gdGltZWxpbmUuaGVpZ2h0K3RpbWVsaW5lLnkgOiAwXG5cbiAgICAgICAgdmFyIGxlZ2VuZCA9IHZhcnMuZy5sZWdlbmQubm9kZSgpLmdldEJCb3goKVxuICAgICAgICBsZWdlbmQgPSB2YXJzLmxlZ2VuZC52YWx1ZSA/IGxlZ2VuZC5oZWlnaHQrbGVnZW5kLnkgOiAwXG5cbiAgICAgICAgdmFycy5tYXJnaW4uYm90dG9tICs9IGRyYXdlcit0aW1lbGluZStsZWdlbmRcblxuICAgICAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZUVuZChcImNhbGN1bGF0aW5nIG1hcmdpbnNcIilcblxuICAgICAgfVxuXG4gICAgICBkM3BsdXMudWkuaGlzdG9yeSh2YXJzKVxuICAgICAgdmFycy5oZWlnaHQudml6IC09ICh2YXJzLm1hcmdpbi50b3ArdmFycy5tYXJnaW4uYm90dG9tKVxuICAgICAgdmFycy53aWR0aC52aXogLT0gKHZhcnMubWFyZ2luLmxlZnQrdmFycy5tYXJnaW4ucmlnaHQpXG5cbiAgICB9LFxuICAgIFwibWVzc2FnZVwiOiB1aU1lc3NhZ2VcbiAgfSlcblxuICBzdGVwcy5wdXNoKHtcbiAgICBcImZ1bmN0aW9uXCI6IGQzcGx1cy51aS5mb2N1cyxcbiAgICBcIm1lc3NhZ2VcIjogdWlNZXNzYWdlXG4gIH0pXG5cbiAgc3RlcHMucHVzaCh7XG4gICAgXCJmdW5jdGlvblwiOiBkM3BsdXMuZHJhdy51cGRhdGUsXG4gICAgXCJtZXNzYWdlXCI6IGRyYXdNZXNzYWdlXG4gIH0pXG5cbiAgaWYgKCB2YXJzLmRyYXcudXBkYXRlICkge1xuICAgIHN0ZXBzLnB1c2goe1xuICAgICAgXCJmdW5jdGlvblwiIDogWyBkM3BsdXMuZHJhdy5hcHBcbiAgICAgICAgICAgICAgICAgICAsIGQzcGx1cy5zaGFwZS5kcmF3IF0sXG4gICAgICBcIm1lc3NhZ2VcIiAgOiBkcmF3TWVzc2FnZVxuICAgIH0pXG4gIH1cblxuICBzdGVwcy5wdXNoKHtcbiAgICBcImZ1bmN0aW9uXCIgOiBbIGQzcGx1cy5kcmF3LmZvY3VzICwgZDNwbHVzLmRyYXcuZmluaXNoIF0sXG4gICAgXCJtZXNzYWdlXCIgOiBkcmF3TWVzc2FnZVxuICB9KVxuXG4gIHJldHVybiBzdGVwc1xuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gVXBkYXRpbmcgRWxlbWVudHNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kM3BsdXMuZHJhdy51cGRhdGUgPSBmdW5jdGlvbih2YXJzKSB7XG5cbiAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWUoXCJ1cGRhdGluZyBTVkcgZWxlbWVudHNcIilcblxuICBpZiAoIHZhcnMuZHJhdy50aW1pbmcgKSB7XG5cbiAgICAvLyBVcGRhdGUgUGFyZW50IEVsZW1lbnRcbiAgICB2YXJzLmNvbnRhaW5lci52YWx1ZS50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgIC5zdHlsZShcIndpZHRoXCIsdmFycy53aWR0aC52YWx1ZStcInB4XCIpXG4gICAgICAuc3R5bGUoXCJoZWlnaHRcIix2YXJzLmhlaWdodC52YWx1ZStcInB4XCIpXG5cbiAgICAvLyBVcGRhdGUgU1ZHXG4gICAgdmFycy5zdmcudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIix2YXJzLndpZHRoLnZhbHVlKVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLHZhcnMuaGVpZ2h0LnZhbHVlKVxuXG4gICAgLy8gVXBkYXRlIEJhY2tncm91bmQgUmVjdGFuZ2xlXG4gICAgdmFycy5nLmJnLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsdmFycy53aWR0aC52YWx1ZSlcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIix2YXJzLmhlaWdodC52YWx1ZSlcblxuICAgIC8vIFVwZGF0ZSBBcHAgQ2xpcHBpbmcgUmVjdGFuZ2xlXG4gICAgdmFycy5nLmNsaXBwaW5nLnNlbGVjdChcInJlY3RcIikudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAuYXR0cihcIndpZHRoXCIsdmFycy53aWR0aC52aXopXG4gICAgICAuYXR0cihcImhlaWdodFwiLHZhcnMuaGVpZ2h0LnZpeilcblxuICAgIC8vIFVwZGF0ZSBDb250YWluZXIgR3JvdXBzXG4gICAgdmFycy5nLmNvbnRhaW5lci50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGUoXCIrdmFycy5tYXJnaW4ubGVmdCtcIixcIit2YXJzLm1hcmdpbi50b3ArXCIpXCIpXG5cbiAgfVxuICBlbHNlIHtcblxuICAgIC8vIFVwZGF0ZSBQYXJlbnQgRWxlbWVudFxuICAgIHZhcnMuY29udGFpbmVyLnZhbHVlXG4gICAgICAuc3R5bGUoXCJ3aWR0aFwiLHZhcnMud2lkdGgudmFsdWUrXCJweFwiKVxuICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsdmFycy5oZWlnaHQudmFsdWUrXCJweFwiKVxuXG4gICAgLy8gVXBkYXRlIFNWR1xuICAgIHZhcnMuc3ZnXG4gICAgICAuYXR0cihcIndpZHRoXCIsdmFycy53aWR0aC52YWx1ZSlcbiAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsdmFycy5oZWlnaHQudmFsdWUpXG5cbiAgICAvLyBVcGRhdGUgQmFja2dyb3VuZCBSZWN0YW5nbGVcbiAgICB2YXJzLmcuYmdcbiAgICAgIC5hdHRyKFwid2lkdGhcIix2YXJzLndpZHRoLnZhbHVlKVxuICAgICAgLmF0dHIoXCJoZWlnaHRcIix2YXJzLmhlaWdodC52YWx1ZSlcblxuICAgIC8vIFVwZGF0ZSBBcHAgQ2xpcHBpbmcgUmVjdGFuZ2xlXG4gICAgdmFycy5nLmNsaXBwaW5nLnNlbGVjdChcInJlY3RcIilcbiAgICAgIC5hdHRyKFwid2lkdGhcIix2YXJzLndpZHRoLnZpeilcbiAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsdmFycy5oZWlnaHQudml6KVxuXG4gICAgLy8gVXBkYXRlIENvbnRhaW5lciBHcm91cHNcbiAgICB2YXJzLmcuY29udGFpbmVyXG4gICAgICAuYXR0cihcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlKFwiK3ZhcnMubWFyZ2luLmxlZnQrXCIsXCIrdmFycy5tYXJnaW4udG9wK1wiKVwiKVxuXG4gIH1cblxuICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZUVuZChcInVwZGF0aW5nIFNWRyBlbGVtZW50c1wiKVxuXG59XG4iLCJ2YXIgZmV0Y2hUZXh0ID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvZmV0Y2gvdGV4dC5qc1wiKVxuLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIERyYXdzIFwic3F1YXJlXCIgYW5kIFwiY2lyY2xlXCIgc2hhcGVzIHVzaW5nIHN2ZzpyZWN0XG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZDNwbHVzLnNoYXBlLmFyZWEgPSBmdW5jdGlvbih2YXJzLHNlbGVjdGlvbixlbnRlcixleGl0KSB7XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIEQzIGFyZWEgZGVmaW5pdGlvblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgdmFyIGFyZWEgPSBkMy5zdmcuYXJlYSgpXG4gICAgLngoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5kM3BsdXMueDsgfSlcbiAgICAueTAoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5kM3BsdXMueTA7IH0pXG4gICAgLnkxKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuZDNwbHVzLnk7IH0pXG4gICAgLmludGVycG9sYXRlKHZhcnMuc2hhcGUuaW50ZXJwb2xhdGUudmFsdWUpXG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIFwicGF0aHNcIiBFbnRlclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgZW50ZXIuYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwiY2xhc3NcIixcImQzcGx1c19kYXRhXCIpXG4gICAgLmF0dHIoXCJkXCIsZnVuY3Rpb24oZCl7IHJldHVybiBhcmVhKGQudmFsdWVzKSB9KVxuICAgIC5jYWxsKGQzcGx1cy5zaGFwZS5zdHlsZSx2YXJzKVxuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBcInBhdGhzXCIgVXBkYXRlXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBzZWxlY3Rpb24uc2VsZWN0QWxsKFwicGF0aC5kM3BsdXNfZGF0YVwiKVxuICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHtcblxuICAgICAgaWYgKHZhcnMubGFiZWxzLnZhbHVlICYmIGQudmFsdWVzLmxlbmd0aCA+IDEpIHtcblxuICAgICAgICB2YXIgdG9wcyA9IFtdXG4gICAgICAgICAgLCBib3R0b21zID0gW11cbiAgICAgICAgICAsIG5hbWVzID0gZmV0Y2hUZXh0KHZhcnMsZClcblxuICAgICAgICBkLnZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHYpe1xuICAgICAgICAgIHRvcHMucHVzaChbdi5kM3BsdXMueCx2LmQzcGx1cy55XSlcbiAgICAgICAgICBib3R0b21zLnB1c2goW3YuZDNwbHVzLngsdi5kM3BsdXMueTBdKVxuICAgICAgICB9KVxuICAgICAgICB0b3BzID0gdG9wcy5jb25jYXQoYm90dG9tcy5yZXZlcnNlKCkpXG5cbiAgICAgICAgdmFyIHN0eWxlID0ge1xuICAgICAgICAgIFwiZm9udC13ZWlnaHRcIjogdmFycy5sYWJlbHMuZm9udC53ZWlnaHQsXG4gICAgICAgICAgXCJmb250LWZhbWlseVwiOiB2YXJzLmxhYmVscy5mb250LmZhbWlseS52YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBzaXplID0gZDNwbHVzLmZvbnQuc2l6ZXMobmFtZXNbMF0sc3R5bGUpXG4gICAgICAgICAgICAsIHJhdGlvID0gc2l6ZVswXS53aWR0aC9zaXplWzBdLmhlaWdodFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciByYXRpbyA9IG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsciA9IGQzcGx1cy5nZW9tLmxhcmdlc3RSZWN0KHRvcHMse1xuICAgICAgICAgIFwiYW5nbGVcIjogZDMucmFuZ2UoLTcwLDcxLDEpLFxuICAgICAgICAgIFwiYXNwZWN0UmF0aW9cIjogcmF0aW8sXG4gICAgICAgICAgXCJ0b2xlcmFuY2VcIjogMFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmIChsciAmJiBsclswXSkge1xuXG4gICAgICAgICAgdmFyIGxhYmVsID0ge1xuICAgICAgICAgICAgXCJ3XCI6IE1hdGguZmxvb3IobHJbMF0ud2lkdGgpLFxuICAgICAgICAgICAgXCJoXCI6IE1hdGguZmxvb3IobHJbMF0uaGVpZ2h0KSxcbiAgICAgICAgICAgIFwieFwiOiBNYXRoLmZsb29yKGxyWzBdLmN4KSxcbiAgICAgICAgICAgIFwieVwiOiBNYXRoLmZsb29yKGxyWzBdLmN5KSxcbiAgICAgICAgICAgIFwiYW5nbGVcIjogbHJbMF0uYW5nbGUqLTEsXG4gICAgICAgICAgICBcInBhZGRpbmdcIjogMixcbiAgICAgICAgICAgIFwibmFtZXNcIjogbmFtZXNcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobHJbMF0uYW5nbGUgIT09IDApIHtcbiAgICAgICAgICAgIGxhYmVsLnRyYW5zbGF0ZSA9IHtcbiAgICAgICAgICAgICAgXCJ4XCI6bGFiZWwueCxcbiAgICAgICAgICAgICAgXCJ5XCI6bGFiZWwueVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxhYmVsLnRyYW5zbGF0ZSA9IGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxhYmVsLncgPj0gMTAgJiYgbGFiZWwuaCA+PSAxMCkge1xuICAgICAgICAgICAgZC5kM3BsdXNfbGFiZWwgPSBsYWJlbFxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtkXTtcbiAgICB9KVxuXG4gIGlmICh2YXJzLmRyYXcudGltaW5nKSB7XG4gICAgc2VsZWN0aW9uLnNlbGVjdEFsbChcInBhdGguZDNwbHVzX2RhdGFcIilcbiAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgICAgLmF0dHIoXCJkXCIsZnVuY3Rpb24oZCl7IHJldHVybiBhcmVhKGQudmFsdWVzKSB9KVxuICAgICAgICAuY2FsbChkM3BsdXMuc2hhcGUuc3R5bGUsdmFycylcbiAgfVxuICBlbHNlIHtcbiAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKFwicGF0aC5kM3BsdXNfZGF0YVwiKVxuICAgICAgLmF0dHIoXCJkXCIsZnVuY3Rpb24oZCl7IHJldHVybiBhcmVhKGQudmFsdWVzKSB9KVxuICAgICAgLmNhbGwoZDNwbHVzLnNoYXBlLnN0eWxlLHZhcnMpXG4gIH1cblxufVxuIiwidmFyIGZldGNoVmFsdWUgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9mZXRjaC92YWx1ZS5qc1wiKVxuICAsIGZldGNoQ29sb3IgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9mZXRjaC9jb2xvci5qc1wiKVxuLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBSZXR1cm5zIHRoZSBjb3JyZWN0IGZpbGwgY29sb3IgZm9yIGEgbm9kZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kM3BsdXMuc2hhcGUuY29sb3IgPSBmdW5jdGlvbihkLHZhcnMpIHtcblxuICB2YXIgc2hhcGUgPSBkLmQzcGx1cyA/IGQuZDNwbHVzLnNoYXBlVHlwZSA6IHZhcnMuc2hhcGUudmFsdWVcblxuICBpZiAodmFycy5zaGFwZS52YWx1ZSA9PSBcImxpbmVcIikge1xuICAgIGlmIChzaGFwZSA9PSBcImNpcmNsZVwiKSB7XG4gICAgICByZXR1cm4gZmV0Y2hDb2xvcih2YXJzLGQpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFwibm9uZVwiXG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKHZhcnMuc2hhcGUudmFsdWUgPT0gXCJhcmVhXCIgfHwgc2hhcGUgPT0gXCJhY3RpdmVcIikge1xuICAgIHJldHVybiBmZXRjaENvbG9yKHZhcnMsZClcbiAgfVxuICBlbHNlIGlmIChzaGFwZSA9PSBcInRlbXBcIikge1xuICAgIHJldHVybiBcInVybCgjZDNwbHVzX2hhdGNoX1wiK2QuZDNwbHVzLmlkK1wiKVwiXG4gIH1cbiAgZWxzZSBpZiAoc2hhcGUgPT0gXCJhY3RpdmVcIikge1xuICAgIHJldHVybiBmZXRjaENvbG9yKHZhcnMsZClcbiAgfVxuXG4gIGlmIChkLmQzcGx1cy5zdGF0aWMpIHtcbiAgICByZXR1cm4gZDNwbHVzLmNvbG9yLmxpZ2h0ZXIoZmV0Y2hDb2xvcih2YXJzLGQpLC43NSk7XG4gIH1cblxuICB2YXIgYWN0aXZlID0gdmFycy5hY3RpdmUudmFsdWUgPyBmZXRjaFZhbHVlKHZhcnMsZCx2YXJzLmFjdGl2ZS52YWx1ZSkgOiBkLmQzcGx1cy5hY3RpdmUsXG4gICAgICB0ZW1wID0gdmFycy50ZW1wLnZhbHVlID8gZmV0Y2hWYWx1ZSh2YXJzLGQsdmFycy50ZW1wLnZhbHVlKSA6IGQuZDNwbHVzLnRlbXAsXG4gICAgICB0b3RhbCA9IHZhcnMudG90YWwudmFsdWUgPyBmZXRjaFZhbHVlKHZhcnMsZCx2YXJzLnRvdGFsLnZhbHVlKSA6IGQuZDNwbHVzLnRvdGFsXG5cbiAgaWYgKCghdmFycy5hY3RpdmUudmFsdWUgJiYgIXZhcnMudGVtcC52YWx1ZSkgfHwgYWN0aXZlID09PSB0cnVlIHx8IChhY3RpdmUgJiYgdG90YWwgJiYgYWN0aXZlID09IHRvdGFsICYmICF0ZW1wKSB8fCAoYWN0aXZlICYmICF0b3RhbCkpIHtcbiAgICByZXR1cm4gZmV0Y2hDb2xvcih2YXJzLGQpXG4gIH1cbiAgZWxzZSBpZiAodmFycy5hY3RpdmUuc3BvdGxpZ2h0LnZhbHVlKSB7XG4gICAgcmV0dXJuIFwiI2VlZVwiXG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIGQzcGx1cy5jb2xvci5saWdodGVyKGZldGNoQ29sb3IodmFycyxkKSwuNzUpO1xuICB9XG5cbn1cbiIsInZhciBmZXRjaFRleHQgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9mZXRjaC90ZXh0LmpzXCIpXG4vL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gRHJhd3MgXCJzcXVhcmVcIiBhbmQgXCJjaXJjbGVcIiBzaGFwZXMgdXNpbmcgc3ZnOnJlY3Rcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kM3BsdXMuc2hhcGUuY29vcmRpbmF0ZXMgPSBmdW5jdGlvbih2YXJzLHNlbGVjdGlvbixlbnRlcixleGl0KSB7XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIERlZmluZSB0aGUgZ2VvZ3JhcGhpY2FsIHByb2plY3Rpb25cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHZhciBwcm9qZWN0aW9uID0gZDMuZ2VvW3ZhcnMuY29vcmRzLnByb2plY3Rpb24udmFsdWVdKClcbiAgICAuY2VudGVyKHZhcnMuY29vcmRzLmNlbnRlcilcblxuICBpZiAoIXZhcnMuem9vbS5zY2FsZSkge1xuICAgIHZhcnMuem9vbS5zY2FsZSA9IDFcbiAgfVxuXG4gIHZhcnMuem9vbS5hcmVhID0gMS92YXJzLnpvb20uc2NhbGUvdmFycy56b29tLnNjYWxlXG5cbiAgdmFycy5wYXRoID0gZDMuZ2VvLnBhdGgoKVxuICAgIC5wcm9qZWN0aW9uKHByb2plY3Rpb24pXG5cbiAgZW50ZXIuYXBwZW5kKFwicGF0aFwiKVxuICAgIC5hdHRyKFwiaWRcIixmdW5jdGlvbihkKXtcbiAgICAgIHJldHVybiBkLmlkXG4gICAgfSlcbiAgICAuYXR0cihcImNsYXNzXCIsXCJkM3BsdXNfZGF0YVwiKVxuICAgIC5hdHRyKFwiZFwiLHZhcnMucGF0aClcbiAgICAuY2FsbChkM3BsdXMuc2hhcGUuc3R5bGUsdmFycylcblxuICBpZiAodmFycy5kcmF3LnRpbWluZykge1xuICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoXCJwYXRoLmQzcGx1c19kYXRhXCIpXG4gICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAgIC5jYWxsKGQzcGx1cy5zaGFwZS5zdHlsZSx2YXJzKVxuICB9XG4gIGVsc2Uge1xuICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoXCJwYXRoLmQzcGx1c19kYXRhXCIpXG4gICAgICAuY2FsbChkM3BsdXMuc2hhcGUuc3R5bGUsdmFycylcbiAgfVxuXG4gIHZhciBzaXplX2NoYW5nZSA9IHZhcnMub2xkX2hlaWdodCAhPSB2YXJzLmhlaWdodC52aXogfHwgdmFycy5oZWlnaHQuY2hhbmdlZFxuICAgIHx8IHZhcnMub2xkX3dpZHRoICE9IHZhcnMud2lkdGgudml6IHx8IHZhcnMud2lkdGguY2hhbmdlZFxuXG4gIHZhcnMub2xkX2hlaWdodCA9IHZhcnMuaGVpZ2h0LnZpelxuICB2YXJzLm9sZF93aWR0aCA9IHZhcnMud2lkdGgudml6XG5cbiAgaWYgKHZhcnMuY29vcmRzLmNoYW5nZWQgfHwgc2l6ZV9jaGFuZ2UgfHwgdmFycy5jb29yZHMubXV0ZS5jaGFuZ2VkIHx8IHZhcnMuY29vcmRzLnNvbG8uY2hhbmdlZCkge1xuXG4gICAgdmFycy56b29tLmJvdW5kcyA9IG51bGxcbiAgICB2YXJzLnpvb20uY29vcmRzID0ge31cbiAgICB2YXJzLnpvb20ubGFiZWxzID0ge31cblxuICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGQpe1xuXG4gICAgICB2YXIgYiA9IHZhcnMucGF0aC5ib3VuZHMoZClcblxuICAgICAgdmFyIGFyZWFzID0gW11cbiAgICAgIGQuZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBkLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmZpbHRlcihmdW5jdGlvbihjLGkpe1xuXG4gICAgICAgIHZhciB0ZXN0ID0gZDNwbHVzLnV0aWwuY29weShkKVxuICAgICAgICB0ZXN0Lmdlb21ldHJ5LmNvb3JkaW5hdGVzID0gW3Rlc3QuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbaV1dXG4gICAgICAgIHZhciBhID0gdmFycy5wYXRoLmFyZWEodGVzdClcbiAgICAgICAgaWYgKGEgPj0gdmFycy5jb29yZHMudGhyZXNob2xkKSB7XG4gICAgICAgICAgYXJlYXMucHVzaChhKVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICAgIH0pXG4gICAgICBhcmVhcy5zb3J0KGZ1bmN0aW9uKGEsYil7XG4gICAgICAgIHJldHVybiBhLWJcbiAgICAgIH0pXG5cbiAgICAgIHZhciByZWR1Y2VkID0gZDNwbHVzLnV0aWwuY29weShkKSxcbiAgICAgICAgICBsYXJnZXN0ID0gZDNwbHVzLnV0aWwuY29weShkKVxuICAgICAgcmVkdWNlZC5nZW9tZXRyeS5jb29yZGluYXRlcyA9IHJlZHVjZWQuZ2VvbWV0cnkuY29vcmRpbmF0ZXMuZmlsdGVyKGZ1bmN0aW9uKGMsaSl7XG5cbiAgICAgICAgdmFyIHRlc3QgPSBkM3BsdXMudXRpbC5jb3B5KGQpXG4gICAgICAgIHRlc3QuZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBbdGVzdC5nZW9tZXRyeS5jb29yZGluYXRlc1tpXV1cbiAgICAgICAgdmFyIGEgPSB2YXJzLnBhdGguYXJlYSh0ZXN0KVxuICAgICAgICBpZiAoYSA9PSBhcmVhc1thcmVhcy5sZW5ndGgtMV0pIHtcbiAgICAgICAgICBsYXJnZXN0Lmdlb21ldHJ5LmNvb3JkaW5hdGVzID0gdGVzdC5nZW9tZXRyeS5jb29yZGluYXRlc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhID49IGQzLnF1YW50aWxlKGFyZWFzLC45KVxuXG4gICAgICB9KVxuICAgICAgdmFycy56b29tLmNvb3Jkc1tkLmQzcGx1cy5pZF0gPSByZWR1Y2VkXG5cbiAgICAgIHZhciBjb29yZHMgPSBsYXJnZXN0Lmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdXG4gICAgICBpZiAoY29vcmRzICYmIGxhcmdlc3QuZ2VvbWV0cnkudHlwZSA9PT0gXCJNdWx0aVBvbHlnb25cIikge1xuICAgICAgICBjb29yZHMgPSBjb29yZHNbMF1cbiAgICAgICAgbGFyZ2VzdC5nZW9tZXRyeS5jb29yZGluYXRlc1swXSA9IGNvb3Jkc1xuICAgICAgICBsYXJnZXN0Lmdlb21ldHJ5LnR5cGUgPSBcIlBvbHlnb25cIlxuICAgICAgfVxuXG4gICAgICBpZiAoY29vcmRzKSB7XG5cbiAgICAgICAgdmFyIHBhdGggPSB2YXJzLnBhdGgobGFyZ2VzdCkuc3BsaXQoXCJNXCIpWzFdLnNwbGl0KFwiWlwiKVswXS5zcGxpdChcIkxcIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcGF0aFtpXSA9IHBhdGhbaV0uc3BsaXQoXCIsXCIpXG4gICAgICAgICAgcGF0aFtpXVswXSA9IHBhcnNlRmxvYXQocGF0aFtpXVswXSlcbiAgICAgICAgICBwYXRoW2ldWzFdID0gcGFyc2VGbG9hdChwYXRoW2ldWzFdKVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0eWxlID0ge1xuICAgICAgICAgIFwiZm9udC13ZWlnaHRcIjogdmFycy5sYWJlbHMuZm9udC53ZWlnaHQsXG4gICAgICAgICAgXCJmb250LWZhbWlseVwiOiB2YXJzLmxhYmVscy5mb250LmZhbWlseS52YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5hbWVzID0gZmV0Y2hUZXh0KHZhcnMsZClcblxuICAgICAgICBpZiAobmFtZXMubGVuZ3RoICYmIG5hbWVzWzBdLnNwbGl0KFwiIFwiKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB2YXIgc2l6ZSA9IGQzcGx1cy5mb250LnNpemVzKG5hbWVzWzBdLHN0eWxlKVswXVxuICAgICAgICAgICAgLCByYXRpbyA9IHNpemUud2lkdGgvc2l6ZS5oZWlnaHRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcmF0aW8gPSBudWxsXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjdCA9IGQzcGx1cy5nZW9tLmxhcmdlc3RSZWN0KHBhdGgse1xuICAgICAgICAgIFwiYW5nbGVcIjogMCxcbiAgICAgICAgICBcImFzcGVjdFJhdGlvXCI6IHJhdGlvXG4gICAgICAgIH0pWzBdXG5cbiAgICAgICAgaWYgKHJlY3QpIHtcblxuICAgICAgICAgIHZhciBsYWJlbCA9IHtcbiAgICAgICAgICAgIFwiYW5jaG9yXCI6IFwibWlkZGxlXCIsXG4gICAgICAgICAgICBcInZhbGlnblwiOiBcImNlbnRlclwiLFxuICAgICAgICAgICAgXCJncm91cFwiOiB2YXJzLmcubGFiZWxzLFxuICAgICAgICAgICAgXCJoXCI6IE1hdGguZmxvb3IocmVjdC5oZWlnaHQpLFxuICAgICAgICAgICAgXCJ3XCI6IE1hdGguZmxvb3IocmVjdC53aWR0aCksXG4gICAgICAgICAgICBcInhcIjogTWF0aC5mbG9vcihyZWN0LmN4KSxcbiAgICAgICAgICAgIFwieVwiOiBNYXRoLmZsb29yKHJlY3QuY3kpLFxuICAgICAgICAgICAgXCJuYW1lc1wiOiBuYW1lc1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhcnMuem9vbS5sYWJlbHNbZC5kM3BsdXMuaWRdID0gbGFiZWxcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB2YXJzLnpvb20ubGFiZWxzW2QuZDNwbHVzLmlkXVxuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkZWxldGUgdmFycy56b29tLmxhYmVsc1tkLmQzcGx1cy5pZF1cbiAgICAgIH1cblxuICAgICAgaWYgKCF2YXJzLnpvb20uYm91bmRzKSB7XG4gICAgICAgIHZhcnMuem9vbS5ib3VuZHMgPSAgYlxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh2YXJzLnpvb20uYm91bmRzWzBdWzBdID4gYlswXVswXSkge1xuICAgICAgICAgIHZhcnMuem9vbS5ib3VuZHNbMF1bMF0gPSBiWzBdWzBdXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhcnMuem9vbS5ib3VuZHNbMF1bMV0gPiBiWzBdWzFdKSB7XG4gICAgICAgICAgdmFycy56b29tLmJvdW5kc1swXVsxXSA9IGJbMF1bMV1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFycy56b29tLmJvdW5kc1sxXVswXSA8IGJbMV1bMF0pIHtcbiAgICAgICAgICB2YXJzLnpvb20uYm91bmRzWzFdWzBdID0gYlsxXVswXVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YXJzLnpvb20uYm91bmRzWzFdWzFdIDwgYlsxXVsxXSkge1xuICAgICAgICAgIHZhcnMuem9vbS5ib3VuZHNbMV1bMV0gPSBiWzFdWzFdXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0pXG5cbiAgfVxuICBlbHNlIGlmICghdmFycy5mb2N1cy52YWx1ZS5sZW5ndGgpIHtcbiAgICB2YXJzLnpvb20udmlld3BvcnQgPSBmYWxzZVxuICB9XG5cbn1cbiIsIi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBEcmF3cyBcImRvbnV0XCIgc2hhcGVzIHVzaW5nIHN2ZzpwYXRoIHdpdGggYXJjc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmQzcGx1cy5zaGFwZS5kb251dCA9IGZ1bmN0aW9uKHZhcnMsc2VsZWN0aW9uLGVudGVyLGV4aXQpIHtcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gSW4gb3JkZXIgdG8gY29ycmVjdGx5IGFuaW1hdGUgZWFjaCBkb251dCdzIHNpemUgYW5kIGFyY3MsIHdlIG5lZWQgdG8gc3RvcmVcbiAgLy8gaXQncyBwcmV2aW91cyB2YWx1ZXMgaW4gYSBsb29rdXAgb2JqZWN0IHRoYXQgZG9lcyBub3QgZ2V0IGRlc3Ryb3llZCB3aGVuXG4gIC8vIHJlZHJhd2luZyB0aGUgdmlzdWFsaXphdGlvbi5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGlmICghdmFycy5hcmNzKSB7XG4gICAgdmFycy5hcmNzID0ge1xuICAgICAgXCJkb251dFwiOiB7fSxcbiAgICAgIFwiYWN0aXZlXCI6IHt9LFxuICAgICAgXCJ0ZW1wXCI6IHt9XG4gICAgfVxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIFRoaXMgaXMgdGhlIG1haW4gYXJjIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGF0IHZhbHVlcyB0byB1c2UgZm9yIGVhY2hcbiAgLy8gYXJjIGFuZ2xlIGFuZCByYWRpdXMuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXIgYXJjID0gZDMuc3ZnLmFyYygpXG4gICAgLnN0YXJ0QW5nbGUoMClcbiAgICAuZW5kQW5nbGUoZnVuY3Rpb24oZCl7XG4gICAgICB2YXIgYSA9IHZhcnMuYXJjc1tkLmQzcGx1cy5zaGFwZVR5cGVdW2QuZDNwbHVzLmlkXS5hXG4gICAgICByZXR1cm4gYSA+IE1hdGguUEkqMiA/IE1hdGguUEkqMiA6IGE7XG4gICAgfSlcbiAgICAuaW5uZXJSYWRpdXMoZnVuY3Rpb24oZCl7XG4gICAgICBpZiAoc2hhcGUgPT0gXCJkb251dFwiICYmICFkLmQzcGx1cy5zdGF0aWMpIHtcbiAgICAgICAgdmFyIHIgPSB2YXJzLmFyY3NbZC5kM3BsdXMuc2hhcGVUeXBlXVtkLmQzcGx1cy5pZF0uclxuICAgICAgICByZXR1cm4gciAqIHZhcnMuZGF0YS5kb251dC5zaXplXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH1cbiAgICB9KVxuICAgIC5vdXRlclJhZGl1cyhmdW5jdGlvbihkKXtcbiAgICAgIHZhciByID0gdmFycy5hcmNzW2QuZDNwbHVzLnNoYXBlVHlwZV1bZC5kM3BsdXMuaWRdLnJcbiAgICAgIGlmIChkLmQzcGx1cy5zaGFwZVR5cGUgIT0gXCJkb251dFwiKSByZXR1cm4gcioyXG4gICAgICBlbHNlIHJldHVybiByXG4gICAgfSlcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gVGhpcyBpcyB0aGUgbWFpbiBcImFyY1R3ZWVuXCIgZnVuY3Rpb24gd2hlcmUgYWxsIG9mIHRoZSBhbmltYXRpb24gaGFwcGVuc1xuICAvLyBmb3IgZWFjaCBhcmMuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBmdW5jdGlvbiBzaXplKHBhdGgsbW9kLHJhZCxhbmcpIHtcbiAgICBpZiAoIW1vZCkgdmFyIG1vZCA9IDBcbiAgICBpZiAodHlwZW9mIHJhZCAhPSBcIm51bWJlclwiKSB2YXIgcmFkID0gdW5kZWZpbmVkXG4gICAgaWYgKHR5cGVvZiBhbmcgIT0gXCJudW1iZXJcIikgdmFyIGFuZyA9IHVuZGVmaW5lZFxuICAgIHBhdGguYXR0clR3ZWVuKFwiZFwiLCBmdW5jdGlvbihkKXtcbiAgICAgIGlmIChyYWQgPT0gdW5kZWZpbmVkKSB2YXIgciA9IGQuZDNwbHVzLnIgPyBkLmQzcGx1cy5yIDogZDMubWF4KFtkLmQzcGx1cy53aWR0aCxkLmQzcGx1cy5oZWlnaHRdKVxuICAgICAgZWxzZSB2YXIgciA9IHJhZFxuICAgICAgaWYgKGFuZyA9PSB1bmRlZmluZWQpIHZhciBhID0gZC5kM3BsdXMuc2VnbWVudHNbZC5kM3BsdXMuc2hhcGVUeXBlXVxuICAgICAgZWxzZSB2YXIgYSA9IGFuZ1xuICAgICAgaWYgKCF2YXJzLmFyY3NbZC5kM3BsdXMuc2hhcGVUeXBlXVtkLmQzcGx1cy5pZF0pIHtcbiAgICAgICAgdmFycy5hcmNzW2QuZDNwbHVzLnNoYXBlVHlwZV1bZC5kM3BsdXMuaWRdID0ge1wiclwiOiAwfVxuICAgICAgICB2YXJzLmFyY3NbZC5kM3BsdXMuc2hhcGVUeXBlXVtkLmQzcGx1cy5pZF0uYSA9IGQuZDNwbHVzLnNoYXBlVHlwZSA9PSBcImRvbnV0XCIgPyBNYXRoLlBJICogMiA6IDBcbiAgICAgIH1cbiAgICAgIHZhciByYWRpdXMgPSBkMy5pbnRlcnBvbGF0ZSh2YXJzLmFyY3NbZC5kM3BsdXMuc2hhcGVUeXBlXVtkLmQzcGx1cy5pZF0ucixyK21vZCksXG4gICAgICAgICAgYW5nbGUgPSBkMy5pbnRlcnBvbGF0ZSh2YXJzLmFyY3NbZC5kM3BsdXMuc2hhcGVUeXBlXVtkLmQzcGx1cy5pZF0uYSxhKVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFycy5hcmNzW2QuZDNwbHVzLnNoYXBlVHlwZV1bZC5kM3BsdXMuaWRdLnIgPSByYWRpdXModClcbiAgICAgICAgdmFycy5hcmNzW2QuZDNwbHVzLnNoYXBlVHlwZV1bZC5kM3BsdXMuaWRdLmEgPSBhbmdsZSh0KVxuICAgICAgICByZXR1cm4gYXJjKGQpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBcInBhdGhzXCIgRXhpdFxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgZXhpdC5zZWxlY3RBbGwoXCJwYXRoLmQzcGx1c19kYXRhXCIpXG4gIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAuY2FsbChzaXplLDAsMClcbiAgICAuZWFjaChcImVuZFwiLGZ1bmN0aW9uKGQpe1xuICAgICAgZGVsZXRlIHZhcnMuYXJjc1tkLmQzcGx1cy5zaGFwZVR5cGVdW2QuZDNwbHVzLmlkXVxuICAgIH0pXG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIFwicGF0aHNcIiBVcGRhdGVcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHNlbGVjdGlvbi5zZWxlY3RBbGwoXCJwYXRoLmQzcGx1c19kYXRhXCIpXG4gICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gW2RdOyB9KVxuICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgIC5jYWxsKHNpemUpXG4gICAgICAuY2FsbChkM3BsdXMuc2hhcGUuc3R5bGUsdmFycylcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gXCJwYXRoc1wiIEVudGVyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBlbnRlci5hcHBlbmQoXCJwYXRoXCIpXG4gICAgLmF0dHIoXCJjbGFzc1wiLFwiZDNwbHVzX2RhdGFcIilcbiAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKDApXG4gICAgICAuY2FsbChzaXplLDAsMClcbiAgICAgIC5jYWxsKGQzcGx1cy5zaGFwZS5zdHlsZSx2YXJzKVxuXG59XG4iLCJ2YXIgZmV0Y2hWYWx1ZSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL2ZldGNoL3ZhbHVlLmpzXCIpLFxuICAgIGZldGNoQ29sb3IgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9mZXRjaC9jb2xvci5qc1wiKSxcbiAgICBmZXRjaFRleHQgID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvZmV0Y2gvdGV4dC5qc1wiKVxuLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIERyYXdzIHRoZSBhcHByb3ByaWF0ZSBzaGFwZSBiYXNlZCBvbiB0aGUgZGF0YVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmQzcGx1cy5zaGFwZS5kcmF3ID0gZnVuY3Rpb24odmFycykge1xuXG4gIHZhciBkYXRhID0gdmFycy5yZXR1cm5lZC5ub2RlcyB8fCBbXSxcbiAgICAgIGVkZ2VzID0gdmFycy5yZXR1cm5lZC5lZGdlcyB8fCBbXVxuXG4gIHZhcnMuZHJhdy50aW1pbmcgPSBkYXRhLmxlbmd0aCA8IHZhcnMuZGF0YS5sYXJnZVxuICAgICAgICAgICAgICAgICAgICAgJiYgZWRnZXMubGVuZ3RoIDwgdmFycy5lZGdlcy5sYXJnZVxuICAgICAgICAgICAgICAgICAgICAgPyB2YXJzLnRpbWluZy50cmFuc2l0aW9ucyA6IDBcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gTWF0Y2ggdmFycy5zaGFwZSB0eXBlcyB0byB0aGVpciByZXNwZWN0aXZlIGQzcGx1cy5zaGFwZSBmdW5jdGlvbnMuIEZvclxuICAvLyBleGFtcGxlLCBib3RoIFwic3F1YXJlXCIsIGFuZCBcImNpcmNsZVwiIHNoYXBlcyB1c2UgXCJyZWN0XCIgYXMgdGhlaXIgZHJhd2luZ1xuICAvLyBjbGFzcy5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHZhciBzaGFwZV9sb29rdXAgPSB7XG4gICAgXCJhcmVhXCI6IFwiYXJlYVwiLFxuICAgIFwiY2lyY2xlXCI6IFwicmVjdFwiLFxuICAgIFwiZG9udXRcIjogXCJkb251dFwiLFxuICAgIFwibGluZVwiOiBcImxpbmVcIixcbiAgICBcInNxdWFyZVwiOiBcInJlY3RcIixcbiAgICBcImNvb3JkaW5hdGVzXCI6IFwiY29vcmRpbmF0ZXNcIlxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIFNwbGl0IHRoZSBkYXRhIGJ5IGVhY2ggc2hhcGUgdHlwZSBpbiB0aGUgZGF0YS5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHZhciBzaGFwZXMgPSB7fVxuICBkYXRhLmZvckVhY2goZnVuY3Rpb24oZCl7XG4gICAgaWYgKCFkLmQzcGx1cykge1xuICAgICAgdmFyIHMgPSBzaGFwZV9sb29rdXBbdmFycy5zaGFwZS52YWx1ZV1cbiAgICB9XG4gICAgZWxzZSBpZiAoIWQuZDNwbHVzLnNoYXBlKSB7XG4gICAgICB2YXIgcyA9IHNoYXBlX2xvb2t1cFt2YXJzLnNoYXBlLnZhbHVlXVxuICAgICAgZC5kM3BsdXMuc2hhcGVUeXBlID0gc1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBzID0gZC5kM3BsdXMuc2hhcGVcbiAgICAgIGQuZDNwbHVzLnNoYXBlVHlwZSA9IHNcbiAgICB9XG4gICAgaWYgKCFzaGFwZXNbc10pIHtcbiAgICAgIHNoYXBlc1tzXSA9IFtdXG4gICAgfVxuICAgIHNoYXBlc1tzXS5wdXNoKGQpXG4gIH0pXG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIFJlc2V0cyB0aGUgXCJpZFwiIG9mIGVhY2ggZGF0YSBwb2ludCB0byB1c2Ugd2l0aCBtYXRjaGluZy5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGZ1bmN0aW9uIGlkKGQpIHtcblxuICAgIGQuZDNwbHVzLmlkID0gXCJcIlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHZhcnMuZGVwdGgudmFsdWU7IGkrKykge1xuICAgICAgZC5kM3BsdXMuaWQgKz0gZmV0Y2hWYWx1ZSh2YXJzLGQsdmFycy5pZC5uZXN0aW5nW2ldKStcIl9cIlxuICAgIH1cblxuICAgIGQuZDNwbHVzLmlkICs9IHNoYXBlXG5cbiAgICB2YXJzLmF4ZXMudmFsdWVzLmZvckVhY2goZnVuY3Rpb24oYXhpcyl7XG4gICAgICBpZiAodmFyc1theGlzXS5zY2FsZS52YWx1ZSA9PSBcImNvbnRpbnVvdXNcIikge1xuICAgICAgICBkLmQzcGx1cy5pZCArPSBcIl9cIitmZXRjaFZhbHVlKHZhcnMsZCx2YXJzW2F4aXNdLnZhbHVlKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBkLmQzcGx1cy5pZCA9IGQzcGx1cy5zdHJpbmcuc3RyaXAoZC5kM3BsdXMuaWQpXG5cbiAgICByZXR1cm4gZFxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIFRyYW5zZm9ybXMgdGhlIHBvc2l0aW9ucyBhbmQgc2NhbGUgb2YgZWFjaCBncm91cC5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybShnLGdyb3cpIHtcblxuICAgIHZhciBzY2FsZXMgPSB2YXJzLnR5cGVzW3ZhcnMudHlwZS52YWx1ZV0uc2NhbGVcbiAgICBpZiAoZ3JvdyAmJiBzY2FsZXMgJiYgc2NhbGVzW3ZhcnMuc2hhcGUudmFsdWVdKSB7XG4gICAgICAgdmFyIHNjYWxlID0gc2NhbGVzW3ZhcnMuc2hhcGUudmFsdWVdXG4gICAgfVxuICAgIGVsc2UgaWYgKGdyb3cgJiYgc2NhbGVzICYmIHR5cGVvZiBzY2FsZXMgPT0gXCJudW1iZXJcIikge1xuICAgICAgdmFyIHNjYWxlID0gc2NhbGVzXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHNjYWxlID0gMVxuICAgIH1cblxuICAgIGdcbiAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsZnVuY3Rpb24oZCl7XG5cbiAgICAgICAgdmFyIHggPSBkLmQzcGx1cy54IHx8IDBcbiAgICAgICAgICAsIHkgPSBkLmQzcGx1cy55IHx8IDBcblxuICAgICAgICBpZiAoW1wibGluZVwiLFwiYXJlYVwiLFwiY29vcmRpbmF0ZXNcIl0uaW5kZXhPZihzaGFwZSkgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiK3grXCIsXCIreStcIilzY2FsZShcIitzY2FsZStcIilcIlxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBcInNjYWxlKFwiK3NjYWxlK1wiKVwiXG4gICAgICAgIH1cblxuICAgICAgfSlcblxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIFJlbW92ZSBvbGQgZ3JvdXBzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBmb3IgKHNoYXBlIGluIHNoYXBlX2xvb2t1cCkge1xuICAgIGlmICghKHNoYXBlX2xvb2t1cFtzaGFwZV0gaW4gc2hhcGVzKSB8fCBkMy5rZXlzKHNoYXBlcykubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodmFycy5kcmF3LnRpbWluZykge1xuICAgICAgICB2YXJzLmcuZGF0YS5zZWxlY3RBbGwoXCJnLmQzcGx1c19cIitzaGFwZV9sb29rdXBbc2hhcGVdKVxuICAgICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwwKVxuICAgICAgICAgIC5yZW1vdmUoKVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhcnMuZy5kYXRhLnNlbGVjdEFsbChcImcuZDNwbHVzX1wiK3NoYXBlX2xvb2t1cFtzaGFwZV0pXG4gICAgICAgICAgLnJlbW92ZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIEluaXRpYWxpemUgYXJyYXlzIGZvciBsYWJlbHMgYW5kIHNpemVzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXIgbGFiZWxzID0gW10sXG4gICAgICBzaGFyZXMgPSBbXVxuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBDcmVhdGUgZ3JvdXBzIGJ5IHNoYXBlLCBhcHBseSBkYXRhLCBhbmQgY2FsbCBzcGVjaWZpYyBzaGFwZSBkcmF3aW5nIGNsYXNzLlxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgZm9yICh2YXIgc2hhcGUgaW4gc2hhcGVzKSB7XG5cbiAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgLy8gQmluZCBEYXRhIHRvIEdyb3Vwc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgc2VsZWN0aW9uID0gdmFycy5nLmRhdGEuc2VsZWN0QWxsKFwiZy5kM3BsdXNfXCIrc2hhcGUpXG4gICAgICAuZGF0YShzaGFwZXNbc2hhcGVdLGZ1bmN0aW9uKGQpe1xuXG4gICAgICAgIGlmICghZC5kM3BsdXMpIGQuZDNwbHVzID0ge31cblxuICAgICAgICBpZiAoIHNoYXBlID09PSBcImNvb3JkaW5hdGVzXCIgKSB7XG4gICAgICAgICAgZC5kM3BsdXMuaWQgPSBkLmlkXG4gICAgICAgICAgcmV0dXJuIGQuaWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggIWQuZDNwbHVzLmlkICkge1xuXG4gICAgICAgICAgaWYgKGQudmFsdWVzKSB7XG5cbiAgICAgICAgICAgIGQudmFsdWVzLmZvckVhY2goZnVuY3Rpb24odil7XG4gICAgICAgICAgICAgIHYgPSBpZCh2KVxuICAgICAgICAgICAgICB2LmQzcGx1cy5zaGFwZVR5cGUgPSBcImNpcmNsZVwiXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgZC5kM3BsdXMuaWQgPSBkLmtleVxuXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBkID0gaWQoZClcblxuICAgICAgICAgICAgaWYgKCFkLmQzcGx1cy5zZWdtZW50cykge1xuXG4gICAgICAgICAgICAgIGQuZDNwbHVzLnNlZ21lbnRzID0ge1wiZG9udXRcIjogTWF0aC5QSSoyfVxuICAgICAgICAgICAgICB2YXIgYWN0aXZlID0gdmFycy5hY3RpdmUudmFsdWUgPyBkLmQzcGx1c1t2YXJzLmFjdGl2ZS52YWx1ZV0gOiBkLmQzcGx1cy5hY3RpdmUsXG4gICAgICAgICAgICAgICAgICB0ZW1wID0gdmFycy50ZW1wLnZhbHVlID8gZC5kM3BsdXNbdmFycy50ZW1wLnZhbHVlXSA6IGQuZDNwbHVzLnRlbXAsXG4gICAgICAgICAgICAgICAgICB0b3RhbCA9IHZhcnMudG90YWwudmFsdWUgPyBkLmQzcGx1c1t2YXJzLnRvdGFsLnZhbHVlXSA6IGQuZDNwbHVzLnRvdGFsXG5cbiAgICAgICAgICAgICAgaWYgKHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgZC5kM3BsdXMuc2VnbWVudHMuYWN0aXZlID0gKGFjdGl2ZS90b3RhbCkgKiAoTWF0aC5QSSAqIDIpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZC5kM3BsdXMuc2VnbWVudHMuYWN0aXZlID0gMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGVtcCkge1xuICAgICAgICAgICAgICAgICAgZC5kM3BsdXMuc2VnbWVudHMudGVtcCA9ICgodGVtcC90b3RhbCkgKiAoTWF0aC5QSSAqIDIpKSArIGQuZDNwbHVzLnNlZ21lbnRzLmFjdGl2ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGQuZDNwbHVzLnNlZ21lbnRzLnRlbXAgPSAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGQuZDNwbHVzID8gZC5kM3BsdXMuaWQgOiBmYWxzZTtcblxuICAgICAgfSlcblxuICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAvLyBHcm91cHMgRXhpdFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBpZiAodmFycy5kcmF3LnRpbWluZykge1xuICAgICAgdmFyIGV4aXQgPSBzZWxlY3Rpb24uZXhpdCgpXG4gICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsMClcbiAgICAgICAgLnJlbW92ZSgpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGV4aXQgPSBzZWxlY3Rpb24uZXhpdCgpXG4gICAgICAgIC5yZW1vdmUoKVxuICAgIH1cblxuICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAvLyBFeGlzdGluZyBHcm91cHMgVXBkYXRlXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGlmICh2YXJzLmRyYXcudGltaW5nKSB7XG4gICAgICBzZWxlY3Rpb25cbiAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgICAgICAuY2FsbCh0cmFuc2Zvcm0pXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc2VsZWN0aW9uLmNhbGwodHJhbnNmb3JtKVxuICAgIH1cblxuICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAvLyBHcm91cHMgRW50ZXJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIG9wYWNpdHkgPSB2YXJzLmRyYXcudGltaW5nID8gMCA6IDFcbiAgICB2YXIgZW50ZXIgPSBzZWxlY3Rpb24uZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgICAuYXR0cihcImNsYXNzXCIsXCJkM3BsdXNfXCIrc2hhcGUpXG4gICAgICAuYXR0cihcIm9wYWNpdHlcIixvcGFjaXR5KVxuICAgICAgLmNhbGwodHJhbnNmb3JtKVxuXG4gICAgaWYgKHZhcnMuZHJhdy50aW1pbmcpIHtcbiAgICAgIGVudGVyLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwxKVxuICAgIH1cblxuICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAvLyBBbGwgR3JvdXBzIFNvcnQgT3JkZXJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgc2VsZWN0aW9uLm9yZGVyKClcblxuICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAvLyBEcmF3IGFwcHJvcHJpYXRlIGdyYXBoaWNzIGluc2lkZSBvZiBlYWNoIGdyb3VwXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lKFwiZHJhd2luZyBcXFwiXCIgKyBzaGFwZSArIFwiXFxcIiBzaGFwZXNcIilcbiAgICBkM3BsdXMuc2hhcGVbc2hhcGVdKCB2YXJzICwgc2VsZWN0aW9uICwgZW50ZXIgLCBleGl0ICwgdHJhbnNmb3JtIClcbiAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZUVuZChcImRyYXdpbmcgXFxcIlwiICsgc2hhcGUgKyBcIlxcXCIgc2hhcGVzXCIpXG5cbiAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgLy8gQ2hlY2sgZm9yIGFjdGl2ZSBhbmQgdGVtcCBmaWxscyBmb3IgcmVjdHMgYW5kIGRvbnV0c1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBpZiAoW1wicmVjdFwiLFwiZG9udXRcIl0uaW5kZXhPZihzaGFwZSkgPj0gMCAmJiB2YXJzLnR5cGVzW3ZhcnMudHlwZS52YWx1ZV0uZmlsbCkge1xuICAgICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWUoXCJmaWxsaW5nIFxcXCJcIiArIHNoYXBlICsgXCJcXFwiIHNoYXBlc1wiKVxuICAgICAgZDNwbHVzLnNoYXBlLmZpbGwoIHZhcnMgLCBzZWxlY3Rpb24gLCBlbnRlciAsIGV4aXQgLCB0cmFuc2Zvcm0gKVxuICAgICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWVFbmQoXCJmaWxsaW5nIFxcXCJcIiArIHNoYXBlICsgXCJcXFwiIHNoYXBlc1wiKVxuICAgIH1cblxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIEZ1bmN0aW9uIHRvIFVwZGF0ZSBFZGdlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgZnVuY3Rpb24gZWRnZV91cGRhdGUoZCkge1xuXG4gICAgaWYgKGQgJiYgdmFycy5nLmVkZ2VzLnNlbGVjdEFsbChcImdcIikuc2l6ZSgpID4gMCkge1xuXG4gICAgICB2YXJzLmcuZWRnZV9ob3ZlclxuICAgICAgICAuc2VsZWN0QWxsKFwiKlwiKVxuICAgICAgICAucmVtb3ZlKClcblxuICAgICAgdmFycy5nLmVkZ2VzLnNlbGVjdEFsbChcImdcIilcbiAgICAgICAgLmVhY2goZnVuY3Rpb24obCl7XG5cbiAgICAgICAgICB2YXIgaWQgPSBkW3ZhcnMuaWQudmFsdWVdLFxuICAgICAgICAgICAgICBzb3VyY2UgPSBsW3ZhcnMuZWRnZXMuc291cmNlXVt2YXJzLmlkLnZhbHVlXSxcbiAgICAgICAgICAgICAgdGFyZ2V0ID0gbFt2YXJzLmVkZ2VzLnRhcmdldF1bdmFycy5pZC52YWx1ZV1cblxuICAgICAgICAgIGlmIChzb3VyY2UgPT0gaWQgfHwgdGFyZ2V0ID09IGlkKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSA9IHZhcnMuZy5lZGdlX2hvdmVyLm5vZGUoKS5hcHBlbmRDaGlsZCh0aGlzLmNsb25lTm9kZSh0cnVlKSlcbiAgICAgICAgICAgIGQzLnNlbGVjdChlbGVtKS5kYXR1bShsKS5hdHRyKFwib3BhY2l0eVwiLDEpXG4gICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJsaW5lLCBwYXRoXCIpLmRhdHVtKGwpXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0pXG5cblxuICAgICAgdmFyIG1hcmtlciA9IHZhcnMuZWRnZXMuYXJyb3dzLnZhbHVlXG5cbiAgICAgIHZhcnMuZy5lZGdlX2hvdmVyXG4gICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLDApXG4gICAgICAgIC5zZWxlY3RBbGwoXCJsaW5lLCBwYXRoXCIpXG4gICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsdmFycy5jb2xvci5wcmltYXJ5KVxuICAgICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gdmFycy5lZGdlcy5zaXplID8gZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIpXG4gICAgICAgICAgICAgICAgIDogdmFycy5kYXRhLnN0cm9rZS53aWR0aCoyXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuYXR0cihcIm1hcmtlci1zdGFydFwiLGZ1bmN0aW9uKGUpe1xuXG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gdmFycy5lZGdlcy5hcnJvd3MuZGlyZWN0aW9uLnZhbHVlXG5cbiAgICAgICAgICAgIGlmIChcImJ1Y2tldFwiIGluIGUuZDNwbHVzKSB7XG4gICAgICAgICAgICAgIHZhciBkID0gXCJfXCIrZS5kM3BsdXMuYnVja2V0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGQgPSBcIlwiXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24gPT0gXCJzb3VyY2VcIiAmJiBtYXJrZXJcbiAgICAgICAgICAgICAgICAgPyBcInVybCgjZDNwbHVzX2VkZ2VfbWFya2VyX2hpZ2hsaWdodFwiK2QrXCIpXCIgOiBcIm5vbmVcIlxuXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuYXR0cihcIm1hcmtlci1lbmRcIixmdW5jdGlvbihlKXtcblxuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHZhcnMuZWRnZXMuYXJyb3dzLmRpcmVjdGlvbi52YWx1ZVxuXG4gICAgICAgICAgICBpZiAoXCJidWNrZXRcIiBpbiBlLmQzcGx1cykge1xuICAgICAgICAgICAgICB2YXIgZCA9IFwiX1wiK2UuZDNwbHVzLmJ1Y2tldFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBkID0gXCJcIlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uID09IFwidGFyZ2V0XCIgJiYgbWFya2VyXG4gICAgICAgICAgICAgICAgID8gXCJ1cmwoI2QzcGx1c19lZGdlX21hcmtlcl9oaWdobGlnaHRcIitkK1wiKVwiIDogXCJub25lXCJcblxuICAgICAgICAgIH0pXG5cblxuICAgICAgdmFycy5nLmVkZ2VfaG92ZXIuc2VsZWN0QWxsKFwidGV4dFwiKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsdmFycy5jb2xvci5wcmltYXJ5KVxuXG4gICAgICBpZiAodmFycy5kcmF3LnRpbWluZykge1xuXG4gICAgICAgIHZhcnMuZy5lZGdlX2hvdmVyXG4gICAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLnRpbWluZy5tb3VzZWV2ZW50cylcbiAgICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwxKVxuXG4gICAgICAgIHZhcnMuZy5lZGdlc1xuICAgICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy50aW1pbmcubW91c2VldmVudHMpXG4gICAgICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsMC41KVxuXG4gICAgICB9XG4gICAgICBlbHNlIHtcblxuICAgICAgICB2YXJzLmcuZWRnZV9ob3ZlclxuICAgICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLDEpXG5cbiAgICAgIH1cblxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgaWYgKHZhcnMuZHJhdy50aW1pbmcpIHtcblxuICAgICAgICB2YXJzLmcuZWRnZV9ob3ZlclxuICAgICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy50aW1pbmcubW91c2VldmVudHMpXG4gICAgICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsMClcbiAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgLnNlbGVjdEFsbChcIipcIilcbiAgICAgICAgICAucmVtb3ZlKClcblxuICAgICAgICB2YXJzLmcuZWRnZXNcbiAgICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMudGltaW5nLm1vdXNlZXZlbnRzKVxuICAgICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLDEpXG5cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuXG4gICAgICAgIHZhcnMuZy5lZGdlX2hvdmVyXG4gICAgICAgICAgLnNlbGVjdEFsbChcIipcIilcbiAgICAgICAgICAucmVtb3ZlKClcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuICBlZGdlX3VwZGF0ZSgpXG5cbiAgaWYgKCFkM3BsdXMudG91Y2gpIHtcblxuICAgIHZhcnMuZy5kYXRhLnNlbGVjdEFsbChcImdcIilcbiAgICAgIC5vbihkM3BsdXMuZXZ0Lm92ZXIsZnVuY3Rpb24oZCl7XG5cbiAgICAgICAgaWYgKCF2YXJzLmRyYXcuZnJvemVuICYmICghZC5kM3BsdXMgfHwgIWQuZDNwbHVzLnN0YXRpYykpIHtcblxuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImN1cnNvclwiLFwicG9pbnRlclwiKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLnRpbWluZy5tb3VzZWV2ZW50cylcbiAgICAgICAgICAgIC5jYWxsKHRyYW5zZm9ybSx0cnVlKVxuXG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnNlbGVjdEFsbChcIi5kM3BsdXNfZGF0YVwiKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLnRpbWluZy5tb3VzZWV2ZW50cylcbiAgICAgICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLDEpXG5cbiAgICAgICAgICB2YXJzLmNvdmVyZWQgPSBmYWxzZVxuXG4gICAgICAgICAgaWYgKHZhcnMuZm9jdXMudmFsdWUubGVuZ3RoICE9PSAxIHx8IHZhcnMuZm9jdXMudmFsdWVbMF0gIT0gZFt2YXJzLmlkLnZhbHVlXSkge1xuXG4gICAgICAgICAgICBpZiAoZC52YWx1ZXMgJiYgdmFycy5jb250aW51b3VzX2F4aXMpIHtcblxuICAgICAgICAgICAgICB2YXIgaW5kZXggPSB2YXJzLmNvbnRpbnVvdXNfYXhpcyA9PT0gXCJ4XCIgPyAwIDogMVxuICAgICAgICAgICAgICAgICwgbW91c2UgPSBkMy5tb3VzZSh2YXJzLmNvbnRhaW5lci52YWx1ZS5ub2RlKCkpW2luZGV4XVxuICAgICAgICAgICAgICAgICwgcG9zaXRpb25zID0gZDNwbHVzLnV0aWwudW5pcXVlcyhkLnZhbHVlcyxmdW5jdGlvbih4KXtyZXR1cm4geC5kM3BsdXNbdmFycy5jb250aW51b3VzX2F4aXNdfSlcbiAgICAgICAgICAgICAgICAsIGNsb3Nlc3QgPSBkM3BsdXMudXRpbC5jbG9zZXN0KHBvc2l0aW9ucyxtb3VzZSlcblxuICAgICAgICAgICAgICBkLmQzcGx1c19kYXRhID0gZC52YWx1ZXNbcG9zaXRpb25zLmluZGV4T2YoY2xvc2VzdCldXG4gICAgICAgICAgICAgIGQuZDNwbHVzID0gZC52YWx1ZXNbcG9zaXRpb25zLmluZGV4T2YoY2xvc2VzdCldLmQzcGx1c1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0b29sdGlwX2RhdGEgPSBkLmQzcGx1c19kYXRhID8gZC5kM3BsdXNfZGF0YSA6IGRcbiAgICAgICAgICAgIGQzcGx1cy50b29sdGlwLmFwcCh7XG4gICAgICAgICAgICAgIFwidmFyc1wiOiB2YXJzLFxuICAgICAgICAgICAgICBcImRhdGFcIjogdG9vbHRpcF9kYXRhXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YXJzLm1vdXNlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFycy5tb3VzZShkKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh2YXJzLm1vdXNlW2QzcGx1cy5ldnQub3Zlcl0pIHtcbiAgICAgICAgICAgIHZhcnMubW91c2VbZDNwbHVzLmV2dC5vdmVyXShkKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGVkZ2VfdXBkYXRlKGQpXG5cbiAgICAgICAgfVxuXG4gICAgICB9KVxuICAgICAgLm9uKGQzcGx1cy5ldnQubW92ZSxmdW5jdGlvbihkKXtcblxuICAgICAgICBpZiAoIXZhcnMuZHJhdy5mcm96ZW4gJiYgKCFkLmQzcGx1cyB8fCAhZC5kM3BsdXMuc3RhdGljKSkge1xuXG4gICAgICAgICAgdmFycy5jb3ZlcmVkID0gZmFsc2VcblxuICAgICAgICAgIGlmIChkLnZhbHVlcyB8fCAodmFycy50eXBlc1t2YXJzLnR5cGUudmFsdWVdLnRvb2x0aXAgPT0gXCJmb2xsb3dcIiAmJiB2YXJzLmZvY3VzLnZhbHVlWzBdICE9IGRbdmFycy5pZC52YWx1ZV0pKSB7XG5cbiAgICAgICAgICAgIGlmIChkLnZhbHVlcyAmJiB2YXJzLmNvbnRpbnVvdXNfYXhpcykge1xuXG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IHZhcnMuY29udGludW91c19heGlzID09PSBcInhcIiA/IDAgOiAxXG4gICAgICAgICAgICAgICAgLCBtb3VzZSA9IGQzLm1vdXNlKHZhcnMuY29udGFpbmVyLnZhbHVlLm5vZGUoKSlbaW5kZXhdXG4gICAgICAgICAgICAgICAgLCBwb3NpdGlvbnMgPSBkM3BsdXMudXRpbC51bmlxdWVzKGQudmFsdWVzLGZ1bmN0aW9uKHgpe3JldHVybiB4LmQzcGx1c1t2YXJzLmNvbnRpbnVvdXNfYXhpc119KVxuICAgICAgICAgICAgICAgICwgY2xvc2VzdCA9IGQzcGx1cy51dGlsLmNsb3Nlc3QocG9zaXRpb25zLG1vdXNlKVxuXG4gICAgICAgICAgICAgIGQuZDNwbHVzX2RhdGEgPSBkLnZhbHVlc1twb3NpdGlvbnMuaW5kZXhPZihjbG9zZXN0KV1cbiAgICAgICAgICAgICAgZC5kM3BsdXMgPSBkLnZhbHVlc1twb3NpdGlvbnMuaW5kZXhPZihjbG9zZXN0KV0uZDNwbHVzXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRvb2x0aXBfZGF0YSA9IGQuZDNwbHVzX2RhdGEgPyBkLmQzcGx1c19kYXRhIDogZFxuICAgICAgICAgICAgZDNwbHVzLnRvb2x0aXAuYXBwKHtcbiAgICAgICAgICAgICAgXCJ2YXJzXCI6IHZhcnMsXG4gICAgICAgICAgICAgIFwiZGF0YVwiOiB0b29sdGlwX2RhdGFcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHZhcnMubW91c2UgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YXJzLm1vdXNlKGQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHZhcnMubW91c2VbZDNwbHVzLmV2dC5tb3ZlXSkge1xuICAgICAgICAgICAgdmFycy5tb3VzZVtkM3BsdXMuZXZ0Lm1vdmVdKGQpXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfSlcbiAgICAgIC5vbihkM3BsdXMuZXZ0Lm91dCxmdW5jdGlvbihkKXtcblxuICAgICAgICB2YXIgY2hpbGQgPSBkM3BsdXMudXRpbC5jaGlsZCh0aGlzLGQzLmV2ZW50LnRvRWxlbWVudClcblxuICAgICAgICBpZiAoIWNoaWxkICYmICF2YXJzLmRyYXcuZnJvemVuICYmICghZC5kM3BsdXMgfHwgIWQuZDNwbHVzLnN0YXRpYykpIHtcblxuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLnRpbWluZy5tb3VzZWV2ZW50cylcbiAgICAgICAgICAgIC5jYWxsKHRyYW5zZm9ybSlcblxuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zZWxlY3RBbGwoXCIuZDNwbHVzX2RhdGFcIilcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy50aW1pbmcubW91c2VldmVudHMpXG4gICAgICAgICAgICAuYXR0cihcIm9wYWNpdHlcIix2YXJzLmRhdGEub3BhY2l0eSlcblxuXG4gICAgICAgICAgaWYgKCF2YXJzLmNvdmVyZWQpIHtcbiAgICAgICAgICAgIGQzcGx1cy50b29sdGlwLnJlbW92ZSh2YXJzLnR5cGUudmFsdWUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YXJzLm1vdXNlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFycy5tb3VzZShkKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh2YXJzLm1vdXNlW2QzcGx1cy5ldnQub3V0XSkge1xuICAgICAgICAgICAgdmFycy5tb3VzZVtkM3BsdXMuZXZ0Lm91dF0oZClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlZGdlX3VwZGF0ZSgpXG5cbiAgICAgICAgfVxuXG4gICAgICB9KVxuXG4gIH1cbiAgZWxzZSB7XG5cbiAgICB2YXJzLmcuZGF0YS5zZWxlY3RBbGwoXCJnXCIpXG4gICAgICAub24oZDNwbHVzLmV2dC5vdmVyLHZhcnMuem9vbS50b3VjaEV2ZW50KVxuICAgICAgLm9uKGQzcGx1cy5ldnQubW92ZSx2YXJzLnpvb20udG91Y2hFdmVudClcbiAgICAgIC5vbihkM3BsdXMuZXZ0Lm91dCx2YXJzLnpvb20udG91Y2hFdmVudClcblxuICB9XG5cbiAgdmFycy5nLmRhdGEuc2VsZWN0QWxsKFwiZ1wiKVxuICAgIC5vbihkM3BsdXMuZXZ0LmNsaWNrLGZ1bmN0aW9uKGQpe1xuXG4gICAgICBpZiAoIWQzLmV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgJiYgIXZhcnMuZHJhdy5mcm96ZW4gJiYgKCFkLmQzcGx1cyB8fCAhZC5kM3BsdXMuc3RhdGljKSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFycy5tb3VzZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB2YXJzLm1vdXNlKGQpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFycy5tb3VzZVtkM3BsdXMuZXZ0Lm91dF0pIHtcbiAgICAgICAgICB2YXJzLm1vdXNlW2QzcGx1cy5ldnQub3V0XShkKVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhcnMubW91c2VbZDNwbHVzLmV2dC5jbGlja10pIHtcbiAgICAgICAgICB2YXJzLm1vdXNlW2QzcGx1cy5ldnQuY2xpY2tdKGQpXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVwdGhfZGVsdGEgPSB2YXJzLnpvb20uZGlyZWN0aW9uKGQuZDNwbHVzX2RhdGEgfHwgZClcbiAgICAgICAgICAsIHByZXZpb3VzID0gdmFycy5pZC5zb2xvLnZhbHVlXG4gICAgICAgICAgLCB0aXRsZSA9IGZldGNoVGV4dCh2YXJzLGQpWzBdXG4gICAgICAgICAgLCBjb2xvciA9IGQzcGx1cy5jb2xvci5sZWdpYmxlKGZldGNoQ29sb3IodmFycyxkKSlcbiAgICAgICAgICAsIHByZXZfc3ViID0gdmFycy50aXRsZS5zdWIudmFsdWUgfHwgZmFsc2VcbiAgICAgICAgICAsIHByZXZfY29sb3IgPSB2YXJzLnRpdGxlLnN1Yi5mb250LmNvbG9yXG4gICAgICAgICAgLCBwcmV2X3RvdGFsID0gdmFycy50aXRsZS50b3RhbC5mb250LmNvbG9yXG5cbiAgICAgICAgaWYgKGQuZDNwbHVzLnRocmVzaG9sZCAmJiBkLmQzcGx1cy5tZXJnZWQgJiYgdmFycy56b29tLnZhbHVlKSB7XG5cbiAgICAgICAgICB2YXJzLmhpc3Rvcnkuc3RhdGVzLnB1c2goZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgdmFycy5zZWxmXG4gICAgICAgICAgICAgIC5pZCh7XCJzb2xvXCI6IHByZXZpb3VzfSlcbiAgICAgICAgICAgICAgLnRpdGxlKHtcbiAgICAgICAgICAgICAgICBcInN1YlwiOiB7XG4gICAgICAgICAgICAgICAgICBcImZvbnRcIjoge1xuICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCI6IHByZXZfY29sb3JcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHByZXZfc3ViXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInRvdGFsXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwiZm9udFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIjogcHJldl90b3RhbFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmRyYXcoKVxuXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHZhcnMuc2VsZlxuICAgICAgICAgICAgLmlkKHtcInNvbG9cIjogZDNwbHVzLnV0aWwudW5pcXVlcyhkLmQzcGx1cy5tZXJnZWQsdmFycy5pZC52YWx1ZSl9KVxuICAgICAgICAgICAgLnRpdGxlKHtcbiAgICAgICAgICAgICAgXCJzdWJcIjoge1xuICAgICAgICAgICAgICAgIFwiZm9udFwiOiB7XG4gICAgICAgICAgICAgICAgICBcImNvbG9yXCI6IGNvbG9yXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHRpdGxlXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwidG90YWxcIjoge1xuICAgICAgICAgICAgICAgIFwiZm9udFwiOiB7XG4gICAgICAgICAgICAgICAgICBcImNvbG9yXCI6IGNvbG9yXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRyYXcoKVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVwdGhfZGVsdGEgPT09IDEgJiYgdmFycy56b29tLnZhbHVlKSB7XG5cbiAgICAgICAgICB2YXIgaWQgPSBmZXRjaFZhbHVlKHZhcnMsZCx2YXJzLmlkLnZhbHVlKVxuXG4gICAgICAgICAgdmFycy5oaXN0b3J5LnN0YXRlcy5wdXNoKGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgIHZhcnMuc2VsZlxuICAgICAgICAgICAgICAuZGVwdGgodmFycy5kZXB0aC52YWx1ZS0xKVxuICAgICAgICAgICAgICAuaWQoe1wic29sb1wiOiBwcmV2aW91c30pXG4gICAgICAgICAgICAgIC50aXRsZSh7XG4gICAgICAgICAgICAgICAgXCJzdWJcIjoge1xuICAgICAgICAgICAgICAgICAgXCJmb250XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiOiBwcmV2X2NvbG9yXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBwcmV2X3N1YlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ0b3RhbFwiOiB7XG4gICAgICAgICAgICAgICAgICBcImZvbnRcIjoge1xuICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCI6IHByZXZfdG90YWxcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5kcmF3KClcblxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICB2YXJzLnNlbGZcbiAgICAgICAgICAgIC5kZXB0aCh2YXJzLmRlcHRoLnZhbHVlKzEpXG4gICAgICAgICAgICAuaWQoe1wic29sb1wiOiBbaWRdfSlcbiAgICAgICAgICAgIC50aXRsZSh7XG4gICAgICAgICAgICAgIFwic3ViXCI6IHtcbiAgICAgICAgICAgICAgICBcImZvbnRcIjoge1xuICAgICAgICAgICAgICAgICAgXCJjb2xvclwiOiBjb2xvclxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB0aXRsZVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcInRvdGFsXCI6IHtcbiAgICAgICAgICAgICAgICBcImZvbnRcIjoge1xuICAgICAgICAgICAgICAgICAgXCJjb2xvclwiOiBjb2xvclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5kcmF3KClcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlcHRoX2RlbHRhID09PSAtMSAmJiB2YXJzLnpvb20udmFsdWUpIHtcblxuICAgICAgICAgIHZhcnMuaGlzdG9yeS5iYWNrKClcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhcnMudHlwZXNbdmFycy50eXBlLnZhbHVlXS56b29tICYmIHZhcnMuem9vbS52YWx1ZSkge1xuXG4gICAgICAgICAgZWRnZV91cGRhdGUoKVxuXG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMudGltaW5nLm1vdXNlZXZlbnRzKVxuICAgICAgICAgICAgLmNhbGwodHJhbnNmb3JtKVxuXG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnNlbGVjdEFsbChcIi5kM3BsdXNfZGF0YVwiKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLnRpbWluZy5tb3VzZWV2ZW50cylcbiAgICAgICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLHZhcnMuZGF0YS5vcGFjaXR5KVxuXG4gICAgICAgICAgZDNwbHVzLnRvb2x0aXAucmVtb3ZlKHZhcnMudHlwZS52YWx1ZSlcbiAgICAgICAgICB2YXJzLmRyYXcudXBkYXRlID0gZmFsc2VcblxuICAgICAgICAgIGlmICghZCB8fCBkW3ZhcnMuaWQudmFsdWVdID09IHZhcnMuZm9jdXMudmFsdWVbMF0pIHtcbiAgICAgICAgICAgIHZhcnMuc2VsZi5mb2N1cyhmYWxzZSkuZHJhdygpXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFycy5zZWxmLmZvY3VzKGRbdmFycy5pZC52YWx1ZV0pLmRyYXcoKVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhcnMuZm9jdXMudmFsdWUubGVuZ3RoICE9PSAxIHx8IGRbdmFycy5pZC52YWx1ZV0gIT0gdmFycy5mb2N1cy52YWx1ZVswXSkge1xuXG4gICAgICAgICAgZWRnZV91cGRhdGUoKVxuXG4gICAgICAgICAgdmFyIHRvb2x0aXBfZGF0YSA9IGQuZDNwbHVzX2RhdGEgPyBkLmQzcGx1c19kYXRhIDogZFxuXG4gICAgICAgICAgZDNwbHVzLnRvb2x0aXAuYXBwKHtcbiAgICAgICAgICAgIFwidmFyc1wiOiB2YXJzLFxuICAgICAgICAgICAgXCJkYXRhXCI6IHRvb2x0aXBfZGF0YVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9KVxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gRHJhd3MgXCJzcXVhcmVcIiBhbmQgXCJjaXJjbGVcIiBzaGFwZXMgdXNpbmcgc3ZnOnJlY3Rcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kM3BsdXMuc2hhcGUuZWRnZXMgPSBmdW5jdGlvbih2YXJzKSB7XG5cbiAgdmFyIGVkZ2VzID0gdmFycy5yZXR1cm5lZC5lZGdlcyB8fCBbXSxcbiAgICAgIHNjYWxlID0gdmFycy56b29tLmJlaGF2aW9yLnNjYWxlRXh0ZW50KClbMF1cblxuICBpZiAodHlwZW9mIHZhcnMuZWRnZXMuc2l6ZSA9PT0gXCJzdHJpbmdcIikge1xuXG4gICAgdmFyIHN0cm9rZURvbWFpbiA9IGQzLmV4dGVudChlZGdlcywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVbdmFycy5lZGdlcy5zaXplXVxuICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgLCBtYXhTaXplID0gZDMubWluKHZhcnMucmV0dXJuZWQubm9kZXMgfHwgW10sIGZ1bmN0aW9uKG4pe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4uZDNwbHVzLnJcbiAgICAgICAgICAgICAgICAgICAgICB9KSouNVxuXG4gICAgdmFycy5lZGdlcy5zY2FsZSA9IGQzLnNjYWxlLnNxcnQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRvbWFpbihzdHJva2VEb21haW4pXG4gICAgICAgICAgICAgICAgICAgICAgICAucmFuZ2UoW3ZhcnMuZWRnZXMud2lkdGgsbWF4U2l6ZSpzY2FsZV0pXG5cbiAgfVxuICBlbHNlIHtcblxuICAgIHZhciBkZWZhdWx0V2lkdGggPSB0eXBlb2YgdmFycy5lZGdlcy5zaXplID09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICAgICAgID8gdmFycy5lZGdlcy5zaXplIDogdmFycy5lZGdlcy53aWR0aFxuXG4gICAgdmFycy5lZGdlcy5zY2FsZSA9IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZGVmYXVsdFdpZHRoXG4gICAgfVxuXG4gIH1cblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gSW5pdGlhbGl6YXRpb24gb2YgTGluZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGZ1bmN0aW9uIGluaXQobCkge1xuXG4gICAgdmFyIG9wYWNpdHkgPSB2YXJzLmVkZ2VzLm9wYWNpdHkgPT0gMSA/IHZhcnMuZWRnZXMub3BhY2l0eSA6IDBcblxuICAgIGxcbiAgICAgIC5hdHRyKFwib3BhY2l0eVwiLG9wYWNpdHkpXG4gICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwwKVxuICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsdmFycy5iYWNrZ3JvdW5kLnZhbHVlKVxuICAgICAgLnN0eWxlKFwiZmlsbFwiLFwibm9uZVwiKVxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIFN0eWxpbmcgb2YgTGluZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGZ1bmN0aW9uIHN0eWxlKGVkZ2VzKSB7XG5cbiAgICB2YXIgbWFya2VyID0gdmFycy5lZGdlcy5hcnJvd3MudmFsdWVcblxuICAgIGVkZ2VzXG4gICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIixmdW5jdGlvbihlKXtcbiAgICAgICAgcmV0dXJuIHZhcnMuZWRnZXMuc2NhbGUoZVt2YXJzLmVkZ2VzLnNpemVdKVxuICAgICAgfSlcbiAgICAgIC5zdHlsZShcInN0cm9rZVwiLHZhcnMuZWRnZXMuY29sb3IpXG4gICAgICAuYXR0cihcIm9wYWNpdHlcIix2YXJzLmVkZ2VzLm9wYWNpdHkpXG4gICAgICAuYXR0cihcIm1hcmtlci1zdGFydFwiLGZ1bmN0aW9uKGUpe1xuXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB2YXJzLmVkZ2VzLmFycm93cy5kaXJlY3Rpb24udmFsdWVcblxuICAgICAgICBpZiAoXCJidWNrZXRcIiBpbiBlLmQzcGx1cykge1xuICAgICAgICAgIHZhciBkID0gXCJfXCIrZS5kM3BsdXMuYnVja2V0XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGQgPSBcIlwiXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGlyZWN0aW9uID09IFwic291cmNlXCIgJiYgbWFya2VyXG4gICAgICAgICAgICAgPyBcInVybCgjZDNwbHVzX2VkZ2VfbWFya2VyX2RlZmF1bHRcIitkK1wiKVwiIDogXCJub25lXCJcblxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwibWFya2VyLWVuZFwiLGZ1bmN0aW9uKGUpe1xuXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB2YXJzLmVkZ2VzLmFycm93cy5kaXJlY3Rpb24udmFsdWVcblxuICAgICAgICBpZiAoXCJidWNrZXRcIiBpbiBlLmQzcGx1cykge1xuICAgICAgICAgIHZhciBkID0gXCJfXCIrZS5kM3BsdXMuYnVja2V0XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGQgPSBcIlwiXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGlyZWN0aW9uID09IFwidGFyZ2V0XCIgJiYgbWFya2VyXG4gICAgICAgICAgICAgPyBcInVybCgjZDNwbHVzX2VkZ2VfbWFya2VyX2RlZmF1bHRcIitkK1wiKVwiIDogXCJub25lXCJcblxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwidmVjdG9yLWVmZmVjdFwiLFwibm9uLXNjYWxpbmctc3Ryb2tlXCIpXG4gICAgICAuYXR0cihcInBvaW50ZXItZXZlbnRzXCIsXCJub25lXCIpXG4gIH1cblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gUG9zaXRpb25pbmcgb2YgTGluZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGZ1bmN0aW9uIGxpbmUobCkge1xuICAgIGxcbiAgICAgIC5hdHRyKFwieDFcIixmdW5jdGlvbihkKXtcbiAgICAgICAgcmV0dXJuIGRbdmFycy5lZGdlcy5zb3VyY2VdLmQzcGx1cy5lZGdlc1tkW3ZhcnMuZWRnZXMudGFyZ2V0XVt2YXJzLmlkLnZhbHVlXV0ueFxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwieTFcIixmdW5jdGlvbihkKXtcbiAgICAgICAgcmV0dXJuIGRbdmFycy5lZGdlcy5zb3VyY2VdLmQzcGx1cy5lZGdlc1tkW3ZhcnMuZWRnZXMudGFyZ2V0XVt2YXJzLmlkLnZhbHVlXV0ueVxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwieDJcIixmdW5jdGlvbihkKXtcbiAgICAgICAgcmV0dXJuIGRbdmFycy5lZGdlcy50YXJnZXRdLmQzcGx1cy5lZGdlc1tkW3ZhcnMuZWRnZXMuc291cmNlXVt2YXJzLmlkLnZhbHVlXV0ueFxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwieTJcIixmdW5jdGlvbihkKXtcbiAgICAgICAgcmV0dXJuIGRbdmFycy5lZGdlcy50YXJnZXRdLmQzcGx1cy5lZGdlc1tkW3ZhcnMuZWRnZXMuc291cmNlXVt2YXJzLmlkLnZhbHVlXV0ueVxuICAgICAgfSlcbiAgfVxuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBQb3NpdGlvbmluZyBvZiBTcGxpbmVzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXIgY3VydmUgPSBkMy5zdmcubGluZSgpLmludGVycG9sYXRlKHZhcnMuZWRnZXMuaW50ZXJwb2xhdGUudmFsdWUpXG5cbiAgZnVuY3Rpb24gc3BsaW5lKGwpIHtcbiAgICBsXG4gICAgICAuYXR0cihcImRcIiwgZnVuY3Rpb24oZCkge1xuXG4gICAgICAgIHJldHVybiBjdXJ2ZShkLmQzcGx1cy5zcGxpbmUpO1xuXG4gICAgICB9KVxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIENhbGN1bGF0ZXMgYW5kIERyYXdzIExhYmVsIGZvciBlZGdlXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBmdW5jdGlvbiBsYWJlbChkKSB7XG5cbiAgICBkZWxldGUgZC5kM3BsdXNfbGFiZWxcblxuICAgIGlmICh2YXJzLmcuZWRnZXMuc2VsZWN0QWxsKFwibGluZSwgcGF0aFwiKS5zaXplKCkgPCB2YXJzLmVkZ2VzLmxhcmdlICYmIHZhcnMuZWRnZXMubGFiZWwgJiYgZFt2YXJzLmVkZ2VzLmxhYmVsXSkge1xuXG4gICAgICBpZiAoXCJzcGxpbmVcIiBpbiBkLmQzcGx1cykge1xuXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmdldFRvdGFsTGVuZ3RoKCksXG4gICAgICAgICAgICBjZW50ZXIgPSB0aGlzLmdldFBvaW50QXRMZW5ndGgobGVuZ3RoLzIpLFxuICAgICAgICAgICAgcHJldiA9IHRoaXMuZ2V0UG9pbnRBdExlbmd0aCgobGVuZ3RoLzIpLShsZW5ndGgqLjEpKSxcbiAgICAgICAgICAgIG5leHQgPSB0aGlzLmdldFBvaW50QXRMZW5ndGgoKGxlbmd0aC8yKSsobGVuZ3RoKi4xKSksXG4gICAgICAgICAgICByYWRpYW5zID0gTWF0aC5hdGFuMihuZXh0LnktcHJldi55LG5leHQueC1wcmV2LngpLFxuICAgICAgICAgICAgYW5nbGUgPSByYWRpYW5zKigxODAvTWF0aC5QSSksXG4gICAgICAgICAgICBib3VuZGluZyA9IHRoaXMucGFyZW50Tm9kZS5nZXRCQm94KCksXG4gICAgICAgICAgICB3aWR0aCA9IGxlbmd0aCouOCxcbiAgICAgICAgICAgIHggPSBjZW50ZXIueCxcbiAgICAgICAgICAgIHkgPSBjZW50ZXIueVxuXG4gICAgICB9XG4gICAgICBlbHNlIHtcblxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCQm94KCksXG4gICAgICAgICAgICBzb3VyY2UgPSBkW3ZhcnMuZWRnZXMuc291cmNlXSxcbiAgICAgICAgICAgIHRhcmdldCA9IGRbdmFycy5lZGdlcy50YXJnZXRdLFxuICAgICAgICAgICAgc3RhcnQgPSB7XCJ4XCI6IHNvdXJjZS5kM3BsdXMuZWRnZXNbdGFyZ2V0W3ZhcnMuaWQudmFsdWVdXS54LCBcInlcIjogc291cmNlLmQzcGx1cy5lZGdlc1t0YXJnZXRbdmFycy5pZC52YWx1ZV1dLnl9LFxuICAgICAgICAgICAgZW5kID0ge1wieFwiOiB0YXJnZXQuZDNwbHVzLmVkZ2VzW3NvdXJjZVt2YXJzLmlkLnZhbHVlXV0ueCwgXCJ5XCI6IHRhcmdldC5kM3BsdXMuZWRnZXNbc291cmNlW3ZhcnMuaWQudmFsdWVdXS55fSxcbiAgICAgICAgICAgIHhkaWZmID0gZW5kLngtc3RhcnQueCxcbiAgICAgICAgICAgIHlkaWZmID0gZW5kLnktc3RhcnQueSxcbiAgICAgICAgICAgIGNlbnRlciA9IHtcInhcIjogZW5kLngtKHhkaWZmKS8yLCBcInlcIjogZW5kLnktKHlkaWZmKS8yfSxcbiAgICAgICAgICAgIHJhZGlhbnMgPSBNYXRoLmF0YW4yKHlkaWZmLHhkaWZmKSxcbiAgICAgICAgICAgIGFuZ2xlID0gcmFkaWFucyooMTgwL01hdGguUEkpLFxuICAgICAgICAgICAgbGVuZ3RoID0gTWF0aC5zcXJ0KCh4ZGlmZip4ZGlmZikrKHlkaWZmKnlkaWZmKSksXG4gICAgICAgICAgICB3aWR0aCA9IGxlbmd0aCxcbiAgICAgICAgICAgIHggPSBjZW50ZXIueCxcbiAgICAgICAgICAgIHkgPSBjZW50ZXIueVxuXG4gICAgICB9XG5cbiAgICAgIHdpZHRoICs9IHZhcnMubGFiZWxzLnBhZGRpbmcqMlxuXG4gICAgICB2YXIgbSA9IDBcbiAgICAgIGlmICh2YXJzLmVkZ2VzLmFycm93cy52YWx1ZSkge1xuICAgICAgICBtID0gdHlwZW9mIHZhcnMuZWRnZXMuYXJyb3dzLnZhbHVlID09PSBcIm51bWJlclwiXG4gICAgICAgICAgPyB2YXJzLmVkZ2VzLmFycm93cy52YWx1ZSA6IDhcbiAgICAgICAgbSA9IG0vdmFycy56b29tLmJlaGF2aW9yLnNjYWxlRXh0ZW50KClbMV1cbiAgICAgICAgd2lkdGggLT0gbSoyXG4gICAgICB9XG5cbiAgICAgIGlmIChhbmdsZSA8IC05MCB8fCBhbmdsZSA+IDkwKSB7XG4gICAgICAgIGFuZ2xlIC09IDE4MFxuICAgICAgfVxuXG4gICAgICBpZiAod2lkdGgqdmFycy56b29tLmJlaGF2aW9yLnNjYWxlRXh0ZW50KClbMF0gPiAyMCkge1xuXG4gICAgICAgIGQuZDNwbHVzX2xhYmVsID0ge1xuICAgICAgICAgIFwieFwiOiB4LFxuICAgICAgICAgIFwieVwiOiB5LFxuICAgICAgICAgIFwidHJhbnNsYXRlXCI6IHtcInhcIjogeCwgXCJ5XCI6IHl9LFxuICAgICAgICAgIFwid1wiOiB3aWR0aCxcbiAgICAgICAgICBcImhcIjogMTUrdmFycy5sYWJlbHMucGFkZGluZyoyLFxuICAgICAgICAgIFwiYW5nbGVcIjogYW5nbGUsXG4gICAgICAgICAgXCJhbmNob3JcIjogXCJtaWRkbGVcIixcbiAgICAgICAgICBcInZhbGlnblwiOiBcImNlbnRlclwiLFxuICAgICAgICAgIFwiY29sb3JcIjogdmFycy5lZGdlcy5jb2xvcixcbiAgICAgICAgICBcInJlc2l6ZVwiOiBmYWxzZSxcbiAgICAgICAgICBcIm5hbWVzXCI6IFt2YXJzLmZvcm1hdC52YWx1ZShkW3ZhcnMuZWRnZXMubGFiZWxdKV0sXG4gICAgICAgICAgXCJiYWNrZ3JvdW5kXCI6IDFcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBFbnRlci91cGRhdGUvZXhpdCB0aGUgQXJyb3cgTWFya2VyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXIgbWFya2VyRGF0YSA9IHZhcnMuZWRnZXMuYXJyb3dzLnZhbHVlID8gdHlwZW9mIHZhcnMuZWRnZXMuc2l6ZSA9PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICA/IFsgXCJkZWZhdWx0XzBcIiwgXCJkZWZhdWx0XzFcIiwgXCJkZWZhdWx0XzJcIixcbiAgICAgICAgICAgICAgICAgICAgICBcImhpZ2hsaWdodF8wXCIsIFwiaGlnaGxpZ2h0XzFcIiwgXCJoaWdobGlnaHRfMlwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZm9jdXNfMFwiLCBcImZvY3VzXzFcIiwgXCJmb2N1c18yXCIgXVxuICAgICAgICAgICAgICAgICAgOiBbIFwiZGVmYXVsdFwiLCBcImhpZ2hsaWdodFwiLCBcImZvY3VzXCIgXSA6IFtdXG5cbiAgaWYgKHR5cGVvZiB2YXJzLmVkZ2VzLnNpemUgPT0gXCJzdHJpbmdcIikge1xuICAgIHZhciBidWNrZXRzID0gZDNwbHVzLnV0aWwuYnVja2V0cyh2YXJzLmVkZ2VzLnNjYWxlLnJhbmdlKCksNClcbiAgICAgICwgbWFya2VyU2l6ZSA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgIG1hcmtlclNpemUucHVzaChidWNrZXRzW2krMV0rKGJ1Y2tldHNbMV0tYnVja2V0c1swXSkqKGkrMikqMilcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgdmFycy5lZGdlcy5hcnJvd3MudmFsdWUgPT09IFwibnVtYmVyXCJcbiAgICAgICAgICA/IHZhcnMuZWRnZXMuYXJyb3dzLnZhbHVlIDogOFxuXG4gICAgdmFyIG1hcmtlclNpemUgPSB0eXBlb2YgdmFycy5lZGdlcy5zaXplID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgICAgICAgID8gdmFycy5lZGdlcy5zaXplL20gOiBtXG4gIH1cblxuICB2YXIgbWFya2VyID0gdmFycy5kZWZzLnNlbGVjdEFsbChcIi5kM3BsdXNfZWRnZV9tYXJrZXJcIilcbiAgICAuZGF0YShtYXJrZXJEYXRhLCBTdHJpbmcpXG5cbiAgdmFyIG1hcmtlcl9zdHlsZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBwYXRoXG4gICAgICAuYXR0cihcImRcIixmdW5jdGlvbihpZCl7XG5cbiAgICAgICAgdmFyIGRlcHRoID0gaWQuc3BsaXQoXCJfXCIpXG5cbiAgICAgICAgaWYgKGRlcHRoLmxlbmd0aCA9PSAyICYmIHZhcnMuZWRnZXMuc2NhbGUpIHtcbiAgICAgICAgICBkZXB0aCA9IHBhcnNlSW50KGRlcHRoWzFdKVxuICAgICAgICAgIHZhciBtID0gbWFya2VyU2l6ZVtkZXB0aF1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgbSA9IG1hcmtlclNpemVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YXJzLmVkZ2VzLmFycm93cy5kaXJlY3Rpb24udmFsdWUgPT0gXCJ0YXJnZXRcIikge1xuICAgICAgICAgIHJldHVybiBcIk0gMCwtXCIrbS8yK1wiIEwgXCIrbSouODUrXCIsMCBMIDAsXCIrbS8yK1wiIEwgMCwtXCIrbS8yXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFwiTSAwLC1cIittLzIrXCIgTCAtXCIrbSouODUrXCIsMCBMIDAsXCIrbS8yK1wiIEwgMCwtXCIrbS8yXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuYXR0cihcImZpbGxcIixmdW5jdGlvbihkKXtcblxuICAgICAgICB2YXIgdHlwZSA9IGQuc3BsaXQoXCJfXCIpWzBdXG5cbiAgICAgICAgaWYgKHR5cGUgPT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICByZXR1cm4gdmFycy5lZGdlcy5jb2xvclxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJmb2N1c1wiKSB7XG4gICAgICAgICAgcmV0dXJuIHZhcnMuY29sb3IuZm9jdXNcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdmFycy5jb2xvci5wcmltYXJ5XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuYXR0cihcInRyYW5zZm9ybVwiLFwic2NhbGUoXCIrMS9zY2FsZStcIilcIilcbiAgfVxuXG4gIGlmICh2YXJzLmRyYXcudGltaW5nKSB7XG4gICAgbWFya2VyLmV4aXQoKS50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgIC5hdHRyKFwib3BhY2l0eVwiLDApXG4gICAgICAucmVtb3ZlKClcblxuICAgIG1hcmtlci5zZWxlY3QoXCJwYXRoXCIpLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsMSlcbiAgICAgIC5jYWxsKG1hcmtlcl9zdHlsZSlcbiAgfVxuICBlbHNlIHtcbiAgICBtYXJrZXIuZXhpdCgpLnJlbW92ZSgpXG5cbiAgICBtYXJrZXIuc2VsZWN0KFwicGF0aFwiKVxuICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsMSlcbiAgICAgIC5jYWxsKG1hcmtlcl9zdHlsZSlcbiAgfVxuXG4gIHZhciBvcGFjaXR5ID0gdmFycy5kcmF3LnRpbWluZyA/IDAgOiAxXG4gIHZhciBlbnRlciA9IG1hcmtlci5lbnRlcigpLmFwcGVuZChcIm1hcmtlclwiKVxuICAgIC5hdHRyKFwiaWRcIixmdW5jdGlvbihkKXtcbiAgICAgIHJldHVybiBcImQzcGx1c19lZGdlX21hcmtlcl9cIitkXG4gICAgfSlcbiAgICAuYXR0cihcImNsYXNzXCIsXCJkM3BsdXNfZWRnZV9tYXJrZXJcIilcbiAgICAuYXR0cihcIm9yaWVudFwiLFwiYXV0b1wiKVxuICAgIC5hdHRyKFwibWFya2VyVW5pdHNcIixcInVzZXJTcGFjZU9uVXNlXCIpXG4gICAgLnN0eWxlKFwib3ZlcmZsb3dcIixcInZpc2libGVcIilcbiAgICAuYXBwZW5kKFwicGF0aFwiKVxuICAgIC5hdHRyKFwib3BhY2l0eVwiLG9wYWNpdHkpXG4gICAgLmF0dHIoXCJ2ZWN0b3ItZWZmZWN0XCIsXCJub24tc2NhbGluZy1zdHJva2VcIilcbiAgICAuY2FsbChtYXJrZXJfc3R5bGUpXG5cbiAgaWYgKHZhcnMuZHJhdy50aW1pbmcpIHtcbiAgICBlbnRlci50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgIC5hdHRyKFwib3BhY2l0eVwiLDEpXG4gIH1cblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gQmluZCBcImVkZ2VzXCIgZGF0YSB0byBsaW5lcyBpbiB0aGUgXCJlZGdlc1wiIGdyb3VwXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXIgc3Ryb2tlQnVja2V0cyA9IHR5cGVvZiB2YXJzLmVkZ2VzLnNpemUgPT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICA/IGQzcGx1cy51dGlsLmJ1Y2tldHModmFycy5lZGdlcy5zY2FsZS5kb21haW4oKSw0KVxuICAgICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAsIGRpcmVjdGlvbiA9IHZhcnMuZWRnZXMuYXJyb3dzLmRpcmVjdGlvbi52YWx1ZVxuXG4gIHZhciBsaW5lX2RhdGEgPSBlZGdlcy5maWx0ZXIoZnVuY3Rpb24obCl7XG5cbiAgICBpZiAoIWwuZDNwbHVzKSBsLmQzcGx1cyA9IHt9XG5cbiAgICBsLmQzcGx1cy5pZCA9IFwiZWRnZV9cIitsW3ZhcnMuZWRnZXMuc291cmNlXVt2YXJzLmlkLnZhbHVlXStcIl9cIitsW3ZhcnMuZWRnZXMudGFyZ2V0XVt2YXJzLmlkLnZhbHVlXVxuXG4gICAgaWYgKCBsLmQzcGx1cy5zcGxpbmUgIT09IHRydWUgKSB7XG5cbiAgICAgIGlmIChzdHJva2VCdWNrZXRzKSB7XG4gICAgICAgIHZhciBzaXplID0gbFt2YXJzLmVkZ2VzLnNpemVdXG4gICAgICAgIGwuZDNwbHVzLmJ1Y2tldCA9IHNpemUgPCBzdHJva2VCdWNrZXRzWzFdID8gMFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzaXplIDwgc3Ryb2tlQnVja2V0c1syXSA/IDEgOiAyXG4gICAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJTaXplW2wuZDNwbHVzLmJ1Y2tldF0qLjg1L3NjYWxlXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGwuZDNwbHVzLmJ1Y2tldFxuICAgICAgICB2YXIgbWFya2VyID0gbWFya2VyU2l6ZSouODUvc2NhbGVcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZSA9IGxbdmFycy5lZGdlcy5zb3VyY2VdXG4gICAgICAgICwgdGFyZ2V0ID0gbFt2YXJzLmVkZ2VzLnRhcmdldF1cblxuICAgICAgaWYgKCFzb3VyY2UuZDNwbHVzIHx8ICF0YXJnZXQuZDNwbHVzKSByZXR1cm4gZmFsc2VcblxuICAgICAgdmFyIHNvdXJjZUFuZ2xlID0gTWF0aC5hdGFuMiggc291cmNlLmQzcGx1cy55IC0gdGFyZ2V0LmQzcGx1cy55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBzb3VyY2UuZDNwbHVzLnggLSB0YXJnZXQuZDNwbHVzLnggKVxuICAgICAgICAsIHRhcmdldEFuZ2xlID0gTWF0aC5hdGFuMiggdGFyZ2V0LmQzcGx1cy55IC0gc291cmNlLmQzcGx1cy55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCB0YXJnZXQuZDNwbHVzLnggLSBzb3VyY2UuZDNwbHVzLnggKVxuICAgICAgICAsIHNvdXJjZVJhZGl1cyA9IGRpcmVjdGlvbiA9PSBcInNvdXJjZVwiICYmIHZhcnMuZWRnZXMuYXJyb3dzLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgID8gc291cmNlLmQzcGx1cy5yICsgbWFya2VyXG4gICAgICAgICAgICAgICAgICAgICAgIDogc291cmNlLmQzcGx1cy5yXG4gICAgICAgICwgdGFyZ2V0UmFkaXVzID0gZGlyZWN0aW9uID09IFwidGFyZ2V0XCIgJiYgdmFycy5lZGdlcy5hcnJvd3MudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgPyB0YXJnZXQuZDNwbHVzLnIgKyBtYXJrZXJcbiAgICAgICAgICAgICAgICAgICAgICAgOiB0YXJnZXQuZDNwbHVzLnJcbiAgICAgICAgLCBzb3VyY2VPZmZzZXQgPSBkM3BsdXMudXRpbC5vZmZzZXQoIHNvdXJjZUFuZ2xlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBzb3VyY2VSYWRpdXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHZhcnMuc2hhcGUudmFsdWUgKVxuICAgICAgICAsIHRhcmdldE9mZnNldCA9IGQzcGx1cy51dGlsLm9mZnNldCggdGFyZ2V0QW5nbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHRhcmdldFJhZGl1c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgdmFycy5zaGFwZS52YWx1ZSApXG5cbiAgICAgIGlmICghKFwiZWRnZXNcIiBpbiBzb3VyY2UuZDNwbHVzKSkgc291cmNlLmQzcGx1cy5lZGdlcyA9IHt9XG4gICAgICBzb3VyY2UuZDNwbHVzLmVkZ2VzW3RhcmdldFt2YXJzLmlkLnZhbHVlXV0gPSB7XG4gICAgICAgICAgXCJ4XCI6IHNvdXJjZS5kM3BsdXMueCAtIHNvdXJjZU9mZnNldC54LFxuICAgICAgICAgIFwieVwiOiBzb3VyY2UuZDNwbHVzLnkgLSBzb3VyY2VPZmZzZXQueVxuICAgICAgfVxuXG4gICAgICBpZiAoIShcImVkZ2VzXCIgaW4gdGFyZ2V0LmQzcGx1cykpIHRhcmdldC5kM3BsdXMuZWRnZXMgPSB7fVxuICAgICAgdGFyZ2V0LmQzcGx1cy5lZGdlc1tzb3VyY2VbdmFycy5pZC52YWx1ZV1dID0ge1xuICAgICAgICAgIFwieFwiOiB0YXJnZXQuZDNwbHVzLnggLSB0YXJnZXRPZmZzZXQueCxcbiAgICAgICAgICBcInlcIjogdGFyZ2V0LmQzcGx1cy55IC0gdGFyZ2V0T2Zmc2V0LnlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcblxuICB9KVxuXG4gIHZhciBsaW5lcyA9IHZhcnMuZy5lZGdlcy5zZWxlY3RBbGwoXCJnLmQzcGx1c19lZGdlX2xpbmVcIilcbiAgICAuZGF0YShsaW5lX2RhdGEsZnVuY3Rpb24oZCl7XG5cbiAgICAgIHJldHVybiBkLmQzcGx1cy5pZFxuXG4gICAgfSlcblxuICB2YXIgc3BsaW5lX2RhdGEgPSBlZGdlcy5maWx0ZXIoZnVuY3Rpb24obCl7XG5cbiAgICBpZiAobC5kM3BsdXMuc3BsaW5lKSB7XG5cbiAgICAgIGlmIChzdHJva2VCdWNrZXRzKSB7XG4gICAgICAgIHZhciBzaXplID0gbFt2YXJzLmVkZ2VzLnNpemVdXG4gICAgICAgIGwuZDNwbHVzLmJ1Y2tldCA9IHNpemUgPCBzdHJva2VCdWNrZXRzWzFdID8gMFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzaXplIDwgc3Ryb2tlQnVja2V0c1syXSA/IDEgOiAyXG4gICAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJTaXplW2wuZDNwbHVzLmJ1Y2tldF0qLjg1L3NjYWxlXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGwuZDNwbHVzLmJ1Y2tldFxuICAgICAgICB2YXIgbWFya2VyID0gbWFya2VyU2l6ZSouODUvc2NhbGVcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZSA9IGxbdmFycy5lZGdlcy5zb3VyY2VdXG4gICAgICAgICwgdGFyZ2V0ID0gbFt2YXJzLmVkZ2VzLnRhcmdldF1cbiAgICAgICAgLCBzb3VyY2VFZGdlID0gc291cmNlLmQzcGx1cy5lZGdlcyA/IHNvdXJjZS5kM3BsdXMuZWRnZXNbdGFyZ2V0W3ZhcnMuaWQudmFsdWVdXSB8fCB7fSA6IHt9XG4gICAgICAgICwgdGFyZ2V0RWRnZSA9IHRhcmdldC5kM3BsdXMuZWRnZXMgPyB0YXJnZXQuZDNwbHVzLmVkZ2VzW3NvdXJjZVt2YXJzLmlkLnZhbHVlXV0gfHwge30gOiB7fVxuICAgICAgICAsIHNvdXJjZU1vZCA9IHZhcnMuZWRnZXMuYXJyb3dzLnZhbHVlICYmIGRpcmVjdGlvbiA9PSBcInNvdXJjZVwiID8gbWFya2VyIDogMFxuICAgICAgICAsIHRhcmdldE1vZCA9IHZhcnMuZWRnZXMuYXJyb3dzLnZhbHVlICYmIGRpcmVjdGlvbiA9PSBcInRhcmdldFwiID8gbWFya2VyIDogMFxuICAgICAgICAsIGFuZ2xlVHdlYWsgPSAwLjFcbiAgICAgICAgLCBzb3VyY2VUd2VhayA9IHNvdXJjZS5kM3BsdXMueCA+IHRhcmdldC5kM3BsdXMueCA/IDEtYW5nbGVUd2VhayA6IDErYW5nbGVUd2Vha1xuICAgICAgICAsIHRhcmdldFR3ZWFrID0gc291cmNlLmQzcGx1cy54ID4gdGFyZ2V0LmQzcGx1cy54ID8gMSthbmdsZVR3ZWFrIDogMS1hbmdsZVR3ZWFrXG4gICAgICAgICwgc291cmNlQW5nbGUgPSB0eXBlb2Ygc291cmNlRWRnZS5hbmdsZSA9PT0gXCJudW1iZXJcIiA/IHNvdXJjZUVkZ2UuYW5nbGVcbiAgICAgICAgICAgICAgICAgICAgICA6IE1hdGguYXRhbjIoIHNvdXJjZS5kM3BsdXMueSAtIHRhcmdldC5kM3BsdXMueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgc291cmNlLmQzcGx1cy54IC0gdGFyZ2V0LmQzcGx1cy54ICkgKiBzb3VyY2VUd2Vha1xuICAgICAgICAsIHNvdXJjZU9mZnNldCA9IGQzcGx1cy51dGlsLm9mZnNldChzb3VyY2VBbmdsZSwgc291cmNlLmQzcGx1cy5yICsgc291cmNlTW9kLCB2YXJzLnNoYXBlLnZhbHVlIClcbiAgICAgICAgLCB0YXJnZXRBbmdsZSA9IHR5cGVvZiB0YXJnZXRFZGdlLmFuZ2xlID09PSBcIm51bWJlclwiID8gdGFyZ2V0RWRnZS5hbmdsZVxuICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5hdGFuMiggdGFyZ2V0LmQzcGx1cy55IC0gc291cmNlLmQzcGx1cy55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCB0YXJnZXQuZDNwbHVzLnggLSBzb3VyY2UuZDNwbHVzLnggKSAqIHRhcmdldFR3ZWFrXG4gICAgICAgICwgdGFyZ2V0T2Zmc2V0ID0gZDNwbHVzLnV0aWwub2Zmc2V0KHRhcmdldEFuZ2xlLCB0YXJnZXQuZDNwbHVzLnIgKyB0YXJnZXRNb2QsIHZhcnMuc2hhcGUudmFsdWUgKVxuICAgICAgICAsIHN0YXJ0ID0gW3NvdXJjZS5kM3BsdXMueC1zb3VyY2VPZmZzZXQueCwgc291cmNlLmQzcGx1cy55LXNvdXJjZU9mZnNldC55XVxuICAgICAgICAsIHN0YXJ0T2Zmc2V0ID0gc291cmNlRWRnZS5vZmZzZXQgPyBkM3BsdXMudXRpbC5vZmZzZXQoc291cmNlQW5nbGUsc291cmNlRWRnZS5vZmZzZXQpIDogZmFsc2VcbiAgICAgICAgLCBzdGFydFBvaW50ID0gc3RhcnRPZmZzZXQgPyBbc3RhcnRbMF0tc3RhcnRPZmZzZXQueCxzdGFydFsxXS1zdGFydE9mZnNldC55XSA6IHN0YXJ0XG4gICAgICAgICwgZW5kID0gW3RhcmdldC5kM3BsdXMueC10YXJnZXRPZmZzZXQueCwgdGFyZ2V0LmQzcGx1cy55LXRhcmdldE9mZnNldC55XVxuICAgICAgICAsIGVuZE9mZnNldCA9IHRhcmdldEVkZ2Uub2Zmc2V0ID8gZDNwbHVzLnV0aWwub2Zmc2V0KHRhcmdldEFuZ2xlLHRhcmdldEVkZ2Uub2Zmc2V0KSA6IGZhbHNlXG4gICAgICAgICwgZW5kUG9pbnQgPSBlbmRPZmZzZXQgPyBbZW5kWzBdLWVuZE9mZnNldC54LGVuZFsxXS1lbmRPZmZzZXQueV0gOiBlbmRcbiAgICAgICAgLCB4ZCA9IGVuZFBvaW50WzBdIC0gc3RhcnRQb2ludFswXVxuICAgICAgICAsIHlkID0gZW5kUG9pbnRbMV0gLSBzdGFydFBvaW50WzFdXG4gICAgICAgICwgc291cmNlRGlzdGFuY2UgPSB0eXBlb2Ygc291cmNlRWRnZS5yYWRpdXMgPT09IFwibnVtYmVyXCIgPyBzb3VyY2VFZGdlLnJhZGl1cyA6IE1hdGguc3FydCh4ZCp4ZCt5ZCp5ZCkvNFxuICAgICAgICAsIHRhcmdldERpc3RhbmNlID0gdHlwZW9mIHRhcmdldEVkZ2UucmFkaXVzID09PSBcIm51bWJlclwiID8gdGFyZ2V0RWRnZS5yYWRpdXMgOiBNYXRoLnNxcnQoeGQqeGQreWQqeWQpLzRcbiAgICAgICAgLCBzdGFydEFuY2hvciA9IGQzcGx1cy51dGlsLm9mZnNldChzb3VyY2VBbmdsZSxzb3VyY2VEaXN0YW5jZS1zb3VyY2UuZDNwbHVzLnItc291cmNlTW9kKjIpXG4gICAgICAgICwgZW5kQW5jaG9yID0gZDNwbHVzLnV0aWwub2Zmc2V0KHRhcmdldEFuZ2xlLHRhcmdldERpc3RhbmNlLXRhcmdldC5kM3BsdXMuci10YXJnZXRNb2QqMilcblxuICAgICAgbC5kM3BsdXMuc3BsaW5lID0gWyBzdGFydCwgZW5kIF1cbiAgICAgIHZhciB0ZXN0QW5nbGUgPSBNYXRoLmFicyhNYXRoLmF0YW4yKCBzb3VyY2UuZDNwbHVzLnkgLSB0YXJnZXQuZDNwbHVzLnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBzb3VyY2UuZDNwbHVzLnggLSB0YXJnZXQuZDNwbHVzLnggKSkudG9GaXhlZCg1KVxuICAgICAgICAsIHRlc3RTdGFydCA9IE1hdGguYWJzKHNvdXJjZUFuZ2xlKS50b0ZpeGVkKDUpXG4gICAgICAgICwgdGVzdEVuZCAgID0gTWF0aC5hYnModGFyZ2V0QW5nbGUgLSBNYXRoLlBJKS50b0ZpeGVkKDUpXG5cbiAgICAgIGlmICh0ZXN0U3RhcnQgIT09IHRlc3RFbmQgfHwgW3Rlc3RTdGFydCx0ZXN0RW5kXS5pbmRleE9mKHRlc3RBbmdsZSkgPCAwKSB7XG5cbiAgICAgICAgbC5kM3BsdXMuc3BsaW5lLnNwbGljZSgxLDAsW3N0YXJ0UG9pbnRbMF0tc3RhcnRBbmNob3IueCxzdGFydFBvaW50WzFdLXN0YXJ0QW5jaG9yLnldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZW5kUG9pbnRbMF0tZW5kQW5jaG9yLngsZW5kUG9pbnRbMV0tZW5kQW5jaG9yLnldKVxuXG4gICAgICAgIGlmIChzdGFydE9mZnNldCkgbC5kM3BsdXMuc3BsaW5lLnNwbGljZSgxLDAsc3RhcnRQb2ludClcbiAgICAgICAgaWYgKGVuZE9mZnNldCkgbC5kM3BsdXMuc3BsaW5lLnNwbGljZShsLmQzcGx1cy5zcGxpbmUubGVuZ3RoLTEsMCxlbmRQb2ludClcblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgfSlcblxuICB2YXIgc3BsaW5lcyA9IHZhcnMuZy5lZGdlcy5zZWxlY3RBbGwoXCJnLmQzcGx1c19lZGdlX3BhdGhcIilcbiAgICAuZGF0YShzcGxpbmVfZGF0YSxmdW5jdGlvbihkKXtcblxuICAgICAgcmV0dXJuIGQuZDNwbHVzLmlkXG5cbiAgICB9KVxuXG4gIGlmICh2YXJzLmRyYXcudGltaW5nKSB7XG5cbiAgICBsaW5lcy5leGl0KCkudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAuYXR0cihcIm9wYWNpdHlcIiwwKVxuICAgICAgLnJlbW92ZSgpXG5cbiAgICBzcGxpbmVzLmV4aXQoKS50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgIC5hdHRyKFwib3BhY2l0eVwiLDApXG4gICAgICAucmVtb3ZlKClcblxuICAgIGxpbmVzLnNlbGVjdEFsbChcInRleHQuZDNwbHVzX2xhYmVsLCByZWN0LmQzcGx1c19sYWJlbF9iZ1wiKVxuICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nLzIpXG4gICAgICAuYXR0cihcIm9wYWNpdHlcIiwwKVxuICAgICAgLnJlbW92ZSgpXG5cbiAgICBzcGxpbmVzLnNlbGVjdEFsbChcInRleHQuZDNwbHVzX2xhYmVsLCByZWN0LmQzcGx1c19sYWJlbF9iZ1wiKVxuICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nLzIpXG4gICAgICAuYXR0cihcIm9wYWNpdHlcIiwwKVxuICAgICAgLnJlbW92ZSgpXG5cbiAgICBsaW5lcy5zZWxlY3RBbGwoXCJsaW5lXCIpXG4gICAgICAuZGF0YShmdW5jdGlvbihkKXsgcmV0dXJuIFtkXSB9KVxuICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgICAgICAuY2FsbChsaW5lKVxuICAgICAgICAuY2FsbChzdHlsZSlcbiAgICAgICAgLmVhY2goXCJlbmRcIixsYWJlbClcblxuICAgIHNwbGluZXMuc2VsZWN0QWxsKFwicGF0aFwiKVxuICAgICAgLmRhdGEoZnVuY3Rpb24oZCl7IHJldHVybiBbZF0gfSlcbiAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgICAgLmNhbGwoc3BsaW5lKVxuICAgICAgICAuY2FsbChzdHlsZSlcbiAgICAgICAgLmVhY2goXCJlbmRcIixsYWJlbClcblxuICAgIGxpbmVzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgICAgLmF0dHIoXCJjbGFzc1wiLFwiZDNwbHVzX2VkZ2VfbGluZVwiKVxuICAgICAgLmFwcGVuZChcImxpbmVcIilcbiAgICAgIC5jYWxsKGxpbmUpXG4gICAgICAuY2FsbChpbml0KVxuICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgICAgICAuY2FsbChzdHlsZSlcbiAgICAgICAgLmVhY2goXCJlbmRcIixsYWJlbClcblxuICAgIHNwbGluZXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgICAuYXR0cihcImNsYXNzXCIsXCJkM3BsdXNfZWRnZV9wYXRoXCIpXG4gICAgICAuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgLmNhbGwoc3BsaW5lKVxuICAgICAgLmNhbGwoaW5pdClcbiAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgICAgLmNhbGwoc3R5bGUpXG4gICAgICAgIC5lYWNoKFwiZW5kXCIsbGFiZWwpXG5cbiAgfVxuICBlbHNlIHtcblxuICAgIGxpbmVzLmV4aXQoKS5yZW1vdmUoKVxuXG4gICAgc3BsaW5lcy5leGl0KCkucmVtb3ZlKClcblxuICAgIGxpbmVzLnNlbGVjdEFsbChcInRleHQuZDNwbHVzX2xhYmVsLCByZWN0LmQzcGx1c19sYWJlbF9iZ1wiKVxuICAgICAgLnJlbW92ZSgpXG5cbiAgICBzcGxpbmVzLnNlbGVjdEFsbChcInRleHQuZDNwbHVzX2xhYmVsLCByZWN0LmQzcGx1c19sYWJlbF9iZ1wiKVxuICAgICAgLnJlbW92ZSgpXG5cbiAgICBsaW5lcy5zZWxlY3RBbGwoXCJsaW5lXCIpXG4gICAgICAuZGF0YShmdW5jdGlvbihkKXsgcmV0dXJuIFtkXSB9KVxuICAgICAgLmNhbGwobGluZSlcbiAgICAgIC5jYWxsKHN0eWxlKVxuICAgICAgLmNhbGwobGFiZWwpXG5cbiAgICBzcGxpbmVzLnNlbGVjdEFsbChcInBhdGhcIilcbiAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpeyByZXR1cm4gW2RdIH0pXG4gICAgICAuY2FsbChzcGxpbmUpXG4gICAgICAuY2FsbChzdHlsZSlcbiAgICAgIC5jYWxsKGxhYmVsKVxuXG4gICAgbGluZXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgICAuYXR0cihcImNsYXNzXCIsXCJkM3BsdXNfZWRnZV9saW5lXCIpXG4gICAgICAuYXBwZW5kKFwibGluZVwiKVxuICAgICAgLmNhbGwobGluZSlcbiAgICAgIC5jYWxsKGluaXQpXG4gICAgICAuY2FsbChzdHlsZSlcbiAgICAgIC5jYWxsKGxhYmVsKVxuXG4gICAgc3BsaW5lcy5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAgIC5hdHRyKFwiY2xhc3NcIixcImQzcGx1c19lZGdlX3BhdGhcIilcbiAgICAgIC5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAuY2FsbChzcGxpbmUpXG4gICAgICAuY2FsbChpbml0KVxuICAgICAgLmNhbGwoc3R5bGUpXG4gICAgICAuY2FsbChsYWJlbClcblxuICB9XG5cbn1cbiIsInZhciBmZXRjaENvbG9yID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvZmV0Y2gvY29sb3IuanNcIilcbi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBEcmF3cyBcInNxdWFyZVwiIGFuZCBcImNpcmNsZVwiIHNoYXBlcyB1c2luZyBzdmc6cmVjdFxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmQzcGx1cy5zaGFwZS5maWxsID0gZnVuY3Rpb24odmFycyxzZWxlY3Rpb24sZW50ZXIsZXhpdCkge1xuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBUaGUgcG9zaXRpb24gYW5kIHNpemUgb2YgZWFjaCByZWN0YW5nbGUgb24gZW50ZXIgYW5kIGV4aXQuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBmdW5jdGlvbiBpbml0KG5vZGVzKSB7XG5cbiAgICBub2Rlc1xuICAgICAgLmF0dHIoXCJ4XCIsMClcbiAgICAgIC5hdHRyKFwieVwiLDApXG4gICAgICAuYXR0cihcIndpZHRoXCIsMClcbiAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsMClcblxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIFRoZSBwb3NpdGlvbiBhbmQgc2l6ZSBvZiBlYWNoIHJlY3RhbmdsZSBvbiB1cGRhdGUuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBmdW5jdGlvbiB1cGRhdGUobm9kZXMsbW9kKSB7XG4gICAgaWYgKCFtb2QpIHZhciBtb2QgPSAwXG4gICAgbm9kZXNcbiAgICAgIC5hdHRyKFwieFwiLGZ1bmN0aW9uKGQpe1xuICAgICAgICB2YXIgdyA9IGQuZDNwbHVzLnIgPyBkLmQzcGx1cy5yKjIgOiBkLmQzcGx1cy53aWR0aFxuICAgICAgICByZXR1cm4gKC13LzIpLShtb2QvMilcbiAgICAgIH0pXG4gICAgICAuYXR0cihcInlcIixmdW5jdGlvbihkKXtcbiAgICAgICAgdmFyIGggPSBkLmQzcGx1cy5yID8gZC5kM3BsdXMucioyIDogZC5kM3BsdXMuaGVpZ2h0XG4gICAgICAgIHJldHVybiAoLWgvMiktKG1vZC8yKVxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwid2lkdGhcIixmdW5jdGlvbihkKXtcbiAgICAgICAgdmFyIHcgPSBkLmQzcGx1cy5yID8gZC5kM3BsdXMucioyIDogZC5kM3BsdXMud2lkdGhcbiAgICAgICAgcmV0dXJuIHcrbW9kXG4gICAgICB9KVxuICAgICAgLmF0dHIoXCJoZWlnaHRcIixmdW5jdGlvbihkKXtcbiAgICAgICAgdmFyIGggPSBkLmQzcGx1cy5yID8gZC5kM3BsdXMucioyIDogZC5kM3BsdXMuaGVpZ2h0XG4gICAgICAgIHJldHVybiBoK21vZFxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwicnhcIixmdW5jdGlvbihkKXtcbiAgICAgICAgdmFyIHcgPSBkLmQzcGx1cy5yID8gZC5kM3BsdXMucioyIDogZC5kM3BsdXMud2lkdGhcbiAgICAgICAgdmFyIHJvdW5kZWQgPSBbXCJjaXJjbGVcIixcImRvbnV0XCJdLmluZGV4T2YodmFycy5zaGFwZS52YWx1ZSkgPj0gMFxuICAgICAgICByZXR1cm4gcm91bmRlZCA/ICh3K21vZCkvMiA6IDBcbiAgICAgIH0pXG4gICAgICAuYXR0cihcInJ5XCIsZnVuY3Rpb24oZCl7XG4gICAgICAgIHZhciBoID0gZC5kM3BsdXMuciA/IGQuZDNwbHVzLnIqMiA6IGQuZDNwbHVzLmhlaWdodFxuICAgICAgICB2YXIgcm91bmRlZCA9IFtcImNpcmNsZVwiLFwiZG9udXRcIl0uaW5kZXhPZih2YXJzLnNoYXBlLnZhbHVlKSA+PSAwXG4gICAgICAgIHJldHVybiByb3VuZGVkID8gKGgrbW9kKS8yIDogMFxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwic2hhcGUtcmVuZGVyaW5nXCIsZnVuY3Rpb24oZCl7XG4gICAgICAgIGlmIChbXCJzcXVhcmVcIl0uaW5kZXhPZih2YXJzLnNoYXBlLnZhbHVlKSA+PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHZhcnMuc2hhcGUucmVuZGVyaW5nLnZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFwiYXV0b1wiXG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gSW4gb3JkZXIgdG8gY29ycmVjdGx5IGFuaW1hdGUgZWFjaCBkb251dCdzIHNpemUgYW5kIGFyY3MsIHdlIG5lZWQgdG8gc3RvcmVcbiAgLy8gaXQncyBwcmV2aW91cyB2YWx1ZXMgaW4gYSBsb29rdXAgb2JqZWN0IHRoYXQgZG9lcyBub3QgZ2V0IGRlc3Ryb3llZCB3aGVuXG4gIC8vIHJlZHJhd2luZyB0aGUgdmlzdWFsaXphdGlvbi5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGlmICghdmFycy5hcmNzKSB7XG4gICAgdmFycy5hcmNzID0ge1xuICAgICAgXCJkb251dFwiOiB7fSxcbiAgICAgIFwiYWN0aXZlXCI6IHt9LFxuICAgICAgXCJ0ZW1wXCI6IHt9XG4gICAgfVxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIFRoaXMgaXMgdGhlIG1haW4gYXJjIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGF0IHZhbHVlcyB0byB1c2UgZm9yIGVhY2hcbiAgLy8gYXJjIGFuZ2xlIGFuZCByYWRpdXMuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXIgYXJjID0gZDMuc3ZnLmFyYygpXG4gICAgLnN0YXJ0QW5nbGUoMClcbiAgICAuZW5kQW5nbGUoZnVuY3Rpb24oZCl7XG4gICAgICB2YXIgYSA9IHZhcnMuYXJjc1tkLmQzcGx1cy5zaGFwZVR5cGVdW2QuZDNwbHVzLmlkXS5hXG4gICAgICByZXR1cm4gYSA+IE1hdGguUEkqMiA/IE1hdGguUEkqMiA6IGE7XG4gICAgfSlcbiAgICAuaW5uZXJSYWRpdXMoZnVuY3Rpb24oZCl7XG4gICAgICBpZiAoc2hhcGUgPT0gXCJkb251dFwiICYmICFkLmQzcGx1cy5zdGF0aWMpIHtcbiAgICAgICAgdmFyIHIgPSB2YXJzLmFyY3NbZC5kM3BsdXMuc2hhcGVUeXBlXVtkLmQzcGx1cy5pZF0uclxuICAgICAgICByZXR1cm4gciAqIHZhcnMuZGF0YS5kb251dC5zaXplXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH1cbiAgICB9KVxuICAgIC5vdXRlclJhZGl1cyhmdW5jdGlvbihkKXtcbiAgICAgIHZhciByID0gdmFycy5hcmNzW2QuZDNwbHVzLnNoYXBlVHlwZV1bZC5kM3BsdXMuaWRdLnJcbiAgICAgIGlmIChkLmQzcGx1cy5zaGFwZVR5cGUgIT0gXCJkb251dFwiKSByZXR1cm4gcioyXG4gICAgICBlbHNlIHJldHVybiByXG4gICAgfSlcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gVGhpcyBpcyB0aGUgbWFpbiBcImFyY1R3ZWVuXCIgZnVuY3Rpb24gd2hlcmUgYWxsIG9mIHRoZSBhbmltYXRpb24gaGFwcGVuc1xuICAvLyBmb3IgZWFjaCBhcmMuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBmdW5jdGlvbiBzaXplKHBhdGgsbW9kLHJhZCxhbmcpIHtcbiAgICBpZiAoIW1vZCkgdmFyIG1vZCA9IDBcbiAgICBpZiAodHlwZW9mIHJhZCAhPSBcIm51bWJlclwiKSB2YXIgcmFkID0gdW5kZWZpbmVkXG4gICAgaWYgKHR5cGVvZiBhbmcgIT0gXCJudW1iZXJcIikgdmFyIGFuZyA9IHVuZGVmaW5lZFxuICAgIHBhdGguYXR0clR3ZWVuKFwiZFwiLCBmdW5jdGlvbihkKXtcbiAgICAgIGlmIChyYWQgPT0gdW5kZWZpbmVkKSB2YXIgciA9IGQuZDNwbHVzLnIgPyBkLmQzcGx1cy5yIDogZDMubWF4KFtkLmQzcGx1cy53aWR0aCxkLmQzcGx1cy5oZWlnaHRdKVxuICAgICAgZWxzZSB2YXIgciA9IHJhZFxuICAgICAgaWYgKGFuZyA9PSB1bmRlZmluZWQpIHZhciBhID0gZC5kM3BsdXMuYVtkLmQzcGx1cy5zaGFwZVR5cGVdXG4gICAgICBlbHNlIHZhciBhID0gYW5nXG4gICAgICBpZiAoIXZhcnMuYXJjc1tkLmQzcGx1cy5zaGFwZVR5cGVdW2QuZDNwbHVzLmlkXSkge1xuICAgICAgICB2YXJzLmFyY3NbZC5kM3BsdXMuc2hhcGVUeXBlXVtkLmQzcGx1cy5pZF0gPSB7XCJyXCI6IDB9XG4gICAgICAgIHZhcnMuYXJjc1tkLmQzcGx1cy5zaGFwZVR5cGVdW2QuZDNwbHVzLmlkXS5hID0gZC5kM3BsdXMuc2hhcGVUeXBlID09IFwiZG9udXRcIiA/IE1hdGguUEkgKiAyIDogMFxuICAgICAgfVxuICAgICAgdmFyIHJhZGl1cyA9IGQzLmludGVycG9sYXRlKHZhcnMuYXJjc1tkLmQzcGx1cy5zaGFwZVR5cGVdW2QuZDNwbHVzLmlkXS5yLHIrbW9kKSxcbiAgICAgICAgICBhbmdsZSA9IGQzLmludGVycG9sYXRlKHZhcnMuYXJjc1tkLmQzcGx1cy5zaGFwZVR5cGVdW2QuZDNwbHVzLmlkXS5hLGEpXG5cbiAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhcnMuYXJjc1tkLmQzcGx1cy5zaGFwZVR5cGVdW2QuZDNwbHVzLmlkXS5yID0gcmFkaXVzKHQpXG4gICAgICAgIHZhcnMuYXJjc1tkLmQzcGx1cy5zaGFwZVR5cGVdW2QuZDNwbHVzLmlkXS5hID0gYW5nbGUodClcbiAgICAgICAgcmV0dXJuIGFyYyhkKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gQ2hlY2sgZWFjaCBkYXRhIHBvaW50IGZvciBhY3RpdmUgYW5kIHRlbXAgZGF0YVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZCl7XG5cbiAgICB2YXIgYWN0aXZlID0gdmFycy5hY3RpdmUudmFsdWUgPyBkLmQzcGx1c1t2YXJzLmFjdGl2ZS52YWx1ZV0gOiBkLmQzcGx1cy5hY3RpdmUsXG4gICAgICAgIHRlbXAgPSB2YXJzLnRlbXAudmFsdWUgPyBkLmQzcGx1c1t2YXJzLnRlbXAudmFsdWVdIDogZC5kM3BsdXMudGVtcCxcbiAgICAgICAgdG90YWwgPSB2YXJzLnRvdGFsLnZhbHVlID8gZC5kM3BsdXNbdmFycy50b3RhbC52YWx1ZV0gOiBkLmQzcGx1cy50b3RhbCxcbiAgICAgICAgZ3JvdXAgPSBkMy5zZWxlY3QodGhpcyksXG4gICAgICAgIGNvbG9yID0gZmV0Y2hDb2xvcih2YXJzLGQpXG5cbiAgICB2YXIgZmlsbF9kYXRhID0gW10sIGhhdGNoX2RhdGEgPSBbXVxuXG4gICAgaWYgKHRvdGFsICYmIHZhcnMudHlwZXNbdmFycy50eXBlLnZhbHVlXS5maWxsKSB7XG5cbiAgICAgIGlmICh0ZW1wKSB7XG4gICAgICAgIHZhciBjb3B5ID0gZDNwbHVzLnV0aWwuY29weShkKVxuICAgICAgICBjb3B5LmQzcGx1cy5zaGFwZVR5cGUgPSBcInRlbXBcIlxuICAgICAgICBmaWxsX2RhdGEucHVzaChjb3B5KVxuICAgICAgICBoYXRjaF9kYXRhID0gW1widGVtcFwiXVxuICAgICAgfVxuXG4gICAgICBpZiAoYWN0aXZlICYmIChhY3RpdmUgPCB0b3RhbCB8fCB0ZW1wKSkge1xuICAgICAgICB2YXIgY29weSA9IGQzcGx1cy51dGlsLmNvcHkoZClcbiAgICAgICAgY29weS5kM3BsdXMuc2hhcGVUeXBlID0gXCJhY3RpdmVcIlxuICAgICAgICBmaWxsX2RhdGEucHVzaChjb3B5KVxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGF0Y2hfbGluZXMobCkge1xuICAgICAgbFxuICAgICAgICAuYXR0cihcInN0cm9rZVwiLGNvbG9yKVxuICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLDEpXG4gICAgICAgIC5hdHRyKFwic2hhcGUtcmVuZGVyaW5nXCIsdmFycy5zaGFwZS5yZW5kZXJpbmcudmFsdWUpXG4gICAgfVxuXG4gICAgdmFyIHBhdHRlcm4gPSB2YXJzLmRlZnMuc2VsZWN0QWxsKFwicGF0dGVybiNkM3BsdXNfaGF0Y2hfXCIrZC5kM3BsdXMuaWQpXG4gICAgICAuZGF0YShoYXRjaF9kYXRhKVxuXG4gICAgaWYgKHZhcnMuZHJhdy50aW1pbmcpIHtcblxuICAgICAgcGF0dGVybi5zZWxlY3RBbGwoXCJyZWN0XCIpXG4gICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLGNvbG9yKVxuXG4gICAgICBwYXR0ZXJuLnNlbGVjdEFsbChcImxpbmVcIilcbiAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2VcIixjb2xvcilcblxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgcGF0dGVybi5zZWxlY3RBbGwoXCJyZWN0XCIpLnN0eWxlKFwiZmlsbFwiLGNvbG9yKVxuXG4gICAgICBwYXR0ZXJuLnNlbGVjdEFsbChcImxpbmVcIikuc3R5bGUoXCJzdHJva2VcIixjb2xvcilcblxuICAgIH1cblxuICAgIHZhciBwYXR0ZXJuX2VudGVyID0gcGF0dGVybi5lbnRlcigpLmFwcGVuZChcInBhdHRlcm5cIilcbiAgICAgIC5hdHRyKFwiaWRcIixcImQzcGx1c19oYXRjaF9cIitkLmQzcGx1cy5pZClcbiAgICAgIC5hdHRyKFwicGF0dGVyblVuaXRzXCIsXCJ1c2VyU3BhY2VPblVzZVwiKVxuICAgICAgLmF0dHIoXCJ4XCIsXCIwXCIpXG4gICAgICAuYXR0cihcInlcIixcIjBcIilcbiAgICAgIC5hdHRyKFwid2lkdGhcIixcIjEwXCIpXG4gICAgICAuYXR0cihcImhlaWdodFwiLFwiMTBcIilcbiAgICAgIC5hcHBlbmQoXCJnXCIpXG5cbiAgICBwYXR0ZXJuX2VudGVyLmFwcGVuZChcInJlY3RcIilcbiAgICAgIC5hdHRyKFwieFwiLFwiMFwiKVxuICAgICAgLmF0dHIoXCJ5XCIsXCIwXCIpXG4gICAgICAuYXR0cihcIndpZHRoXCIsXCIxMFwiKVxuICAgICAgLmF0dHIoXCJoZWlnaHRcIixcIjEwXCIpXG4gICAgICAuYXR0cihcImZpbGxcIixjb2xvcilcbiAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsMC4yNSlcblxuICAgIHBhdHRlcm5fZW50ZXIuYXBwZW5kKFwibGluZVwiKVxuICAgICAgLmF0dHIoXCJ4MVwiLFwiMFwiKVxuICAgICAgLmF0dHIoXCJ4MlwiLFwiMTBcIilcbiAgICAgIC5hdHRyKFwieTFcIixcIjBcIilcbiAgICAgIC5hdHRyKFwieTJcIixcIjEwXCIpXG4gICAgICAuY2FsbChoYXRjaF9saW5lcylcblxuICAgIHBhdHRlcm5fZW50ZXIuYXBwZW5kKFwibGluZVwiKVxuICAgICAgLmF0dHIoXCJ4MVwiLFwiLTFcIilcbiAgICAgIC5hdHRyKFwieDJcIixcIjFcIilcbiAgICAgIC5hdHRyKFwieTFcIixcIjlcIilcbiAgICAgIC5hdHRyKFwieTJcIixcIjExXCIpXG4gICAgICAuY2FsbChoYXRjaF9saW5lcylcblxuICAgIHBhdHRlcm5fZW50ZXIuYXBwZW5kKFwibGluZVwiKVxuICAgICAgLmF0dHIoXCJ4MVwiLFwiOVwiKVxuICAgICAgLmF0dHIoXCJ4MlwiLFwiMTFcIilcbiAgICAgIC5hdHRyKFwieTFcIixcIi0xXCIpXG4gICAgICAuYXR0cihcInkyXCIsXCIxXCIpXG4gICAgICAuY2FsbChoYXRjaF9saW5lcylcblxuICAgIHZhciBjbGlwX2RhdGEgPSBmaWxsX2RhdGEubGVuZ3RoID8gW2RdIDogW11cblxuICAgIHZhciBjbGlwID0gZ3JvdXAuc2VsZWN0QWxsKFwiI2QzcGx1c19jbGlwX1wiK2QuZDNwbHVzLmlkKVxuICAgICAgLmRhdGEoY2xpcF9kYXRhKVxuXG4gICAgY2xpcC5lbnRlcigpLmluc2VydChcImNsaXBQYXRoXCIsXCIuZDNwbHVzX21vdXNlXCIpXG4gICAgICAuYXR0cihcImlkXCIsXCJkM3BsdXNfY2xpcF9cIitkLmQzcGx1cy5pZClcbiAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAuYXR0cihcImNsYXNzXCIsXCJkM3BsdXNfY2xpcHBpbmdcIilcbiAgICAgIC5jYWxsKGluaXQpXG5cbiAgICBpZiAodmFycy5kcmF3LnRpbWluZykge1xuXG4gICAgICBjbGlwLnNlbGVjdEFsbChcInJlY3RcIikudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAgIC5jYWxsKHVwZGF0ZSlcblxuICAgICAgY2xpcC5leGl0KCkudHJhbnNpdGlvbigpLmRlbGF5KHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAgIC5yZW1vdmUoKVxuXG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICBjbGlwLnNlbGVjdEFsbChcInJlY3RcIikuY2FsbCh1cGRhdGUpXG5cbiAgICAgIGNsaXAuZXhpdCgpLnJlbW92ZSgpXG5cbiAgICB9XG5cbiAgICB2YXIgZmlsbHMgPSBncm91cC5zZWxlY3RBbGwoXCJwYXRoLmQzcGx1c19maWxsXCIpXG4gICAgICAuZGF0YShmaWxsX2RhdGEpXG5cbiAgICBmaWxscy50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgIC5jYWxsKGQzcGx1cy5zaGFwZS5zdHlsZSx2YXJzKVxuICAgICAgLmNhbGwoc2l6ZSlcblxuICAgIGZpbGxzLmVudGVyKCkuaW5zZXJ0KFwicGF0aFwiLFwicmVjdC5kM3BsdXNfbW91c2VcIilcbiAgICAgIC5hdHRyKFwiY2xhc3NcIixcImQzcGx1c19maWxsXCIpXG4gICAgICAuYXR0cihcImNsaXAtcGF0aFwiLFwidXJsKCNkM3BsdXNfY2xpcF9cIitkLmQzcGx1cy5pZCtcIilcIilcbiAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24oMClcbiAgICAgICAgLmNhbGwoc2l6ZSwwLHVuZGVmaW5lZCwwKVxuICAgICAgICAuY2FsbChkM3BsdXMuc2hhcGUuc3R5bGUsdmFycylcbiAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgICAgICAgIC5jYWxsKHNpemUpXG5cbiAgICBmaWxscy5leGl0KCkudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAuY2FsbChzaXplLDAsdW5kZWZpbmVkLDApXG4gICAgICAucmVtb3ZlKClcblxuICB9KVxuXG59XG4iLCJ2YXIgZmV0Y2hUZXh0ID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvZmV0Y2gvdGV4dC5qc1wiKVxuLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIERyYXdzIFwibGFiZWxzXCIgdXNpbmcgc3ZnOnRleHQgYW5kIGQzcGx1cy50ZXh0d3JhcFxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmQzcGx1cy5zaGFwZS5sYWJlbHMgPSBmdW5jdGlvbiggdmFycyAsIGdyb3VwICkge1xuXG4gIHZhciBzY2FsZSA9IHZhcnMuem9vbS5iZWhhdmlvci5zY2FsZUV4dGVudCgpXG4gICAgLCBzZWxlY3Rpb24gPSB2YXJzLmdbIGdyb3VwIF0uc2VsZWN0QWxsKFwiZ1wiKVxuXG4gIHZhciBvcGFjaXR5ID0gZnVuY3Rpb24oZWxlbSkge1xuXG4gICAgZWxlbVxuICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsZnVuY3Rpb24oZCl7XG4gICAgICAgIGlmICghZCkgdmFyIGQgPSB7XCJzY2FsZVwiOiBzY2FsZVsxXX1cbiAgICAgICAgdmFyIHNpemUgPSBwYXJzZUZsb2F0KGQzLnNlbGVjdCh0aGlzKS5hdHRyKFwiZm9udC1zaXplXCIpLDEwKVxuICAgICAgICBkLnZpc2libGUgPSBzaXplL2Quc2NhbGUqdmFycy56b29tLnNjYWxlID49IDdcbiAgICAgICAgcmV0dXJuIGQudmlzaWJsZSA/IDEgOiAwXG4gICAgICB9KVxuXG4gIH1cblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gTGFiZWwgRXhpdGluZ1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcmVtb3ZlID0gZnVuY3Rpb24odGV4dCkge1xuXG4gICAgaWYgKHZhcnMuZHJhdy50aW1pbmcpIHtcbiAgICAgIHRleHRcbiAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwwKVxuICAgICAgICAucmVtb3ZlKClcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0ZXh0LnJlbW92ZSgpXG4gICAgfVxuXG4gIH1cblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gTGFiZWwgU3R5bGluZ1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgc3R5bGUgPSBmdW5jdGlvbih0ZXh0LHdyYXApIHtcblxuICAgIGZ1bmN0aW9uIHhfcG9zKHQpIHtcblxuICAgICAgaWYgKCB0LnNoYXBlID09PSBcImNpcmNsZVwiICkge1xuICAgICAgICByZXR1cm4gXCIwcHhcIlxuICAgICAgfVxuXG4gICAgICB2YXIgYWxpZ24gPSB0LmFuY2hvciB8fCB2YXJzLmxhYmVscy5hbGlnbixcbiAgICAgICAgICB0c3BhbiA9IHRoaXMudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInRzcGFuXCIsXG4gICAgICAgICAgc2hhcmUgPSB0c3BhbiA/IHRoaXMucGFyZW50Tm9kZS5jbGFzc05hbWUuYmFzZVZhbCA9PSBcImQzcGx1c19zaGFyZVwiIDogdGhpcy5jbGFzc05hbWUuYmFzZVZhbCA9PSBcImQzcGx1c19zaGFyZVwiLFxuICAgICAgICAgIHdpZHRoID0gZDMuc2VsZWN0KHRoaXMpLm5vZGUoKS5nZXRDb21wdXRlZFRleHRMZW5ndGgoKS9zY2FsZVsxXVxuXG4gICAgICBpZiAoYWxpZ24gPT0gXCJtaWRkbGVcIiB8fCBzaGFyZSkge1xuICAgICAgICB2YXIgcG9zID0gdC54LXdpZHRoLzJcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKChhbGlnbiA9PSBcImVuZFwiICYmICFkM3BsdXMucnRsKSB8fCAoYWxpZ24gPT0gXCJzdGFydFwiICYmIGQzcGx1cy5ydGwpKSB7XG4gICAgICAgIHZhciBwb3MgPSB0LngrKHQudy10LnBhZGRpbmcpLzItd2lkdGhcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgcG9zID0gdC54LSh0LnctdC5wYWRkaW5nKS8yXG4gICAgICB9XG5cbiAgICAgIGlmICh0c3Bhbikge1xuICAgICAgICB2YXIgdF93aWR0aCA9IHRoaXMuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCkvc2NhbGVbMV1cbiAgICAgICAgaWYgKGFsaWduID09IFwibWlkZGxlXCIpIHtcbiAgICAgICAgICBpZiAoZDNwbHVzLnJ0bCkge1xuICAgICAgICAgICAgcG9zIC09ICh3aWR0aC10X3dpZHRoKS8yXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9zICs9ICh3aWR0aC10X3dpZHRoKS8yXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFsaWduID09IFwiZW5kXCIpIHtcbiAgICAgICAgICBpZiAoZDNwbHVzLnJ0bCkge1xuICAgICAgICAgICAgcG9zIC09ICh3aWR0aC10X3dpZHRoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvcyArPSAod2lkdGgtdF93aWR0aClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGQzcGx1cy5ydGwpIHtcbiAgICAgICAgcG9zICs9IHdpZHRoXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb3Mqc2NhbGVbMV1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHlfcG9zKHQpIHtcblxuICAgICAgaWYgKGQzLnNlbGVjdCh0aGlzKS5zZWxlY3QoXCJ0c3BhblwiKS5lbXB0eSgpKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9XG4gICAgICBlbHNlIHtcblxuICAgICAgICB2YXIgYWxpZ24gPSB2YXJzLmxhYmVscy5hbGlnbixcbiAgICAgICAgICAgIGhlaWdodCA9IGQzLnNlbGVjdCh0aGlzKS5ub2RlKCkuZ2V0QkJveCgpLmhlaWdodC9zY2FsZVsxXSxcbiAgICAgICAgICAgIGRpZmYgPSAocGFyc2VGbG9hdChkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJmb250LXNpemVcIiksMTApLzUpL3NjYWxlWzFdXG5cbiAgICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lLmJhc2VWYWwgPT0gXCJkM3BsdXNfc2hhcmVcIikge1xuICAgICAgICAgIHZhciBkYXRhID0gZDMuc2VsZWN0KHRoaXMucGFyZW50Tm9kZSkuZGF0dW0oKVxuICAgICAgICAgIHZhciBwaGVpZ2h0ID0gZGF0YS5kM3BsdXMuciA/IGRhdGEuZDNwbHVzLnIqMiA6IGRhdGEuZDNwbHVzLmhlaWdodFxuICAgICAgICAgIHBoZWlnaHQgPSBwaGVpZ2h0L3NjYWxlWzFdXG4gICAgICAgICAgaWYgKGFsaWduID09IFwiZW5kXCIpIHtcbiAgICAgICAgICAgIHZhciB5ID0gdC55LXBoZWlnaHQvMitkaWZmLzJcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgeSA9IHQueStwaGVpZ2h0LzItaGVpZ2h0LWRpZmYvMlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgIGlmICh0LnNoYXBlID09PSBcImNpcmNsZVwiIHx8IGFsaWduID09PSBcIm1pZGRsZVwiIHx8IHQudmFsaWduID09PSBcImNlbnRlclwiKSB7XG4gICAgICAgICAgICB2YXIgeSA9IHQueS1oZWlnaHQvMi1kaWZmLzJcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoYWxpZ24gPT0gXCJlbmRcIikge1xuICAgICAgICAgICAgdmFyIHkgPSB0LnkrKHQuaC10LnBhZGRpbmcpLzItaGVpZ2h0K2RpZmYvMlxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB5ID0gdC55LSh0LmgtdC5wYWRkaW5nKS8yLWRpZmZcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB5KnNjYWxlWzFdXG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0ZXh0XG4gICAgICAuYXR0cihcImZvbnQtd2VpZ2h0XCIsdmFycy5sYWJlbHMuZm9udC53ZWlnaHQpXG4gICAgICAuYXR0cihcImZvbnQtZmFtaWx5XCIsdmFycy5sYWJlbHMuZm9udC5mYW1pbHkudmFsdWUpXG4gICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLGZ1bmN0aW9uKHQpe1xuICAgICAgICByZXR1cm4gdC5zaGFwZSA9PT0gXCJjaXJjbGVcIiA/IFwibWlkZGxlXCIgOiBcInN0YXJ0XCJcbiAgICAgIH0pXG4gICAgICAuYXR0cihcInBvaW50ZXItZXZlbnRzXCIsZnVuY3Rpb24odCl7XG4gICAgICAgIHJldHVybiB0Lm1vdXNlID8gXCJhdXRvXCI6IFwibm9uZVwiXG4gICAgICB9KVxuICAgICAgLmF0dHIoXCJmaWxsXCIsIGZ1bmN0aW9uKHQpe1xuXG4gICAgICAgIGlmICggdC5jb2xvciApIHJldHVybiB0LmNvbG9yXG5cbiAgICAgICAgdmFyIGNvbG9yID0gZDNwbHVzLnNoYXBlLmNvbG9yKHQucGFyZW50LHZhcnMpXG4gICAgICAgICAgLCBsZWdpYmxlID0gZDNwbHVzLmNvbG9yLnRleHQoY29sb3IpXG4gICAgICAgICAgLCBvcGFjaXR5ID0gdC50ZXh0ID8gMC4xNSA6IDFcblxuICAgICAgICByZXR1cm4gZDNwbHVzLmNvbG9yLm1peCggY29sb3IgLCBsZWdpYmxlICwgMC4yICwgb3BhY2l0eSApXG5cbiAgICAgIH0pXG4gICAgICAuYXR0cihcInhcIix4X3BvcylcbiAgICAgIC5hdHRyKFwieVwiLHlfcG9zKVxuXG4gICAgaWYgKHdyYXApIHtcblxuICAgICAgdGV4dFxuICAgICAgICAuZWFjaChmdW5jdGlvbih0KXtcblxuICAgICAgICAgIGlmICh0LnJlc2l6ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICB2YXIgbWluID0gdC5yZXNpemVbMF1cbiAgICAgICAgICAgICAgLCBtYXggPSB0LnJlc2l6ZVsxXVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0LnRleHQpIHtcblxuXG4gICAgICAgICAgICBpZiAoICEodC5yZXNpemUgaW5zdGFuY2VvZiBBcnJheSkgKSB7XG4gICAgICAgICAgICAgIHZhciBzaXplID0gWyA5IC8gdC5zY2FsZSAsIDUwICogdC5zY2FsZSBdXG4gICAgICAgICAgICAgICAgLCByZXNpemUgPSB0LnJlc2l6ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBzaXplID0gdC5yZXNpemVcbiAgICAgICAgICAgICAgICAsIHJlc2l6ZSA9IHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZDNwbHVzLnRleHR3cmFwKClcbiAgICAgICAgICAgICAgLmNvbnRhaW5lciggZDMuc2VsZWN0KHRoaXMpIClcbiAgICAgICAgICAgICAgLmhlaWdodCggdC5oICogdC5zY2FsZSAtIHQucGFkZGluZyApXG4gICAgICAgICAgICAgIC5yZXNpemUoIHJlc2l6ZSApXG4gICAgICAgICAgICAgIC5zaXplKCBzaXplIClcbiAgICAgICAgICAgICAgLnRleHQoIHZhcnMuZm9ybWF0LnZhbHVlKHQudGV4dCoxMDAsXCJzaGFyZVwiKStcIiVcIiApXG4gICAgICAgICAgICAgIC53aWR0aCggdC53ICogdC5zY2FsZSAtIHQucGFkZGluZyApXG4gICAgICAgICAgICAgIC5kcmF3KClcblxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgaWYgKHZhcnMubGFiZWxzLmFsaWduICE9PSBcIm1pZGRsZVwiICYmIHQuc2hhcmUpIHtcbiAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHQuaCAtIHQuc2hhcmUgLSB0LnBhZGRpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdC5oXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggISh0LnJlc2l6ZSBpbnN0YW5jZW9mIEFycmF5KSApIHtcbiAgICAgICAgICAgICAgdmFyIHNpemUgPSBbIDkgLyB0LnNjYWxlICwgNDAgKiB0LnNjYWxlIF1cbiAgICAgICAgICAgICAgICAsIHJlc2l6ZSA9IHQucmVzaXplXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHNpemUgPSB0LnJlc2l6ZVxuICAgICAgICAgICAgICAgICwgcmVzaXplID0gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0LnNoYXBlIHx8IFwic3F1YXJlXCJcblxuICAgICAgICAgICAgZDNwbHVzLnRleHR3cmFwKClcbiAgICAgICAgICAgICAgLmNvbnRhaW5lciggZDMuc2VsZWN0KHRoaXMpIClcbiAgICAgICAgICAgICAgLmhlaWdodCggaGVpZ2h0ICogdC5zY2FsZSAtIHQucGFkZGluZyApXG4gICAgICAgICAgICAgIC5yZXNpemUoIHJlc2l6ZSApXG4gICAgICAgICAgICAgIC5zaXplKCBzaXplIClcbiAgICAgICAgICAgICAgLnNoYXBlKCBzaGFwZSApXG4gICAgICAgICAgICAgIC50ZXh0KCB0Lm5hbWVzIClcbiAgICAgICAgICAgICAgLndpZHRoKCB0LncgKiB0LnNjYWxlIC0gdC5wYWRkaW5nIClcbiAgICAgICAgICAgICAgLmRyYXcoKVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwieFwiLHhfcG9zKVxuICAgICAgICAuYXR0cihcInlcIix5X3BvcylcblxuICAgIH1cblxuICAgIHRleHRcbiAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsZnVuY3Rpb24odCl7XG4gICAgICAgIHZhciBhID0gdC5hbmdsZSB8fCAwLFxuICAgICAgICAgICAgeCA9IHQudHJhbnNsYXRlICYmIHQudHJhbnNsYXRlLnggPyB0LnRyYW5zbGF0ZS54IDogMCxcbiAgICAgICAgICAgIHkgPSB0LnRyYW5zbGF0ZSAmJiB0LnRyYW5zbGF0ZS55ID8gdC50cmFuc2xhdGUueSA6IDBcblxuICAgICAgICByZXR1cm4gXCJyb3RhdGUoXCIrYStcIixcIit4K1wiLFwiK3krXCIpc2NhbGUoXCIrMS9zY2FsZVsxXStcIilcIlxuICAgICAgfSlcbiAgICAgIC5zZWxlY3RBbGwoXCJ0c3BhblwiKVxuICAgICAgICAuYXR0cihcInhcIix4X3BvcylcblxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIExvb3AgdGhyb3VnaCBlYWNoIHNlbGVjdGlvbiBhbmQgYW5hbHl6ZSB0aGUgbGFiZWxzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBpZiAoZ3JvdXAgPT09IFwiZWRnZXNcIiB8fCB2YXJzLmxhYmVscy52YWx1ZSkge1xuXG4gICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIHtcbiAgICAgIHZhciB0aW1lclN0cmluZyA9IFwiZHJhd2luZyBcIiArIGdyb3VwICsgXCIgbGFiZWxzXCJcbiAgICAgIGQzcGx1cy5jb25zb2xlLnRpbWUoIHRpbWVyU3RyaW5nIClcbiAgICB9XG5cbiAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkKXtcblxuICAgICAgdmFyIGRpc2FibGVkID0gZC5kM3BsdXMgJiYgXCJsYWJlbFwiIGluIGQuZDNwbHVzICYmICFkLmQzcGx1cy5sYWJlbCxcbiAgICAgICAgICBzdGF0ID0gZC5kM3BsdXMgJiYgXCJzdGF0aWNcIiBpbiBkLmQzcGx1cyAmJiBkLmQzcGx1cy5zdGF0aWNcbiAgICAgICAgICBsYWJlbCA9IGQuZDNwbHVzX2xhYmVsID8gZC5kM3BsdXNfbGFiZWwgOiB2YXJzLnpvb20ubGFiZWxzID8gdmFycy56b29tLmxhYmVsc1tkLmQzcGx1cy5pZF0gOiBudWxsLFxuICAgICAgICAgIHNoYXJlID0gZC5kM3BsdXNfc2hhcmUsXG4gICAgICAgICAgbmFtZXMgPSBsYWJlbCAmJiBsYWJlbC5uYW1lcyA/IGxhYmVsLm5hbWVzIDogZmV0Y2hUZXh0KHZhcnMsZCksXG4gICAgICAgICAgZ3JvdXAgPSBsYWJlbCAmJiBcImdyb3VwXCIgaW4gbGFiZWwgPyBsYWJlbC5ncm91cCA6IGQzLnNlbGVjdCh0aGlzKSxcbiAgICAgICAgICBzaGFyZV9zaXplID0gMCxcbiAgICAgICAgICBmaWxsID0gdmFycy50eXBlc1t2YXJzLnR5cGUudmFsdWVdLmZpbGxcblxuICAgICAgaWYgKGxhYmVsKSB7XG5cbiAgICAgICAgaWYgKFtcImxpbmVcIixcImFyZWFcIl0uaW5kZXhPZih2YXJzLnNoYXBlLnZhbHVlKSA+PSAwKSB7XG4gICAgICAgICAgdmFyIGJhY2tncm91bmQgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZCAmJiBcImQzcGx1c1wiIGluIGQpIHtcbiAgICAgICAgICB2YXIgYWN0aXZlID0gdmFycy5hY3RpdmUudmFsdWUgPyBkLmQzcGx1c1t2YXJzLmFjdGl2ZS52YWx1ZV0gOiBkLmQzcGx1cy5hY3RpdmUsXG4gICAgICAgICAgICAgIHRlbXAgPSB2YXJzLnRlbXAudmFsdWUgPyBkLmQzcGx1c1t2YXJzLnRlbXAudmFsdWVdIDogZC5kM3BsdXMudGVtcCxcbiAgICAgICAgICAgICAgdG90YWwgPSB2YXJzLnRvdGFsLnZhbHVlID8gZC5kM3BsdXNbdmFycy50b3RhbC52YWx1ZV0gOiBkLmQzcGx1cy50b3RhbCxcbiAgICAgICAgICAgICAgYmFja2dyb3VuZCA9ICghdGVtcCAmJiAhYWN0aXZlKSB8fCAoYWN0aXZlID09IHRvdGFsKVxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCFkaXNhYmxlZCAmJiAoYmFja2dyb3VuZCB8fCAhZmlsbCkgJiYgIXN0YXQpIHtcblxuICAgICAgICBpZiAoc2hhcmUgJiYgZC5kM3BsdXMuc2hhcmUgJiYgdmFycy5sYWJlbHMuYWxpZ24gIT0gXCJtaWRkbGVcIikge1xuXG4gICAgICAgICAgc2hhcmUucmVzaXplID0gdmFycy5sYWJlbHMucmVzaXplLnZhbHVlID09PSBmYWxzZSA/IGZhbHNlIDpcbiAgICAgICAgICAgIHNoYXJlICYmIFwicmVzaXplXCIgaW4gc2hhcmUgPyBzaGFyZS5yZXNpemUgOiB0cnVlXG5cbiAgICAgICAgICBzaGFyZS5zY2FsZSA9IHNoYXJlLnJlc2l6ZSA/IHNjYWxlWzFdIDogc2NhbGVbMF1cblxuICAgICAgICAgIHNoYXJlLnBhZGRpbmcgPSAodmFycy5sYWJlbHMucGFkZGluZy9zaGFyZS5zY2FsZSkqMlxuXG4gICAgICAgICAgc2hhcmUudGV4dCA9IGQuZDNwbHVzLnNoYXJlXG4gICAgICAgICAgc2hhcmUucGFyZW50ID0gZFxuXG4gICAgICAgICAgdmFyIHRleHQgPSBncm91cC5zZWxlY3RBbGwoXCJ0ZXh0I2QzcGx1c19zaGFyZV9cIitkLmQzcGx1cy5pZClcbiAgICAgICAgICAgIC5kYXRhKFtzaGFyZV0sZnVuY3Rpb24odCl7XG4gICAgICAgICAgICAgIHJldHVybiB0LncrXCJcIit0LmgrXCJcIit0LnRleHRcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICBpZiAodmFycy5kcmF3LnRpbWluZykge1xuXG4gICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZy8yKVxuICAgICAgICAgICAgICAuY2FsbChzdHlsZSlcblxuICAgICAgICAgICAgdGV4dC5lbnRlcigpLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgICAgLmF0dHIoXCJpZFwiLFwiZDNwbHVzX3NoYXJlX1wiK2QuZDNwbHVzLmlkKVxuICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsXCJkM3BsdXNfc2hhcmVcIilcbiAgICAgICAgICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsMClcbiAgICAgICAgICAgICAgLmNhbGwoc3R5bGUsdHJ1ZSlcbiAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nLzIpXG4gICAgICAgICAgICAgIC5kZWxheSh2YXJzLmRyYXcudGltaW5nLzIpXG4gICAgICAgICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLDEpXG5cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsMSlcbiAgICAgICAgICAgICAgLmNhbGwoc3R5bGUpXG5cbiAgICAgICAgICAgIHRleHQuZW50ZXIoKS5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwiaWRcIixcImQzcGx1c19zaGFyZV9cIitkLmQzcGx1cy5pZClcbiAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLFwiZDNwbHVzX3NoYXJlXCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLDEpXG4gICAgICAgICAgICAgIC5jYWxsKHN0eWxlLHRydWUpXG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzaGFyZV9zaXplID0gdGV4dC5ub2RlKCkuZ2V0QkJveCgpLmhlaWdodFxuXG4gICAgICAgICAgdGV4dC5leGl0KCkuY2FsbChyZW1vdmUpXG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBncm91cC5zZWxlY3RBbGwoXCJ0ZXh0LmQzcGx1c19zaGFyZVwiKVxuICAgICAgICAgICAgLmNhbGwocmVtb3ZlKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhYmVsKSB7XG5cbiAgICAgICAgICBsYWJlbC5yZXNpemUgPSB2YXJzLmxhYmVscy5yZXNpemUudmFsdWUgPT09IGZhbHNlID8gZmFsc2UgOlxuICAgICAgICAgICAgbGFiZWwgJiYgXCJyZXNpemVcIiBpbiBsYWJlbCA/IGxhYmVsLnJlc2l6ZSA6IHRydWVcblxuICAgICAgICAgIGxhYmVsLnNjYWxlID0gbGFiZWwucmVzaXplID8gc2NhbGVbMV0gOiBzY2FsZVswXVxuXG4gICAgICAgICAgdmFyIHBhZGRpbmcgPSB0eXBlb2YgbGFiZWwucGFkZGluZyA9PT0gXCJudW1iZXJcIiA/IGxhYmVsLnBhZGRpbmcgOiB2YXJzLmxhYmVscy5wYWRkaW5nXG4gICAgICAgICAgbGFiZWwucGFkZGluZyA9IChwYWRkaW5nL2xhYmVsLnNjYWxlKSoyXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYWJlbCAmJiBsYWJlbC53KmxhYmVsLnNjYWxlLWxhYmVsLnBhZGRpbmcgPj0gMjAgJiYgbGFiZWwuaCpsYWJlbC5zY2FsZS1sYWJlbC5wYWRkaW5nID49IDEwICYmIG5hbWVzLmxlbmd0aCkge1xuXG4gICAgICAgICAgdmFyIGFuZCA9IHZhcnMuZm9ybWF0LmxvY2FsZS52YWx1ZS51aS5hbmRcbiAgICAgICAgICAgICwgbW9yZSA9IHZhcnMuZm9ybWF0LmxvY2FsZS52YWx1ZS51aS5tb3JlXG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobmFtZXNbaV0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICBuYW1lc1tpXSA9IGQzcGx1cy5zdHJpbmcubGlzdChuYW1lc1tpXSxhbmQsMyxtb3JlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxhYmVsLm5hbWVzID0gbmFtZXNcblxuICAgICAgICAgIGxhYmVsLnNoYXJlID0gc2hhcmVfc2l6ZVxuICAgICAgICAgIGxhYmVsLnBhcmVudCA9IGRcblxuICAgICAgICAgIHZhciB0ZXh0ID0gZ3JvdXAuc2VsZWN0QWxsKFwidGV4dCNkM3BsdXNfbGFiZWxfXCIrZC5kM3BsdXMuaWQpXG4gICAgICAgICAgICAuZGF0YShbbGFiZWxdLGZ1bmN0aW9uKHQpe1xuICAgICAgICAgICAgICBpZiAoIXQpIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICByZXR1cm4gdC53K1wiX1wiK3QuaCtcIl9cIit0LngrXCJfXCIrdC55K1wiX1wiK3QubmFtZXMuam9pbihcIl9cIilcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAsIGZvbnRTaXplID0gbGFiZWwucmVzaXplID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgIDogdmFycy5sYWJlbHMuZm9udC5zaXplICogbGFiZWwuc2NhbGVcblxuICAgICAgICAgIGlmICggdmFycy5kcmF3LnRpbWluZyApIHtcblxuICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcvMilcbiAgICAgICAgICAgICAgLmNhbGwoc3R5bGUpXG4gICAgICAgICAgICAgIC5jYWxsKG9wYWNpdHkpXG5cbiAgICAgICAgICAgIHRleHQuZW50ZXIoKS5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwiZm9udC1zaXplXCIsZm9udFNpemUpXG4gICAgICAgICAgICAgIC5hdHRyKFwiaWRcIixcImQzcGx1c19sYWJlbF9cIitkLmQzcGx1cy5pZClcbiAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLFwiZDNwbHVzX2xhYmVsXCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLDApXG4gICAgICAgICAgICAgIC5jYWxsKHN0eWxlLHRydWUpXG4gICAgICAgICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZy8yKVxuICAgICAgICAgICAgICAuZGVsYXkodmFycy5kcmF3LnRpbWluZy8yKVxuICAgICAgICAgICAgICAuY2FsbChvcGFjaXR5KVxuXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLDEpXG4gICAgICAgICAgICAgIC5jYWxsKHN0eWxlKVxuICAgICAgICAgICAgICAuY2FsbChvcGFjaXR5KVxuXG4gICAgICAgICAgICB0ZXh0LmVudGVyKCkuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgICAuYXR0cihcImZvbnQtc2l6ZVwiLGZvbnRTaXplKVxuICAgICAgICAgICAgICAuYXR0cihcImlkXCIsXCJkM3BsdXNfbGFiZWxfXCIrZC5kM3BsdXMuaWQpXG4gICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIixcImQzcGx1c19sYWJlbFwiKVxuICAgICAgICAgICAgICAuY2FsbChzdHlsZSx0cnVlKVxuICAgICAgICAgICAgICAuY2FsbChvcGFjaXR5KVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGV4dC5leGl0KCkuY2FsbChyZW1vdmUpXG5cbiAgICAgICAgICBpZiAodGV4dC5zaXplKCkgPT0gMCB8fCB0ZXh0Lmh0bWwoKSA9PSBcIlwiKSB7XG4gICAgICAgICAgICBkZWxldGUgZC5kM3BsdXNfbGFiZWxcbiAgICAgICAgICAgIGdyb3VwLnNlbGVjdEFsbChcInRleHQjZDNwbHVzX2xhYmVsX1wiK2QuZDNwbHVzLmlkK1wiLCByZWN0I2QzcGx1c19sYWJlbF9iZ19cIitkLmQzcGx1cy5pZClcbiAgICAgICAgICAgICAgLmNhbGwocmVtb3ZlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgaWYgKGxhYmVsLmJhY2tncm91bmQpIHtcblxuICAgICAgICAgICAgICB2YXIgYmFja2dyb3VuZF9kYXRhID0gW1wiYmFja2dyb3VuZFwiXVxuXG4gICAgICAgICAgICAgIHZhciBib3VuZHMgPSB0ZXh0Lm5vZGUoKS5nZXRCQm94KClcblxuICAgICAgICAgICAgICBib3VuZHMud2lkdGggKz0gdmFycy5sYWJlbHMucGFkZGluZypzY2FsZVswXVxuICAgICAgICAgICAgICBib3VuZHMuaGVpZ2h0ICs9IHZhcnMubGFiZWxzLnBhZGRpbmcqc2NhbGVbMF1cbiAgICAgICAgICAgICAgYm91bmRzLnggLT0gKHZhcnMubGFiZWxzLnBhZGRpbmcqc2NhbGVbMF0pLzJcbiAgICAgICAgICAgICAgYm91bmRzLnkgLT0gKHZhcnMubGFiZWxzLnBhZGRpbmcqc2NhbGVbMF0pLzJcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBiYWNrZ3JvdW5kX2RhdGEgPSBbXSxcbiAgICAgICAgICAgICAgICAgIGJvdW5kcyA9IHt9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBiZyA9IGdyb3VwLnNlbGVjdEFsbChcInJlY3QjZDNwbHVzX2xhYmVsX2JnX1wiK2QuZDNwbHVzLmlkKVxuICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShiYWNrZ3JvdW5kX2RhdGEpXG4gICAgICAgICAgICAgICwgYmdfb3BhY2l0eSA9IHR5cGVvZiBsYWJlbC5iYWNrZ3JvdW5kID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICA/IGxhYmVsLmJhY2tncm91bmQgOiAwLjZcblxuICAgICAgICAgICAgZnVuY3Rpb24gYmdfc3R5bGUoZWxlbSkge1xuXG4gICAgICAgICAgICAgIHZhciBjb2xvciA9IHZhcnMuYmFja2dyb3VuZC52YWx1ZSA9PT0gXCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCIjZmZmZmZmXCIgOiB2YXJzLmJhY2tncm91bmQudmFsdWVcbiAgICAgICAgICAgICAgICAsIGZpbGwgPSB0eXBlb2YgbGFiZWwuYmFja2dyb3VuZCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICA/IGxhYmVsLmJhY2tncm91bmQgOiBjb2xvclxuICAgICAgICAgICAgICAgICwgYSA9IGxhYmVsLmFuZ2xlIHx8IDBcbiAgICAgICAgICAgICAgICAsIHggPSBsYWJlbC50cmFuc2xhdGUgPyBib3VuZHMueCtib3VuZHMud2lkdGgvMiA6IDBcbiAgICAgICAgICAgICAgICAsIHkgPSBsYWJlbC50cmFuc2xhdGUgPyBib3VuZHMueStib3VuZHMuaGVpZ2h0LzIgOiAwXG4gICAgICAgICAgICAgICAgLCB0cmFuc2Zvcm0gPSBcInNjYWxlKFwiKzEvc2NhbGVbMV0rXCIpcm90YXRlKFwiK2ErXCIsXCIreCtcIixcIit5K1wiKVwiXG5cbiAgICAgICAgICAgICAgZWxlbVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLGZpbGwpXG4gICAgICAgICAgICAgICAgLmF0dHIoYm91bmRzKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsdHJhbnNmb3JtKVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YXJzLmRyYXcudGltaW5nKSB7XG5cbiAgICAgICAgICAgICAgYmcuZXhpdCgpLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLDApXG4gICAgICAgICAgICAgICAgLnJlbW92ZSgpXG5cbiAgICAgICAgICAgICAgYmcudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsYmdfb3BhY2l0eSlcbiAgICAgICAgICAgICAgICAuY2FsbChiZ19zdHlsZSlcblxuICAgICAgICAgICAgICBiZy5lbnRlcigpLmluc2VydChcInJlY3RcIixcIi5kM3BsdXNfbGFiZWxcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImlkXCIsXCJkM3BsdXNfbGFiZWxfYmdfXCIrZC5kM3BsdXMuaWQpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLFwiZDNwbHVzX2xhYmVsX2JnXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsMClcbiAgICAgICAgICAgICAgICAuY2FsbChiZ19zdHlsZSlcbiAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAgICAgICAgICAgICAuYXR0cihcIm9wYWNpdHlcIixiZ19vcGFjaXR5KVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICBiZy5leGl0KCkucmVtb3ZlKClcblxuICAgICAgICAgICAgICBiZy5lbnRlcigpLmluc2VydChcInJlY3RcIixcIi5kM3BsdXNfbGFiZWxcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImlkXCIsXCJkM3BsdXNfbGFiZWxfYmdfXCIrZC5kM3BsdXMuaWQpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLFwiZDNwbHVzX2xhYmVsX2JnXCIpXG5cbiAgICAgICAgICAgICAgYmcuYXR0cihcIm9wYWNpdHlcIixiZ19vcGFjaXR5KVxuICAgICAgICAgICAgICAgIC5jYWxsKGJnX3N0eWxlKVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZC5kM3BsdXNfbGFiZWxcbiAgICAgICAgICBncm91cC5zZWxlY3RBbGwoXCJ0ZXh0I2QzcGx1c19sYWJlbF9cIitkLmQzcGx1cy5pZCtcIiwgcmVjdCNkM3BsdXNfbGFiZWxfYmdfXCIrZC5kM3BsdXMuaWQpXG4gICAgICAgICAgICAuY2FsbChyZW1vdmUpXG4gICAgICAgIH1cblxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBkLmQzcGx1c19sYWJlbFxuICAgICAgICBncm91cC5zZWxlY3RBbGwoXCJ0ZXh0I2QzcGx1c19sYWJlbF9cIitkLmQzcGx1cy5pZCtcIiwgcmVjdCNkM3BsdXNfbGFiZWxfYmdfXCIrZC5kM3BsdXMuaWQpXG4gICAgICAgICAgLmNhbGwocmVtb3ZlKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZUVuZCggdGltZXJTdHJpbmcgKVxuXG4gIH1cbiAgZWxzZSB7XG5cbiAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkge1xuICAgICAgdmFyIHRpbWVyU3RyaW5nID0gXCJyZW1vdmluZyBcIiArIGdyb3VwICsgXCIgbGFiZWxzXCJcbiAgICAgIGQzcGx1cy5jb25zb2xlLnRpbWUoIHRpbWVyU3RyaW5nIClcbiAgICB9XG5cbiAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKFwidGV4dC5kM3BsdXNfbGFiZWwsIHJlY3QuZDNwbHVzX2xhYmVsX2JnXCIpXG4gICAgICAuY2FsbChyZW1vdmUpXG5cbiAgICB2YXJzLmcubGFiZWxzLnNlbGVjdEFsbChcInRleHQuZDNwbHVzX2xhYmVsLCByZWN0LmQzcGx1c19sYWJlbF9iZ1wiKVxuICAgICAgLmNhbGwocmVtb3ZlKVxuXG4gICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWVFbmQoIHRpbWVyU3RyaW5nIClcblxuICB9XG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gRHJhd3MgXCJsaW5lXCIgc2hhcGVzIHVzaW5nIHN2ZzpsaW5lXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZDNwbHVzLnNoYXBlLmxpbmUgPSBmdW5jdGlvbih2YXJzLHNlbGVjdGlvbixlbnRlcixleGl0KSB7XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIFRoZSBEMyBsaW5lIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGF0IHZhcmlhYmxlcyB0byB1c2UgZm9yIHggYW5kIHlcbiAgLy8gcG9zaXRpb25pbmcsIGFzIHdlbGwgYXMgbGluZSBpbnRlcnBvbGF0aW9uIGRlZmluZWQgYnkgdGhlIHVzZXIuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXIgbGluZSA9IGQzLnN2Zy5saW5lKClcbiAgICAueChmdW5jdGlvbihkKXsgcmV0dXJuIGQuZDNwbHVzLng7IH0pXG4gICAgLnkoZnVuY3Rpb24oZCl7IHJldHVybiBkLmQzcGx1cy55OyB9KVxuICAgIC5pbnRlcnBvbGF0ZSh2YXJzLnNoYXBlLmludGVycG9sYXRlLnZhbHVlKVxuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBEaXZpZGUgZWFjaCBsaW5lIGludG8gaXQncyBzZWdtZW50cy4gV2UgZG8gdGhpcyBzbyB0aGF0IHRoZXJlIGNhbiBiZSBnYXBzXG4gIC8vIGluIHRoZSBsaW5lIGFuZCBtb3VzZW92ZXIuXG4gIC8vXG4gIC8vIFRoZW4sIGNyZWF0ZSBuZXcgZGF0YSBncm91cCBmcm9tIHZhbHVlcyB0byBiZWNvbWUgc21hbGwgbm9kZXMgYXQgZWFjaFxuICAvLyBwb2ludCBvbiB0aGUgbGluZS5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIGhpdGFyZWEgPSB2YXJzLmRhdGEuc3Ryb2tlLndpZHRoXG4gIGlmIChoaXRhcmVhIDwgMzApIHtcbiAgICBoaXRhcmVhID0gMzBcbiAgfVxuXG4gIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGQpe1xuXG4gICAgdmFyIHN0ZXAgPSBmYWxzZSxcbiAgICAgICAgc2VnbWVudHMgPSBbXSxcbiAgICAgICAgbm9kZXMgPSBbXSxcbiAgICAgICAgdGVtcCA9IGQzcGx1cy51dGlsLmNvcHkoZCksXG4gICAgICAgIGdyb3VwID0gZDMuc2VsZWN0KHRoaXMpXG5cbiAgICB0ZW1wLnZhbHVlcyA9IFtdXG4gICAgZC52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbih2LGksYXJyKXtcblxuICAgICAgbm9kZXMucHVzaCh2KVxuXG4gICAgICB2YXIgayA9IHZbdmFyc1t2YXJzLmNvbnRpbnVvdXNfYXhpc10udmFsdWVdLFxuICAgICAgICAgIGluZGV4ID0gdmFycy50aWNrVmFsdWVzW3ZhcnMuY29udGludW91c19heGlzXS5pbmRleE9mKGspXG5cbiAgICAgIGlmIChzdGVwID09PSBmYWxzZSkge1xuICAgICAgICBzdGVwID0gaW5kZXhcbiAgICAgIH1cblxuICAgICAgaWYgKCBpICsgc3RlcCA9PT0gaW5kZXggKSB7XG4gICAgICAgIHRlbXAudmFsdWVzLnB1c2godilcbiAgICAgICAgdGVtcC5rZXkgKz0gXCJfXCIrc2VnbWVudHMubGVuZ3RoXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgc2VnbWVudHMucHVzaCh0ZW1wKVxuICAgICAgICAgIHRlbXAgPSBkM3BsdXMudXRpbC5jb3B5KGQpXG4gICAgICAgICAgdGVtcC52YWx1ZXMgPSBbXVxuICAgICAgICB9XG4gICAgICAgIHRlbXAudmFsdWVzLnB1c2godilcbiAgICAgICAgdGVtcC5rZXkgKz0gXCJfXCIrc2VnbWVudHMubGVuZ3RoXG4gICAgICAgIHN0ZXArK1xuICAgICAgfVxuXG4gICAgICBpZiAoIGkgPT09IGFyci5sZW5ndGggLSAxICkge1xuICAgICAgICBzZWdtZW50cy5wdXNoKHRlbXApXG4gICAgICB9XG5cbiAgICB9KVxuXG4gICAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAgIC8vIEJpbmQgc2VnbWVudCBkYXRhIHRvIFwicGF0aHNcIlxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgcGF0aHMgPSBncm91cC5zZWxlY3RBbGwoXCJwYXRoLmQzcGx1c19saW5lXCIpXG4gICAgICAuZGF0YShzZWdtZW50cywgZnVuY3Rpb24oZCl7XG4gICAgICAgIHJldHVybiBkLmtleVxuICAgICAgfSlcblxuICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAvLyBCaW5kIG5vZGUgZGF0YSB0byBcInJlY3RzXCJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIHJlY3RzID0gZ3JvdXAuc2VsZWN0QWxsKFwicmVjdC5kM3BsdXNfYW5jaG9yXCIpXG4gICAgICAuZGF0YShub2RlcywgZnVuY3Rpb24oZCl7XG4gICAgICAgIHJldHVybiBkLmQzcGx1cy5pZFxuICAgICAgfSlcblxuICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAvLyBcInBhdGhzXCIgYW5kIFwicmVjdHNcIiBFbnRlci9VcGRhdGVcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgaWYgKHZhcnMuZHJhdy50aW1pbmcpIHtcblxuICAgICAgcGF0aHMudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAgIC5hdHRyKFwiZFwiLGZ1bmN0aW9uKGQpeyByZXR1cm4gbGluZShkLnZhbHVlcykgfSlcbiAgICAgICAgLmNhbGwoZDNwbHVzLnNoYXBlLnN0eWxlLHZhcnMpXG5cbiAgICAgIHBhdGhzLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsXCJkM3BsdXNfbGluZVwiKVxuICAgICAgICAuYXR0cihcImRcIixmdW5jdGlvbihkKXsgcmV0dXJuIGxpbmUoZC52YWx1ZXMpIH0pXG4gICAgICAgIC5jYWxsKGQzcGx1cy5zaGFwZS5zdHlsZSx2YXJzKVxuXG4gICAgICByZWN0cy5lbnRlcigpLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLFwiZDNwbHVzX2FuY2hvclwiKVxuICAgICAgICAuYXR0cihcImlkXCIsZnVuY3Rpb24oZCl7XG4gICAgICAgICAgcmV0dXJuIGQuZDNwbHVzLmlkXG4gICAgICAgIH0pXG4gICAgICAgIC5jYWxsKGluaXQpXG4gICAgICAgIC5jYWxsKGQzcGx1cy5zaGFwZS5zdHlsZSx2YXJzKVxuXG4gICAgICByZWN0cy50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgICAgLmNhbGwodXBkYXRlKVxuICAgICAgICAuY2FsbChkM3BsdXMuc2hhcGUuc3R5bGUsdmFycylcblxuICAgICAgcmVjdHMuZXhpdCgpLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgICAgICAuY2FsbChpbml0KVxuICAgICAgICAucmVtb3ZlKClcblxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgcGF0aHMuZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIixcImQzcGx1c19saW5lXCIpXG5cbiAgICAgIHBhdGhzXG4gICAgICAgIC5hdHRyKFwiZFwiLGZ1bmN0aW9uKGQpeyByZXR1cm4gbGluZShkLnZhbHVlcykgfSlcbiAgICAgICAgLmNhbGwoZDNwbHVzLnNoYXBlLnN0eWxlLHZhcnMpXG5cbiAgICAgIHJlY3RzLmVudGVyKCkuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsXCJkM3BsdXNfYW5jaG9yXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIixmdW5jdGlvbihkKXtcbiAgICAgICAgICByZXR1cm4gZC5kM3BsdXMuaWRcbiAgICAgICAgfSlcblxuICAgICAgcmVjdHMuY2FsbCh1cGRhdGUpXG4gICAgICAgIC5jYWxsKGQzcGx1cy5zaGFwZS5zdHlsZSx2YXJzKVxuXG4gICAgfVxuXG4gICAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAgIC8vIENyZWF0ZSBtb3VzZSBldmVudCBsaW5lc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgbW91c2UgPSBncm91cC5zZWxlY3RBbGwoXCJwYXRoLmQzcGx1c19tb3VzZVwiKVxuICAgICAgLmRhdGEoc2VnbWVudHMsIGZ1bmN0aW9uKGQpe1xuICAgICAgICByZXR1cm4gZC5rZXlcbiAgICAgIH0pXG5cbiAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgLy8gTW91c2UgXCJwYXRoc1wiIEVudGVyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIG1vdXNlLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgLmF0dHIoXCJjbGFzc1wiLFwiZDNwbHVzX21vdXNlXCIpXG4gICAgICAuYXR0cihcImRcIixmdW5jdGlvbihsKXsgcmV0dXJuIGxpbmUobC52YWx1ZXMpIH0pXG4gICAgICAuc3R5bGUoXCJzdHJva2VcIixcImJsYWNrXCIpXG4gICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIixoaXRhcmVhKVxuICAgICAgLnN0eWxlKFwiZmlsbFwiLFwibm9uZVwiKVxuICAgICAgLnN0eWxlKFwic3Ryb2tlLWxpbmVjYXBcIixcInJvdW5kXCIpXG4gICAgICAuYXR0cihcIm9wYWNpdHlcIiwwKVxuXG4gICAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAgIC8vIE1vdXNlIFwicGF0aHNcIiBVcGRhdGVcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgbW91c2VcbiAgICAgIC5vbihkM3BsdXMuZXZ0Lm92ZXIsZnVuY3Rpb24obSl7XG5cbiAgICAgICAgaWYgKCF2YXJzLmRyYXcuZnJvemVuKSB7XG5cbiAgICAgICAgICBkMy5zZWxlY3QodGhpcy5wYXJlbnROb2RlKS5zZWxlY3RBbGwoXCJwYXRoLmQzcGx1c19saW5lXCIpXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMudGltaW5nLm1vdXNlZXZlbnRzKVxuICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsdmFycy5kYXRhLnN0cm9rZS53aWR0aCoyKVxuXG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMucGFyZW50Tm9kZSkuc2VsZWN0QWxsKFwicmVjdFwiKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLnRpbWluZy5tb3VzZWV2ZW50cylcbiAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLHZhcnMuZGF0YS5zdHJva2Uud2lkdGgqMilcbiAgICAgICAgICAgIC5jYWxsKHVwZGF0ZSwyKVxuXG4gICAgICAgIH1cblxuICAgICAgfSlcbiAgICAgIC5vbihkM3BsdXMuZXZ0Lm91dCxmdW5jdGlvbihkKXtcblxuICAgICAgICBpZiAoIXZhcnMuZHJhdy5mcm96ZW4pIHtcblxuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzLnBhcmVudE5vZGUpLnNlbGVjdEFsbChcInBhdGguZDNwbHVzX2xpbmVcIilcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy50aW1pbmcubW91c2VldmVudHMpXG4gICAgICAgICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIix2YXJzLmRhdGEuc3Ryb2tlLndpZHRoKVxuXG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMucGFyZW50Tm9kZSkuc2VsZWN0QWxsKFwicmVjdFwiKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLnRpbWluZy5tb3VzZWV2ZW50cylcbiAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLHZhcnMuZGF0YS5zdHJva2Uud2lkdGgpXG4gICAgICAgICAgICAuY2FsbCh1cGRhdGUpXG5cbiAgICAgICAgfVxuXG4gICAgICB9KVxuXG4gICAgaWYgKHZhcnMuZHJhdy50aW1pbmcpIHtcblxuICAgICAgbW91c2UudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAgIC5hdHRyKFwiZFwiLGZ1bmN0aW9uKGwpeyByZXR1cm4gbGluZShsLnZhbHVlcykgfSlcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsaGl0YXJlYSlcblxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgbW91c2UuYXR0cihcImRcIixmdW5jdGlvbihsKXsgcmV0dXJuIGxpbmUobC52YWx1ZXMpIH0pXG4gICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLGhpdGFyZWEpXG5cbiAgICB9XG5cbiAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgLy8gTW91c2UgXCJwYXRoc1wiIEV4aXRcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgbW91c2UuZXhpdCgpLnJlbW92ZSgpXG5cbiAgfSlcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gVGhlIHBvc2l0aW9uIGFuZCBzaXplIG9mIGVhY2ggYW5jaG9yIHBvaW50IG9uIGVudGVyIGFuZCBleGl0LlxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgZnVuY3Rpb24gaW5pdChuKSB7XG5cbiAgICBuXG4gICAgICAuYXR0cihcInhcIixmdW5jdGlvbihkKXtcbiAgICAgICAgcmV0dXJuIGQuZDNwbHVzLnhcbiAgICAgIH0pXG4gICAgICAuYXR0cihcInlcIixmdW5jdGlvbihkKXtcbiAgICAgICAgcmV0dXJuIGQuZDNwbHVzLnlcbiAgICAgIH0pXG4gICAgICAuYXR0cihcIndpZHRoXCIsMClcbiAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsMClcblxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIFRoZSBwb3NpdGlvbiBhbmQgc2l6ZSBvZiBlYWNoIGFuY2hvciBwb2ludCBvbiB1cGRhdGUuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBmdW5jdGlvbiB1cGRhdGUobixtb2QpIHtcblxuICAgIGlmICghbW9kKSB2YXIgbW9kID0gMFxuXG4gICAgblxuICAgICAgLmF0dHIoXCJ4XCIsZnVuY3Rpb24oZCl7XG4gICAgICAgIHZhciB3ID0gZC5kM3BsdXMuciA/IGQuZDNwbHVzLnIqMiA6IGQuZDNwbHVzLndpZHRoXG4gICAgICAgIHJldHVybiBkLmQzcGx1cy54IC0gKCh3LzIpKyhtb2QvMikpXG4gICAgICB9KVxuICAgICAgLmF0dHIoXCJ5XCIsZnVuY3Rpb24oZCl7XG4gICAgICAgIHZhciBoID0gZC5kM3BsdXMuciA/IGQuZDNwbHVzLnIqMiA6IGQuZDNwbHVzLmhlaWdodFxuICAgICAgICByZXR1cm4gZC5kM3BsdXMueSAtICgoaC8yKSsobW9kLzIpKVxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwid2lkdGhcIixmdW5jdGlvbihkKXtcbiAgICAgICAgdmFyIHcgPSBkLmQzcGx1cy5yID8gZC5kM3BsdXMucioyIDogZC5kM3BsdXMud2lkdGhcbiAgICAgICAgcmV0dXJuIHcrbW9kXG4gICAgICB9KVxuICAgICAgLmF0dHIoXCJoZWlnaHRcIixmdW5jdGlvbihkKXtcbiAgICAgICAgdmFyIGggPSBkLmQzcGx1cy5yID8gZC5kM3BsdXMucioyIDogZC5kM3BsdXMuaGVpZ2h0XG4gICAgICAgIHJldHVybiBoK21vZFxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwicnhcIixmdW5jdGlvbihkKXtcbiAgICAgICAgdmFyIHcgPSBkLmQzcGx1cy5yID8gZC5kM3BsdXMucioyIDogZC5kM3BsdXMud2lkdGhcbiAgICAgICAgcmV0dXJuICh3K21vZCkvMlxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwicnlcIixmdW5jdGlvbihkKXtcbiAgICAgICAgdmFyIGggPSBkLmQzcGx1cy5yID8gZC5kM3BsdXMucioyIDogZC5kM3BsdXMuaGVpZ2h0XG4gICAgICAgIHJldHVybiAoaCttb2QpLzJcbiAgICAgIH0pXG5cbiAgfVxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gRHJhd3MgXCJzcXVhcmVcIiBhbmQgXCJjaXJjbGVcIiBzaGFwZXMgdXNpbmcgc3ZnOnJlY3Rcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kM3BsdXMuc2hhcGUucmVjdCA9IGZ1bmN0aW9uKHZhcnMsc2VsZWN0aW9uLGVudGVyLGV4aXQpIHtcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gQ2FsY3VsYXRlIGxhYmVsIHBvc2l0aW9uIGFuZCBwYXNzIGRhdGEgZnJvbSBwYXJlbnQuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBmdW5jdGlvbiBkYXRhKGQpIHtcblxuICAgIGlmICh2YXJzLmxhYmVscy52YWx1ZSAmJiAhZC5kM3BsdXMubGFiZWwpIHtcblxuICAgICAgZC5kM3BsdXNfbGFiZWwgPSB7XG4gICAgICAgIFwid1wiOiAwLFxuICAgICAgICBcImhcIjogMCxcbiAgICAgICAgXCJ4XCI6IDAsXG4gICAgICAgIFwieVwiOiAwXG4gICAgICB9XG5cbiAgICAgIHZhciB3ID0gZC5kM3BsdXMuciA/IGQuZDNwbHVzLnIqMiA6IGQuZDNwbHVzLndpZHRoLFxuICAgICAgICAgIGggPSBkLmQzcGx1cy5yID8gZC5kM3BsdXMucioyIDogZC5kM3BsdXMuaGVpZ2h0XG5cbiAgICAgIGQuZDNwbHVzX3NoYXJlID0ge1xuICAgICAgICBcIndcIjogdyxcbiAgICAgICAgXCJoXCI6IGQzLm1heChbMjUsaC8zXSksXG4gICAgICAgIFwieFwiOiAwLFxuICAgICAgICBcInlcIjogMFxuICAgICAgfVxuXG4gICAgICBkLmQzcGx1c19sYWJlbC53ID0gd1xuICAgICAgZC5kM3BsdXNfbGFiZWwuaCA9IGhcblxuICAgICAgZC5kM3BsdXNfbGFiZWwuc2hhcGUgPSB2YXJzLnNoYXBlLnZhbHVlID09PSBcImNpcmNsZVwiID8gXCJjaXJjbGVcIiA6IFwic3F1YXJlXCJcblxuICAgIH1cbiAgICBlbHNlIGlmIChkLmQzcGx1cy5sYWJlbCkge1xuICAgICAgZC5kM3BsdXNfbGFiZWwgPSBkLmQzcGx1cy5sYWJlbFxuICAgIH1cblxuICAgIHJldHVybiBbZF07XG5cbiAgfVxuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBUaGUgcG9zaXRpb24gYW5kIHNpemUgb2YgZWFjaCByZWN0YW5nbGUgb24gZW50ZXIgYW5kIGV4aXQuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBmdW5jdGlvbiBpbml0KG5vZGVzKSB7XG5cbiAgICBub2Rlc1xuICAgICAgLmF0dHIoXCJ4XCIsMClcbiAgICAgIC5hdHRyKFwieVwiLDApXG4gICAgICAuYXR0cihcIndpZHRoXCIsMClcbiAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsMClcblxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIFRoZSBwb3NpdGlvbiBhbmQgc2l6ZSBvZiBlYWNoIHJlY3RhbmdsZSBvbiB1cGRhdGUuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBmdW5jdGlvbiB1cGRhdGUobm9kZXMpIHtcblxuICAgIG5vZGVzXG4gICAgICAuYXR0cihcInhcIixmdW5jdGlvbihkKXtcbiAgICAgICAgdmFyIHcgPSBkLmQzcGx1cy5yID8gZC5kM3BsdXMucioyIDogZC5kM3BsdXMud2lkdGhcbiAgICAgICAgcmV0dXJuIC13LzJcbiAgICAgIH0pXG4gICAgICAuYXR0cihcInlcIixmdW5jdGlvbihkKXtcbiAgICAgICAgdmFyIGggPSBkLmQzcGx1cy5yID8gZC5kM3BsdXMucioyIDogZC5kM3BsdXMuaGVpZ2h0XG4gICAgICAgIHJldHVybiAtaC8yXG4gICAgICB9KVxuICAgICAgLmF0dHIoXCJ3aWR0aFwiLGZ1bmN0aW9uKGQpe1xuICAgICAgICB2YXIgdyA9IGQuZDNwbHVzLnIgPyBkLmQzcGx1cy5yKjIgOiBkLmQzcGx1cy53aWR0aFxuICAgICAgICByZXR1cm4gd1xuICAgICAgfSlcbiAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsZnVuY3Rpb24oZCl7XG4gICAgICAgIHZhciBoID0gZC5kM3BsdXMuciA/IGQuZDNwbHVzLnIqMiA6IGQuZDNwbHVzLmhlaWdodFxuICAgICAgICByZXR1cm4gaFxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwicnhcIixmdW5jdGlvbihkKXtcbiAgICAgICAgdmFyIHJvdW5kZWQgPSB2YXJzLnNoYXBlLnZhbHVlID09IFwiY2lyY2xlXCJcbiAgICAgICAgdmFyIHcgPSBkLmQzcGx1cy5yID8gZC5kM3BsdXMucioyIDogZC5kM3BsdXMud2lkdGhcbiAgICAgICAgcmV0dXJuIHJvdW5kZWQgPyAodysyKS8yIDogMFxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwicnlcIixmdW5jdGlvbihkKXtcbiAgICAgICAgdmFyIHJvdW5kZWQgPSB2YXJzLnNoYXBlLnZhbHVlID09IFwiY2lyY2xlXCJcbiAgICAgICAgdmFyIGggPSBkLmQzcGx1cy5yID8gZC5kM3BsdXMucioyIDogZC5kM3BsdXMuaGVpZ2h0XG4gICAgICAgIHJldHVybiByb3VuZGVkID8gKGgrMikvMiA6IDBcbiAgICAgIH0pXG4gICAgICAuYXR0cihcInRyYW5zZm9ybVwiLGZ1bmN0aW9uKGQpe1xuICAgICAgICBpZiAoXCJyb3RhdGVcIiBpbiBkLmQzcGx1cykge1xuICAgICAgICAgIHJldHVybiBcInJvdGF0ZShcIitkLmQzcGx1cy5yb3RhdGUrXCIpXCJcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIlxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwic2hhcGUtcmVuZGVyaW5nXCIsZnVuY3Rpb24oZCl7XG4gICAgICAgIGlmICh2YXJzLnNoYXBlLnZhbHVlID09IFwic3F1YXJlXCIgJiYgIShcInJvdGF0ZVwiIGluIGQuZDNwbHVzKSkge1xuICAgICAgICAgIHJldHVybiB2YXJzLnNoYXBlLnJlbmRlcmluZy52YWx1ZVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBcImF1dG9cIlxuICAgICAgICB9XG4gICAgICB9KVxuXG4gIH1cblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gXCJyZWN0c1wiIEVudGVyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBpZiAodmFycy5kcmF3LnRpbWluZykge1xuICAgIGVudGVyLmFwcGVuZChcInJlY3RcIilcbiAgICAgIC5hdHRyKFwiY2xhc3NcIixcImQzcGx1c19kYXRhXCIpXG4gICAgICAuY2FsbChpbml0KVxuICAgICAgLmNhbGwoZDNwbHVzLnNoYXBlLnN0eWxlLHZhcnMpXG4gIH1cbiAgZWxzZSB7XG4gICAgZW50ZXIuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgLmF0dHIoXCJjbGFzc1wiLFwiZDNwbHVzX2RhdGFcIilcbiAgfVxuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBcInJlY3RzXCIgVXBkYXRlXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBpZiAodmFycy5kcmF3LnRpbWluZykge1xuICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoXCJyZWN0LmQzcGx1c19kYXRhXCIpXG4gICAgICAuZGF0YShkYXRhKVxuICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgICAgICAuY2FsbCh1cGRhdGUpXG4gICAgICAgIC5jYWxsKGQzcGx1cy5zaGFwZS5zdHlsZSx2YXJzKVxuICB9XG4gIGVsc2Uge1xuICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoXCJyZWN0LmQzcGx1c19kYXRhXCIpXG4gICAgICAuZGF0YShkYXRhKVxuICAgICAgLmNhbGwodXBkYXRlKVxuICAgICAgLmNhbGwoZDNwbHVzLnNoYXBlLnN0eWxlLHZhcnMpXG4gIH1cblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gXCJyZWN0c1wiIEV4aXRcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGlmICh2YXJzLmRyYXcudGltaW5nKSB7XG4gICAgZXhpdC5zZWxlY3RBbGwoXCJyZWN0LmQzcGx1c19kYXRhXCIpXG4gICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAuY2FsbChpbml0KVxuICB9XG5cbn1cbiIsIi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gRmlsbCBzdHlsZSBmb3IgYWxsIHNoYXBlc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kM3BsdXMuc2hhcGUuc3R5bGUgPSBmdW5jdGlvbihub2Rlcyx2YXJzKSB7XG5cbiAgbm9kZXNcbiAgICAuYXR0cihcImZpbGxcIixmdW5jdGlvbihkKXtcblxuICAgICAgaWYgKGQuZDNwbHVzICYmIGQuZDNwbHVzLnNwbGluZSkge1xuICAgICAgICByZXR1cm4gXCJub25lXCJcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZDNwbHVzLnNoYXBlLmNvbG9yKGQsdmFycylcbiAgICAgIH1cblxuICAgIH0pXG4gICAgLnN0eWxlKFwic3Ryb2tlXCIsIGZ1bmN0aW9uKGQpe1xuICAgICAgaWYgKGQudmFsdWVzKSB7XG4gICAgICAgIHZhciBjb2xvciA9IGQzcGx1cy5zaGFwZS5jb2xvcihkLnZhbHVlc1swXSx2YXJzKVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBjb2xvciA9IGQzcGx1cy5zaGFwZS5jb2xvcihkLHZhcnMpXG4gICAgICB9XG4gICAgICByZXR1cm4gZDMucmdiKGNvbG9yKS5kYXJrZXIoMC41KVxuICAgIH0pXG4gICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsdmFycy5kYXRhLnN0cm9rZS53aWR0aClcbiAgICAuYXR0cihcIm9wYWNpdHlcIix2YXJzLmRhdGEub3BhY2l0eSlcbiAgICAuYXR0cihcInZlY3Rvci1lZmZlY3RcIixcIm5vbi1zY2FsaW5nLXN0cm9rZVwiKVxuXG59XG4iLCJ2YXIgZmV0Y2hWYWx1ZSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL2ZldGNoL3ZhbHVlLmpzXCIpLFxuICAgIGZldGNoQ29sb3IgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9mZXRjaC9jb2xvci5qc1wiKSxcbiAgICBmZXRjaFRleHQgID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvZmV0Y2gvdGV4dC5qc1wiKVxuLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIEJ1YmJsZXNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgYnViYmxlcyA9IGZ1bmN0aW9uKHZhcnMpIHtcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gVGVzdCBmb3IgbGFiZWxzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXIgbGFiZWxfaGVpZ2h0ID0gdmFycy5sYWJlbHMudmFsdWUgJiYgIXZhcnMuc21hbGwgPyA1MCA6IDBcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gU29ydCBEYXRhXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBkM3BsdXMuYXJyYXkuc29ydCggdmFycy5kYXRhLmFwcCAsIHZhcnMub3JkZXIudmFsdWUgfHwgdmFycy5zaXplLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgLCB2YXJzLm9yZGVyLnNvcnQudmFsdWUgLCB2YXJzLmNvbG9yLnZhbHVlICwgdmFycyApXG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIENhbGN1bGF0ZSByb3dzIGFuZCBjb2x1bW5zXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXIgZGF0YUxlbmd0aCA9IHZhcnMuZGF0YS5hcHAubGVuZ3RoXG5cbiAgaWYgKGRhdGFMZW5ndGggPCA0KSB7XG5cbiAgICB2YXIgY29sdW1ucyA9IGRhdGFMZW5ndGhcbiAgICAgICwgcm93cyAgICA9IDFcbiAgfVxuICBlbHNlIHtcblxuICAgIHZhciBzY3JlZW5SYXRpbyA9IHZhcnMud2lkdGgudml6IC8gdmFycy5oZWlnaHQudml6XG4gICAgICAsIGNvbHVtbnMgICAgID0gTWF0aC5jZWlsKCBNYXRoLnNxcnQoIGRhdGFMZW5ndGggKiBzY3JlZW5SYXRpbyApIClcbiAgICAgICwgcm93cyAgICAgICAgPSBNYXRoLmNlaWwoIE1hdGguc3FydCggZGF0YUxlbmd0aCAvIHNjcmVlblJhdGlvICkgKVxuXG4gIH1cblxuICBpZiAoZGF0YUxlbmd0aCA+IDApIHtcblxuICAgIHdoaWxlICgocm93cy0xKSpjb2x1bW5zID49IHZhcnMuZGF0YS5hcHAubGVuZ3RoKSB7XG4gICAgICByb3dzLS1cbiAgICB9XG5cbiAgfVxuXG4gIHZhciBjb2x1bW5fd2lkdGggPSB2YXJzLndpZHRoLnZpei9jb2x1bW5zLFxuICAgICAgY29sdW1uX2hlaWdodCA9IHZhcnMuaGVpZ2h0LnZpei9yb3dzXG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIERlZmluZSBzaXplIHNjYWxlXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXIgZG9tYWluX21pbiA9IGQzLm1pbih2YXJzLmRhdGEuYXBwLCBmdW5jdGlvbihkKXtcbiAgICBpZiAoIXZhcnMuc2l6ZS52YWx1ZSkgcmV0dXJuIDBcbiAgICByZXR1cm4gZmV0Y2hWYWx1ZSh2YXJzLGQsdmFycy5zaXplLnZhbHVlLG51bGwsXCJtaW5cIilcbiAgfSlcblxuICB2YXIgZG9tYWluX21heCA9IGQzLm1heCh2YXJzLmRhdGEuYXBwLCBmdW5jdGlvbihkKXtcbiAgICBpZiAoIXZhcnMuc2l6ZS52YWx1ZSkgcmV0dXJuIDBcbiAgICByZXR1cm4gZmV0Y2hWYWx1ZSh2YXJzLGQsdmFycy5zaXplLnZhbHVlKVxuICB9KVxuXG4gIHZhciBwYWRkaW5nID0gNVxuXG4gIHZhciBzaXplX21pbiA9IDIwXG4gIHZhciBzaXplX21heCA9IChkMy5taW4oW2NvbHVtbl93aWR0aCxjb2x1bW5faGVpZ2h0XSkvMiktKHBhZGRpbmcqMilcbiAgc2l6ZV9tYXggLT0gbGFiZWxfaGVpZ2h0XG5cbiAgdmFyIHNpemUgPSB2YXJzLnNpemUuc2NhbGUudmFsdWVcbiAgICAuZG9tYWluKFtkb21haW5fbWluLGRvbWFpbl9tYXhdKVxuICAgIC5yYW5nZVJvdW5kKFtzaXplX21pbixzaXplX21heF0pXG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIENhbGN1bGF0ZSBidWJibGUgcGFja2luZ1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgdmFyIHBhY2sgPSBkMy5sYXlvdXQucGFjaygpXG4gICAgLnNpemUoW2NvbHVtbl93aWR0aC1wYWRkaW5nKjIsY29sdW1uX2hlaWdodC1wYWRkaW5nKjItbGFiZWxfaGVpZ2h0XSlcbiAgICAudmFsdWUoZnVuY3Rpb24oZCkge1xuICAgICAgaWYgKCF2YXJzLnNpemUudmFsdWUpIHJldHVybiAwXG4gICAgICByZXR1cm4gZmV0Y2hWYWx1ZSh2YXJzLGQsdmFycy5zaXplLnZhbHVlKVxuICAgIH0pXG4gICAgLnBhZGRpbmcocGFkZGluZylcbiAgICAucmFkaXVzKGZ1bmN0aW9uKGQpe1xuICAgICAgcmV0dXJuIHNpemUoZClcbiAgICB9KVxuXG4gIHZhciBkYXRhID0gW11cblxuICB2YXIgcm93ID0gMFxuICB2YXJzLmRhdGEuYXBwLmZvckVhY2goZnVuY3Rpb24oZCxpKXtcblxuICAgIHZhciB0ZW1wID0gcGFjay5ub2RlcyhkKVxuXG4gICAgdmFyIHhvZmZzZXQgPSAoY29sdW1uX3dpZHRoKmkpICUgdmFycy53aWR0aC52aXosXG4gICAgICAgIHlvZmZzZXQgPSBjb2x1bW5faGVpZ2h0KnJvd1xuXG4gICAgdGVtcC5mb3JFYWNoKGZ1bmN0aW9uKHQpe1xuICAgICAgdC54b2Zmc2V0ID0geG9mZnNldFxuICAgICAgdC55b2Zmc2V0ID0geW9mZnNldCtsYWJlbF9oZWlnaHRcbiAgICAgIGlmICh0LmRlcHRoIDwgdmFycy5kZXB0aC52YWx1ZSkge1xuICAgICAgICB0LmQzcGx1cy5zdGF0aWMgPSB0cnVlXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdC5kM3BsdXMuc3RhdGljID0gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmICh0ZW1wLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHQuZDNwbHVzLmxhYmVsID0gZmFsc2VcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0LmQzcGx1cy5sYWJlbCA9IHRydWVcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgZGF0YSA9IGRhdGEuY29uY2F0KHRlbXApXG5cbiAgICBpZiAoKGkrMSkgJSBjb2x1bW5zID09IDApIHtcbiAgICAgIHJvdysrXG4gICAgfVxuXG4gIH0pXG5cbiAgdmFyIGRvd25zY2FsZSA9IHNpemVfbWF4L2QzLm1heChkYXRhLGZ1bmN0aW9uKGQpeyByZXR1cm4gZC5yIH0pXG5cbiAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQpe1xuICAgIGQueCA9ICgoZC54LWNvbHVtbl93aWR0aC8yKSpkb3duc2NhbGUpK2NvbHVtbl93aWR0aC8yXG4gICAgZC5kM3BsdXMueCA9IGQueCtkLnhvZmZzZXRcbiAgICBkLnkgPSAoKGQueS1jb2x1bW5faGVpZ2h0LzIpKmRvd25zY2FsZSkrY29sdW1uX2hlaWdodC8yXG4gICAgZC5kM3BsdXMueSA9IGQueStkLnlvZmZzZXRcbiAgICBkLnIgPSBkLnIqZG93bnNjYWxlXG4gICAgZC5kM3BsdXMuciA9IGQuclxuICB9KVxuXG4gIGRhdGEuc29ydChmdW5jdGlvbiggYSAsIGIgKXtcbiAgICByZXR1cm4gYS5kZXB0aCAtIGIuZGVwdGhcbiAgfSlcblxuICB2YXIgbGFiZWxfZGF0YSA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpe1xuICAgIHJldHVybiBkLmRlcHRoID09IDBcbiAgfSlcblxuICB2YXIgbGFiZWxzID0gdmFycy5ncm91cC5zZWxlY3RBbGwoXCJ0ZXh0LmQzcGx1c19idWJibGVfbGFiZWxcIilcbiAgICAuZGF0YShsYWJlbF9kYXRhLGZ1bmN0aW9uKGQpe1xuICAgICAgaWYgKCFkLmQzcGx1cy5sYWJlbF9oZWlnaHQpIGQuZDNwbHVzLmxhYmVsX2hlaWdodCA9IDBcbiAgICAgIHJldHVybiBkW3ZhcnMuaWQubmVzdGluZ1tkLmRlcHRoXV1cbiAgICB9KVxuXG4gIGZ1bmN0aW9uIGxhYmVsX3N0eWxlKGwpIHtcbiAgICBsXG4gICAgICAuYXR0cihcInhcIixmdW5jdGlvbihkKXtcbiAgICAgICAgcmV0dXJuIGQuZDNwbHVzLnhcbiAgICAgIH0pXG4gICAgICAuYXR0cihcInlcIixmdW5jdGlvbihkKXtcbiAgICAgICAgcmV0dXJuIGQuZDNwbHVzLnktZC5yLWQuZDNwbHVzLmxhYmVsX2hlaWdodC1wYWRkaW5nXG4gICAgICB9KVxuICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIixcIm1pZGRsZVwiKVxuICAgICAgLmF0dHIoXCJmb250LXdlaWdodFwiLHZhcnMubGFiZWxzLmZvbnQud2VpZ2h0KVxuICAgICAgLmF0dHIoXCJmb250LWZhbWlseVwiLHZhcnMubGFiZWxzLmZvbnQuZmFtaWx5LnZhbHVlKVxuICAgICAgLmF0dHIoXCJmb250LXNpemVcIixcIjEycHhcIilcbiAgICAgIC5zdHlsZShcImZpbGxcIixmdW5jdGlvbihkKXtcbiAgICAgICAgdmFyIGNvbG9yID0gZmV0Y2hDb2xvcih2YXJzLGQpXG4gICAgICAgIHJldHVybiBkM3BsdXMuY29sb3IubGVnaWJsZShjb2xvcilcbiAgICAgIH0pXG4gICAgICAuZWFjaChmdW5jdGlvbihkKXtcbiAgICAgICAgaWYgKGQuciA+IDEwICYmIGxhYmVsX2hlaWdodCA+IDEwKSB7XG5cbiAgICAgICAgICB2YXIgbmFtZXMgPSBmZXRjaFRleHQodmFycyxkLGQuZGVwdGgpXG5cbiAgICAgICAgICBkM3BsdXMudGV4dHdyYXAoKVxuICAgICAgICAgICAgLmNvbnRhaW5lciggZDMuc2VsZWN0KHRoaXMpIClcbiAgICAgICAgICAgIC5oZWlnaHQoIGxhYmVsX2hlaWdodCApXG4gICAgICAgICAgICAudGV4dCggbmFtZXMgKVxuICAgICAgICAgICAgLndpZHRoKCBjb2x1bW5fd2lkdGggLSBwYWRkaW5nICogMiApXG4gICAgICAgICAgICAuZHJhdygpXG5cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwieVwiLGZ1bmN0aW9uKGQpe1xuICAgICAgICBkLmQzcGx1cy5sYWJlbF9oZWlnaHQgPSBkMy5zZWxlY3QodGhpcykubm9kZSgpLmdldEJCb3goKS5oZWlnaHRcbiAgICAgICAgcmV0dXJuIGQuZDNwbHVzLnktZC5yLWQuZDNwbHVzLmxhYmVsX2hlaWdodC1wYWRkaW5nXG4gICAgICB9KVxuICAgICAgLnNlbGVjdEFsbChcInRzcGFuXCIpXG4gICAgICAgIC5hdHRyKFwieFwiLGZ1bmN0aW9uKGQpe1xuICAgICAgICAgIHJldHVybiBkLmQzcGx1cy54XG4gICAgICAgIH0pXG4gIH1cblxuICBsYWJlbHMuZW50ZXIoKS5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgLmF0dHIoXCJjbGFzc1wiLFwiZDNwbHVzX2J1YmJsZV9sYWJlbFwiKVxuICAgIC5jYWxsKGxhYmVsX3N0eWxlKVxuICAgIC5hdHRyKFwib3BhY2l0eVwiLDApXG5cbiAgbGFiZWxzLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgIC5jYWxsKGxhYmVsX3N0eWxlKVxuICAgIC5hdHRyKFwib3BhY2l0eVwiLDEpXG5cbiAgbGFiZWxzLmV4aXQoKVxuICAgIC5hdHRyKFwib3BhY2l0eVwiLDApXG4gICAgLnJlbW92ZSgpXG5cbiAgcmV0dXJuIGRhdGFcblxufVxuXG4vL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gVmlzdWFsaXphdGlvbiBTZXR0aW5ncyBhbmQgSGVscGVyIEZ1bmN0aW9uc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmJ1YmJsZXMuZmlsbCAgICAgICAgID0gdHJ1ZVxuYnViYmxlcy5yZXF1aXJlbWVudHMgPSBbIFwiZGF0YVwiIF1cbmJ1YmJsZXMuc2NhbGUgICAgICAgID0gMS4wNVxuYnViYmxlcy5zaGFwZXMgICAgICAgPSBbIFwiY2lyY2xlXCIgLCBcImRvbnV0XCIgXVxuYnViYmxlcy50b29sdGlwICAgICAgPSBcInN0YXRpY1wiXG5cbm1vZHVsZS5leHBvcnRzID0gYnViYmxlc1xuIiwidmFyIGZldGNoVmFsdWUgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9mZXRjaC92YWx1ZS5qc1wiKVxuICAsIGZldGNoQ29sb3IgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9mZXRjaC9jb2xvci5qc1wiKVxuICAsIGZldGNoRGF0YSAgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9mZXRjaC9kYXRhLmpzXCIpXG4vL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gQ2hhcnRcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgY2hhcnQgPSBmdW5jdGlvbih2YXJzKSB7XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIENhbGN1bGF0ZSBzaXplIGFuZCBwb3NpdGlvbiBvZiBncmFwaFxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgaWYgKHZhcnMuc21hbGwpIHtcbiAgICB2YXIgZ3JhcGggPSB7XCJtYXJnaW5cIjoge1widG9wXCI6IDAsIFwicmlnaHRcIjogMCwgXCJib3R0b21cIjogMCwgXCJsZWZ0XCI6IDB9fVxuICB9XG4gIGVsc2Uge1xuICAgIHZhciBncmFwaCA9IHtcIm1hcmdpblwiOiB7XCJ0b3BcIjogMTAsIFwicmlnaHRcIjogMTAsIFwiYm90dG9tXCI6IDQwLCBcImxlZnRcIjogNDB9fVxuICB9XG4gIGdyYXBoLndpZHRoID0gdmFycy53aWR0aC52aXotZ3JhcGgubWFyZ2luLmxlZnQtZ3JhcGgubWFyZ2luLnJpZ2h0XG4gIGdyYXBoLmhlaWdodCA9IHZhcnMuaGVpZ2h0LnZpei1ncmFwaC5tYXJnaW4udG9wLWdyYXBoLm1hcmdpbi5ib3R0b21cblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gSWYgdGhlcmUgaXMgZGF0YSwgcnVuIHRoZSBuZWVkZWQgY2FsY3VsYXRpb25zXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBpZiAodmFycy5kYXRhLmFwcC5sZW5ndGgpIHtcblxuICAgIGlmICghdmFycy50aWNrVmFsdWVzKSB2YXJzLnRpY2tWYWx1ZXMgPSB7fVxuXG4gICAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgLy8gRGV0ZXJtaW5lIFggYW5kIFkgYXhpc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhcnMuY29udGludW91c19heGlzID0gbnVsbFxuICAgIHZhcnMub3BwX2F4aXMgPSBudWxsXG4gICAgdmFycy5zdGFja2VkX2F4aXMgPSBudWxsXG5cbiAgICB2YXJzLmF4ZXMudmFsdWVzLmZvckVhY2goZnVuY3Rpb24oYXhpcyl7XG5cbiAgICAgIGlmICh2YXJzW2F4aXNdLnN0YWNrZWQudmFsdWUpIHtcbiAgICAgICAgdmFycy5zdGFja2VkX2F4aXMgPSBheGlzXG4gICAgICB9XG4gICAgICBpZiAoIXZhcnMuY29udGludW91c19heGlzICYmIHZhcnNbYXhpc10uc2NhbGUudmFsdWUgPT0gXCJjb250aW51b3VzXCIpIHtcbiAgICAgICAgdmFycy5jb250aW51b3VzX2F4aXMgPSBheGlzXG4gICAgICAgIHZhcnMub3BwX2F4aXMgPSBheGlzID09IFwieFwiID8gXCJ5XCIgOiBcInhcIlxuICAgICAgfVxuXG4gICAgICBpZiAodmFycy5kYXRhLmNoYW5nZWQgfHwgdmFycy5kZXB0aC5jaGFuZ2VkIHx8ICF2YXJzW2F4aXMrXCJfcmFuZ2VcIl0gfHwgdmFycy50aW1lLmZpeGVkLnZhbHVlKSB7XG5cbiAgICAgICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWUoXCJkZXRlcm1pbmluZyBcIitheGlzK1wiLWF4aXNcIilcbiAgICAgICAgaWYgKHZhcnNbYXhpc10uc2NhbGUudmFsdWUgPT0gXCJzaGFyZVwiKSB7XG4gICAgICAgICAgdmFyc1theGlzK1wiX3JhbmdlXCJdID0gWzAsMV1cbiAgICAgICAgICB2YXJzLnRpY2tWYWx1ZXNbYXhpc10gPSBkM3BsdXMudXRpbC5idWNrZXRzKFswLDFdLDExKVxuICAgICAgICAgIHZhcnMuc3RhY2tlZF9heGlzID0gYXhpc1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhcnNbYXhpc10uc3RhY2tlZC52YWx1ZSkge1xuICAgICAgICAgIGlmICh2YXJzLnRpbWUuZml4ZWQudmFsdWUpIHtcbiAgICAgICAgICAgIHZhciByYW5nZV9kYXRhID0gdmFycy5kYXRhLmFwcFxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByYW5nZV9kYXRhID0gZmV0Y2hEYXRhKHZhcnMsW1wiYWxsXCJdKVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgeGF4aXNfc3VtcyA9IGQzLm5lc3QoKVxuICAgICAgICAgICAgLmtleShmdW5jdGlvbihkKXtyZXR1cm4gZFt2YXJzLngudmFsdWVdIH0pXG4gICAgICAgICAgICAucm9sbHVwKGZ1bmN0aW9uKGxlYXZlcyl7XG4gICAgICAgICAgICAgIHJldHVybiBkMy5zdW0obGVhdmVzLCBmdW5jdGlvbihkKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hWYWx1ZSh2YXJzLGQsdmFyc1theGlzXS52YWx1ZSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZW50cmllcyhyYW5nZV9kYXRhKVxuXG4gICAgICAgICAgdmFyc1theGlzK1wiX3JhbmdlXCJdID0gWzAsZDMubWF4KHhheGlzX3N1bXMsIGZ1bmN0aW9uKGQpeyByZXR1cm4gZC52YWx1ZXM7IH0pXVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhcnNbYXhpc10uZG9tYWluIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICB2YXJzW2F4aXMrXCJfcmFuZ2VcIl0gPSB2YXJzW2F4aXNdLmRvbWFpblxuICAgICAgICAgIHZhcnMudGlja1ZhbHVlc1theGlzXSA9IGQzcGx1cy51dGlsLnVuaXF1ZXModmFycy5kYXRhLmFwcCx2YXJzW2F4aXNdLnZhbHVlKVxuICAgICAgICAgIHZhcnMudGlja1ZhbHVlc1theGlzXSA9IHZhcnMudGlja1ZhbHVlc1theGlzXS5maWx0ZXIoZnVuY3Rpb24odCl7XG4gICAgICAgICAgICByZXR1cm4gdCA+PSB2YXJzW2F4aXMrXCJfcmFuZ2VcIl1bMF0gJiYgdCA8PSB2YXJzW2F4aXMrXCJfcmFuZ2VcIl1bMV1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhcnMudGltZS5maXhlZC52YWx1ZSkge1xuICAgICAgICAgIHZhcnNbYXhpcytcIl9yYW5nZVwiXSA9IGQzLmV4dGVudCh2YXJzLmRhdGEuYXBwLGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoVmFsdWUodmFycyxkLHZhcnNbYXhpc10udmFsdWUpXG4gICAgICAgICAgfSlcbiAgICAgICAgICB2YXJzLnRpY2tWYWx1ZXNbYXhpc10gPSBkM3BsdXMudXRpbC51bmlxdWVzKHZhcnMuZGF0YS5hcHAsdmFyc1theGlzXS52YWx1ZSlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgYWxsX2RlcHRocyA9IFtdXG4gICAgICAgICAgZm9yIChpZCBpbiB2YXJzLmlkLm5lc3RpbmcpIHtcbiAgICAgICAgICAgIGFsbF9kZXB0aHMgPSBhbGxfZGVwdGhzLmNvbmNhdCh2YXJzLmRhdGEuZ3JvdXBlZFt2YXJzLmlkLm5lc3RpbmdbaWRdXS5hbGwpXG4gICAgICAgICAgfVxuICAgICAgICAgIHZhcnNbYXhpcytcIl9yYW5nZVwiXSA9IGQzLmV4dGVudChhbGxfZGVwdGhzLGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoVmFsdWUodmFycyxkLHZhcnNbYXhpc10udmFsdWUpXG4gICAgICAgICAgfSlcbiAgICAgICAgICB2YXJzLnRpY2tWYWx1ZXNbYXhpc10gPSBkM3BsdXMudXRpbC51bmlxdWVzKGZldGNoRGF0YSh2YXJzLFtcImFsbFwiXSksdmFyc1theGlzXS52YWx1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBwYWRkaW5nIHRvIGF4aXMgaWYgdGhlcmUgaXMgb25seSAxIHZhbHVlXG4gICAgICAgIGlmICh2YXJzW2F4aXMrXCJfcmFuZ2VcIl1bMF0gPT09IHZhcnNbYXhpcytcIl9yYW5nZVwiXVsxXSkge1xuICAgICAgICAgIGlmICh2YXJzW2F4aXNdLnZhbHVlID09PSB2YXJzLnRpbWUudmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjbG9zZXN0VGltZSA9IGQzcGx1cy51dGlsLmNsb3Nlc3QodmFycy5kYXRhLnRpbWUudGlja3MsdmFyc1theGlzK1wiX3JhbmdlXCJdWzBdKVxuICAgICAgICAgICAgICAsIHRpbWVJbmRleCA9IHZhcnMuZGF0YS50aW1lLnRpY2tzLmluZGV4T2YoY2xvc2VzdFRpbWUpXG5cbiAgICAgICAgICAgIGlmICh0aW1lSW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgIHZhcnNbYXhpcytcIl9yYW5nZVwiXVswXSA9IHZhcnMuZGF0YS50aW1lLnRpY2tzW3RpbWVJbmRleC0xXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBkaWZmID0gdmFycy5kYXRhLnRpbWUudGlja3NbdGltZUluZGV4KzFdIC0gY2xvc2VzdFRpbWVcbiAgICAgICAgICAgICAgdmFyc1theGlzK1wiX3JhbmdlXCJdWzBdID0gbmV3IERhdGUoY2xvc2VzdFRpbWUuZ2V0VGltZSgpIC0gZGlmZilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aW1lSW5kZXggPCB2YXJzLmRhdGEudGltZS50aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIHZhcnNbYXhpcytcIl9yYW5nZVwiXVsxXSA9IHZhcnMuZGF0YS50aW1lLnRpY2tzW3RpbWVJbmRleCsxXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBkaWZmID0gY2xvc2VzdFRpbWUgLSB2YXJzLmRhdGEudGltZS50aWNrc1t0aW1lSW5kZXgtMV1cbiAgICAgICAgICAgICAgdmFyc1theGlzK1wiX3JhbmdlXCJdWzFdID0gbmV3IERhdGUoY2xvc2VzdFRpbWUuZ2V0VGltZSgpICsgZGlmZilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXJzW2F4aXMrXCJfcmFuZ2VcIl1bMF0gLT0gMVxuICAgICAgICAgICAgdmFyc1theGlzK1wiX3JhbmdlXCJdWzFdICs9IDFcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXZlcnNlIFkgYXhpc1xuICAgICAgICBpZiAoYXhpcyA9PSBcInlcIikgdmFycy55X3JhbmdlID0gdmFycy55X3JhbmdlLnJldmVyc2UoKVxuXG4gICAgICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lRW5kKFwiZGV0ZXJtaW5pbmcgXCIrYXhpcytcIi1heGlzXCIpXG4gICAgICB9XG4gICAgICBlbHNlIGlmICghdmFyc1theGlzK1wiX3JhbmdlXCJdKSB7XG4gICAgICAgIHZhcnNbYXhpcytcIl9yYW5nZVwiXSA9IFstMSwxXVxuICAgICAgfVxuXG4gICAgfSlcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgLy8gTWlycm9yIGF4ZXMsIGlmIGFwcGxpY2FibGVcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBpZiAodmFycy5heGVzLm1pcnJvci52YWx1ZSkge1xuICAgICAgdmFyIGRvbWFpbnMgPSB2YXJzLnlfcmFuZ2UuY29uY2F0KHZhcnMueF9yYW5nZSlcbiAgICAgIHZhcnMueF9yYW5nZSA9IGQzLmV4dGVudChkb21haW5zKVxuICAgICAgdmFycy55X3JhbmdlID0gZDMuZXh0ZW50KGRvbWFpbnMpLnJldmVyc2UoKVxuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgdmFyIGRhdGEgPSB2YXJzLmRhdGEuYXBwXG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAgIC8vIERldGVybWluZSBzaXplIG9mIG5vZGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBpZiAoZGF0YSkge1xuXG4gICAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZShcImRldGVybWluaW5nIHNpemUgc2NhbGVcIilcbiAgICAgIGlmICh2YXJzLnNpemUudmFsdWUpIHtcbiAgICAgICAgaWYgKHZhcnMudGltZS5maXhlZC52YWx1ZSkge1xuICAgICAgICAgIHZhciBzaXplX2RvbWFpbiA9IGQzLmV4dGVudCh2YXJzLmRhdGEuYXBwLGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgdmFyIHZhbCA9IGZldGNoVmFsdWUodmFycyxkLHZhcnMuc2l6ZS52YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiB2YWwgPT0gMCA/IG51bGwgOiB2YWxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBhbGxfZGVwdGhzID0gW11cbiAgICAgICAgICBmb3IgKGlkIGluIHZhcnMuaWQubmVzdGluZykge1xuICAgICAgICAgICAgYWxsX2RlcHRocyA9IGFsbF9kZXB0aHMuY29uY2F0KHZhcnMuZGF0YS5ncm91cGVkW3ZhcnMuaWQubmVzdGluZ1tpZF1dLmFsbClcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNpemVfZG9tYWluID0gZDMuZXh0ZW50KGFsbF9kZXB0aHMsZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICB2YXIgdmFsID0gZmV0Y2hWYWx1ZSh2YXJzLGQsdmFycy5zaXplLnZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIHZhbCA9PSAwID8gbnVsbCA6IHZhbFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzaXplX2RvbWFpblswXSB8fCAhc2l6ZV9kb21haW5bMV0pIHNpemVfZG9tYWluID0gWzAsMF1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgc2l6ZV9kb21haW4gPSBbMCwwXVxuICAgICAgfVxuXG4gICAgICB2YXIgbWF4X3NpemUgPSBNYXRoLmZsb29yKGQzLm1heChbZDMubWluKFtncmFwaC53aWR0aCxncmFwaC5oZWlnaHRdKS8xNSwxMF0pKSxcbiAgICAgICAgICBtaW5fc2l6ZSA9IDEwXG5cbiAgICAgIGlmIChzaXplX2RvbWFpblswXSA9PSBzaXplX2RvbWFpblsxXSkgdmFyIG1pbl9zaXplID0gbWF4X3NpemVcblxuICAgICAgdmFyIHNpemVfcmFuZ2UgPSBbbWluX3NpemUsbWF4X3NpemVdXG5cbiAgICAgIHZhciByYWRpdXMgPSB2YXJzLnNpemUuc2NhbGUudmFsdWVcbiAgICAgICAgLmRvbWFpbihzaXplX2RvbWFpbilcbiAgICAgICAgLnJhbmdlUm91bmQoc2l6ZV9yYW5nZSlcblxuICAgICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWVFbmQoXCJkZXRlcm1pbmluZyBzaXplIHNjYWxlXCIpXG5cbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAgIC8vIENyZWF0ZSBheGlzIHNjYWxlcyBhbmQgYWRkIGJ1ZmZlciBpZiBuZWNlc3NhcnlcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgdGlja0F0dHJzID0ge1xuICAgICAgXCJmb250LXNpemVcIjogICB2YXJzLmF4ZXMudGlja3MuZm9udC5zaXplLFxuICAgICAgXCJmaWxsXCI6ICAgICAgICB2YXJzLmF4ZXMudGlja3MuZm9udC5jb2xvcixcbiAgICAgIFwiZm9udC1mYW1pbHlcIjogdmFycy5heGVzLnRpY2tzLmZvbnQuZmFtaWx5LnZhbHVlLFxuICAgICAgXCJmb250LXdlaWdodFwiOiB2YXJzLmF4ZXMudGlja3MuZm9udC53ZWlnaHRcbiAgICB9XG5cbiAgICB2YXJzLmF4ZXMudmFsdWVzLmZvckVhY2goZnVuY3Rpb24oYXhpcyl7XG5cbiAgICAgIC8vIENyZWF0ZSBBeGVzXG4gICAgICB2YXIgcmFuZ2VfbWF4ID0gYXhpcyA9PSBcInhcIiA/IGdyYXBoLndpZHRoIDogZ3JhcGguaGVpZ2h0XG5cbiAgICAgIGlmIChbXCJjb250aW51b3VzXCIsXCJzaGFyZVwiXS5pbmRleE9mKHZhcnNbYXhpc10uc2NhbGUudmFsdWUpID49IDApIHtcbiAgICAgICAgdmFyIHMgPSBcImxpbmVhclwiXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIHMgPSB2YXJzW2F4aXNdLnNjYWxlLnZhbHVlXG4gICAgICB9XG5cbiAgICAgIHZhcnNbYXhpcytcIl9zY2FsZVwiXSA9IGQzLnNjYWxlW3NdKClcbiAgICAgICAgLmRvbWFpbih2YXJzW2F4aXMrXCJfcmFuZ2VcIl0pXG4gICAgICAgIC5yYW5nZVJvdW5kKFswLHJhbmdlX21heF0pXG5cbiAgICAgIC8vIHNldCBidWZmZXIgcm9vbSAodGFrZSBpbnRvIGFjY291bnQgbGFyZ2VzdCBzaXplIHZhcilcbiAgICAgIGlmIChbXCJzcXVhcmVcIixcImNpcmNsZVwiLFwiZG9udXRcIl0uaW5kZXhPZih2YXJzLnNoYXBlLnZhbHVlKSA+PSAwICYmXG4gICAgICAgICAgW1wic2hhcmVcIl0uaW5kZXhPZih2YXJzW2F4aXNdLnNjYWxlLnZhbHVlKSA8IDApIHtcblxuICAgICAgICB2YXIgc2NhbGUgPSB2YXJzW2F4aXMrXCJfc2NhbGVcIl1cbiAgICAgICAgICAsIGxhcmdlc3Rfc2l6ZSA9IHJhZGl1cy5yYW5nZSgpWzFdKjJcbiAgICAgICAgICAsIGRvbWFpbkhpZ2ggPSBzY2FsZS5pbnZlcnQoLWxhcmdlc3Rfc2l6ZSlcbiAgICAgICAgICAsIGRvbWFpbkxvdz0gc2NhbGUuaW52ZXJ0KHJhbmdlX21heCtsYXJnZXN0X3NpemUpXG5cbiAgICAgICAgdmFyc1theGlzK1wiX3NjYWxlXCJdLmRvbWFpbihbZG9tYWluSGlnaCxkb21haW5Mb3ddKVxuXG4gICAgICB9XG5cbiAgICAgIHZhciBvcmllbnQgPSBheGlzID09IFwieFwiID8gXCJib3R0b21cIiA6IFwibGVmdFwiXG5cbiAgICAgIHZhcnNbYXhpcytcIl9heGlzXCJdID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAudGlja1NpemUodmFycy5heGVzLnRpY2tzLnNpemUpXG4gICAgICAgIC50aWNrUGFkZGluZyg1KVxuICAgICAgICAub3JpZW50KG9yaWVudClcbiAgICAgICAgLnNjYWxlKHZhcnNbYXhpcytcIl9zY2FsZVwiXSlcbiAgICAgICAgLnRpY2tGb3JtYXQoZnVuY3Rpb24oZCwgaSkge1xuXG4gICAgICAgICAgdmFyIHZpc2libGUgPSB0cnVlXG4gICAgICAgICAgaWYgKHZhcnNbYXhpc10udmFsdWUgPT0gdmFycy50aW1lLnZhbHVlICYmIGQgJSAxICE9IDApIHtcbiAgICAgICAgICAgIHZpc2libGUgPSBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgoKHZhcnNbYXhpc10uc2NhbGUudmFsdWUgPT0gXCJsb2dcIiAmJiBkLnRvU3RyaW5nKCkuY2hhckF0KDApID09IFwiMVwiKVxuICAgICAgICAgICAgICB8fCB2YXJzW2F4aXNdLnNjYWxlLnZhbHVlICE9IFwibG9nXCIpICYmIHZpc2libGUpIHtcblxuICAgICAgICAgICAgaWYgKHZhcnNbYXhpc10uc2NhbGUudmFsdWUgPT0gXCJzaGFyZVwiKSB7XG4gICAgICAgICAgICAgIHZhciB0ZXh0ID0gZCoxMDArXCIlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGQuY29uc3RydWN0b3IgPT09IERhdGUpIHtcbiAgICAgICAgICAgICAgdmFyIHRleHQgPSB2YXJzLmRhdGEudGltZS5tdWx0aUZvcm1hdChkKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciB0ZXh0ID0gdmFycy5mb3JtYXQudmFsdWUoZCx2YXJzW2F4aXNdLnZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gbnVsbFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0ZXh0O1xuXG4gICAgICAgIH0pXG5cbiAgICAgIGlmICh2YXJzW2F4aXNdLnZhbHVlID09PSB2YXJzLnRpbWUudmFsdWUpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gdmFyc1theGlzK1wiX3JhbmdlXCJdXG4gICAgICAgIHZhcnNbYXhpc10udGlja3MgPSB2YXJzLmRhdGEudGltZS50aWNrcy5maWx0ZXIoZnVuY3Rpb24odCl7XG4gICAgICAgICAgcmV0dXJuIHQgPD0gcmFuZ2VbMV0gJiYgdCA+PSByYW5nZVswXVxuICAgICAgICB9KVxuXG4gICAgICAgIHZhciBtaW5DbG9zZXN0ID0gZDNwbHVzLnV0aWwuY2xvc2VzdCh2YXJzLmRhdGEudGltZS50aWNrcyxyYW5nZVswXSlcbiAgICAgICAgdmFyIG1heENsb3Nlc3QgPSBkM3BsdXMudXRpbC5jbG9zZXN0KHZhcnMuZGF0YS50aW1lLnRpY2tzLHJhbmdlWzFdKVxuICAgICAgICBpZiAodmFyc1theGlzXS50aWNrcy5pbmRleE9mKG1pbkNsb3Nlc3QpIDwgMCkge1xuICAgICAgICAgIHZhcnNbYXhpc10udGlja3MudW5zaGlmdChtaW5DbG9zZXN0KVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YXJzW2F4aXNdLnRpY2tzLmluZGV4T2YobWF4Q2xvc2VzdCkgPCAwKSB7XG4gICAgICAgICAgdmFyc1theGlzXS50aWNrcy5wdXNoKG1heENsb3Nlc3QpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHZhcnMuY29udGludW91c19heGlzID09PSBheGlzKSB7XG4gICAgICAgIHZhcnNbYXhpc10udGlja3MgPSB2YXJzLnRpY2tWYWx1ZXNbYXhpc11cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXJzW2F4aXNdLnRpY2tzID0gdmFyc1theGlzK1wiX3NjYWxlXCJdLnRpY2tzKClcbiAgICAgIH1cblxuICAgICAgdmFyc1theGlzK1wiX2F4aXNcIl0udGlja1ZhbHVlcyh2YXJzW2F4aXNdLnRpY2tzKVxuXG4gICAgfSlcblxuICB9XG5cbiAgLy8gRnVuY3Rpb24gZm9yIFRpY2sgU3R5bGluZ1xuICBmdW5jdGlvbiB0aWNrX3N0eWxlKHQsYXhpcykge1xuICAgIHRcbiAgICAgIC5hdHRyKFwic3Ryb2tlXCIsdmFycy5heGVzLnRpY2tzLmNvbG9yKVxuICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIix2YXJzLmF4ZXMudGlja3Mud2lkdGgpXG4gICAgICAuYXR0cihcInNoYXBlLXJlbmRlcmluZ1wiLHZhcnMuc2hhcGUucmVuZGVyaW5nLnZhbHVlKVxuICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLGZ1bmN0aW9uKGQpe1xuICAgICAgICB2YXIgbGlnaHRlciA9IHZhcnNbYXhpc10uc2NhbGUudmFsdWUgPT0gXCJsb2dcIiAmJiBkLnRvU3RyaW5nKCkuY2hhckF0KDApICE9IFwiMVwiXG4gICAgICAgIHJldHVybiBsaWdodGVyID8gMC4yNSA6IDFcbiAgICAgIH0pXG4gIH1cblxuICAvLyBGdW5jdGlvbiBmb3IgVGljayBTdHlsaW5nXG4gIGZ1bmN0aW9uIHRpY2tfcG9zaXRpb24odCxheGlzKSB7XG4gICAgdFxuICAgICAgLmF0dHIoXCJ4MVwiLGZ1bmN0aW9uKGQpe1xuICAgICAgICByZXR1cm4gYXhpcyA9PSBcInhcIiA/IHZhcnMueF9zY2FsZShkKSA6IDBcbiAgICAgIH0pXG4gICAgICAuYXR0cihcIngyXCIsZnVuY3Rpb24oZCl7XG4gICAgICAgIHJldHVybiBheGlzID09IFwieFwiID8gdmFycy54X3NjYWxlKGQpIDogZ3JhcGgud2lkdGhcbiAgICAgIH0pXG4gICAgICAuYXR0cihcInkxXCIsZnVuY3Rpb24oZCl7XG4gICAgICAgIHJldHVybiBheGlzID09IFwieVwiID8gdmFycy55X3NjYWxlKGQpIDogMFxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwieTJcIixmdW5jdGlvbihkKXtcbiAgICAgICAgcmV0dXJuIGF4aXMgPT0gXCJ5XCIgPyB2YXJzLnlfc2NhbGUoZCkgOiBncmFwaC5oZWlnaHRcbiAgICAgIH0pXG4gIH1cblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gQ2FsY3VsYXRlIFNwYWNpbmcgTmVlZGVkIGZvciBBeGVzIExhYmVsc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgdmFyIHlUaWNrcyA9IHZhcnMueS50aWNrcy5tYXAoZnVuY3Rpb24oZCl7XG4gICAgICAgIHJldHVybiB2YXJzLmZvcm1hdC52YWx1ZShkLHZhcnMueS52YWx1ZSlcbiAgICAgIH0pXG4gICAgLCB5QXhpc1dpZHRoID0gZDMubWF4KGQzcGx1cy5mb250LnNpemVzKHlUaWNrcyx0aWNrQXR0cnMpLGZ1bmN0aW9uKGQpe3JldHVybiBkLndpZHRofSkgKyB2YXJzLmxhYmVscy5wYWRkaW5nXG4gIGdyYXBoLm1hcmdpbi5sZWZ0ICs9IHlBeGlzV2lkdGhcbiAgZ3JhcGgud2lkdGggLT0geUF4aXNXaWR0aFxuXG4gIHZhciB4VGlja3MgPSB2YXJzLngudGlja3MubWFwKGZ1bmN0aW9uKGQpe1xuICAgICAgICByZXR1cm4gdmFycy5mb3JtYXQudmFsdWUoZCx2YXJzLngudmFsdWUpXG4gICAgICB9KVxuICAgICwgeFNpemVzID0gZDNwbHVzLmZvbnQuc2l6ZXMoeFRpY2tzLHRpY2tBdHRycylcbiAgICAsIHhBeGlzV2lkdGggPSBkMy5tYXgoeFNpemVzLGZ1bmN0aW9uKGQpe3JldHVybiBkLndpZHRofSlcbiAgICAsIHhBeGlzSGVpZ2h0ID0gZDMubWF4KHhTaXplcyxmdW5jdGlvbihkKXtyZXR1cm4gZC5oZWlnaHR9KVxuICAgICwgeE1heFdpZHRoID0gZDMubWluKFtncmFwaC53aWR0aC8oeFRpY2tzLmxlbmd0aCsxKSxncmFwaC5tYXJnaW4ubGVmdCoyXSkgLSB2YXJzLmxhYmVscy5wYWRkaW5nKjJcblxuICBpZiAoeEF4aXNXaWR0aCA8IHhNYXhXaWR0aCkge1xuICAgIHhBeGlzV2lkdGggKz0gdmFycy5sYWJlbHMucGFkZGluZ1xuICAgIHZhciB4QW5jaG9yID0gXCJtaWRkbGVcIlxuICAgICAgLCB4RHkgICAgID0gXCIwZXhcIlxuICAgICAgLCB4VHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoMCwxMClcIlxuICB9XG4gIGVsc2Uge1xuICAgIHhBeGlzV2lkdGggPSB4QXhpc0hlaWdodCArIHZhcnMubGFiZWxzLnBhZGRpbmdcbiAgICB4QXhpc0hlaWdodCA9IGQzLm1heCh4U2l6ZXMsZnVuY3Rpb24oZCl7cmV0dXJuIGQud2lkdGh9KVxuICAgIHZhciB4Um90YXRlID0gdHJ1ZVxuICAgICAgLCB4QW5jaG9yID0gXCJzdGFydFwiXG4gICAgICAsIHhEeSAgICAgPSBcIjAuNWV4XCJcbiAgICAgICwgeFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKDE1LDEwKXJvdGF0ZSg3MClcIlxuICB9XG5cbiAgZ3JhcGguaGVpZ2h0IC09IHhBeGlzSGVpZ2h0XG4gIGdyYXBoLndpZHRoIC09IHhBeGlzV2lkdGgvMlxuICB2YXJzLnhfc2NhbGUucmFuZ2VSb3VuZChbMCxncmFwaC53aWR0aF0pXG4gIHZhcnMueV9zY2FsZS5yYW5nZVJvdW5kKFswLGdyYXBoLmhlaWdodF0pXG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIEVudGVyIFNWRyBFbGVtZW50c1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBFbnRlciBCYWNrZ3JvdW5kIFBsYW5lXG4gIHZhciBwbGFuZSA9IHZhcnMuZ3JvdXAuc2VsZWN0QWxsKFwiZyNwbGFuZVwiKS5kYXRhKFtcInBsYW5lXCJdKVxuICBwbGFuZS5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAuYXR0cihcImlkXCIsXCJwbGFuZVwiKVxuICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgZ3JhcGgubWFyZ2luLmxlZnQgKyBcIixcIiArIGdyYXBoLm1hcmdpbi50b3AgKyBcIilcIilcblxuICAvLyBFbnRlciBCYWNrZ3JvdW5kIFJlY3RhbmdsZVxuICB2YXIgYmcgPSBwbGFuZS5zZWxlY3RBbGwoXCJyZWN0I2JhY2tncm91bmRcIikuZGF0YShbXCJiYWNrZ3JvdW5kXCJdKVxuICBiZy5lbnRlcigpLmFwcGVuZChcInJlY3RcIilcbiAgICAuYXR0cihcImlkXCIsXCJiYWNrZ3JvdW5kXCIpXG4gICAgLmF0dHIoXCJ4XCIsMClcbiAgICAuYXR0cihcInlcIiwwKVxuICAgIC5hdHRyKFwid2lkdGhcIiwgZ3JhcGgud2lkdGgpXG4gICAgLmF0dHIoXCJoZWlnaHRcIiwgZ3JhcGguaGVpZ2h0KVxuICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsMSlcbiAgICAuYXR0cihcInN0cm9rZVwiLFwiI2NjY1wiKVxuICAgIC5hdHRyKFwic2hhcGUtcmVuZGVyaW5nXCIsdmFycy5zaGFwZS5yZW5kZXJpbmcudmFsdWUpXG4gICAgLmF0dHIoXCJmaWxsXCIsXCIjZmFmYWZhXCIpXG5cbiAgLy8gRW50ZXIgQmFja2dyb3VuZCBNaXJyb3JcbiAgdmFyIG1pcnJvciA9IHBsYW5lLnNlbGVjdEFsbChcInBhdGgjbWlycm9yXCIpLmRhdGEoW1wibWlycm9yXCJdKVxuICBtaXJyb3IuZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpXG4gICAgLmF0dHIoXCJpZFwiLFwibWlycm9yXCIpXG4gICAgLmF0dHIoXCJmaWxsXCIsXCIjMDAwXCIpXG4gICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwwLjAzKVxuICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsMSlcbiAgICAuYXR0cihcInN0cm9rZVwiLFwiI2NjY1wiKVxuICAgIC5hdHRyKFwic3Ryb2tlLWRhc2hhcnJheVwiLFwiMTAsMTBcIilcbiAgICAuYXR0cihcIm9wYWNpdHlcIiwwKVxuXG4gIC8vIEVudGVyIEF4ZXNcbiAgdmFyIGF4ZXMgPSB2YXJzLmdyb3VwLnNlbGVjdEFsbChcImcjYXhlc1wiKS5kYXRhKFtcImF4ZXNcIl0pXG4gIGF4ZXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgLmF0dHIoXCJpZFwiLFwiYXhlc1wiKVxuXG4gIC8vIEVudGVyIFggQXhpcyBHcmlkXG4gIHZhciB4Z3JpZCA9IHBsYW5lLnNlbGVjdEFsbChcImcjeGdyaWRcIikuZGF0YShbXCJ4Z3JpZFwiXSlcbiAgeGdyaWQuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgLmF0dHIoXCJpZFwiLFwieGdyaWRcIilcblxuICAvLyBFbnRlciBZIEF4aXMgR3JpZFxuICB2YXIgeWdyaWQgPSBwbGFuZS5zZWxlY3RBbGwoXCJnI3lncmlkXCIpLmRhdGEoW1wieWdyaWRcIl0pXG4gIHlncmlkLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgIC5hdHRyKFwiaWRcIixcInlncmlkXCIpXG5cbiAgLy8gRW50ZXIgWCBBeGlzIFNjYWxlXG4gIHZhciB4YXhpcyA9IHBsYW5lLnNlbGVjdEFsbChcImcjeGF4aXNcIikuZGF0YShbXCJ4YXhpc1wiXSlcbiAgeGF4aXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgLmF0dHIoXCJpZFwiLFwieGF4aXNcIilcbiAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgZ3JhcGguaGVpZ2h0ICsgXCIpXCIpXG4gICAgLmNhbGwodmFycy54X2F4aXMuc2NhbGUodmFycy54X3NjYWxlKSlcbiAgICAuc2VsZWN0QWxsKFwiZy50aWNrXCIpLnNlbGVjdChcInRleHRcIilcbiAgICAgIC5hdHRyKHRpY2tBdHRycylcbiAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIseEFuY2hvcilcbiAgICAgIC5hdHRyKFwiZHlcIix4RHkpXG4gICAgICAuYXR0cihcInRyYW5zZm9ybVwiLHhUcmFuc2Zvcm0pXG5cbiAgLy8gRW50ZXIgWSBBeGlzIFNjYWxlXG4gIHZhciB5YXhpcyA9IHBsYW5lLnNlbGVjdEFsbChcImcjeWF4aXNcIikuZGF0YShbXCJ5YXhpc1wiXSlcbiAgeWF4aXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgLmF0dHIoXCJpZFwiLFwieWF4aXNcIilcbiAgICAuY2FsbCh2YXJzLnlfYXhpcy5zY2FsZSh2YXJzLnlfc2NhbGUpKVxuICAgIC5zZWxlY3RBbGwoXCJnLnRpY2tcIikuc2VsZWN0KFwidGV4dFwiKVxuICAgICAgLmF0dHIodGlja0F0dHJzKVxuXG4gIC8vIEVudGVyIFggQXhpcyBMYWJlbFxuICB2YXIgeGxhYmVsID0gYXhlcy5zZWxlY3RBbGwoXCJ0ZXh0I3hsYWJlbFwiKS5kYXRhKHZhcnMuc21hbGwgPyBbXSA6IFtcInhsYWJlbFwiXSlcbiAgeGxhYmVsLmVudGVyKCkuYXBwZW5kKFwidGV4dFwiKVxuICAgIC5hdHRyKFwiaWRcIiwgXCJ4bGFiZWxcIilcbiAgICAuYXR0cihcInhcIiwgdmFycy53aWR0aC52aXovMilcbiAgICAuYXR0cihcInlcIiwgdmFycy5oZWlnaHQudml6LTEwKVxuICAgIC50ZXh0KHZhcnMuZm9ybWF0LnZhbHVlKHZhcnMueC52YWx1ZSkpXG4gICAgLmF0dHIoXCJmb250LWZhbWlseVwiLHZhcnMubGFiZWxzLmZvbnQuZmFtaWx5LnZhbHVlKVxuICAgIC5hdHRyKFwiZm9udC13ZWlnaHRcIix2YXJzLmxhYmVscy5mb250LndlaWdodClcbiAgICAuYXR0cihcImZvbnQtc2l6ZVwiLHZhcnMubGFiZWxzLmZvbnQuc2l6ZSlcbiAgICAuYXR0cihcImZpbGxcIix2YXJzLmxhYmVscy5mb250LmNvbG9yKVxuICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsdmFycy5sYWJlbHMuZm9udC5hbGlnbilcbiAgeGxhYmVsLmV4aXQoKS5yZW1vdmUoKVxuXG4gIC8vIEVudGVyIFkgQXhpcyBMYWJlbFxuICB2YXIgeWxhYmVsID0gYXhlcy5zZWxlY3RBbGwoXCJ0ZXh0I3lsYWJlbFwiKS5kYXRhKHZhcnMuc21hbGwgPyBbXSA6IFtcInlsYWJlbFwiXSlcbiAgeWxhYmVsLmVudGVyKCkuYXBwZW5kKFwidGV4dFwiKVxuICAgIC5hdHRyKFwiaWRcIiwgXCJ5bGFiZWxcIilcbiAgICAuYXR0cihcInlcIiwgMTUpXG4gICAgLmF0dHIoXCJ4XCIsIC0oZ3JhcGguaGVpZ2h0LzIrZ3JhcGgubWFyZ2luLnRvcCkpXG4gICAgLnRleHQodmFycy5mb3JtYXQudmFsdWUodmFycy55LnZhbHVlKSlcbiAgICAuYXR0cihcInRyYW5zZm9ybVwiLFwicm90YXRlKC05MClcIilcbiAgICAuYXR0cihcImZvbnQtZmFtaWx5XCIsdmFycy5sYWJlbHMuZm9udC5mYW1pbHkudmFsdWUpXG4gICAgLmF0dHIoXCJmb250LXdlaWdodFwiLHZhcnMubGFiZWxzLmZvbnQud2VpZ2h0KVxuICAgIC5hdHRyKFwiZm9udC1zaXplXCIsdmFycy5sYWJlbHMuZm9udC5zaXplKVxuICAgIC5hdHRyKFwiZmlsbFwiLHZhcnMubGFiZWxzLmZvbnQuY29sb3IpXG4gICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIix2YXJzLmxhYmVscy5mb250LmFsaWduKVxuICB5bGFiZWwuZXhpdCgpLnJlbW92ZSgpXG5cbiAgLy8gRW50ZXIgTW91c2UgRXZlbnQgR3JvdXBcbiAgdmFyIG1vdXNlZXZlbnRzID0gdmFycy5ncm91cC5zZWxlY3RBbGwoXCJnI21vdXNlZXZlbnRzXCIpLmRhdGEoW1wibW91c2VldmVudHNcIl0pXG4gIG1vdXNlZXZlbnRzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgIC5hdHRyKFwiaWRcIixcIm1vdXNlZXZlbnRzXCIpXG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIFVwZGF0ZSBTVkcgRWxlbWVudHNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gVXBkYXRlIFBsYW5lIEdyb3VwXG4gIHBsYW5lLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgZ3JhcGgubWFyZ2luLmxlZnQgKyBcIixcIiArIGdyYXBoLm1hcmdpbi50b3AgKyBcIilcIilcblxuICAvLyBVcGRhdGUgUGxhbmUgQmFja2dyb3VuZFxuICBiZy5hdHRyKFwid2lkdGhcIiwgZ3JhcGgud2lkdGgpXG4gICAgLmF0dHIoXCJoZWlnaHRcIiwgZ3JhcGguaGVpZ2h0KVxuXG4gIC8vIFVwZGF0ZSBNaXJyb3IgVHJpYW5nbGVcbiAgbWlycm9yLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgIC5hdHRyKFwib3BhY2l0eVwiLGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdmFycy5heGVzLm1pcnJvci52YWx1ZSA/IDEgOiAwXG4gICAgfSlcbiAgICAuYXR0cihcImRcIixmdW5jdGlvbigpe1xuICAgICAgdmFyIHcgPSBncmFwaC53aWR0aCwgaCA9IGdyYXBoLmhlaWdodFxuICAgICAgcmV0dXJuIFwiTSBcIit3K1wiIFwiK2grXCIgTCAwIFwiK2grXCIgTCBcIit3K1wiIDAgWlwiXG4gICAgfSlcblxuICAvLyBVcGRhdGUgWSBBeGlzXG4gIHlheGlzLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgIC5jYWxsKHZhcnMueV9heGlzLnNjYWxlKHZhcnMueV9zY2FsZSkpXG4gICAgLnNlbGVjdEFsbChcImcudGlja1wiKS5zZWxlY3QoXCJ0ZXh0XCIpXG4gICAgICAuYXR0cih0aWNrQXR0cnMpXG5cbiAgeWF4aXMuc2VsZWN0QWxsKFwibGluZVwiKS50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgIC5jYWxsKHRpY2tfc3R5bGUsXCJ5XCIpXG5cbiAgeWF4aXMuc2VsZWN0QWxsKFwicGF0aFwiKS5hdHRyKFwiZmlsbFwiLFwibm9uZVwiKVxuXG4gIC8vIFVwZGF0ZSBYIEF4aXNcbiAgeGF4aXMudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGdyYXBoLmhlaWdodCArIFwiKVwiKVxuICAgIC5jYWxsKHZhcnMueF9heGlzLnNjYWxlKHZhcnMueF9zY2FsZSkpXG4gICAgLnNlbGVjdEFsbChcImcudGlja1wiKS5zZWxlY3QoXCJ0ZXh0XCIpXG4gICAgICAuYXR0cih0aWNrQXR0cnMpXG4gICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLHhBbmNob3IpXG4gICAgICAuYXR0cihcImR5XCIseER5KVxuICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIix4VHJhbnNmb3JtKVxuXG4gIHhheGlzLnNlbGVjdEFsbChcImxpbmVcIikudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAuY2FsbCh0aWNrX3N0eWxlLFwieFwiKVxuXG4gIHhheGlzLnNlbGVjdEFsbChcInBhdGhcIikuYXR0cihcImZpbGxcIixcIm5vbmVcIilcblxuICAvLyBVcGRhdGUgWSBHcmlkXG4gIHZhciB5bGluZXMgPSB5Z3JpZC5zZWxlY3RBbGwoXCJsaW5lXCIpXG4gICAgLmRhdGEodmFycy55LnRpY2tzKVxuXG4gIHlsaW5lcy5lbnRlcigpLmFwcGVuZChcImxpbmVcIilcbiAgICAuc3R5bGUoXCJvcGFjaXR5XCIsMClcbiAgICAuY2FsbCh0aWNrX3Bvc2l0aW9uLFwieVwiKVxuICAgIC5jYWxsKHRpY2tfc3R5bGUsXCJ5XCIpXG5cbiAgeWxpbmVzLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgIC5zdHlsZShcIm9wYWNpdHlcIiwxKVxuICAgIC5jYWxsKHRpY2tfcG9zaXRpb24sXCJ5XCIpXG4gICAgLmNhbGwodGlja19zdHlsZSxcInlcIilcblxuICB5bGluZXMuZXhpdCgpLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgIC5zdHlsZShcIm9wYWNpdHlcIiwwKVxuICAgIC5yZW1vdmUoKVxuXG4gIC8vIFVwZGF0ZSBYIEdyaWRcbiAgdmFyIHhsaW5lcyA9IHhncmlkLnNlbGVjdEFsbChcImxpbmVcIilcbiAgICAuZGF0YSh2YXJzLngudGlja3MpXG5cbiAgeGxpbmVzLmVudGVyKCkuYXBwZW5kKFwibGluZVwiKVxuICAgIC5zdHlsZShcIm9wYWNpdHlcIiwwKVxuICAgIC5jYWxsKHRpY2tfcG9zaXRpb24sXCJ4XCIpXG4gICAgLmNhbGwodGlja19zdHlsZSxcInhcIilcblxuICB4bGluZXMudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgLnN0eWxlKFwib3BhY2l0eVwiLDEpXG4gICAgLmNhbGwodGlja19wb3NpdGlvbixcInhcIilcbiAgICAuY2FsbCh0aWNrX3N0eWxlLFwieFwiKVxuXG4gIHhsaW5lcy5leGl0KCkudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgLnN0eWxlKFwib3BhY2l0eVwiLDApXG4gICAgLnJlbW92ZSgpXG5cbiAgLy8gVXBkYXRlIFggQXhpcyBMYWJlbFxuICB4bGFiZWwudGV4dCh2YXJzLmZvcm1hdC52YWx1ZSh2YXJzLngudmFsdWUpKVxuICAgIC5hdHRyKFwieFwiLCB2YXJzLndpZHRoLnZpei8yKVxuICAgIC5hdHRyKFwieVwiLCB2YXJzLmhlaWdodC52aXotMTApXG4gICAgLmF0dHIoXCJvcGFjaXR5XCIsZnVuY3Rpb24oKXtcbiAgICAgIGlmICh2YXJzLmRhdGEuYXBwLmxlbmd0aCA9PSAwKSByZXR1cm4gMFxuICAgICAgZWxzZSByZXR1cm4gMVxuICAgIH0pXG5cbiAgLy8gVXBkYXRlIFkgQXhpcyBMYWJlbFxuICB5bGFiZWwudGV4dCh2YXJzLmZvcm1hdC52YWx1ZSh2YXJzLnkudmFsdWUpKVxuICAgIC5hdHRyKFwieVwiLCAxNSlcbiAgICAuYXR0cihcInhcIiwgLShncmFwaC5oZWlnaHQvMitncmFwaC5tYXJnaW4udG9wKSlcbiAgICAuYXR0cihcIm9wYWNpdHlcIixmdW5jdGlvbigpe1xuICAgICAgaWYgKHZhcnMuZGF0YS5hcHAubGVuZ3RoID09IDApIHJldHVybiAwXG4gICAgICBlbHNlIHJldHVybiAxXG4gICAgfSlcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gRW50ZXIvVXBkYXRlIFVzZXItRGVmaW5lZCBBeGlzIExpbmVzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGZ1bmN0aW9uIGdldF9uYW1lKGQpIHtcbiAgICBpZiAodHlwZW9mIGQgPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgZCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gZDMua2V5cyhkKVswXVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldF92YWwoZCkge1xuICAgIGlmICh0eXBlb2YgZCA9PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gZDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHYgPSBkW2QzLmtleXMoZClbMF1dXG4gICAgICBpZiAodHlwZW9mIHYgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXJzLmF4ZXMudmFsdWVzLmZvckVhY2goZnVuY3Rpb24oYXhpcyl7XG5cbiAgICB2YXIgbGluZXMgPSBwbGFuZS5zZWxlY3RBbGwoXCJnLmQzcGx1c19cIitheGlzK1wibGluZVwiKVxuICAgICAgLmRhdGEodmFyc1theGlzXS5saW5lcyxmdW5jdGlvbihsKXtcbiAgICAgICAgaWYgKHR5cGVvZiBsID09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGwgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJldHVybiBsXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGQzLmtleXMobClbMF1cbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgIHZhciBlbnRlciA9IGxpbmVzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgICAgLmF0dHIoXCJjbGFzc1wiLFwiZDNwbHVzX1wiK2F4aXMrXCJsaW5lXCIpXG5cbiAgICB2YXIgbWF4ID0gYXhpcyA9PSBcInhcIiA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCIsXG4gICAgICAgIHBvcyA9IGF4aXMgPT0gXCJ4XCIgPyAoZ3JhcGguaGVpZ2h0LTgpK1wicHhcIiA6IFwiMTBweFwiLFxuICAgICAgICBwYWRkaW5nID0gYXhpcyA9PSBcInhcIiA/IDEwIDogMjBcblxuICAgIGVudGVyLmFwcGVuZChcImxpbmVcIilcbiAgICAgIC5hdHRyKGF4aXMrXCIxXCIsMClcbiAgICAgIC5hdHRyKGF4aXMrXCIyXCIsZ3JhcGhbbWF4XSlcbiAgICAgIC5hdHRyKFwic3Ryb2tlXCIsXCIjY2NjXCIpXG4gICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLDMpXG4gICAgICAuYXR0cihcInN0cm9rZS1kYXNoYXJyYXlcIixcIjEwLDEwXCIpXG5cbiAgICBlbnRlci5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAuYXR0cihcImZvbnQtc2l6ZVwiLHZhcnMuYXhlcy50aWNrcy5mb250LnNpemUpXG4gICAgICAuYXR0cihcImZpbGxcIix2YXJzLmF4ZXMudGlja3MuZm9udC5jb2xvcilcbiAgICAgIC5hdHRyKFwidGV4dC1hbGlnblwiLFwic3RhcnRcIilcbiAgICAgIC5hdHRyKGF4aXMscG9zKVxuXG4gICAgbGluZXMuc2VsZWN0QWxsKFwibGluZVwiKS50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgIC5hdHRyKGF4aXMrXCIxXCIsZnVuY3Rpb24oZCl7XG4gICAgICAgIHJldHVybiBnZXRfdmFsKGQpID8gdmFyc1theGlzK1wiX3NjYWxlXCJdKGdldF92YWwoZCkpIDogMFxuICAgICAgfSlcbiAgICAgIC5hdHRyKGF4aXMrXCIyXCIsZnVuY3Rpb24oZCl7XG4gICAgICAgIHJldHVybiBnZXRfdmFsKGQpID8gdmFyc1theGlzK1wiX3NjYWxlXCJdKGdldF92YWwoZCkpIDogMFxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwib3BhY2l0eVwiLGZ1bmN0aW9uKGQpe1xuICAgICAgICB2YXIgeWVzID0gZ2V0X3ZhbChkKSA+IHZhcnNbYXhpcytcIl9zY2FsZVwiXS5kb21haW4oKVsxXSAmJiBnZXRfdmFsKGQpIDwgdmFyc1theGlzK1wiX3NjYWxlXCJdLmRvbWFpbigpWzBdXG4gICAgICAgIHJldHVybiBnZXRfdmFsKGQpICE9PSBudWxsICYmIHllcyA/IDEgOiAwXG4gICAgICB9KVxuXG4gICAgbGluZXMuc2VsZWN0QWxsKFwidGV4dFwiKS50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgIC50ZXh0KGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmIChnZXRfdmFsKGQpICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIHYgPSB2YXJzLmZvcm1hdC52YWx1ZShnZXRfdmFsKGQpLHlfbmFtZSlcbiAgICAgICAgICByZXR1cm4gZ2V0X25hbWUoZCkgPyB2YXJzLmZvcm1hdC52YWx1ZShnZXRfbmFtZShkKSkgKyBcIjogXCIgKyB2IDogdlxuICAgICAgICB9XG4gICAgICAgIGVsc2UgcmV0dXJuIG51bGxcbiAgICAgIH0pXG4gICAgICAuYXR0cihheGlzLGZ1bmN0aW9uKGQpe1xuICAgICAgICByZXR1cm4gKHZhcnNbYXhpcytcIl9zY2FsZVwiXShnZXRfdmFsKGQpKStwYWRkaW5nKStcInB4XCJcbiAgICAgIH0pXG5cbiAgfSlcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gRm9ybWF0IERhdGEgZm9yIFBsb3R0aW5nXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGlmIChbXCJsaW5lXCIsXCJhcmVhXCJdLmluZGV4T2YodmFycy5zaGFwZS52YWx1ZSkgPj0gMCkge1xuICAgIHJhZGl1cy5yYW5nZVJvdW5kKFsyLDJdKVxuICB9XG5cbiAgdmFycy5heGlzX29mZnNldCA9IHtcbiAgICBcInhcIjogZ3JhcGgubWFyZ2luLmxlZnQsXG4gICAgXCJ5XCI6IGdyYXBoLm1hcmdpbi50b3BcbiAgfVxuXG4gIGRhdGEuZm9yRWFjaChmdW5jdGlvbihkKXtcbiAgICBkLmQzcGx1cy54ID0gdmFycy54X3NjYWxlKGZldGNoVmFsdWUodmFycyxkLHZhcnMueC52YWx1ZSkpXG4gICAgZC5kM3BsdXMueCArPSB2YXJzLmF4aXNfb2Zmc2V0LnhcblxuICAgIGQuZDNwbHVzLnIgPSByYWRpdXMoZmV0Y2hWYWx1ZSh2YXJzLGQsdmFycy5zaXplLnZhbHVlKSlcblxuICAgIGlmICghdmFycy5zdGFja2VkX2F4aXMpIHtcblxuICAgICAgZC5kM3BsdXMueSA9IHZhcnMueV9zY2FsZShmZXRjaFZhbHVlKHZhcnMsZCx2YXJzLnkudmFsdWUpKVxuICAgICAgZC5kM3BsdXMueSArPSB2YXJzLmF4aXNfb2Zmc2V0LnlcblxuICAgICAgaWYgKHZhcnMuc2hhcGUudmFsdWUgPT0gXCJhcmVhXCIpIHtcbiAgICAgICAgZC5kM3BsdXNbdmFycy5vcHBfYXhpcytcIjBcIl0gPSB2YXJzW3ZhcnMub3BwX2F4aXMrXCJfc2NhbGVcIl0ucmFuZ2UoKVsxXVxuICAgICAgICBkLmQzcGx1c1t2YXJzLm9wcF9heGlzK1wiMFwiXSArPSB2YXJzLmF4aXNfb2Zmc2V0W3ZhcnMub3BwX2F4aXNdXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfSlcblxuICB2YXIgc29ydCA9IHZhcnMub3JkZXIudmFsdWUgPyB2YXJzLm9yZGVyLnZhbHVlIDogdmFycy5jb250aW51b3VzX2F4aXNcbiAgICAgICAgICAgPyB2YXJzW3ZhcnMub3BwX2F4aXNdLnZhbHVlIDogdmFycy5zaXplLnZhbHVlIHx8IHZhcnMuaWQudmFsdWVcblxuICBpZiAoW1wibGluZVwiLFwiYXJlYVwiXS5pbmRleE9mKHZhcnMuc2hhcGUudmFsdWUpID49IDApIHtcblxuICAgIGRhdGEgPSBkMy5uZXN0KClcbiAgICAgIC5rZXkoZnVuY3Rpb24oZCl7XG4gICAgICAgIHZhciBpZCA9IGZldGNoVmFsdWUodmFycyxkLHZhcnMuaWQudmFsdWUpLFxuICAgICAgICAgICAgZGVwdGggPSBkLmQzcGx1cy5kZXB0aCA/IGQuZDNwbHVzLmRlcHRoIDogMFxuICAgICAgICByZXR1cm4gZDNwbHVzLnN0cmluZy5zdHJpcChpZCkrXCJfXCIrZGVwdGgrXCJfXCIrdmFycy5zaGFwZS52YWx1ZVxuICAgICAgfSlcbiAgICAgIC5yb2xsdXAoZnVuY3Rpb24obGVhdmVzKXtcblxuICAgICAgICB2YXIgYXZhaWxhYmxlcyA9IGQzcGx1cy51dGlsLnVuaXF1ZXMobGVhdmVzLHZhcnNbdmFycy5jb250aW51b3VzX2F4aXNdLnZhbHVlKSxcbiAgICAgICAgICAgIHByZXZpb3VzTWlzc2luZyA9IGZhbHNlLFxuICAgICAgICAgICAgdGltZVZhcnMgPSB2YXJzW3ZhcnMuY29udGludW91c19heGlzXS52YWx1ZSA9PT0gdmFycy50aW1lLnZhbHVlXG5cbiAgICAgICAgaWYgKHRpbWVWYXJzICYmIGF2YWlsYWJsZXNbMF0uY29uc3RydWN0b3IgPT09IERhdGUpIHtcbiAgICAgICAgICBhdmFpbGFibGVzID0gYXZhaWxhYmxlcy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2V0VGltZSgpfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHZhcnNbdmFycy5jb250aW51b3VzX2F4aXNdLnRpY2tzLmZvckVhY2goZnVuY3Rpb24odixpLGFycil7XG5cbiAgICAgICAgICB2YXIgdGVzdGVyID0gdGltZVZhcnMgPyB2LmdldFRpbWUoKSA6IHZcblxuICAgICAgICAgIGlmKGF2YWlsYWJsZXMuaW5kZXhPZih0ZXN0ZXIpIDwgMCl7XG5cbiAgICAgICAgICAgIHZhciBvYmogPSB7fVxuICAgICAgICAgICAgb2JqW3ZhcnNbdmFycy5jb250aW51b3VzX2F4aXNdLnZhbHVlXSA9IHZcbiAgICAgICAgICAgIG9ialt2YXJzLmlkLnZhbHVlXSA9IGxlYXZlc1swXVt2YXJzLmlkLnZhbHVlXVxuICAgICAgICAgICAgb2JqW3ZhcnNbdmFycy5vcHBfYXhpc10udmFsdWVdID0gdmFyc1t2YXJzLm9wcF9heGlzK1wiX3NjYWxlXCJdLmRvbWFpbigpWzFdXG4gICAgICAgICAgICBvYmouZDNwbHVzID0ge31cblxuICAgICAgICAgICAgb2JqLmQzcGx1cy5yID0gcmFkaXVzKHJhZGl1cy5kb21haW4oKVswXSlcbiAgICAgICAgICAgIG9iai5kM3BsdXNbdmFycy5jb250aW51b3VzX2F4aXNdICs9IHZhcnMuYXhpc19vZmZzZXRbdmFycy5jb250aW51b3VzX2F4aXNdXG5cbiAgICAgICAgICAgIGlmICghdmFycy5zdGFja2VkX2F4aXMpIHtcbiAgICAgICAgICAgICAgb2JqLmQzcGx1c1t2YXJzLm9wcF9heGlzXSA9IHZhcnNbdmFycy5vcHBfYXhpcytcIl9zY2FsZVwiXS5yYW5nZSgpWzFdXG4gICAgICAgICAgICAgIG9iai5kM3BsdXNbdmFycy5vcHBfYXhpc10gKz0gdmFycy5heGlzX29mZnNldFt2YXJzLm9wcF9heGlzXVxuICAgICAgICAgICAgICBvYmouZDNwbHVzW3ZhcnMub3BwX2F4aXMrXCIwXCJdID0gb2JqLmQzcGx1c1t2YXJzLm9wcF9heGlzXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFyc1t2YXJzLmNvbnRpbnVvdXNfYXhpc10uemVyb2ZpbGwudmFsdWUgfHwgdmFyc1t2YXJzLm9wcF9heGlzXS5zdGFja2VkLnZhbHVlKSB7XG4gICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHZhcnNbdmFycy5jb250aW51b3VzX2F4aXMrXCJfc2NhbGVcIl0odilcbiAgICAgICAgICAgICAgcG9zaXRpb24gKz0gdmFycy5heGlzX29mZnNldFt2YXJzLmNvbnRpbnVvdXNfYXhpc11cbiAgICAgICAgICAgICAgb2JqLmQzcGx1c1t2YXJzLmNvbnRpbnVvdXNfYXhpc10gPSBwb3NpdGlvblxuICAgICAgICAgICAgICBsZWF2ZXMucHVzaChvYmopXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YXJzLnNoYXBlLnZhbHVlICE9IFwibGluZVwiKSB7XG4gICAgICAgICAgICAgIGlmICghcHJldmlvdXNNaXNzaW5nICYmIGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdmFyc1t2YXJzLmNvbnRpbnVvdXNfYXhpcytcIl9zY2FsZVwiXShhcnJbaS0xXSlcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSB2YXJzLmF4aXNfb2Zmc2V0W3ZhcnMuY29udGludW91c19heGlzXVxuICAgICAgICAgICAgICAgIG9iai5kM3BsdXNbdmFycy5jb250aW51b3VzX2F4aXNdID0gcG9zaXRpb25cbiAgICAgICAgICAgICAgICBsZWF2ZXMucHVzaChvYmopXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGkgPCBhcnIubGVuZ3RoLTEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB2YXJzW3ZhcnMuY29udGludW91c19heGlzK1wiX3NjYWxlXCJdKGFycltpKzFdKVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IHZhcnMuYXhpc19vZmZzZXRbdmFycy5jb250aW51b3VzX2F4aXNdXG4gICAgICAgICAgICAgICAgdmFyIG9iajIgPSBkM3BsdXMudXRpbC5jb3B5KG9iailcbiAgICAgICAgICAgICAgICBvYmoyLmQzcGx1c1t2YXJzLmNvbnRpbnVvdXNfYXhpc10gPSBwb3NpdGlvblxuICAgICAgICAgICAgICAgIGxlYXZlcy5wdXNoKG9iajIpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzTWlzc2luZyA9IHRydWVcblxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByZXZpb3VzTWlzc2luZyA9IGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0pXG5cbiAgICAgICAgbGVhdmVzLnNvcnQoZnVuY3Rpb24oYSxiKXtcbiAgICAgICAgICB2YXIgeHNvcnQgPSBhLmQzcGx1c1t2YXJzLmNvbnRpbnVvdXNfYXhpc10gLSBiLmQzcGx1c1t2YXJzLmNvbnRpbnVvdXNfYXhpc11cbiAgICAgICAgICBpZiAoeHNvcnQpIHJldHVybiB4c29ydFxuICAgICAgICAgIHZhciBrc29ydCA9IGFbdmFyc1t2YXJzLmNvbnRpbnVvdXNfYXhpc10udmFsdWVdIC0gYlt2YXJzW3ZhcnMuY29udGludW91c19heGlzXS52YWx1ZV1cbiAgICAgICAgICByZXR1cm4ga3NvcnRcbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gbGVhdmVzXG4gICAgICB9KVxuICAgICAgLmVudHJpZXMoZGF0YSlcblxuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihkLGkpe1xuXG4gICAgICBpZiAoXCJkM3BsdXNcIiBpbiBkLnZhbHVlc1swXSkge1xuXG4gICAgICAgIGlmICghZC5kM3BsdXMpIGQuZDNwbHVzID0ge31cblxuICAgICAgICBkLnZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKGwpe1xuICAgICAgICAgIGlmIChsLmQzcGx1cy5tZXJnZWQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgaWYgKCFkLmQzcGx1cy5tZXJnZWQpIGQuZDNwbHVzLm1lcmdlZCA9IFtdXG4gICAgICAgICAgICBkLmQzcGx1cy5tZXJnZWQgPSBkLmQzcGx1cy5tZXJnZWQuY29uY2F0KGwuZDNwbHVzLm1lcmdlZClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGwuZDNwbHVzLnRleHQpIGQuZDNwbHVzLnRleHQgPSBsLmQzcGx1cy50ZXh0XG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHZhcnMuaWQubmVzdGluZy5mb3JFYWNoKGZ1bmN0aW9uKG4saSl7XG4gICAgICAgIGlmIChpIDw9IHZhcnMuZGVwdGgudmFsdWUgJiYgIWRbbl0pIHtcbiAgICAgICAgICBkW25dID0gZDNwbHVzLnV0aWwudW5pcXVlcyhkLnZhbHVlcyxuKS5maWx0ZXIoZnVuY3Rpb24odW5pcXVlKXtcbiAgICAgICAgICAgIHJldHVybiB1bmlxdWUgJiYgdW5pcXVlICE9IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICB9KVswXVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBpZiAoICEoc29ydCBpbiBkKSApIHtcbiAgICAgICAgZFtzb3J0XSA9IDBcbiAgICAgICAgZC52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbih2KXtcbiAgICAgICAgICB2YXIgdmFsID0gZmV0Y2hWYWx1ZSh2YXJzLHYsc29ydClcbiAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgIGRbc29ydF0gKz0gdmFsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgZFtzb3J0XSA9IHZhbFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgIH0pXG5cbiAgfVxuXG4gIGlmIChzb3J0KSB7XG5cbiAgICBkM3BsdXMuYXJyYXkuc29ydCggZGF0YSAsIHNvcnRcbiAgICAgICAgICAgICAgICAgICAgICwgdmFycy5vcmRlci5zb3J0LnZhbHVlID09PSBcImRlc2NcIiA/IFwiYXNjXCIgOiBcImRlc2NcIlxuICAgICAgICAgICAgICAgICAgICAgLCB2YXJzLmNvbG9yLnZhbHVlIHx8IFtdICwgdmFycyApXG5cbiAgfVxuXG4gIGlmICh2YXJzLnN0YWNrZWRfYXhpcykge1xuXG4gICAgdmFyIHN0YWNrID0gZDMubGF5b3V0LnN0YWNrKClcbiAgICAgIC52YWx1ZXMoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXM7IH0pXG4gICAgICAueChmdW5jdGlvbihkKSB7IHJldHVybiBkLmQzcGx1cy54OyB9KVxuICAgICAgLy8gLngoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5kM3BsdXMueTsgfSlcbiAgICAgIC55KGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdmFyIGZsaXAgPSBncmFwaC5oZWlnaHQsXG4gICAgICAgICAgICB2YWwgPSBmZXRjaFZhbHVlKHZhcnMsZCx2YXJzLnkudmFsdWUpXG4gICAgICAgIHJldHVybiBmbGlwLXZhcnMueV9zY2FsZSh2YWwpO1xuICAgICAgfSlcbiAgICAgIC5vdXQoZnVuY3Rpb24oZCx5MCx5KXtcblxuICAgICAgICB2YXIgZmxpcCA9IGdyYXBoLmhlaWdodFxuXG4gICAgICAgIGlmICh2YXJzW3ZhcnMuc3RhY2tlZF9heGlzXS5zY2FsZS52YWx1ZSA9PSBcInNoYXJlXCIpIHtcbiAgICAgICAgICBkLmQzcGx1cy55MCA9ICgxLXkwKSpmbGlwXG4gICAgICAgICAgZC5kM3BsdXMueSA9IGQuZDNwbHVzLnkwLSh5KmZsaXApXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZC5kM3BsdXMueTAgPSBmbGlwLXkwXG4gICAgICAgICAgZC5kM3BsdXMueSA9IGQuZDNwbHVzLnkwLXlcbiAgICAgICAgfVxuICAgICAgICBkLmQzcGx1cy55ICs9IGdyYXBoLm1hcmdpbi50b3BcbiAgICAgICAgZC5kM3BsdXMueTAgKz0gZ3JhcGgubWFyZ2luLnRvcFxuXG4gICAgICB9KVxuXG4gICAgdmFyIG9mZnNldCA9IHZhcnNbdmFycy5zdGFja2VkX2F4aXNdLnNjYWxlLnZhbHVlID09IFwic2hhcmVcIiA/IFwiZXhwYW5kXCIgOiBcInplcm9cIjtcbiAgICB2YXIgZGF0YSA9IHN0YWNrLm9mZnNldChvZmZzZXQpKGRhdGEpXG5cbiAgfVxuICBlbHNlIGlmIChbXCJhcmVhXCIsXCJsaW5lXCJdLmluZGV4T2YodmFycy5zaGFwZS52YWx1ZSkgPCAwKSB7XG5cbiAgICBmdW5jdGlvbiBkYXRhX3RpY2sobCxheGlzKSB7XG4gICAgICBsXG4gICAgICAgIC5hdHRyKFwieDFcIixmdW5jdGlvbihkKXtcbiAgICAgICAgICByZXR1cm4gYXhpcyA9PSBcInlcIiA/IDAgOiBkLmQzcGx1cy54LWdyYXBoLm1hcmdpbi5sZWZ0XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwieDJcIixmdW5jdGlvbihkKXtcbiAgICAgICAgICByZXR1cm4gYXhpcyA9PSBcInlcIiA/IC01IDogZC5kM3BsdXMueC1ncmFwaC5tYXJnaW4ubGVmdFxuICAgICAgICB9KVxuICAgICAgICAuYXR0cihcInkxXCIsZnVuY3Rpb24oZCl7XG4gICAgICAgICAgcmV0dXJuIGF4aXMgPT0gXCJ4XCIgPyBncmFwaC5oZWlnaHQgOiBkLmQzcGx1cy55LWdyYXBoLm1hcmdpbi50b3BcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJ5MlwiLGZ1bmN0aW9uKGQpe1xuICAgICAgICAgIHJldHVybiBheGlzID09IFwieFwiID8gZ3JhcGguaGVpZ2h0KzUgOiBkLmQzcGx1cy55LWdyYXBoLm1hcmdpbi50b3BcbiAgICAgICAgfSlcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsZnVuY3Rpb24oZCl7XG4gICAgICAgICAgcmV0dXJuIGQzcGx1cy5jb2xvci5sZWdpYmxlKGZldGNoQ29sb3IodmFycyxkKSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLHZhcnMuZGF0YS5zdHJva2Uud2lkdGgpXG4gICAgICAgIC5hdHRyKFwic2hhcGUtcmVuZGVyaW5nXCIsdmFycy5zaGFwZS5yZW5kZXJpbmcudmFsdWUpXG4gICAgfVxuXG4gICAgdmFyIGRhdGFfdGlja3MgPSBwbGFuZS5zZWxlY3RBbGwoXCJnLmQzcGx1c19kYXRhX3RpY2tzXCIpXG4gICAgICAuZGF0YShkYXRhLGZ1bmN0aW9uKGQpe1xuICAgICAgICByZXR1cm4gZFt2YXJzLmlkLnZhbHVlXStcIl9cIitkLmQzcGx1cy5kZXB0aFxuICAgICAgfSlcblxuICAgIHZhciB0aWNrX2VudGVyID0gZGF0YV90aWNrcy5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAgIC5hdHRyKFwiY2xhc3NcIixcImQzcGx1c19kYXRhX3RpY2tzXCIpXG4gICAgICAuYXR0cihcIm9wYWNpdHlcIiwwKVxuXG4gICAgdGlja19lbnRlci5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAuYXR0cihcImNsYXNzXCIsXCJkM3BsdXNfZGF0YV95XCIpXG4gICAgICAuY2FsbChkYXRhX3RpY2ssXCJ5XCIpXG5cbiAgICBkYXRhX3RpY2tzLnNlbGVjdEFsbChcImxpbmUuZDNwbHVzX2RhdGFfeVwiKVxuICAgICAgLmNhbGwoZGF0YV90aWNrLFwieVwiKVxuXG4gICAgdGlja19lbnRlci5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAuYXR0cihcImNsYXNzXCIsXCJkM3BsdXNfZGF0YV94XCIpXG4gICAgICAuY2FsbChkYXRhX3RpY2ssXCJ4XCIpXG5cbiAgICBkYXRhX3RpY2tzLnNlbGVjdEFsbChcImxpbmUuZDNwbHVzX2RhdGFfeFwiKVxuICAgICAgLmNhbGwoZGF0YV90aWNrLFwieFwiKVxuXG4gICAgZGF0YV90aWNrcy50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgIC5hdHRyKFwib3BhY2l0eVwiLDEpXG5cbiAgICBkYXRhX3RpY2tzLmV4aXQoKS50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgIC5hdHRyKFwib3BhY2l0eVwiLDApXG4gICAgICAucmVtb3ZlKClcblxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIFBsb3QgZGF0YSBvbiBjaGFydCFcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgZnVuY3Rpb24gYXhpc19saW5lcyhub2RlKSB7XG5cbiAgICB2YXIgY2xpY2tfcmVtb3ZlID0gZDMuZXZlbnQudHlwZSA9PSBkM3BsdXMuZXZ0LmNsaWNrICYmICh2YXJzLnRvb2x0aXAudmFsdWUubG9uZyB8fCB2YXJzLnRvb2x0aXAuaHRtbC52YWx1ZSksXG4gICAgICAgIGNyZWF0ZSA9IFtkM3BsdXMuZXZ0Lm92ZXIsZDNwbHVzLmV2dC5tb3ZlXS5pbmRleE9mKGQzLmV2ZW50LnR5cGUpID49IDBcblxuICAgIGlmICghY2xpY2tfcmVtb3ZlICYmIGNyZWF0ZSAmJiB2YXJzLnNoYXBlLnZhbHVlICE9IFwiYXJlYVwiKSB7XG5cbiAgICAgIGlmIChub2RlLmRhdGEpIHZhciBub2RlID0gbm9kZS5kYXRhXG5cbiAgICAgIHZhciBsaW5lX2RhdGEgPSBbXG4gICAgICAgIGQzcGx1cy51dGlsLmNvcHkobm9kZS5kM3BsdXMpLFxuICAgICAgICBkM3BsdXMudXRpbC5jb3B5KG5vZGUuZDNwbHVzKVxuICAgICAgXVxuICAgICAgbGluZV9kYXRhWzBdLmF4aXMgPSBcInhcIlxuICAgICAgbGluZV9kYXRhWzFdLmF4aXMgPSBcInlcIlxuXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGxpbmVfZGF0YSA9IFtdXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZV9pbml0KGwpIHtcbiAgICAgIGxcbiAgICAgICAgLmF0dHIoXCJ4MlwiLGZ1bmN0aW9uKGQpe1xuICAgICAgICAgIHZhciByZXQgPSBkLmF4aXMgPT0gXCJ4XCIgPyBkLnggOiBkLngtZC5yXG4gICAgICAgICAgcmV0dXJuIHJldFxuICAgICAgICB9KVxuICAgICAgICAuYXR0cihcInkyXCIsZnVuY3Rpb24oZCl7XG4gICAgICAgICAgdmFyIHJldCA9IGQuYXhpcyA9PSBcInlcIiA/IGQueSA6IGQueStkLnJcbiAgICAgICAgICByZXR1cm4gcmV0XG4gICAgICAgIH0pXG4gICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLDApXG4gICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLDApXG4gICAgfVxuXG4gICAgdmFyIGxpbmVzID0gbW91c2VldmVudHMuc2VsZWN0QWxsKFwibGluZS5kM3BsdXNfYXhpc19sYWJlbFwiKVxuICAgICAgLmRhdGEobGluZV9kYXRhLGZ1bmN0aW9uKGQpe1xuICAgICAgICByZXR1cm4gZC5heGlzK1wiX1wiK2QuaWRcbiAgICAgIH0pXG5cbiAgICBsaW5lcy5lbnRlcigpLmFwcGVuZChcImxpbmVcIilcbiAgICAgIC5hdHRyKFwiY2xhc3NcIixcImQzcGx1c19heGlzX2xhYmVsXCIpXG4gICAgICAuY2FsbChsaW5lX2luaXQpXG4gICAgICAuYXR0cihcIngxXCIsZnVuY3Rpb24oZCl7XG4gICAgICAgIHJldHVybiBkLmF4aXMgPT0gXCJ4XCIgPyBkLnggOiBkLngtZC5yXG4gICAgICB9KVxuICAgICAgLmF0dHIoXCJ5MVwiLGZ1bmN0aW9uKGQpe1xuICAgICAgICByZXR1cm4gZC5heGlzID09IFwieVwiID8gZC55IDogZC55K2QuclxuICAgICAgfSlcbiAgICAgIC5zdHlsZShcInN0cm9rZVwiLGZ1bmN0aW9uKGQpe1xuICAgICAgICByZXR1cm4gZmV0Y2hDb2xvcih2YXJzLG5vZGUpXG4gICAgICB9KVxuICAgICAgLmF0dHIoXCJzaGFwZS1yZW5kZXJpbmdcIix2YXJzLnNoYXBlLnJlbmRlcmluZy52YWx1ZSlcblxuICAgIGxpbmVzLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLnRpbWluZy5tb3VzZWV2ZW50cylcbiAgICAgIC5hdHRyKFwiY2xhc3NcIixcImQzcGx1c19heGlzX2xhYmVsXCIpXG4gICAgICAuYXR0cihcIngyXCIsZnVuY3Rpb24oZCl7XG4gICAgICAgIHJldHVybiBkLmF4aXMgPT0gXCJ4XCIgPyBkLnggOiBncmFwaC5tYXJnaW4ubGVmdC12YXJzLmF4ZXMudGlja3Muc2l6ZVxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwieTJcIixmdW5jdGlvbihkKXtcbiAgICAgICAgcmV0dXJuIGQuYXhpcyA9PSBcInlcIiA/IGQueSA6IGdyYXBoLmhlaWdodCtncmFwaC5tYXJnaW4udG9wK3ZhcnMuYXhlcy50aWNrcy5zaXplXG4gICAgICB9KVxuICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsZnVuY3Rpb24oZCl7XG4gICAgICAgIHJldHVybiBkM3BsdXMuY29sb3IubGVnaWJsZShmZXRjaENvbG9yKHZhcnMsbm9kZSkpO1xuICAgICAgfSlcbiAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLHZhcnMuZGF0YS5zdHJva2Uud2lkdGgpXG4gICAgICAuYXR0cihcIm9wYWNpdHlcIiwxKVxuXG4gICAgbGluZXMuZXhpdCgpLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLnRpbWluZy5tb3VzZWV2ZW50cylcbiAgICAgIC5jYWxsKGxpbmVfaW5pdClcbiAgICAgIC5yZW1vdmUoKVxuXG4gICAgdmFyIHRleHRzID0gbW91c2VldmVudHMuc2VsZWN0QWxsKFwidGV4dC5kM3BsdXNfYXhpc19sYWJlbFwiKVxuICAgICAgLmRhdGEobGluZV9kYXRhLGZ1bmN0aW9uKGQpe1xuICAgICAgICByZXR1cm4gZC5heGlzK1wiX1wiK2QuaWRcbiAgICAgIH0pXG5cbiAgICB0ZXh0cy5lbnRlcigpLmFwcGVuZChcInRleHRcIilcbiAgICAgIC5hdHRyKFwiY2xhc3NcIixcImQzcGx1c19heGlzX2xhYmVsXCIpXG4gICAgICAuYXR0cihcImlkXCIsZnVuY3Rpb24oZCl7XG4gICAgICAgIHJldHVybiBkLmF4aXMrXCJfXCIrZC5pZFxuICAgICAgfSlcbiAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpe1xuICAgICAgICB2YXIgdmFsID0gZmV0Y2hWYWx1ZSh2YXJzLG5vZGUuZDNwbHVzX2RhdGEgfHwgbm9kZSx2YXJzW2QuYXhpc10udmFsdWUpXG4gICAgICAgIHJldHVybiB2YXJzLmZvcm1hdC52YWx1ZSh2YWwsdmFyc1tkLmF4aXNdLnZhbHVlKVxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwieFwiLGZ1bmN0aW9uKGQpe1xuICAgICAgICByZXR1cm4gZC5heGlzID09IFwieFwiID8gZC54IDogZ3JhcGgubWFyZ2luLmxlZnQtNS12YXJzLmF4ZXMudGlja3Muc2l6ZVxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwieVwiLGZ1bmN0aW9uKGQpe1xuICAgICAgICByZXR1cm4gZC5heGlzID09IFwieVwiID8gZC55IDogZ3JhcGguaGVpZ2h0K2dyYXBoLm1hcmdpbi50b3ArNSt2YXJzLmF4ZXMudGlja3Muc2l6ZVxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwiZHlcIixmdW5jdGlvbihkKXtcbiAgICAgICAgcmV0dXJuIGQuYXhpcyA9PSBcInlcIiA/ICh2YXJzLmF4ZXMudGlja3MuZm9udC5zaXplKi4zNSkgOiB2YXJzLmF4ZXMudGlja3MuZm9udC5zaXplXG4gICAgICB9KVxuICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIixmdW5jdGlvbihkKXtcbiAgICAgICAgcmV0dXJuIGQuYXhpcyA9PSBcInlcIiA/IFwiZW5kXCI6IFwibWlkZGxlXCJcbiAgICAgIH0pXG4gICAgICAuYXR0cihcImZpbGxcIixmdW5jdGlvbihkKXtcbiAgICAgICAgcmV0dXJuIGQzcGx1cy5jb2xvci5sZWdpYmxlKGZldGNoQ29sb3IodmFycyxub2RlKSk7XG4gICAgICB9KVxuICAgICAgLmF0dHIoXCJmb250LXNpemVcIix2YXJzLmF4ZXMudGlja3MuZm9udC5zaXplKVxuICAgICAgLmF0dHIoXCJmb250LWZhbWlseVwiLHZhcnMuYXhlcy50aWNrcy5mb250LmZhbWlseS52YWx1ZSlcbiAgICAgIC5hdHRyKFwiZm9udC13ZWlnaHRcIix2YXJzLmF4ZXMudGlja3MuZm9udC53ZWlnaHQpXG4gICAgICAuYXR0cihcIm9wYWNpdHlcIiwwKVxuXG4gICAgdGV4dHMudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMudGltaW5nLm1vdXNlZXZlbnRzKVxuICAgICAgLmRlbGF5KHZhcnMudGltaW5nLm1vdXNlZXZlbnRzKVxuICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsMSlcblxuICAgIHRleHRzLmV4aXQoKS50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy50aW1pbmcubW91c2VldmVudHMpXG4gICAgICAuYXR0cihcIm9wYWNpdHlcIiwwKVxuICAgICAgLnJlbW92ZSgpXG5cbiAgICB2YXIgcmVjdHMgPSBtb3VzZWV2ZW50cy5zZWxlY3RBbGwoXCJyZWN0LmQzcGx1c19heGlzX2xhYmVsXCIpXG4gICAgICAuZGF0YShsaW5lX2RhdGEsZnVuY3Rpb24oZCl7XG4gICAgICAgIHJldHVybiBkLmF4aXMrXCJfXCIrZC5pZFxuICAgICAgfSlcblxuICAgIHJlY3RzLmVudGVyKCkuaW5zZXJ0KFwicmVjdFwiLFwidGV4dFwiKVxuICAgICAgLmF0dHIoXCJjbGFzc1wiLFwiZDNwbHVzX2F4aXNfbGFiZWxcIilcbiAgICAgIC5hdHRyKFwieFwiLGZ1bmN0aW9uKGQpe1xuICAgICAgICB2YXIgd2lkdGggPSBkMy5zZWxlY3QoXCJ0ZXh0I1wiK2QuYXhpcytcIl9cIitkLmlkKS5ub2RlKCkuZ2V0QkJveCgpLndpZHRoXG4gICAgICAgIHZhciByZXQgPSBkLmF4aXMgPT0gXCJ4XCIgPyBkLnggOiBncmFwaC5tYXJnaW4ubGVmdC12YXJzLmF4ZXMudGlja3Muc2l6ZVxuICAgICAgICByZXR1cm4gZC5heGlzID09IFwieFwiID8gcmV0LXdpZHRoLzItNSA6IHJldC13aWR0aC0xMFxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwieVwiLGZ1bmN0aW9uKGQpe1xuICAgICAgICB2YXIgaGVpZ2h0ID0gZDMuc2VsZWN0KFwidGV4dCNcIitkLmF4aXMrXCJfXCIrZC5pZCkubm9kZSgpLmdldEJCb3goKS5oZWlnaHRcbiAgICAgICAgdmFyIHJldCA9IGQuYXhpcyA9PSBcInlcIiA/IGQueSA6IGdyYXBoLmhlaWdodCtncmFwaC5tYXJnaW4udG9wXG4gICAgICAgIHJldHVybiBkLmF4aXMgPT0gXCJ4XCIgPyByZXQrdmFycy5heGVzLnRpY2tzLnNpemUgOiByZXQtaGVpZ2h0LzItNVxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwid2lkdGhcIixmdW5jdGlvbihkKXtcbiAgICAgICAgdmFyIHRleHQgPSBkMy5zZWxlY3QoXCJ0ZXh0I1wiK2QuYXhpcytcIl9cIitkLmlkKS5ub2RlKCkuZ2V0QkJveCgpXG4gICAgICAgIHJldHVybiB0ZXh0LndpZHRoICsgMTBcbiAgICAgIH0pXG4gICAgICAuYXR0cihcImhlaWdodFwiLGZ1bmN0aW9uKGQpe1xuICAgICAgICB2YXIgdGV4dCA9IGQzLnNlbGVjdChcInRleHQjXCIrZC5heGlzK1wiX1wiK2QuaWQpLm5vZGUoKS5nZXRCQm94KClcbiAgICAgICAgcmV0dXJuIHRleHQuaGVpZ2h0ICsgMTBcbiAgICAgIH0pXG4gICAgICAuc3R5bGUoXCJzdHJva2VcIixmdW5jdGlvbihkKXtcbiAgICAgICAgcmV0dXJuIGQzcGx1cy5jb2xvci5sZWdpYmxlKGZldGNoQ29sb3IodmFycyxub2RlKSk7XG4gICAgICB9KVxuICAgICAgLmF0dHIoXCJmaWxsXCIsXCJ3aGl0ZVwiKVxuICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsdmFycy5kYXRhLnN0cm9rZS53aWR0aClcbiAgICAgIC5hdHRyKFwic2hhcGUtcmVuZGVyaW5nXCIsdmFycy5zaGFwZS5yZW5kZXJpbmcudmFsdWUpXG4gICAgICAuYXR0cihcIm9wYWNpdHlcIiwwKVxuXG4gICAgcmVjdHMudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMudGltaW5nLm1vdXNlZXZlbnRzKVxuICAgICAgLmRlbGF5KHZhcnMudGltaW5nLm1vdXNlZXZlbnRzKVxuICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsMSlcblxuICAgIHJlY3RzLmV4aXQoKS50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy50aW1pbmcubW91c2VldmVudHMpXG4gICAgICAuYXR0cihcIm9wYWNpdHlcIiwwKVxuICAgICAgLnJlbW92ZSgpXG5cbiAgfVxuXG4gIHZhcnMubW91c2UgPSBheGlzX2xpbmVzXG5cbiAgcmV0dXJuIGRhdGFcblxufVxuXG4vL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gVmlzdWFsaXphdGlvbiBTZXR0aW5ncyBhbmQgSGVscGVyIEZ1bmN0aW9uc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNoYXJ0LmZpbGwgICAgICAgICA9IHRydWVcbmNoYXJ0LnJlcXVpcmVtZW50cyA9IFtcImRhdGFcIixcInhcIixcInlcIl1cbmNoYXJ0LnNjYWxlICAgICAgICA9IHtcImNpcmNsZVwiOiAxLjEsIFwiZG9udXRcIjogMS4xLCBcInNxdWFyZVwiOiAxLjEgfVxuY2hhcnQuc2V0dXAgICAgICAgID0gZnVuY3Rpb24odmFycykge1xuICBpZiAodmFycy54LnZhbHVlID09PSB2YXJzLnRpbWUudmFsdWUpIHZhcnMuc2VsZi54KHtcInNjYWxlXCI6IFwiY29udGludW91c1wifSlcbiAgaWYgKHZhcnMueS52YWx1ZSA9PT0gdmFycy50aW1lLnZhbHVlKSB2YXJzLnNlbGYueSh7XCJzY2FsZVwiOiBcImNvbnRpbnVvdXNcIn0pXG59XG5jaGFydC5zaGFwZXMgICAgICAgPSBbXCJjaXJjbGVcIixcImRvbnV0XCIsXCJsaW5lXCIsXCJzcXVhcmVcIixcImFyZWFcIl1cbmNoYXJ0LnRvb2x0aXAgICAgICA9IFwic3RhdGljXCJcblxubW9kdWxlLmV4cG9ydHMgPSBjaGFydFxuIiwiLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIEdlbyBNYXBcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgZ2VvX21hcCA9IGZ1bmN0aW9uKHZhcnMpIHtcblxuICB0b3BvanNvbi5wcmVzaW1wbGlmeSh2YXJzLmNvb3Jkcy52YWx1ZSlcblxuICB2YXIgY29vcmRzID0gdmFycy5jb29yZHMudmFsdWVcbiAgICAsIGtleSA9IGQzLmtleXMoY29vcmRzLm9iamVjdHMpWzBdXG4gICAgLCB0b3BvID0gdG9wb2pzb24uZmVhdHVyZShjb29yZHMsIGNvb3Jkcy5vYmplY3RzW2tleV0pXG4gICAgLCBmZWF0dXJlcyA9IHRvcG8uZmVhdHVyZXNcblxuICB2YXIgZmVhdHVyZXMgPSBmZWF0dXJlcy5maWx0ZXIoZnVuY3Rpb24oZil7XG5cbiAgICBmW3ZhcnMuaWQudmFsdWVdID0gZi5pZFxuXG4gICAgaWYgKHZhcnMuY29vcmRzLnNvbG8udmFsdWUubGVuZ3RoKSB7XG5cbiAgICAgIHJldHVybiB2YXJzLmNvb3Jkcy5zb2xvLnZhbHVlLmluZGV4T2YoZi5pZCkgPj0gMFxuXG4gICAgfVxuICAgIGVsc2UgaWYgKHZhcnMuY29vcmRzLm11dGUudmFsdWUubGVuZ3RoKSB7XG5cbiAgICAgIHJldHVybiB2YXJzLmNvb3Jkcy5tdXRlLnZhbHVlLmluZGV4T2YoZi5pZCkgPCAwXG5cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuXG4gIH0pXG5cbiAgcmV0dXJuIGZlYXR1cmVzXG5cbn07XG5cbi8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBWaXN1YWxpemF0aW9uIFNldHRpbmdzIGFuZCBIZWxwZXIgRnVuY3Rpb25zXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZ2VvX21hcC5saWJzICAgICAgICAgPSBbIFwidG9wb2pzb25cIiBdO1xuZ2VvX21hcC5uZXN0aW5nICAgICAgPSBmYWxzZVxuZ2VvX21hcC5yZXF1aXJlbWVudHMgPSBbIFwiY29sb3JcIiAsIFwiY29vcmRzXCIgXTtcbmdlb19tYXAuc2NhbGUgICAgICAgID0gMVxuZ2VvX21hcC5zaGFwZXMgICAgICAgPSBbIFwiY29vcmRpbmF0ZXNcIiBdO1xuZ2VvX21hcC50b29sdGlwICAgICAgPSBcImZvbGxvd1wiXG5nZW9fbWFwLnpvb20gICAgICAgICA9IHRydWVcblxubW9kdWxlLmV4cG9ydHMgPSBnZW9fbWFwXG4iLCJ2YXIgY2hhcnQgPSByZXF1aXJlKFwiLi9jaGFydC5qc1wiKVxuLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIExpbmUgUGxvdFxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBsaW5lID0gZnVuY3Rpb24odmFycykge1xuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBUaGlzIHZpc3VhbGl6YXRpb24gaXMgYW4gZXh0ZW50aW9uIG9mIHRoZSBDaGFydCB2aXN1YWxpemF0aW9uLlxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcmV0dXJuIGNoYXJ0KHZhcnMpXG5cbn1cblxuLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIFZpc3VhbGl6YXRpb24gU2V0dGluZ3MgYW5kIEhlbHBlciBGdW5jdGlvbnNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5saW5lLnJlcXVpcmVtZW50cyA9IFsgXCJkYXRhXCIgLCBcInhcIiAsIFwieVwiIF1cbmxpbmUuc2V0dXAgPSBmdW5jdGlvbih2YXJzKSB7XG4gIHZhcnMuc2VsZi54KHsgXCJzY2FsZVwiIDogXCJjb250aW51b3VzXCIgfSlcbn1cbmxpbmUuc2hhcGVzICAgICAgID0gWyBcImxpbmVcIiBdXG5saW5lLnRvb2x0aXAgICAgICA9IFwic3RhdGljXCJcblxubW9kdWxlLmV4cG9ydHMgPSBsaW5lXG4iLCJ2YXIgZmV0Y2hWYWx1ZSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL2ZldGNoL3ZhbHVlLmpzXCIpXG4vL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gTmV0d29ya1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBuZXR3b3JrID0gZnVuY3Rpb24odmFycykge1xuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBVc2UgZmlsdGVyZWQgbGlzdHMgaWYgdGhleSBhcmUgYXZhaWxhYmxlXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXIgbm9kZXMgPSB2YXJzLm5vZGVzLnJlc3RyaWN0ZWQgfHwgdmFycy5ub2Rlcy52YWx1ZSxcbiAgICAgIGVkZ2VzID0gdmFycy5lZGdlcy5yZXN0cmljdGVkIHx8IHZhcnMuZWRnZXMudmFsdWVcblxuICB2YXIgeF9yYW5nZSA9IGQzLmV4dGVudChub2RlcyxmdW5jdGlvbihuKXtyZXR1cm4gbi54fSksXG4gICAgICB5X3JhbmdlID0gZDMuZXh0ZW50KG5vZGVzLGZ1bmN0aW9uKG4pe3JldHVybiBuLnl9KVxuXG4gIHZhciB2YWxfcmFuZ2UgPSB2YXJzLnNpemUudmFsdWUgPyBkMy5leHRlbnQobm9kZXMsIGZ1bmN0aW9uKGQpe1xuICAgIHZhciB2YWwgPSBmZXRjaFZhbHVlKCB2YXJzICwgZCAsIHZhcnMuc2l6ZS52YWx1ZSApXG4gICAgcmV0dXJuIHZhbCA9PT0gMCA/IG51bGwgOiB2YWxcbiAgfSkgOiBbIDEgLCAxIF1cblxuICBpZiAodHlwZW9mIHZhbF9yYW5nZVswXSA9PSBcInVuZGVmaW5lZFwiKSB2YWxfcmFuZ2UgPSBbMSwxXVxuXG4gIHZhciBtYXhfc2l6ZSA9IGQzLm1pbihkM3BsdXMudXRpbC5kaXN0YW5jZXMobm9kZXMpKVxuXG4gIHZhciBvdmVybGFwID0gdmFycy5zaXplLnZhbHVlID8gdmFycy5ub2Rlcy5vdmVybGFwIDogMC40XG4gIG1heF9zaXplID0gbWF4X3NpemUgKiBvdmVybGFwXG5cbiAgaWYgKHZhcnMuZWRnZXMuYXJyb3dzLnZhbHVlKSB7XG4gICAgbWF4X3NpemUgPSBtYXhfc2l6ZSAqIDAuNVxuICB9XG5cbiAgaWYgKCB2YWxfcmFuZ2VbMF0gPT09IHZhbF9yYW5nZVsxXSApIHtcbiAgICB2YXIgbWluX3NpemUgPSBtYXhfc2l6ZVxuICB9XG4gIGVsc2Uge1xuXG4gICAgdmFyIHdpZHRoID0gKHhfcmFuZ2VbMV0rbWF4X3NpemUqMS4xKS0oeF9yYW5nZVswXS1tYXhfc2l6ZSoxLjEpLFxuICAgICAgICBoZWlnaHQgPSAoeV9yYW5nZVsxXSttYXhfc2l6ZSoxLjEpLSh5X3JhbmdlWzBdLW1heF9zaXplKjEuMSlcbiAgICAgICAgYXNwZWN0ID0gd2lkdGgvaGVpZ2h0LFxuICAgICAgICBhcHAgPSB2YXJzLndpZHRoLnZpei92YXJzLmhlaWdodC52aXpcblxuICAgIGlmICggYXBwID4gYXNwZWN0ICkge1xuICAgICAgdmFyIHNjYWxlID0gdmFycy5oZWlnaHQudml6L2hlaWdodFxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBzY2FsZSA9IHZhcnMud2lkdGgudml6L3dpZHRoXG4gICAgfVxuICAgIHZhciBtaW5fc2l6ZSA9IG1heF9zaXplICogMC4yNVxuICAgIGlmICggbWluX3NpemUgKiBzY2FsZSA8IDIgKSB7XG4gICAgICBtaW5fc2l6ZSA9IDIvc2NhbGVcbiAgICB9XG5cbiAgfVxuXG4gIC8vIENyZWF0ZSBzaXplIHNjYWxlXG4gIHZhciByYWRpdXMgPSB2YXJzLnNpemUuc2NhbGUudmFsdWVcbiAgICAuZG9tYWluKHZhbF9yYW5nZSlcbiAgICAucmFuZ2UoW21pbl9zaXplLCBtYXhfc2l6ZV0pXG5cbiAgdmFycy56b29tLmJvdW5kcyA9IFsgWyB4X3JhbmdlWzBdLW1heF9zaXplKjEuMSAsIHlfcmFuZ2VbMF0tbWF4X3NpemUqMS4xIF1cbiAgICAgICAgICAgICAgICAgICAgICwgWyB4X3JhbmdlWzFdK21heF9zaXplKjEuMSAsIHlfcmFuZ2VbMV0rbWF4X3NpemUqMS4xIF0gXVxuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBNYXRjaCBub2RlcyB0byBkYXRhXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXIgZGF0YSA9IFtdLCBsb29rdXAgPSB7fVxuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG4pe1xuXG4gICAgdmFyIGQgPSB2YXJzLmRhdGEuYXBwLmZpbHRlcihmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBhW3ZhcnMuaWQudmFsdWVdID09IG5bdmFycy5pZC52YWx1ZV1cbiAgICB9KVswXVxuXG4gICAgaWYgKGQpIHtcbiAgICAgIHZhciBvYmogPSBkM3BsdXMub2JqZWN0Lm1lcmdlKG4sZClcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgb2JqID0gZDNwbHVzLnV0aWwuY29weShuKVxuICAgIH1cblxuICAgIG9iai5kM3BsdXMgPSB7fVxuICAgIG9iai5kM3BsdXMueCA9IG4ueFxuICAgIG9iai5kM3BsdXMueSA9IG4ueVxuICAgIHZhciB2YWwgPSBmZXRjaFZhbHVlKHZhcnMsb2JqLHZhcnMuc2l6ZS52YWx1ZSlcbiAgICBvYmouZDNwbHVzLnIgPSB2YWwgPyByYWRpdXModmFsKSA6IHJhZGl1cy5yYW5nZSgpWzBdXG4gICAgbG9va3VwW29ialt2YXJzLmlkLnZhbHVlXV0gPSB7XG4gICAgICBcInhcIjogb2JqLmQzcGx1cy54LFxuICAgICAgXCJ5XCI6IG9iai5kM3BsdXMueSxcbiAgICAgIFwiclwiOiBvYmouZDNwbHVzLnJcbiAgICB9XG4gICAgZGF0YS5wdXNoKG9iailcbiAgfSlcblxuICBkYXRhLnNvcnQoZnVuY3Rpb24oYSxiKXtcbiAgICByZXR1cm4gYi5kM3BsdXMuciAtIGEuZDNwbHVzLnJcbiAgfSlcblxuICBlZGdlcy5mb3JFYWNoKGZ1bmN0aW9uKGwsaSl7XG5cbiAgICBsW3ZhcnMuZWRnZXMuc291cmNlXS5kM3BsdXMgPSB7fVxuICAgIHZhciBzb3VyY2UgPSBsb29rdXBbbFt2YXJzLmVkZ2VzLnNvdXJjZV1bdmFycy5pZC52YWx1ZV1dXG4gICAgbFt2YXJzLmVkZ2VzLnNvdXJjZV0uZDNwbHVzLnIgPSBzb3VyY2UuclxuICAgIGxbdmFycy5lZGdlcy5zb3VyY2VdLmQzcGx1cy54ID0gc291cmNlLnhcbiAgICBsW3ZhcnMuZWRnZXMuc291cmNlXS5kM3BsdXMueSA9IHNvdXJjZS55XG5cbiAgICBsW3ZhcnMuZWRnZXMudGFyZ2V0XS5kM3BsdXMgPSB7fVxuICAgIHZhciB0YXJnZXQgPSBsb29rdXBbbFt2YXJzLmVkZ2VzLnRhcmdldF1bdmFycy5pZC52YWx1ZV1dXG4gICAgbFt2YXJzLmVkZ2VzLnRhcmdldF0uZDNwbHVzLnIgPSB0YXJnZXQuclxuICAgIGxbdmFycy5lZGdlcy50YXJnZXRdLmQzcGx1cy54ID0gdGFyZ2V0LnhcbiAgICBsW3ZhcnMuZWRnZXMudGFyZ2V0XS5kM3BsdXMueSA9IHRhcmdldC55XG5cbiAgfSlcblxuICByZXR1cm4ge1wibm9kZXNcIjogZGF0YSwgXCJlZGdlc1wiOiBlZGdlc31cblxufVxuXG4vL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gVmlzdWFsaXphdGlvbiBTZXR0aW5ncyBhbmQgSGVscGVyIEZ1bmN0aW9uc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbm5ldHdvcmsubmVzdGluZyAgICAgID0gZmFsc2Vcbm5ldHdvcmsucmVxdWlyZW1lbnRzID0gW1wibm9kZXNcIixcImVkZ2VzXCJdXG5uZXR3b3JrLnNjYWxlICAgICAgICA9IDEuMDVcbm5ldHdvcmsuc2hhcGVzICAgICAgID0gWyBcImNpcmNsZVwiICwgXCJzcXVhcmVcIiAsIFwiZG9udXRcIiBdXG5uZXR3b3JrLnRvb2x0aXAgICAgICA9IFwic3RhdGljXCJcbm5ldHdvcmsuem9vbSAgICAgICAgID0gdHJ1ZVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldHdvcmtcbiIsInNob3J0ZXN0UGF0aCA9IHJlcXVpcmUgXCIuLi8uLi9uZXR3b3JrL3Nob3J0ZXN0UGF0aC5jb2ZmZWVcIlxuZmV0Y2hWYWx1ZSAgID0gcmVxdWlyZSBcIi4uLy4uL2NvcmUvZmV0Y2gvdmFsdWUuanNcIlxuXG4jIFBhdGhzIFZpc3VhbGl6YXRpb25cbnZpeiA9ICh2YXJzKSAtPlxuXG4gIGVkZ2VzID0gW11cbiAgcGF0aExvb2t1cCA9IHt9XG4gIHBhdGhMb29rdXBbdmFycy5mb2N1cy52YWx1ZVswXV0gPSAwXG4gIHBhdGhMb29rdXBbdmFycy5mb2N1cy52YWx1ZVsxXV0gPSAwXG4gIHBhdGhzID0ge2FsbDogW1t2YXJzLmZvY3VzLnZhbHVlWzBdXSxbdmFycy5mb2N1cy52YWx1ZVsxXV1dfVxuXG4gIGZvciBwYXRoLCBwYXRoSW50IGluIHZpei5wYXRoc1xuXG4gICAgZWRnZXMgPSBlZGdlcy5jb25jYXQgcGF0aC5lZGdlc1xuICAgIGxhc3RIb3AgPSB2YXJzLmZvY3VzLnZhbHVlWzBdXG4gICAgcGF0aHNbcGF0aEludF0gPSBbbGFzdEhvcF1cblxuICAgIGZvciBlZGdlLCBlZGdlSW50IGluIHBhdGguZWRnZXNcblxuICAgICAgZWRnZVt2YXJzLmVkZ2VzLnNvdXJjZV0gPSB2YXJzLmRhdGEuYXBwLmZpbHRlcigoZCkgLT5cbiAgICAgICAgZWRnZVt2YXJzLmVkZ2VzLnNvdXJjZV1bdmFycy5pZC52YWx1ZV0gaXMgZFt2YXJzLmlkLnZhbHVlXSApWzBdXG5cbiAgICAgIGVkZ2VbdmFycy5lZGdlcy50YXJnZXRdID0gdmFycy5kYXRhLmFwcC5maWx0ZXIoKGQpIC0+XG4gICAgICAgIGVkZ2VbdmFycy5lZGdlcy50YXJnZXRdW3ZhcnMuaWQudmFsdWVdIGlzIGRbdmFycy5pZC52YWx1ZV0gKVswXVxuXG4gICAgICBuZXh0RGlyID0gaWYgZWRnZVt2YXJzLmVkZ2VzLnNvdXJjZV1bdmFycy5pZC52YWx1ZV0gaXMgbGFzdEhvcCB0aGVuIFwidGFyZ2V0XCIgZWxzZSBcInNvdXJjZVwiXG5cbiAgICAgIG5leHRIb3AgPSBlZGdlW3ZhcnMuZWRnZXNbbmV4dERpcl1dW3ZhcnMuaWQudmFsdWVdXG5cbiAgICAgIGlmIHBhdGhMb29rdXBbbmV4dEhvcF0gaXMgdW5kZWZpbmVkXG4gICAgICAgIHBhdGhMb29rdXBbbmV4dEhvcF0gPSBwYXRoSW50XG5cbiAgICAgIHBhdGhzW3BhdGhJbnRdLnB1c2ggbmV4dEhvcFxuXG4gICAgICBsYXN0SG9wID0gbmV4dEhvcFxuXG4gIHJvd3MgPSAwXG4gIGZvciBwYXRoSW50LCBwYXRoIG9mIHBhdGhzXG4gICAgaWYgcGF0aEludCBpc250IFwiYWxsXCJcbiAgICAgIG5ld1BhdGggPSAwXG4gICAgICBmb3IgaWQsIGkgaW4gcGF0aFxuICAgICAgICBpZiBpIG5vdCBpbiBbMCwgcGF0aC5sZW5ndGgtMV0gYW5kIHBhdGhMb29rdXBbaWRdIGlzIHBhcnNlRmxvYXQocGF0aEludClcbiAgICAgICAgICBuZXdQYXRoID0gMVxuICAgICAgICAgIHByZXYgPSBwYXRoW2ktMV1cbiAgICAgICAgICBuZXh0ID0gcGF0aFtpKzFdXG4gICAgICAgICAgcHJldkluZGV4ID0gbnVsbFxuICAgICAgICAgIG5leHRJbmRleCA9IG51bGxcbiAgICAgICAgICBmb3IgY29sLCBjb2xJbmRleCBpbiBwYXRocy5hbGxcbiAgICAgICAgICAgIGlmIHByZXYgaW4gY29sXG4gICAgICAgICAgICAgIHByZXZJbmRleCA9IGNvbEluZGV4XG4gICAgICAgICAgICBpZiBuZXh0IGluIGNvbFxuICAgICAgICAgICAgICBuZXh0SW5kZXggPSBjb2xJbmRleFxuICAgICAgICAgIGlmIHByZXZJbmRleCBpc250IG51bGwgYW5kIG5leHRJbmRleCBpcyBudWxsXG4gICAgICAgICAgICBpZiBwcmV2SW5kZXggKyAxIGlzIHBhdGhzLmFsbC5sZW5ndGggLSAxXG4gICAgICAgICAgICAgIHBhdGhzLmFsbC5zcGxpY2UgcHJldkluZGV4ICsgMSwgMCwgW2lkXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBwYXRocy5hbGxbcHJldkluZGV4ICsgMV0ucHVzaCBpZFxuICAgICAgICAgIGVsc2UgaWYgbmV4dEluZGV4IC0gcHJldkluZGV4IGlzIDFcbiAgICAgICAgICAgIHBhdGhzLmFsbC5zcGxpY2UgbmV4dEluZGV4LCAwLCBbaWRdXG4gICAgICAgICAgZWxzZSBpZiBuZXh0SW5kZXggLSBwcmV2SW5kZXggPiAxXG4gICAgICAgICAgICBwYXRocy5hbGxbbmV4dEluZGV4IC0gMV0ucHVzaCBpZFxuICAgICAgcm93cyArPSBuZXdQYXRoXG5cbiAgcm93SGVpZ2h0ID0gTWF0aC5mbG9vciB2YXJzLmhlaWdodC52aXogLyByb3dzXG5cbiAgeURvbWFpbiA9IFtdXG4gIGkgPSAwXG4gIHdoaWxlIGkgPCByb3dzXG4gICAgaWYgaSAlIDIgaXMgMFxuICAgICAgeURvbWFpbi5wdXNoIGlcbiAgICBlbHNlXG4gICAgICB5RG9tYWluLnVuc2hpZnQgaVxuICAgIGkrK1xuXG4gIGxhYmVsU3BhY2UgPSBpZiB2YXJzLnNpemUudmFsdWUgYW5kICF2YXJzLnNtYWxsIHRoZW4gMzAgZWxzZSAwXG5cbiAgeSA9IGQzLnNjYWxlLm9yZGluYWwoKVxuICAgIC5kb21haW4geURvbWFpblxuICAgIC5yYW5nZSBkMy5yYW5nZSByb3dIZWlnaHQvMiAtIGxhYmVsU3BhY2UsIHZhcnMuaGVpZ2h0LnZpeiArIHJvd0hlaWdodC8yIC0gbGFiZWxTcGFjZSwgKHZhcnMuaGVpZ2h0LnZpeiAtIHJvd0hlaWdodCkvKHJvd3MtMSlcblxuICBjb2x1bW5zID0gcGF0aHNbXCJhbGxcIl0ubGVuZ3RoXG5cbiAgY29sdW1uV2lkdGggPSBNYXRoLmZsb29yIHZhcnMud2lkdGgudml6IC8gY29sdW1uc1xuXG4gIHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgIC5kb21haW4gWzAsIGNvbHVtbnMgLSAxXVxuICAgIC5yYW5nZVJvdW5kIFtjb2x1bW5XaWR0aC8yLCB2YXJzLndpZHRoLnZpeiAtIGNvbHVtbldpZHRoLzJdXG5cbiAgbWluUmFkaXVzID0gNVxuICBtYXhSYWRpdXMgPSBkMy5taW4oW2NvbHVtbldpZHRoLHJvd0hlaWdodCAtIGxhYmVsU3BhY2VdKSAqIDAuNFxuXG4gIHNpemVEb21haW4gPSBkMy5leHRlbnQgdmFycy5kYXRhLmFwcCwgKG5vZGUpIC0+XG4gICAgdmFsID0gZmV0Y2hWYWx1ZSB2YXJzLCBub2RlLCB2YXJzLnNpemUudmFsdWVcbiAgICByZXR1cm4gdmFsIG9yIDBcblxuICBzaXplID0gdmFycy5zaXplLnNjYWxlLnZhbHVlXG4gICAgLmRvbWFpbiBzaXplRG9tYWluXG4gICAgLnJhbmdlUm91bmQgW21pblJhZGl1cywgbWF4UmFkaXVzXVxuXG4gIGZvciBub2RlIGluIHZhcnMuZGF0YS5hcHBcblxuICAgIG5vZGUuZDNwbHVzID89IHt9XG5cbiAgICBmb3IgY29sLCBjb2xJbmRleCBpbiBwYXRoc1tcImFsbFwiXVxuICAgICAgaWYgbm9kZVt2YXJzLmlkLnZhbHVlXSBpbiBjb2xcbiAgICAgICAgbm9kZS5kM3BsdXMueCA9IHgoY29sSW5kZXgpXG5cbiAgICBub2RlLmQzcGx1cy55ID0geShwYXRoTG9va3VwW25vZGVbdmFycy5pZC52YWx1ZV1dKVxuXG4gICAgaWYgdmFycy5zaXplLnZhbHVlXG4gICAgICB2YWwgPSBmZXRjaFZhbHVlIHZhcnMsIG5vZGUsIHZhcnMuc2l6ZS52YWx1ZVxuICAgICAgbm9kZS5kM3BsdXMuciA9IGlmIHZhbCB0aGVuIHNpemUodmFsKSBlbHNlIG1pblJhZGl1c1xuICAgIGVsc2VcbiAgICAgIG5vZGUuZDNwbHVzLnIgPSBtYXhSYWRpdXNcblxuICAgIGlmIG5vZGUuZDNwbHVzLnIgPCBjb2x1bW5XaWR0aCAqIDAuMSBhbmQgIXZhcnMuc21hbGxcbiAgICAgIG5vZGUuZDNwbHVzLmxhYmVsID1cbiAgICAgICAgeDogMFxuICAgICAgICB5OiBub2RlLmQzcGx1cy5yICsgdmFycy5sYWJlbHMucGFkZGluZyoyXG4gICAgICAgIHc6IGNvbHVtbldpZHRoICogMC42XG4gICAgICAgIGg6IGxhYmVsU3BhY2UgKyBtYXhSYWRpdXMgLSBub2RlLmQzcGx1cy5yXG4gICAgICAgIHJlc2l6ZTogZmFsc2VcbiAgICBlbHNlXG4gICAgICBkZWxldGUgbm9kZS5kM3BsdXMubGFiZWxcblxuICBmb3IgcGF0aCwgcGF0aEludCBpbiB2aXoucGF0aHNcblxuICAgIGxhc3RIb3AgPSB2YXJzLmZvY3VzLnZhbHVlWzBdXG5cbiAgICBmb3IgZWRnZSwgZWRnZUludCBpbiBwYXRoLmVkZ2VzXG5cbiAgICAgIG5leHREaXIgPSBpZiBlZGdlW3ZhcnMuZWRnZXMuc291cmNlXVt2YXJzLmlkLnZhbHVlXSBpcyBsYXN0SG9wIHRoZW4gXCJ0YXJnZXRcIiBlbHNlIFwic291cmNlXCJcbiAgICAgIGxhc3REaXIgPSBpZiBuZXh0RGlyIGlzIFwidGFyZ2V0XCIgdGhlbiBcInNvdXJjZVwiIGVsc2UgXCJ0YXJnZXRcIlxuXG4gICAgICBuZXh0SG9wID0gZWRnZVt2YXJzLmVkZ2VzW25leHREaXJdXVt2YXJzLmlkLnZhbHVlXVxuXG4gICAgICBpZiBwYXRoTG9va3VwW2xhc3RIb3BdIGlzbnQgcGF0aExvb2t1cFtuZXh0SG9wXVxuXG4gICAgICAgIGVkZ2UuZDNwbHVzID1cbiAgICAgICAgICBzcGxpbmU6IHRydWVcblxuICAgICAgICBlZGdlW3ZhcnMuZWRnZXMuc291cmNlXS5kM3BsdXMgPz0ge31cbiAgICAgICAgZWRnZVt2YXJzLmVkZ2VzLnNvdXJjZV0uZDNwbHVzLmVkZ2VzID89IHt9XG4gICAgICAgIGVkZ2VbdmFycy5lZGdlcy50YXJnZXRdLmQzcGx1cyA/PSB7fVxuICAgICAgICBlZGdlW3ZhcnMuZWRnZXMudGFyZ2V0XS5kM3BsdXMuZWRnZXMgPz0ge31cblxuICAgICAgICB4RGlmZiA9IGVkZ2VbbmV4dERpcl0uZDNwbHVzLnggLSBlZGdlW2xhc3REaXJdLmQzcGx1cy54XG5cbiAgICAgICAgZWRnZVtsYXN0RGlyXS5kM3BsdXMuZWRnZXNbZWRnZVtuZXh0RGlyXVt2YXJzLmlkLnZhbHVlXV0gPVxuICAgICAgICAgIGFuZ2xlOiBNYXRoLlBJXG4gICAgICAgICAgcmFkaXVzOiBjb2x1bW5XaWR0aC8yXG4gICAgICAgIGVkZ2VbbmV4dERpcl0uZDNwbHVzLmVkZ2VzW2VkZ2VbbGFzdERpcl1bdmFycy5pZC52YWx1ZV1dID1cbiAgICAgICAgICBhbmdsZTogMFxuICAgICAgICAgIHJhZGl1czogY29sdW1uV2lkdGgvMlxuICAgICAgICAgIG9mZnNldDogeERpZmYgLSBjb2x1bW5XaWR0aFxuXG4gICAgICBlbHNlXG4gICAgICAgIGRlbGV0ZSBlZGdlLmQzcGx1c1xuXG4gICAgICBsYXN0SG9wID0gbmV4dEhvcFxuXG4gICMgcmV0dXJuXG4gIG5vZGVzOiB2YXJzLmRhdGEuYXBwXG4gIGVkZ2VzOiBlZGdlc1xuXG52aXouZmlsdGVyID0gKHZhcnMsIGRhdGEpIC0+XG5cbiAgZWRnZXMgPSB2YXJzLmVkZ2VzLmZpbHRlcmVkIG9yIHZhcnMuZWRnZXMudmFsdWVcblxuICB2aXoucGF0aHMgPSBzaG9ydGVzdFBhdGggZWRnZXMsIHZhcnMuZm9jdXMudmFsdWVbMF0sXG4gICAgdGFyZ2V0OiAgICAgdmFycy5mb2N1cy52YWx1ZVsxXVxuICAgIGRpc3RhbmNlOiAgIHZhcnMuZWRnZXMuc2l6ZSBvciB1bmRlZmluZWRcbiAgICBub2RlaWQ6ICAgICB2YXJzLmlkLnZhbHVlXG4gICAgc3RhcnRwb2ludDogdmFycy5lZGdlcy5zb3VyY2VcbiAgICBlbmRwb2ludDogICB2YXJzLmVkZ2VzLnRhcmdldFxuICAgIEs6ICAgICAgICAgIHZhcnMuZWRnZXMubGltaXQudmFsdWUgb3IgNVxuXG4gIHZpei5ub2RlcyA9IFtdXG4gIGFkZGVkID0gW11cbiAgZm9yIHBhdGggaW4gdml6LnBhdGhzXG4gICAgZm9yIGVkZ2UgaW4gcGF0aC5lZGdlc1xuICAgICAgc291cmNlID0gZWRnZVt2YXJzLmVkZ2VzLnNvdXJjZV1cbiAgICAgIHRhcmdldCA9IGVkZ2VbdmFycy5lZGdlcy50YXJnZXRdXG4gICAgICBpZiBhZGRlZC5pbmRleE9mKHNvdXJjZVt2YXJzLmlkLnZhbHVlXSkgPCAwXG4gICAgICAgIHZpei5ub2Rlcy5wdXNoIHNvdXJjZVxuICAgICAgICBhZGRlZC5wdXNoIHNvdXJjZVt2YXJzLmlkLnZhbHVlXVxuICAgICAgaWYgYWRkZWQuaW5kZXhPZih0YXJnZXRbdmFycy5pZC52YWx1ZV0pIDwgMFxuICAgICAgICB2aXoubm9kZXMucHVzaCB0YXJnZXRcbiAgICAgICAgYWRkZWQucHVzaCB0YXJnZXRbdmFycy5pZC52YWx1ZV1cblxuICBpZHMgPSBkM3BsdXMudXRpbC51bmlxdWVzKHZpei5ub2RlcywgdmFycy5pZC52YWx1ZSlcbiAgcmV0dXJuRGF0YSA9IFtdXG4gIGZvciBpZCBpbiBpZHNcbiAgICBkID0gZGF0YS5maWx0ZXIgKGQpIC0+XG4gICAgICBkW3ZhcnMuaWQudmFsdWVdIGlzIGlkXG4gICAgdW5sZXNzIGRbMF1cbiAgICAgIG9iaiA9IGQzcGx1czoge31cbiAgICAgIG9ialt2YXJzLmlkLnZhbHVlXSA9IGlkXG4gICAgICByZXR1cm5EYXRhLnB1c2ggb2JqXG4gICAgZWxzZVxuICAgICAgcmV0dXJuRGF0YS5wdXNoIGRbMF1cblxuICByZXR1cm5EYXRhXG5cbnZpei5uZXN0aW5nICAgICAgPSBmYWxzZVxudml6LnJlcXVpcmVtZW50cyA9IFtcbiAgKHZhcnMpIC0+XG4gICAgc3RhdHVzOiB2YXJzLmZvY3VzLnZhbHVlLmxlbmd0aCA9PSAyXG4gICAgdGV4dDogdmFycy5mb3JtYXQubG9jYWxlLnZhbHVlLm1ldGhvZC5mb2N1cyArIFwiIHggMlwiXG4gIFwiZWRnZXNcIlxuXVxudml6LnNjYWxlICAgPSAxXG52aXouc2hhcGVzICA9IFtcImNpcmNsZVwiLCBcInNxdWFyZVwiLCBcImRvbnV0XCJdXG52aXoudG9vbHRpcCA9IFwic3RhdGljXCJcblxubW9kdWxlLmV4cG9ydHMgPSB2aXpcbiIsInZhciBmZXRjaFZhbHVlID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvZmV0Y2gvdmFsdWUuanNcIilcbiAgLCBmZXRjaENvbG9yID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvZmV0Y2gvY29sb3IuanNcIilcbnZhciByaW5ncyA9IGZ1bmN0aW9uKHZhcnMpIHtcblxuICB2YXIgcmFkaXVzID0gZDMubWluKFt2YXJzLmhlaWdodC52aXosdmFycy53aWR0aC52aXpdKS8yXG4gICAgLCByaW5nX3dpZHRoID0gdmFycy5zbWFsbCB8fCAhdmFycy5sYWJlbHMudmFsdWVcbiAgICAgICAgICAgICAgICAgPyAocmFkaXVzLXZhcnMubGFiZWxzLnBhZGRpbmcqMikvMiA6IHJhZGl1cy8zXG4gICAgLCBwcmltYXJ5UmluZyA9IHZhcnMuc21hbGwgfHwgIXZhcnMubGFiZWxzLnZhbHVlXG4gICAgICAgICAgICAgICAgICA/IHJpbmdfd2lkdGgqMS40IDogcmluZ193aWR0aFxuICAgICwgc2Vjb25kYXJ5UmluZyA9IHJpbmdfd2lkdGgqMlxuICAgICwgZWRnZXMgPSBbXVxuICAgICwgbm9kZXMgPSBbXVxuXG4gIHZhciBjZW50ZXIgPSB2YXJzLmRhdGEuYXBwLmZpbHRlcihmdW5jdGlvbihkKXtcbiAgICByZXR1cm4gZFt2YXJzLmlkLnZhbHVlXSA9PT0gdmFycy5mb2N1cy52YWx1ZVswXVxuICB9KVswXVxuXG4gIGlmICggIWNlbnRlciApIHtcbiAgICBjZW50ZXIgPSB7IFwiZDNwbHVzXCIgOiB7fSB9XG4gICAgY2VudGVyW3ZhcnMuaWQudmFsdWVdID0gdmFycy5mb2N1cy52YWx1ZVswXVxuICB9XG5cbiAgY2VudGVyLmQzcGx1cy54ID0gdmFycy53aWR0aC52aXovMlxuICBjZW50ZXIuZDNwbHVzLnkgPSB2YXJzLmhlaWdodC52aXovMlxuICBjZW50ZXIuZDNwbHVzLnIgPSBwcmltYXJ5UmluZyouNjVcblxuICB2YXIgcHJpbWFyaWVzID0gW10sIGNsYWltZWQgPSBbdmFycy5mb2N1cy52YWx1ZVswXV1cbiAgdmFycy5lZGdlcy5jb25uZWN0aW9ucyh2YXJzLmZvY3VzLnZhbHVlWzBdLHZhcnMuaWQudmFsdWUpLmZvckVhY2goZnVuY3Rpb24oZWRnZSl7XG5cbiAgICB2YXIgYyA9IGVkZ2VbdmFycy5lZGdlcy5zb3VyY2VdW3ZhcnMuaWQudmFsdWVdID09IHZhcnMuZm9jdXMudmFsdWVbMF0gPyBlZGdlW3ZhcnMuZWRnZXMudGFyZ2V0XSA6IGVkZ2VbdmFycy5lZGdlcy5zb3VyY2VdXG4gICAgdmFyIG4gPSB2YXJzLmRhdGEuYXBwLmZpbHRlcihmdW5jdGlvbihkKXtcbiAgICAgIHJldHVybiBkW3ZhcnMuaWQudmFsdWVdID09PSBjW3ZhcnMuaWQudmFsdWVdXG4gICAgfSlbMF1cblxuICAgIGlmICggIW4gKSB7XG4gICAgICBuID0geyBcImQzcGx1c1wiIDoge30gfVxuICAgICAgblt2YXJzLmlkLnZhbHVlXSA9IGNbdmFycy5pZC52YWx1ZV1cbiAgICB9XG5cbiAgICBuLmQzcGx1cy5lZGdlcyA9IHZhcnMuZWRnZXMuY29ubmVjdGlvbnMoblt2YXJzLmlkLnZhbHVlXSx2YXJzLmlkLnZhbHVlKS5maWx0ZXIoZnVuY3Rpb24oYyl7XG4gICAgICByZXR1cm4gY1t2YXJzLmVkZ2VzLnNvdXJjZV1bdmFycy5pZC52YWx1ZV0gIT0gdmFycy5mb2N1cy52YWx1ZVswXSAmJiBjW3ZhcnMuZWRnZXMudGFyZ2V0XVt2YXJzLmlkLnZhbHVlXSAhPSB2YXJzLmZvY3VzLnZhbHVlWzBdXG4gICAgfSlcbiAgICBuLmQzcGx1cy5lZGdlID0gZWRnZVxuICAgIGNsYWltZWQucHVzaChuW3ZhcnMuaWQudmFsdWVdKVxuICAgIHByaW1hcmllcy5wdXNoKG4pXG5cbiAgfSlcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIFNvcnQgcHJpbWFyeSBub2RlcyBieSBjaGlsZHJlbiAoc21hbGxlc3QgdG8gbGFyZ2VzdCkgYW5kIHRoZW4gYnkgc29ydFxuICAvLyBvcmRlci5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXIgc29ydCA9IHZhcnMub3JkZXIudmFsdWUgfHwgdmFycy5jb2xvci52YWx1ZVxuICAgICAgICAgIHx8IHZhcnMuc2l6ZS52YWx1ZSB8fCB2YXJzLmlkLnZhbHVlXG5cbiAgcHJpbWFyaWVzLnNvcnQoZnVuY3Rpb24oYSxiKXtcblxuICAgIHZhciBsZW5ndGhkaWZmID0gYS5kM3BsdXMuZWRnZXMubGVuZ3RoIC0gYi5kM3BsdXMuZWRnZXMubGVuZ3RoXG5cbiAgICBpZiAoIGxlbmd0aGRpZmYgKSB7XG5cbiAgICAgIHJldHVybiBsZW5ndGhkaWZmXG5cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgIHJldHVybiBkM3BsdXMuYXJyYXkuc29ydCggW2EsYl0gLCBzb3J0ICwgdmFycy5vcmRlci5zb3J0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHZhcnMuY29sb3IudmFsdWUgfHwgW10gLCB2YXJzKVxuXG4gICAgfVxuXG4gIH0pXG5cbiAgaWYgKHR5cGVvZiB2YXJzLmVkZ2VzLmxpbWl0LnZhbHVlID09IFwibnVtYmVyXCIpIHtcbiAgICBwcmltYXJpZXMgPSBwcmltYXJpZXMuc2xpY2UoMCx2YXJzLmVkZ2VzLmxpbWl0LnZhbHVlKVxuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiB2YXJzLmVkZ2VzLmxpbWl0LnZhbHVlID09IFwiZnVuY3Rpb25cIikge1xuICAgIHByaW1hcmllcyA9IHZhcnMuZWRnZXMubGltaXQudmFsdWUocHJpbWFyaWVzKVxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIENoZWNrIGZvciBzaW1pbGFyIGNoaWxkcmVuIGFuZCBnaXZlIHByZWZlcmVuY2UgdG8gbm9kZXMgd2l0aCBsZXNzXG4gIC8vIG92ZXJhbGwgY2hpbGRyZW4uXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXIgc2Vjb25kYXJpZXMgPSBbXSwgdG90YWwgPSAwXG4gIHByaW1hcmllcy5mb3JFYWNoKGZ1bmN0aW9uKHApe1xuXG4gICAgdmFyIHByaW1hcnlJZCA9IHBbdmFycy5pZC52YWx1ZV1cblxuICAgIHAuZDNwbHVzLmVkZ2VzID0gcC5kM3BsdXMuZWRnZXMuZmlsdGVyKGZ1bmN0aW9uKGMpe1xuXG4gICAgICB2YXIgc291cmNlID0gY1t2YXJzLmVkZ2VzLnNvdXJjZV1bdmFycy5pZC52YWx1ZV1cbiAgICAgICAgLCB0YXJnZXQgPSBjW3ZhcnMuZWRnZXMudGFyZ2V0XVt2YXJzLmlkLnZhbHVlXVxuICAgICAgcmV0dXJuIChjbGFpbWVkLmluZGV4T2Yoc291cmNlKSA8IDAgJiYgdGFyZ2V0ID09IHByaW1hcnlJZClcbiAgICAgICAgICB8fCAoY2xhaW1lZC5pbmRleE9mKHRhcmdldCkgPCAwICYmIHNvdXJjZSA9PSBwcmltYXJ5SWQpXG5cbiAgICB9KVxuXG4gICAgdG90YWwgKz0gcC5kM3BsdXMuZWRnZXMubGVuZ3RoIHx8IDFcblxuICAgIHAuZDNwbHVzLmVkZ2VzLmZvckVhY2goZnVuY3Rpb24oYyl7XG5cbiAgICAgIHZhciBzb3VyY2UgPSBjW3ZhcnMuZWRnZXMuc291cmNlXVxuICAgICAgICAsIHRhcmdldCA9IGNbdmFycy5lZGdlcy50YXJnZXRdXG4gICAgICB2YXIgY2xhaW0gPSB0YXJnZXRbdmFycy5pZC52YWx1ZV0gPT0gcHJpbWFyeUlkID8gc291cmNlIDogdGFyZ2V0XG4gICAgICBjbGFpbWVkLnB1c2goY2xhaW1bdmFycy5pZC52YWx1ZV0pXG5cbiAgICB9KVxuICB9KVxuXG4gIGQzcGx1cy5hcnJheS5zb3J0KCBwcmltYXJpZXMgLCBzb3J0ICwgdmFycy5vcmRlci5zb3J0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgLCB2YXJzLmNvbG9yLnZhbHVlIHx8IFtdICwgdmFycylcblxuICB2YXIgb2Zmc2V0ID0gMCxcbiAgICAgIHJhZGlhbiA9IE1hdGguUEkqMixcbiAgICAgIHN0YXJ0ID0gMFxuXG4gIHByaW1hcmllcy5mb3JFYWNoKGZ1bmN0aW9uKHAsaSl7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSBwLmQzcGx1cy5lZGdlcy5sZW5ndGggfHwgMSxcbiAgICAgICAgc3BhY2UgPSAocmFkaWFuL3RvdGFsKSpjaGlsZHJlblxuXG4gICAgaWYgKGkgPT0gMCkge1xuICAgICAgc3RhcnQgPSBhbmdsZVxuICAgICAgb2Zmc2V0IC09IHNwYWNlLzJcbiAgICB9XG5cbiAgICB2YXIgYW5nbGUgPSBvZmZzZXQrKHNwYWNlLzIpXG4gICAgYW5nbGUgLT0gcmFkaWFuLzRcblxuICAgIHAuZDNwbHVzLnJhZGlhbnMgPSBhbmdsZVxuICAgIHAuZDNwbHVzLnggPSB2YXJzLndpZHRoLnZpei8yICsgKHByaW1hcnlSaW5nICogTWF0aC5jb3MoYW5nbGUpKVxuICAgIHAuZDNwbHVzLnkgPSB2YXJzLmhlaWdodC52aXovMiArIChwcmltYXJ5UmluZyAqIE1hdGguc2luKGFuZ2xlKSlcblxuICAgIG9mZnNldCArPSBzcGFjZVxuICAgIHAuZDNwbHVzLmVkZ2VzLnNvcnQoZnVuY3Rpb24oYSxiKXtcblxuICAgICAgdmFyIGEgPSBhW3ZhcnMuZWRnZXMuc291cmNlXVt2YXJzLmlkLnZhbHVlXSA9PSBwW3ZhcnMuaWQudmFsdWVdXG4gICAgICAgICAgICA/IGFbdmFycy5lZGdlcy50YXJnZXRdIDogYVt2YXJzLmVkZ2VzLnNvdXJjZV1cbiAgICAgICAgLCBiID0gYlt2YXJzLmVkZ2VzLnNvdXJjZV1bdmFycy5pZC52YWx1ZV0gPT0gcFt2YXJzLmlkLnZhbHVlXVxuICAgICAgICAgICAgPyBiW3ZhcnMuZWRnZXMudGFyZ2V0XSA6IGJbdmFycy5lZGdlcy5zb3VyY2VdXG5cbiAgICAgIHJldHVybiBkM3BsdXMuYXJyYXkuc29ydCggW2EsYl0gLCBzb3J0ICwgdmFycy5vcmRlci5zb3J0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHZhcnMuY29sb3IudmFsdWUgfHwgW10gLCB2YXJzKVxuXG4gICAgfSlcblxuICAgIHAuZDNwbHVzLmVkZ2VzLmZvckVhY2goZnVuY3Rpb24oZWRnZSxpKXtcblxuICAgICAgdmFyIGMgPSBlZGdlW3ZhcnMuZWRnZXMuc291cmNlXVt2YXJzLmlkLnZhbHVlXSA9PSBwW3ZhcnMuaWQudmFsdWVdXG4gICAgICAgICAgPyBlZGdlW3ZhcnMuZWRnZXMudGFyZ2V0XSA6IGVkZ2VbdmFycy5lZGdlcy5zb3VyY2VdXG4gICAgICAgICwgcyA9IHJhZGlhbi90b3RhbFxuXG4gICAgICB2YXIgZCA9IHZhcnMuZGF0YS5hcHAuZmlsdGVyKGZ1bmN0aW9uKGEpe1xuICAgICAgICByZXR1cm4gYVt2YXJzLmlkLnZhbHVlXSA9PT0gY1t2YXJzLmlkLnZhbHVlXVxuICAgICAgfSlbMF1cblxuICAgICAgaWYgKCAhZCApIHtcbiAgICAgICAgZCA9IHsgXCJkM3BsdXNcIiA6IHt9IH1cbiAgICAgICAgZFt2YXJzLmlkLnZhbHVlXSA9IGNbdmFycy5pZC52YWx1ZV1cbiAgICAgIH1cblxuICAgICAgYSA9IChhbmdsZS0ocypjaGlsZHJlbi8yKSsocy8yKSkrKChzKSppKVxuICAgICAgZC5kM3BsdXMucmFkaWFucyA9IGFcbiAgICAgIGQuZDNwbHVzLnggPSB2YXJzLndpZHRoLnZpei8yICsgKChzZWNvbmRhcnlSaW5nKSAqIE1hdGguY29zKGEpKVxuICAgICAgZC5kM3BsdXMueSA9IHZhcnMuaGVpZ2h0LnZpei8yICsgKChzZWNvbmRhcnlSaW5nKSAqIE1hdGguc2luKGEpKVxuICAgICAgc2Vjb25kYXJpZXMucHVzaChkKVxuICAgIH0pXG5cbiAgfSlcblxuICB2YXIgcHJpbWFyeURpc3RhbmNlID0gZDMubWluKGQzcGx1cy51dGlsLmRpc3RhbmNlcyhwcmltYXJpZXMsZnVuY3Rpb24obil7XG4gICAgICAgIHJldHVybiBbbi5kM3BsdXMueCxuLmQzcGx1cy55XVxuICAgICAgfSkpXG4gICAgLCBzZWNvbmRhcnlEaXN0YW5jZSA9IGQzLm1pbihkM3BsdXMudXRpbC5kaXN0YW5jZXMoc2Vjb25kYXJpZXMsZnVuY3Rpb24obil7XG4gICAgICAgIHJldHVybiBbbi5kM3BsdXMueCxuLmQzcGx1cy55XVxuICAgICAgfSkpXG5cbiAgaWYgKCFwcmltYXJ5RGlzdGFuY2UpIHtcbiAgICBwcmltYXJ5RGlzdGFuY2UgPSByaW5nX3dpZHRoLzJcbiAgfVxuXG4gIGlmICghc2Vjb25kYXJ5RGlzdGFuY2UpIHtcbiAgICBzZWNvbmRhcnlEaXN0YW5jZSA9IHJpbmdfd2lkdGgvNFxuICB9XG5cbiAgaWYgKHByaW1hcnlEaXN0YW5jZS8yIC0gNCA8IDgpIHtcbiAgICB2YXIgcHJpbWFyeU1heCA9IGQzLm1pbihbcHJpbWFyeURpc3RhbmNlLzIsOF0pXG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIHByaW1hcnlNYXggPSBwcmltYXJ5RGlzdGFuY2UvMiAtIDRcbiAgfVxuXG4gIGlmIChzZWNvbmRhcnlEaXN0YW5jZS8yIC0gNCA8IDQpIHtcbiAgICB2YXIgc2Vjb25kYXJ5TWF4ID0gZDMubWluKFtzZWNvbmRhcnlEaXN0YW5jZS8yLDRdKVxuICB9XG4gIGVsc2Uge1xuICAgIHZhciBzZWNvbmRhcnlNYXggPSBzZWNvbmRhcnlEaXN0YW5jZS8yIC0gNFxuICB9XG5cbiAgaWYgKHNlY29uZGFyeU1heCA+IHJpbmdfd2lkdGgvMTApIHtcbiAgICBzZWNvbmRhcnlNYXggPSByaW5nX3dpZHRoLzEwXG4gIH1cblxuICBpZiAoc2Vjb25kYXJ5TWF4ID4gcHJpbWFyeU1heCkge1xuICAgIHNlY29uZGFyeU1heCA9IHByaW1hcnlNYXgqLjc1XG4gIH1cbiAgZWxzZSBpZiAocHJpbWFyeU1heCA+IHNlY29uZGFyeU1heCoxLjUpIHtcbiAgICBwcmltYXJ5TWF4ID0gc2Vjb25kYXJ5TWF4KjEuNVxuICB9XG5cbiAgcHJpbWFyeU1heCA9IE1hdGguZmxvb3IocHJpbWFyeU1heClcbiAgc2Vjb25kYXJ5TWF4ID0gTWF0aC5mbG9vcihzZWNvbmRhcnlNYXgpXG5cbiAgdmFyIGlkcyA9IGQzcGx1cy51dGlsLnVuaXF1ZXMocHJpbWFyaWVzLHZhcnMuaWQudmFsdWUpXG4gIGlkcyA9IGlkcy5jb25jYXQoZDNwbHVzLnV0aWwudW5pcXVlcyhzZWNvbmRhcmllcyx2YXJzLmlkLnZhbHVlKSlcbiAgaWRzLnB1c2godmFycy5mb2N1cy52YWx1ZVswXSlcblxuICB2YXIgZGF0YSA9IHZhcnMuZGF0YS5hcHAuZmlsdGVyKGZ1bmN0aW9uKGQpe1xuICAgIHJldHVybiBpZHMuaW5kZXhPZihkW3ZhcnMuaWQudmFsdWVdKSA+PSAwXG4gIH0pXG5cbiAgaWYgKHZhcnMuc2l6ZS52YWx1ZSkge1xuXG4gICAgdmFyIGRvbWFpbiA9IGQzLmV4dGVudChkYXRhLGZ1bmN0aW9uKGQpe1xuICAgICAgcmV0dXJuIGZldGNoVmFsdWUodmFycyxkLHZhcnMuc2l6ZS52YWx1ZSlcbiAgICB9KVxuXG4gICAgaWYgKGRvbWFpblswXSA9PSBkb21haW5bMV0pIHtcbiAgICAgIGRvbWFpblswXSA9IDBcbiAgICB9XG5cbiAgICB2YXIgcmFkaXVzID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgIC5kb21haW4oZG9tYWluKVxuICAgICAgLnJhbmdlUm91bmQoWzMsZDMubWluKFtwcmltYXJ5TWF4LHNlY29uZGFyeU1heF0pXSlcblxuICAgIHZhciB2YWwgPSBmZXRjaFZhbHVlKHZhcnMsY2VudGVyLHZhcnMuc2l6ZS52YWx1ZSlcbiAgICBjZW50ZXIuZDNwbHVzLnIgPSByYWRpdXModmFsKVxuXG4gIH1cbiAgZWxzZSB7XG5cbiAgICB2YXIgcmFkaXVzID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgIC5kb21haW4oWzEsMl0pXG4gICAgICAucmFuZ2VSb3VuZChbcHJpbWFyeU1heCxzZWNvbmRhcnlNYXhdKVxuXG5cbiAgICBpZiAodmFycy5lZGdlcy5sYWJlbCkge1xuICAgICAgY2VudGVyLmQzcGx1cy5yID0gcmFkaXVzKDEpKjEuNVxuICAgIH1cblxuICB9XG5cbiAgc2Vjb25kYXJpZXMuZm9yRWFjaChmdW5jdGlvbihzKXtcbiAgICBzLmQzcGx1cy5yaW5nID0gMlxuICAgIHZhciB2YWwgPSB2YXJzLnNpemUudmFsdWUgPyBmZXRjaFZhbHVlKHZhcnMscyx2YXJzLnNpemUudmFsdWUpIDogMlxuICAgIHMuZDNwbHVzLnIgPSByYWRpdXModmFsKVxuICB9KVxuXG4gIHByaW1hcmllcy5mb3JFYWNoKGZ1bmN0aW9uKHApe1xuICAgIHAuZDNwbHVzLnJpbmcgPSAxXG4gICAgdmFyIHZhbCA9IHZhcnMuc2l6ZS52YWx1ZSA/IGZldGNoVmFsdWUodmFycyxwLHZhcnMuc2l6ZS52YWx1ZSkgOiAxXG4gICAgcC5kM3BsdXMuciA9IHJhZGl1cyh2YWwpXG4gIH0pXG5cbiAgbm9kZXMgPSBbY2VudGVyXS5jb25jYXQocHJpbWFyaWVzKS5jb25jYXQoc2Vjb25kYXJpZXMpXG5cbiAgcHJpbWFyaWVzLmZvckVhY2goZnVuY3Rpb24ocCxpKXtcblxuICAgIHZhciBjaGVjayA9IFt2YXJzLmVkZ2VzLnNvdXJjZSx2YXJzLmVkZ2VzLnRhcmdldF1cbiAgICAgICwgZWRnZSA9IHAuZDNwbHVzLmVkZ2VcblxuICAgIGNoZWNrLmZvckVhY2goZnVuY3Rpb24obm9kZSl7XG5cbiAgICAgIGVkZ2Vbbm9kZV0gPSBub2Rlcy5maWx0ZXIoZnVuY3Rpb24obil7XG4gICAgICAgIHJldHVybiBuW3ZhcnMuaWQudmFsdWVdID09IGVkZ2Vbbm9kZV1bdmFycy5pZC52YWx1ZV1cbiAgICAgIH0pWzBdXG5cbiAgICB9KVxuXG4gICAgZGVsZXRlIGVkZ2UuZDNwbHVzXG4gICAgZWRnZXMucHVzaChlZGdlKVxuXG4gICAgdmFycy5lZGdlcy5jb25uZWN0aW9ucyhwW3ZhcnMuaWQudmFsdWVdLHZhcnMuaWQudmFsdWUpLmZvckVhY2goZnVuY3Rpb24oZWRnZSl7XG5cbiAgICAgIHZhciBjID0gZWRnZVt2YXJzLmVkZ2VzLnNvdXJjZV1bdmFycy5pZC52YWx1ZV0gPT0gcFt2YXJzLmlkLnZhbHVlXVxuICAgICAgICAgICAgPyBlZGdlW3ZhcnMuZWRnZXMudGFyZ2V0XSA6IGVkZ2VbdmFycy5lZGdlcy5zb3VyY2VdXG5cbiAgICAgIGlmIChjW3ZhcnMuaWQudmFsdWVdICE9IGNlbnRlclt2YXJzLmlkLnZhbHVlXSkge1xuXG4gICAgICAgIHZhciB0YXJnZXQgPSBzZWNvbmRhcmllcy5maWx0ZXIoZnVuY3Rpb24ocyl7XG4gICAgICAgICAgcmV0dXJuIHNbdmFycy5pZC52YWx1ZV0gPT0gY1t2YXJzLmlkLnZhbHVlXVxuICAgICAgICB9KVswXVxuXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgdmFyIHIgPSBwcmltYXJ5UmluZ1xuICAgICAgICAgIHRhcmdldCA9IHByaW1hcmllcy5maWx0ZXIoZnVuY3Rpb24ocyl7XG4gICAgICAgICAgICByZXR1cm4gc1t2YXJzLmlkLnZhbHVlXSA9PSBjW3ZhcnMuaWQudmFsdWVdXG4gICAgICAgICAgfSlbMF1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgciA9IHNlY29uZGFyeVJpbmdcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXJnZXQpIHtcblxuICAgICAgICAgIGVkZ2UuZDNwbHVzID0ge1xuICAgICAgICAgICAgXCJzcGxpbmVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwidHJhbnNsYXRlXCI6IHtcbiAgICAgICAgICAgICAgXCJ4XCI6IHZhcnMud2lkdGgudml6LzIsXG4gICAgICAgICAgICAgIFwieVwiOiB2YXJzLmhlaWdodC52aXovMlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjaGVjayA9IFt2YXJzLmVkZ2VzLnNvdXJjZSx2YXJzLmVkZ2VzLnRhcmdldF1cblxuICAgICAgICAgIGNoZWNrLmZvckVhY2goZnVuY3Rpb24obm9kZSxpKXtcblxuICAgICAgICAgICAgZWRnZVtub2RlXSA9IG5vZGVzLmZpbHRlcihmdW5jdGlvbihuKXtcbiAgICAgICAgICAgICAgcmV0dXJuIG5bdmFycy5pZC52YWx1ZV0gPT0gZWRnZVtub2RlXVt2YXJzLmlkLnZhbHVlXVxuICAgICAgICAgICAgfSlbMF1cblxuICAgICAgICAgICAgaWYgKGVkZ2Vbbm9kZV0uZDNwbHVzLmVkZ2VzID09PSB1bmRlZmluZWQpIGVkZ2Vbbm9kZV0uZDNwbHVzLmVkZ2VzID0ge31cblxuICAgICAgICAgICAgdmFyIG9wcElEID0gaSA9PT0gMCA/IGVkZ2VbdmFycy5lZGdlcy50YXJnZXRdW3ZhcnMuaWQudmFsdWVdIDogZWRnZVt2YXJzLmVkZ2VzLnNvdXJjZV1bdmFycy5pZC52YWx1ZV1cblxuICAgICAgICAgICAgaWYgKGVkZ2Vbbm9kZV1bdmFycy5pZC52YWx1ZV0gPT0gcFt2YXJzLmlkLnZhbHVlXSkge1xuXG4gICAgICAgICAgICAgIGVkZ2Vbbm9kZV0uZDNwbHVzLmVkZ2VzW29wcElEXSA9IHtcbiAgICAgICAgICAgICAgICBcImFuZ2xlXCI6IHAuZDNwbHVzLnJhZGlhbnMgKyBNYXRoLlBJLFxuICAgICAgICAgICAgICAgIFwicmFkaXVzXCI6IHJpbmdfd2lkdGgvMlxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgIGVkZ2Vbbm9kZV0uZDNwbHVzLmVkZ2VzW29wcElEXSA9IHtcbiAgICAgICAgICAgICAgICBcImFuZ2xlXCI6IHRhcmdldC5kM3BsdXMucmFkaWFucyxcbiAgICAgICAgICAgICAgICBcInJhZGl1c1wiOiByaW5nX3dpZHRoLzJcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGVkZ2VzLnB1c2goZWRnZSlcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0pXG5cbiAgfSlcblxuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcblxuICAgIGlmICghdmFycy5zbWFsbCAmJiB2YXJzLmxhYmVscy52YWx1ZSkge1xuXG4gICAgICBpZiAoblt2YXJzLmlkLnZhbHVlXSAhPSB2YXJzLmZvY3VzLnZhbHVlWzBdKSB7XG5cbiAgICAgICAgbi5kM3BsdXMucm90YXRlID0gbi5kM3BsdXMucmFkaWFucyooMTgwL01hdGguUEkpXG5cbiAgICAgICAgdmFyIGFuZ2xlID0gbi5kM3BsdXMucm90YXRlLFxuICAgICAgICAgICAgd2lkdGggPSByaW5nX3dpZHRoLSh2YXJzLmxhYmVscy5wYWRkaW5nKjMpLW4uZDNwbHVzLnJcblxuICAgICAgICBpZiAoYW5nbGUgPCAtOTAgfHwgYW5nbGUgPiA5MCkge1xuICAgICAgICAgIGFuZ2xlID0gYW5nbGUtMTgwXG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IC0obi5kM3BsdXMucit3aWR0aC8yK3ZhcnMubGFiZWxzLnBhZGRpbmcpLFxuICAgICAgICAgICAgICBhbmNob3IgPSBcImVuZFwiXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IG4uZDNwbHVzLnIrd2lkdGgvMit2YXJzLmxhYmVscy5wYWRkaW5nLFxuICAgICAgICAgICAgICBhbmNob3IgPSBcInN0YXJ0XCJcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiYWNrZ3JvdW5kID0gcHJpbWFyaWVzLmluZGV4T2YobikgPj0gMCA/IHRydWUgOiBmYWxzZVxuXG4gICAgICAgIHZhciBoZWlnaHQgPSBuLmQzcGx1cy5yaW5nID09IDEgPyBwcmltYXJ5RGlzdGFuY2UgOiBzZWNvbmRhcnlEaXN0YW5jZVxuICAgICAgICBoZWlnaHQgKz0gdmFycy5sYWJlbHMucGFkZGluZyoyXG5cbiAgICAgICAgbi5kM3BsdXMubGFiZWwgPSB7XG4gICAgICAgICAgXCJ4XCI6IGJ1ZmZlcixcbiAgICAgICAgICBcInlcIjogMCxcbiAgICAgICAgICBcIndcIjogd2lkdGgsXG4gICAgICAgICAgXCJoXCI6IGhlaWdodCxcbiAgICAgICAgICBcImFuZ2xlXCI6IGFuZ2xlLFxuICAgICAgICAgIFwiYW5jaG9yXCI6IGFuY2hvcixcbiAgICAgICAgICBcInZhbGlnblwiOiBcImNlbnRlclwiLFxuICAgICAgICAgIFwiY29sb3JcIjogZDNwbHVzLmNvbG9yLmxlZ2libGUoZmV0Y2hDb2xvcih2YXJzLG5bdmFycy5pZC52YWx1ZV0pKSxcbiAgICAgICAgICBcInJlc2l6ZVwiOiBbOCx2YXJzLmxhYmVscy5mb250LnNpemVdLFxuICAgICAgICAgIFwiYmFja2dyb3VuZFwiOiBiYWNrZ3JvdW5kLFxuICAgICAgICAgIFwibW91c2VcIjogdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHZhcnMuc2l6ZS52YWx1ZSB8fCB2YXJzLmVkZ2VzLmxhYmVsKSB7XG5cbiAgICAgICAgdmFyIGhlaWdodCA9IHByaW1hcnlSaW5nLW4uZDNwbHVzLnIqMi12YXJzLmxhYmVscy5wYWRkaW5nKjJcblxuICAgICAgICBuLmQzcGx1cy5sYWJlbCA9IHtcbiAgICAgICAgICBcInhcIjogMCxcbiAgICAgICAgICBcInlcIjogbi5kM3BsdXMucitoZWlnaHQvMixcbiAgICAgICAgICBcIndcIjogcHJpbWFyeVJpbmcsXG4gICAgICAgICAgXCJoXCI6IGhlaWdodCxcbiAgICAgICAgICBcImNvbG9yXCI6IGQzcGx1cy5jb2xvci5sZWdpYmxlKGZldGNoQ29sb3IodmFycyxuW3ZhcnMuaWQudmFsdWVdKSksXG4gICAgICAgICAgXCJyZXNpemVcIjogWzEwLDQwXSxcbiAgICAgICAgICBcImJhY2tncm91bmRcIjogdHJ1ZSxcbiAgICAgICAgICBcIm1vdXNlXCI6IHRydWVcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZGVsZXRlIG4uZDNwbHVzLnJvdGF0ZVxuICAgICAgICBkZWxldGUgbi5kM3BsdXMubGFiZWxcbiAgICAgIH1cblxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGRlbGV0ZSBuLmQzcGx1cy5yb3RhdGVcbiAgICAgIGRlbGV0ZSBuLmQzcGx1cy5sYWJlbFxuICAgIH1cblxuICB9KVxuXG4gIHZhcnMubW91c2VbZDNwbHVzLmV2dC5jbGlja10gPSBmdW5jdGlvbihkKSB7XG4gICAgaWYgKGRbdmFycy5pZC52YWx1ZV0gIT0gdmFycy5mb2N1cy52YWx1ZVswXSkge1xuICAgICAgZDNwbHVzLnRvb2x0aXAucmVtb3ZlKHZhcnMudHlwZS52YWx1ZSlcbiAgICAgIHZhcnMuc2VsZi5mb2N1cyhkW3ZhcnMuaWQudmFsdWVdKS5kcmF3KClcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1wiZWRnZXNcIjogZWRnZXMsIFwibm9kZXNcIjogbm9kZXMsIFwiZGF0YVwiOiBkYXRhfVxuXG59O1xuXG4vL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gVmlzdWFsaXphdGlvbiBTZXR0aW5ncyBhbmQgSGVscGVyIEZ1bmN0aW9uc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnJpbmdzLmZpbHRlciAgICAgICA9IGZ1bmN0aW9uKCB2YXJzICwgZGF0YSApIHtcblxuICB2YXIgcHJpbWFyaWVzID0gdmFycy5lZGdlcy5jb25uZWN0aW9ucyh2YXJzLmZvY3VzLnZhbHVlWzBdLHZhcnMuaWQudmFsdWUsdHJ1ZSlcbiAgICAsIHNlY29uZGFyaWVzID0gW11cblxuICBwcmltYXJpZXMuZm9yRWFjaChmdW5jdGlvbihwKXtcbiAgICBzZWNvbmRhcmllcyA9IHNlY29uZGFyaWVzLmNvbmNhdCh2YXJzLmVkZ2VzLmNvbm5lY3Rpb25zKHBbdmFycy5pZC52YWx1ZV0sdmFycy5pZC52YWx1ZSx0cnVlKSlcbiAgfSlcblxuICB2YXIgY29ubmVjdGlvbnMgPSBwcmltYXJpZXMuY29uY2F0KHNlY29uZGFyaWVzKVxuICAgICwgaWRzID0gZDNwbHVzLnV0aWwudW5pcXVlcyhjb25uZWN0aW9ucyx2YXJzLmlkLnZhbHVlKVxuICAgICwgcmV0dXJuRGF0YSA9IFtdXG5cbiAgaWRzLmZvckVhY2goZnVuY3Rpb24oaWQpe1xuXG4gICAgdmFyIGQgPSBkYXRhLmZpbHRlcihmdW5jdGlvbihkKXtcbiAgICAgIHJldHVybiBkW3ZhcnMuaWQudmFsdWVdID09IGlkXG4gICAgfSlbMF1cblxuICAgIGlmICggIWQgKSB7XG4gICAgICB2YXIgb2JqID0ge1wiZDNwbHVzXCI6IHt9fVxuICAgICAgb2JqW3ZhcnMuaWQudmFsdWVdID0gaWRcbiAgICAgIHJldHVybkRhdGEucHVzaChvYmopXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuRGF0YS5wdXNoKGQpXG4gICAgfVxuXG4gIH0pXG5cbiAgcmV0dXJuIHJldHVybkRhdGFcblxufVxucmluZ3MubmVzdGluZyAgICAgID0gZmFsc2VcbnJpbmdzLnNjYWxlICAgICAgICA9IDFcbnJpbmdzLnNoYXBlcyAgICAgICA9IFsgXCJjaXJjbGVcIiAsIFwic3F1YXJlXCIgLCBcImRvbnV0XCIgXVxucmluZ3MucmVxdWlyZW1lbnRzID0gWyBcImVkZ2VzXCIgLCBcImZvY3VzXCIgXVxucmluZ3MudG9vbHRpcCAgICAgID0gXCJzdGF0aWNcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IHJpbmdzXG4iLCJ2YXIgY2hhcnQgPSByZXF1aXJlKFwiLi9jaGFydC5qc1wiKVxuLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIFNjYXR0ZXJwbG90XG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIHNjYXR0ZXIgPSBmdW5jdGlvbih2YXJzKSB7XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIFRoaXMgdmlzdWFsaXphdGlvbiBpcyBhbiBleHRlbnRpb24gb2YgdGhlIENoYXJ0IHZpc3VhbGl6YXRpb24uXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICByZXR1cm4gY2hhcnQodmFycylcblxufVxuXG4vL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gVmlzdWFsaXphdGlvbiBTZXR0aW5ncyBhbmQgSGVscGVyIEZ1bmN0aW9uc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnNjYXR0ZXIuZmlsbCAgICAgICAgID0gdHJ1ZVxuc2NhdHRlci5yZXF1aXJlbWVudHMgPSBbIFwiZGF0YVwiICwgXCJ4XCIgLCBcInlcIiBdXG5zY2F0dGVyLnNjYWxlICAgICAgICA9IGNoYXJ0LnNjYWxlXG5zY2F0dGVyLnNldHVwICAgICAgICA9IGNoYXJ0LnNldHVwXG5zY2F0dGVyLnNoYXBlcyAgICAgICA9IFsgXCJjaXJjbGVcIiAsIFwic3F1YXJlXCIgLCBcImRvbnV0XCIgXVxuc2NhdHRlci50b29sdGlwICAgICAgPSBcInN0YXRpY1wiXG5cbm1vZHVsZS5leHBvcnRzID0gc2NhdHRlclxuIiwidmFyIGNoYXJ0ID0gcmVxdWlyZShcIi4vY2hhcnQuanNcIiksXG4gICAgZGF0YVRocmVzaG9sZCA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL2RhdGEvdGhyZXNob2xkLmpzXCIpXG4vL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gU3RhY2tlZCBBcmVhIENoYXJ0XG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIHN0YWNrZWQgPSBmdW5jdGlvbih2YXJzKSB7XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIFRoaXMgdmlzdWFsaXphdGlvbiBpcyBhbiBleHRlbnRpb24gb2YgdGhlIENoYXJ0IHZpc3VhbGl6YXRpb24uXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICByZXR1cm4gY2hhcnQodmFycylcblxufVxuXG4vL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gVmlzdWFsaXphdGlvbiBTZXR0aW5ncyBhbmQgSGVscGVyIEZ1bmN0aW9uc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnN0YWNrZWQuZmlsdGVyICAgICAgID0gZnVuY3Rpb24oIHZhcnMgLCBkYXRhICkge1xuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBNZXJnZSBkYXRhIHBvaW50cyBiZWxvdyB0aGUgdGhyZXNob2xkXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICByZXR1cm4gZGF0YVRocmVzaG9sZCggdmFycyAsIGRhdGEgLCB2YXJzLngudmFsdWUgKVxuXG59XG5zdGFja2VkLnJlcXVpcmVtZW50cyA9IFsgXCJkYXRhXCIgLCBcInhcIiAsIFwieVwiIF1cblxuc3RhY2tlZC5zZXR1cCAgICAgICAgPSBmdW5jdGlvbiggdmFycyApIHtcblxuICB2YXJzLnNlbGZcbiAgICAueCh7IFwic2NhbGVcIiA6IFwiY29udGludW91c1wiICwgXCJ6ZXJvZmlsbFwiIDogdHJ1ZSB9KVxuICAgIC55KHsgXCJzdGFja2VkXCIgOiB0cnVlIH0pXG5cbiAgdmFyIHkgICAgPSB2YXJzLnlcbiAgICAsIHNpemUgPSB2YXJzLnNpemVcblxuICBpZiAoICggIXkudmFsdWUgJiYgc2l6ZS52YWx1ZSApIHx8ICggc2l6ZS5jaGFuZ2VkICYmIHNpemUucHJldmlvdXMgPT09IHkudmFsdWUgKSApIHtcblxuICAgIHZhcnMuc2VsZi55KCBzaXplLnZhbHVlIClcblxuICB9XG4gIGVsc2UgaWYgKCAoICFzaXplLnZhbHVlICYmIHkudmFsdWUgKSB8fCAoIHkuY2hhbmdlZCAmJiB5LnByZXZpb3VzID09PSBzaXplLnZhbHVlICkgKSB7XG5cbiAgICB2YXJzLnNlbGYuc2l6ZSggeS52YWx1ZSApXG5cbiAgfVxuXG59XG5cbnN0YWNrZWQuc2hhcGVzICAgICAgID0gWyBcImFyZWFcIiBdXG5zdGFja2VkLnRocmVzaG9sZCAgICA9IGZ1bmN0aW9uKCB2YXJzICkge1xuICByZXR1cm4gMjAgLyB2YXJzLmhlaWdodC52aXpcbn1cbnN0YWNrZWQudG9vbHRpcCAgICAgID0gXCJzdGF0aWNcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrZWRcbiIsInZhciBkYXRhVGhyZXNob2xkID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvZGF0YS90aHJlc2hvbGQuanNcIiksXG4gICAgZmV0Y2hWYWx1ZSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL2ZldGNoL3ZhbHVlLmpzXCIpXG4vL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gVHJlZSBNYXBcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgdHJlZV9tYXAgPSBmdW5jdGlvbih2YXJzKSB7XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIEdyb3VwIHRoZSBkYXRhIGJ5IGVhY2ggZGVwdGggZGVmaW5lZCBieSB0aGUgLmlkKCkgbWV0aG9kLlxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgdmFyIGdyb3VwZWRfZGF0YSA9IGQzLm5lc3QoKVxuXG4gIHZhcnMuaWQubmVzdGluZy5mb3JFYWNoKGZ1bmN0aW9uKG4saSl7XG5cbiAgICBpZiAoaSA8IHZhcnMuZGVwdGgudmFsdWUpIHtcblxuICAgICAgZ3JvdXBlZF9kYXRhLmtleShmdW5jdGlvbihkKXtcblxuICAgICAgICByZXR1cm4gZmV0Y2hWYWx1ZSh2YXJzLGQuZDNwbHVzLG4pXG5cbiAgICAgIH0pXG5cbiAgICB9XG5cbiAgfSlcblxuICB2YXIgc3RyaXBwZWREYXRhID0gW11cbiAgdmFycy5kYXRhLmFwcC5mb3JFYWNoKGZ1bmN0aW9uKGQpe1xuXG4gICAgdmFyIHZhbCA9IGZldGNoVmFsdWUodmFycyxkLHZhcnMuc2l6ZS52YWx1ZSlcblxuICAgIGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIikge1xuXG4gICAgICBzdHJpcHBlZERhdGEucHVzaCh7XG4gICAgICAgIFwiZDNwbHVzXCIgOiBkLFxuICAgICAgICBcImlkXCIgICAgIDogZFt2YXJzLmlkLnZhbHVlXSxcbiAgICAgICAgXCJ2YWx1ZVwiICA6IGZldGNoVmFsdWUodmFycyxkLHZhcnMuc2l6ZS52YWx1ZSlcbiAgICAgIH0pXG5cbiAgICB9XG5cbiAgfSlcblxuICBncm91cGVkX2RhdGEgPSBncm91cGVkX2RhdGEuZW50cmllcyhzdHJpcHBlZERhdGEpXG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIFBhc3MgZGF0YSB0aHJvdWdoIHRoZSBEM2pzIC50cmVlbWFwKCkgbGF5b3V0LlxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgdmFyIGRhdGEgPSBkMy5sYXlvdXQudHJlZW1hcCgpXG4gICAgLm1vZGUodmFycy50eXBlLm1vZGUudmFsdWUpXG4gICAgLnJvdW5kKHRydWUpXG4gICAgLnNpemUoWyB2YXJzLndpZHRoLnZpeiAsIHZhcnMuaGVpZ2h0LnZpeiBdKVxuICAgIC5jaGlsZHJlbihmdW5jdGlvbihkKSB7XG5cbiAgICAgIHJldHVybiBkLnZhbHVlc1xuXG4gICAgfSlcbiAgICAucGFkZGluZygxKVxuICAgIC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblxuICAgICAgdmFyIHNpemVEaWZmID0gYS52YWx1ZSAtIGIudmFsdWVcbiAgICAgIHJldHVybiBzaXplRGlmZiA9PT0gMCA/IGEuaWQgPCBiLmlkIDogc2l6ZURpZmZcblxuICAgIH0pXG4gICAgLm5vZGVzKHtcbiAgICAgIFwibmFtZVwiOlwicm9vdFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogZ3JvdXBlZF9kYXRhXG4gICAgfSlcbiAgICAuZmlsdGVyKGZ1bmN0aW9uKGQpIHtcblxuICAgICAgcmV0dXJuICFkLnZhbHVlcyAmJiBkLmFyZWFcblxuICAgIH0pXG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIElmIHRoZSBcImRhdGFcIiBhcnJheSBoYXMgZW50cmllcy4uLlxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgaWYgKGRhdGEubGVuZ3RoKSB7XG5cbiAgICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgLy8gQ3JlYXRlIHRoZSBcInJvb3RcIiBub2RlIHRvIHVzZSB3aGVuIGNhbGN1bGF0aW5nIHNoYXJlIHBlcmNlbnRhZ2UuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciByb290ID0gZGF0YVswXVxuXG4gICAgd2hpbGUgKHJvb3QucGFyZW50KSB7XG5cbiAgICAgIHJvb3QgPSByb290LnBhcmVudFxuXG4gICAgfVxuXG4gICAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24sIHNpemUsIGFuZCBzaGFyZSBwZXJjZW50YWdlIG9mIGVhY2ggc3F1YXJlLlxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgcmV0dXJuRGF0YSA9IFtdXG4gICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQpe1xuXG4gICAgICBkLmQzcGx1cy5kM3BsdXMgPSBkM3BsdXMub2JqZWN0Lm1lcmdlKGQuZDNwbHVzLmQzcGx1cyx7XG4gICAgICAgIFwieFwiOiBkLngrZC5keC8yLFxuICAgICAgICBcInlcIjogZC55K2QuZHkvMixcbiAgICAgICAgXCJ3aWR0aFwiOiBkLmR4LFxuICAgICAgICBcImhlaWdodFwiOiBkLmR5LFxuICAgICAgICBcInNoYXJlXCI6IGQudmFsdWUvcm9vdC52YWx1ZVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuRGF0YS5wdXNoKGQuZDNwbHVzKVxuXG4gICAgfSlcblxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIFJldHVybiB0aGUgZGF0YSBhcnJheS5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHJldHVybiByZXR1cm5EYXRhXG5cbn1cblxuLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIFZpc3VhbGl6YXRpb24gU2V0dGluZ3MgYW5kIEhlbHBlciBGdW5jdGlvbnNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG50cmVlX21hcC5maWx0ZXIgICAgICAgPSBmdW5jdGlvbiggdmFycyAsIGRhdGEgKSB7XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIE1lcmdlIGRhdGEgcG9pbnRzIGJlbG93IHRoZSB0aHJlc2hvbGRcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHJldHVybiBkYXRhVGhyZXNob2xkKCB2YXJzICwgZGF0YSApXG5cbn1cbnRyZWVfbWFwLm1vZGVzICAgICAgICA9IFtcInNxdWFyaWZ5XCIsIFwic2xpY2VcIiwgXCJkaWNlXCIsIFwic2xpY2UtZGljZVwiXVxudHJlZV9tYXAucmVxdWlyZW1lbnRzID0gW1wiZGF0YVwiLCBcInNpemVcIl1cbnRyZWVfbWFwLnNoYXBlcyAgICAgICA9IFtcInNxdWFyZVwiXVxudHJlZV9tYXAudGhyZXNob2xkICAgID0gZnVuY3Rpb24oIHZhcnMgKSB7XG4gIHJldHVybiAoIDQwICogNDAgKSAvICh2YXJzLndpZHRoLnZpeiAqIHZhcnMuaGVpZ2h0LnZpeilcbn1cbnRyZWVfbWFwLnRvb2x0aXAgICAgICA9IFwiZm9sbG93XCJcblxubW9kdWxlLmV4cG9ydHMgPSB0cmVlX21hcFxuIiwiLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIERyYXdzIGEgVUkgZHJhd2VyLCBpZiBkZWZpbmVkLlxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmQzcGx1cy51aS5kcmF3ZXIgPSBmdW5jdGlvbiggdmFycyApIHtcblxuICB2YXIgZW5hYmxlZCA9IHZhcnMudWkudmFsdWUgJiYgdmFycy51aS52YWx1ZS5sZW5ndGhcbiAgICAsIHBvc2l0aW9uID0gdmFycy51aS5wb3NpdGlvbi52YWx1ZVxuXG4gIGlmICggdmFycy5kZXYudmFsdWUgJiYgZW5hYmxlZCApIGQzcGx1cy5jb25zb2xlLnRpbWUoXCJkcmF3aW5nIGN1c3RvbSBVSSBlbGVtZW50c1wiKVxuXG4gIHZhciBkcmF3ZXIgPSB2YXJzLmNvbnRhaW5lci52YWx1ZS5zZWxlY3RBbGwoXCJkaXYjZDNwbHVzX2RyYXdlclwiKVxuICAgIC5kYXRhKFtcImQzcGx1c19kcmF3ZXJcIl0pXG5cbiAgZHJhd2VyLmVudGVyKCkuYXBwZW5kKFwiZGl2XCIpXG4gICAgLmF0dHIoXCJpZFwiLFwiZDNwbHVzX2RyYXdlclwiKVxuXG4gIHZhciBwb3NpdGlvblN0eWxlcyA9IHt9XG4gIHZhcnMudWkucG9zaXRpb24uYWNjZXB0ZWQuZm9yRWFjaChmdW5jdGlvbihwKXtcbiAgICBwb3NpdGlvblN0eWxlc1twXSA9IHAgPT0gcG9zaXRpb24gPyB2YXJzLm1hcmdpbi5ib3R0b20rXCJweFwiIDogXCJhdXRvXCJcbiAgfSlcblxuICBkcmF3ZXJcbiAgICAuc3R5bGUoXCJ0ZXh0LWFsaWduXCIsdmFycy51aS5hbGlnbi52YWx1ZSlcbiAgICAuc3R5bGUoXCJwb3NpdGlvblwiLFwiYWJzb2x1dGVcIilcbiAgICAuc3R5bGUoXCJ3aWR0aFwiLHZhcnMud2lkdGgudmFsdWUtKHZhcnMudWkucGFkZGluZyoyKStcInB4XCIpXG4gICAgLnN0eWxlKFwiaGVpZ2h0XCIsXCJhdXRvXCIpXG4gICAgLnN0eWxlKHBvc2l0aW9uU3R5bGVzKVxuXG4gIHZhciB1aSA9IGRyYXdlci5zZWxlY3RBbGwoXCJkaXYuZDNwbHVzX2RyYXdlcl91aVwiKVxuICAgIC5kYXRhKGVuYWJsZWQgPyB2YXJzLnVpLnZhbHVlIDogW10sIGZ1bmN0aW9uKGQpe1xuICAgICAgcmV0dXJuIGQubWV0aG9kIHx8IGZhbHNlXG4gICAgfSlcblxuICB1aS5lbnRlcigpLmFwcGVuZChcImRpdlwiKVxuICAgIC5hdHRyKFwiY2xhc3NcIixcImQzcGx1c19kcmF3ZXJfdWlcIilcbiAgICAuc3R5bGUoXCJwYWRkaW5nXCIsdmFycy51aS5wYWRkaW5nK1wicHhcIilcbiAgICAuc3R5bGUoXCJkaXNwbGF5XCIsXCJpbmxpbmUtYmxvY2tcIilcbiAgICAuZWFjaChmdW5jdGlvbihkKXtcblxuICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKVxuXG4gICAgICBkLmZvcm0gPSBkM3BsdXMuZm9ybSgpXG4gICAgICAgIC5jb250YWluZXIoY29udGFpbmVyKVxuICAgICAgICAuZm9jdXModmFyc1tkLm1ldGhvZF0udmFsdWUsZnVuY3Rpb24odmFsdWUpe1xuXG4gICAgICAgICAgaWYgKCB2YWx1ZVswXSAhPT0gdmFyc1tkLm1ldGhvZF0udmFsdWUgKSB7XG4gICAgICAgICAgICB2YXJzLnNlbGZbZC5tZXRob2RdKHZhbHVlWzBdKS5kcmF3KClcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSlcbiAgICAgICAgLmlkKFwiaWRcIilcbiAgICAgICAgLnRleHQoXCJ0ZXh0XCIpXG4gICAgICAgIC50eXBlKFwiYXV0b1wiKVxuXG4gICAgfSlcblxuICB1aS5lYWNoKGZ1bmN0aW9uKGQpe1xuXG4gICAgdmFyIGRhdGEgPSBbXVxuICAgICAgLCB0aXRsZSA9IHZhcnMuZm9ybWF0LmxvY2FsZS52YWx1ZS5tZXRob2RbZC5tZXRob2RdIHx8IGQubWV0aG9kXG5cbiAgICBkLnZhbHVlLmZvckVhY2goZnVuY3Rpb24obyl7XG5cbiAgICAgIHZhciBvYmogPSB7XG4gICAgICAgIFwiaWRcIjogbyxcbiAgICAgICAgXCJ0ZXh0XCI6IHZhcnMuZm9ybWF0LnZhbHVlKG8pXG4gICAgICB9XG4gICAgICBkYXRhLnB1c2gob2JqKVxuXG4gICAgfSlcblxuICAgIHZhciBmb250ID0gZDNwbHVzLnV0aWwuY29weSh2YXJzLnVpLmZvbnQpXG4gICAgZm9udC5zZWNvbmRhcnkgPSB2YXJzLnVpLmZvbnRcblxuICAgIGQuZm9ybVxuICAgICAgLmRhdGEoZGF0YSlcbiAgICAgIC5mb250KGZvbnQpXG4gICAgICAuZm9ybWF0KHZhcnMuZm9ybWF0LmxvY2FsZS5sYW5ndWFnZSlcbiAgICAgIC50aXRsZSh2YXJzLmZvcm1hdC52YWx1ZSh0aXRsZSkpXG4gICAgICAudWkoe1xuICAgICAgICBcImFsaWduXCI6IHZhcnMudWkuYWxpZ24udmFsdWUsXG4gICAgICAgIFwicGFkZGluZ1wiOiB2YXJzLnVpLnBhZGRpbmcsXG4gICAgICAgIFwibWFyZ2luXCI6IDBcbiAgICAgIH0pXG4gICAgICAud2lkdGgoZC53aWR0aCB8fCBmYWxzZSlcbiAgICAgIC5kcmF3KClcblxuICB9KVxuXG4gIHVpLmV4aXQoKS5yZW1vdmUoKVxuXG4gIHZhciBkcmF3ZXJIZWlnaHQgPSBkcmF3ZXIubm9kZSgpLm9mZnNldEhlaWdodCB8fCBkcmF3ZXIubm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodFxuXG4gIGlmICggZHJhd2VySGVpZ2h0ICkge1xuICAgIHZhcnMubWFyZ2luW3Bvc2l0aW9uXSArPSBkcmF3ZXJIZWlnaHRcbiAgfVxuXG4gIGlmICggdmFycy5kZXYudmFsdWUgJiYgZW5hYmxlZCApIGQzcGx1cy5jb25zb2xlLnRpbWVFbmQoXCJkcmF3aW5nIGN1c3RvbSBVSSBlbGVtZW50c1wiKVxuXG59XG4iLCJ2YXIgZmV0Y2hWYWx1ZSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL2ZldGNoL3ZhbHVlLmpzXCIpXG4vL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIENyZWF0ZXMgZm9jdXMgdG9vbHRpcCwgaWYgYXBwbGljYWJsZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kM3BsdXMudWkuZm9jdXMgPSBmdW5jdGlvbih2YXJzKSB7XG5cbiAgaWYgKCF2YXJzLmludGVybmFsX2Vycm9yICYmIHZhcnMuZm9jdXMudmFsdWUubGVuZ3RoID09PSAxICYmIHZhcnMuZm9jdXMudmFsdWUubGVuZ3RoICYmICF2YXJzLnNtYWxsICYmIHZhcnMuZm9jdXMudG9vbHRpcC52YWx1ZSkge1xuXG4gICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWUoXCJkcmF3aW5nIGZvY3VzIHRvb2x0aXBcIilcblxuICAgIHZhciBkYXRhID0gdmFycy5kYXRhLnBvb2wuZmlsdGVyKGZ1bmN0aW9uKGQpe1xuICAgICAgcmV0dXJuIGZldGNoVmFsdWUodmFycyxkLHZhcnMuaWQudmFsdWUpID09IHZhcnMuZm9jdXMudmFsdWVbMF1cbiAgICB9KVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID49IDEpIHtcbiAgICAgIGRhdGEgPSBkYXRhWzBdXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZGF0YSA9IHt9XG4gICAgICBkYXRhW3ZhcnMuaWQudmFsdWVdID0gdmFycy5mb2N1cy52YWx1ZVswXVxuICAgIH1cblxuICAgIHZhciBvZmZzZXQgPSB2YXJzLmxhYmVscy5wYWRkaW5nXG5cbiAgICBkM3BsdXMudG9vbHRpcC5hcHAoe1xuICAgICAgXCJhbmNob3JcIjogXCJ0b3AgbGVmdFwiLFxuICAgICAgXCJhcnJvd1wiOiBmYWxzZSxcbiAgICAgIFwiZGF0YVwiOiBkYXRhLFxuICAgICAgXCJsZW5ndGhcIjogXCJsb25nXCIsXG4gICAgICBcImZ1bGxzY3JlZW5cIjogZmFsc2UsXG4gICAgICBcImlkXCI6IHZhcnMudHlwZS52YWx1ZStcIl9mb2N1c1wiLFxuICAgICAgXCJtYXhoZWlnaHRcIjogdmFycy5oZWlnaHQudml6LW9mZnNldCoyLFxuICAgICAgXCJtb3VzZWV2ZW50c1wiOiB0cnVlLFxuICAgICAgXCJvZmZzZXRcIjogMCxcbiAgICAgIFwidmFyc1wiOiB2YXJzLFxuICAgICAgXCJ4XCI6IHZhcnMud2lkdGgudmFsdWUtdmFycy5tYXJnaW4ucmlnaHQtb2Zmc2V0LFxuICAgICAgXCJ5XCI6IHZhcnMubWFyZ2luLnRvcCtvZmZzZXQsXG4gICAgICBcIndpZHRoXCI6IHZhcnMudG9vbHRpcC5sYXJnZVxuICAgIH0pXG5cbiAgICBpZighZDMuc2VsZWN0KFwiZGl2I2QzcGx1c190b29sdGlwX2lkX1wiK3ZhcnMudHlwZS52YWx1ZStcIl9mb2N1c1wiKS5lbXB0eSgpKSB7XG4gICAgICB2YXJzLndpZHRoLnZpeiAtPSAodmFycy50b29sdGlwLmxhcmdlK29mZnNldCoyKVxuICAgIH1cblxuICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lRW5kKFwiZHJhd2luZyBmb2N1cyB0b29sdGlwXCIpXG5cbiAgfVxuICBlbHNlIHtcbiAgICBkM3BsdXMudG9vbHRpcC5yZW1vdmUodmFycy50eXBlLnZhbHVlK1wiX2ZvY3VzXCIpXG4gIH1cblxufVxuIiwiLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIENyZWF0ZXMgXCJiYWNrXCIgYnV0dG9uLCBpZiBhcHBsaWNhYmxlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZDNwbHVzLnVpLmhpc3RvcnkgPSBmdW5jdGlvbih2YXJzKSB7XG5cbiAgaWYgKCF2YXJzLnNtYWxsICYmIHZhcnMuaGlzdG9yeS5zdGF0ZXMubGVuZ3RoID4gMCkge1xuXG4gICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWUoXCJkcmF3aW5nIGJhY2sgYnV0dG9uXCIpXG5cbiAgICB2YXIgYnV0dG9uID0gdmFycy5jb250YWluZXIudmFsdWUuc2VsZWN0QWxsKFwiZGl2I2QzcGx1c19iYWNrX2J1dHRvblwiKVxuICAgICAgLmRhdGEoW1wiZDNwbHVzX2JhY2tfYnV0dG9uXCJdKVxuXG4gICAgdmFyIHNpemUgPSB2YXJzLnRpdGxlLnZhbHVlXG4gICAgICA/IHZhcnMudGl0bGUuZm9udC5zaXplIDogdmFycy50aXRsZS5zdWIuZm9udC5zaXplXG5cbiAgICB2YXIgY29sb3IgPSB2YXJzLnRpdGxlLnN1Yi52YWx1ZVxuICAgICAgPyB2YXJzLnRpdGxlLnN1Yi5mb250LmNvbG9yIDogdmFycy50aXRsZS5mb250LmNvbG9yXG5cbiAgICB2YXIgZmFtaWx5ID0gdmFycy50aXRsZS5zdWIudmFsdWVcbiAgICAgID8gdmFycy50aXRsZS5zdWIuZm9udC5mYW1pbHkudmFsdWUgOiB2YXJzLnRpdGxlLmZvbnQuZmFtaWx5LnZhbHVlXG5cbiAgICB2YXIgd2VpZ2h0ID0gdmFycy50aXRsZS5zdWIudmFsdWVcbiAgICAgID8gdmFycy50aXRsZS5zdWIuZm9udC53ZWlnaHQgOiB2YXJzLnRpdGxlLmZvbnQud2VpZ2h0XG5cbiAgICB2YXIgcGFkZGluZyA9IHZhcnMudGl0bGUuc3ViLnZhbHVlXG4gICAgICA/IHZhcnMudGl0bGUuc3ViW1wicGFkZGluZ1wiXSA6IHZhcnMudGl0bGVbXCJwYWRkaW5nXCJdXG5cbiAgICBmdW5jdGlvbiBzdHlsZShlbGVtKSB7XG5cbiAgICAgICAgZWxlbVxuICAgICAgICAgIC5zdHlsZShcInBvc2l0aW9uXCIsXCJhYnNvbHV0ZVwiKVxuICAgICAgICAgIC5zdHlsZShcImxlZnRcIix2YXJzLnVpLnBhZGRpbmcrXCJweFwiKVxuICAgICAgICAgIC5zdHlsZShcInRvcFwiLHZhcnMubWFyZ2luLnRvcC8yLXNpemUvMitcInB4XCIpXG4gICAgICAgICAgLnN0eWxlKFwiY29sb3JcIiwgY29sb3IpXG4gICAgICAgICAgLnN0eWxlKFwiZm9udC1mYW1pbHlcIiwgZmFtaWx5KVxuICAgICAgICAgIC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsIHdlaWdodClcbiAgICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIixzaXplK1wicHhcIilcbiAgICAgICAgICAuc3R5bGUoXCJ6LWluZGV4XCIsMjAwMClcblxuICAgIH1cblxuICAgIHZhciBtaW5faGVpZ2h0ID0gc2l6ZSArIHBhZGRpbmcqMlxuICAgIGlmICh2YXJzLm1hcmdpbi50b3AgPCBtaW5faGVpZ2h0KSB7XG4gICAgICB2YXJzLm1hcmdpbi50b3AgPSBtaW5faGVpZ2h0XG4gICAgfVxuXG4gICAgdmFyIGVudGVyID0gYnV0dG9uLmVudGVyKCkuYXBwZW5kKFwiZGl2XCIpXG4gICAgICAuYXR0cihcImlkXCIsXCJkM3BsdXNfYmFja19idXR0b25cIilcbiAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwwKVxuICAgICAgLmNhbGwoc3R5bGUpXG4gICAgICAuaHRtbChmdW5jdGlvbigpe1xuXG4gICAgICAgIGlmIChkM3BsdXMuZm9udC5hd2Vzb21lKSB7XG4gICAgICAgICAgdmFyIGFycm93ID0gXCI8c3BhbiBzdHlsZT0nZm9udC1mYW1pbHk6Rm9udEF3ZXNvbWU7bWFyZ2luLXJpZ2h0OjVweDsnPiYjeGYxMDQ8L3NwYW4+XCJcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgYXJyb3cgPSBcIiZsYXF1bzsgXCJcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnJvdyt2YXJzLmZvcm1hdC52YWx1ZSh2YXJzLmZvcm1hdC5sb2NhbGUudmFsdWUudWkuYmFjaylcblxuICAgICAgfSlcblxuICAgIGJ1dHRvblxuICAgICAgLm9uKGQzcGx1cy5ldnQub3ZlcixmdW5jdGlvbigpe1xuXG4gICAgICAgIGlmICghdmFycy5zbWFsbCAmJiB2YXJzLmhpc3Rvcnkuc3RhdGVzLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgLnN0eWxlKFwiY3Vyc29yXCIsXCJwb2ludGVyXCIpXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMudGltaW5nLm1vdXNlZXZlbnRzKVxuICAgICAgICAgICAgICAuc3R5bGUoXCJjb2xvclwiLGQzcGx1cy5jb2xvci5saWdodGVyKGNvbG9yLC4yNSkpXG5cbiAgICAgICAgfVxuXG4gICAgICB9KVxuICAgICAgLm9uKGQzcGx1cy5ldnQub3V0LGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgaWYgKCF2YXJzLnNtYWxsICYmIHZhcnMuaGlzdG9yeS5zdGF0ZXMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAuc3R5bGUoXCJjdXJzb3JcIixcImF1dG9cIilcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy50aW1pbmcubW91c2VldmVudHMpXG4gICAgICAgICAgICAgIC5zdHlsZShcImNvbG9yXCIsY29sb3IpXG5cbiAgICAgICAgfVxuXG4gICAgICB9KVxuICAgICAgLm9uKGQzcGx1cy5ldnQuY2xpY2ssZnVuY3Rpb24oKXtcblxuICAgICAgICB2YXJzLmhpc3RvcnkuYmFjaygpXG5cbiAgICAgIH0pXG4gICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwxKVxuICAgICAgICAuY2FsbChzdHlsZSlcblxuICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lRW5kKFwiZHJhd2luZyBiYWNrIGJ1dHRvblwiKVxuXG4gIH1cbiAgZWxzZSB7XG4gICAgdmFycy5jb250YWluZXIudmFsdWUuc2VsZWN0QWxsKFwiZGl2I2QzcGx1c19iYWNrX2J1dHRvblwiKVxuICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLDApXG4gICAgICAucmVtb3ZlKClcbiAgfVxuXG59XG4iLCJ2YXIgZGF0YU5lc3QgICA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL2RhdGEvbmVzdC5qc1wiKSxcbiAgICBmZXRjaFZhbHVlID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvZmV0Y2gvdmFsdWUuanNcIiksXG4gICAgZmV0Y2hDb2xvciA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL2ZldGNoL2NvbG9yLmpzXCIpLFxuICAgIGZldGNoVGV4dCAgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9mZXRjaC90ZXh0LmpzXCIpXG4vL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gQ3JlYXRlcyBjb2xvciBrZXlcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kM3BsdXMudWkubGVnZW5kID0gZnVuY3Rpb24odmFycykge1xuXG4gIHZhciBrZXlfZGlzcGxheSA9IHRydWUsXG4gICAgICBzcXVhcmVfc2l6ZSA9IDAsXG4gICAgICBrZXkgPSB2YXJzLmNvbG9yLnZhbHVlXG4gICAgLCBjb2xvck5hbWUgPSB2YXJzLmNvbG9yLnZhbHVlIHx8IFwiZDNwbHVzX2NvbG9yXCJcblxuICBpZiAoIXZhcnMuaW50ZXJuYWxfZXJyb3IgJiYga2V5ICYmICF2YXJzLnNtYWxsICYmIHZhcnMubGVnZW5kLnZhbHVlKSB7XG5cbiAgICBpZiAoIXZhcnMuY29sb3IudmFsdWVTY2FsZSkge1xuXG4gICAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZShcImdyb3VwaW5nIGRhdGEgYnkgY29sb3JzXCIpXG5cbiAgICAgIGlmICggdmFycy5ub2Rlcy52YWx1ZSAmJiB2YXJzLnR5cGVzW3ZhcnMudHlwZS52YWx1ZV0ucmVxdWlyZW1lbnRzLmluZGV4T2YoXCJub2Rlc1wiKSA+PSAwICkge1xuICAgICAgICB2YXIgZGF0YSA9IHZhcnMubm9kZXMucmVzdHJpY2VkIHx8IHZhcnMubm9kZXMudmFsdWVcbiAgICAgICAgaWYgKCB2YXJzLmRhdGEuYXBwLmxlbmd0aCApIHtcbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgZGF0YS5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgICB2YXIgYXBwRGF0YSA9IHZhcnMuZGF0YS5hcHAuZmlsdGVyKGZ1bmN0aW9uKGEpe1xuICAgICAgICAgICAgICByZXR1cm4gYVt2YXJzLmlkLnZhbHVlXSA9PT0gZGF0YVtpXVt2YXJzLmlkLnZhbHVlXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGlmIChhcHBEYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICBkYXRhW2ldID0gZDNwbHVzLm9iamVjdC5tZXJnZShkYXRhW2ldLGFwcERhdGFbMF0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGRhdGEgPSB2YXJzLmRhdGEuYXBwXG4gICAgICAgIC8vIHZhciBkYXRhID0gZGF0YU5lc3QodmFycywgdmFycy5kYXRhLmFwcCwgdmFycy5pZC5uZXN0aW5nLCBbXSlcbiAgICAgIH1cblxuICAgICAgLy8gZm9yICggdmFyIHogPSAwIDsgeiA8IGRhdGEubGVuZ3RoIDsgeisrICkge1xuICAgICAgLy9cbiAgICAgIC8vICAgZCA9IGRhdGFbel1cbiAgICAgIC8vXG4gICAgICAvLyAgIGZvciAoIHZhciBpID0gMCA7IGkgPCB2YXJzLmlkLm5lc3RpbmcubGVuZ3RoIDsgaSsrICkge1xuICAgICAgLy9cbiAgICAgIC8vICAgICB2YXIgY29sb3JLZXkgPSB2YXJzLmlkLm5lc3RpbmdbaV1cbiAgICAgIC8vXG4gICAgICAvLyAgICAgaWYgKCAhKGNvbG9yS2V5IGluIGQpICkge1xuICAgICAgLy8gICAgICAgdmFyIG5leHRLZXkgPSB2YXJzLmlkLm5lc3RpbmdbIGkgKyAxIF1cbiAgICAgIC8vICAgICAgIGRbY29sb3JLZXldID0gZmV0Y2hWYWx1ZSggdmFycyAsIGRbbmV4dEtleV0gLCBjb2xvcktleSAsIG5leHRLZXkgKVxuICAgICAgLy8gICAgIH1cbiAgICAgIC8vXG4gICAgICAvLyAgIH1cbiAgICAgIC8vXG4gICAgICAvLyB9XG5cbiAgICAgIHZhciBjb2xvckZ1bmN0aW9uID0gZnVuY3Rpb24oIGQgKXtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaENvbG9yKCB2YXJzICwgZCAsIGNvbG9yS2V5IClcbiAgICAgICAgICB9XG4gICAgICAgICwgY29sb3JEZXB0aCA9IDBcbiAgICAgICAgLCBjb2xvcktleSA9IHZhcnMuaWQudmFsdWVcblxuICAgICAgaWYgKHZhcnMuaWQubmVzdGluZy5pbmRleE9mKGNvbG9yTmFtZSkgPj0gMCkge1xuICAgICAgICBjb2xvckRlcHRoID0gdmFycy5pZC5uZXN0aW5nLmluZGV4T2YodmFycy5jb2xvci52YWx1ZSlcbiAgICAgICAgY29sb3JLZXkgPSB2YXJzLmlkLm5lc3RpbmdbdmFycy5pZC5uZXN0aW5nLmluZGV4T2YoY29sb3JOYW1lKV1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPD0gdmFycy5kZXB0aC52YWx1ZSA7IGkrKyApIHtcblxuICAgICAgICAgIGNvbG9yRGVwdGggPSBpXG4gICAgICAgICAgY29sb3JLZXkgICA9IHZhcnMuaWQubmVzdGluZ1tpXVxuXG4gICAgICAgICAgdmFyIHVuaXF1ZUlEcyA9IGQzcGx1cy51dGlsLnVuaXF1ZXMoIGRhdGEgLCBmdW5jdGlvbihkKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hWYWx1ZSh2YXJzLCBkLCBjb2xvcktleSlcbiAgICAgICAgICAgICAgfSApXG4gICAgICAgICAgICAsIHVuaXF1ZUNvbG9ycyA9IGQzcGx1cy51dGlsLnVuaXF1ZXMoIGRhdGEgLCBjb2xvckZ1bmN0aW9uIClcblxuICAgICAgICAgIGlmICggdW5pcXVlSURzLmxlbmd0aCA9PT0gdW5pcXVlQ29sb3JzLmxlbmd0aCAmJiB1bmlxdWVDb2xvcnMubGVuZ3RoID4gMSApIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICB2YXIgY29sb3JzID0gZGF0YU5lc3QoIHZhcnMgLCBkYXRhICwgWyBjb2xvckZ1bmN0aW9uIF0gLCBbXSApXG5cbiAgICAgIC8vIGZvciAoIHZhciB6ID0gMCA7IHogPCBjb2xvcnMubGVuZ3RoIDsgeisrICkge1xuICAgICAgLy9cbiAgICAgIC8vICAgdmFyIGQgPSBjb2xvcnNbel1cbiAgICAgIC8vXG4gICAgICAvLyAgIC8vIHZhciBuZXh0S2V5ID0gdmFycy5pZC5uZXN0aW5nWyBjb2xvckRlcHRoICsgMSBdXG4gICAgICAvLyAgIC8vXG4gICAgICAvLyAgIC8vIGRbY29sb3JLZXldID0gZFtjb2xvcktleV1cbiAgICAgIC8vICAgLy8gICB8fCBmZXRjaFZhbHVlKCB2YXJzICwgZFtuZXh0S2V5XSAsIGNvbG9yS2V5ICwgbmV4dEtleSApXG4gICAgICAvLyAgIC8vXG4gICAgICAvLyAgIC8vIGRbY29sb3JOYW1lXSA9IGRbY29sb3JOYW1lXVxuICAgICAgLy8gICAvLyAgIHx8IGZldGNoVmFsdWUoIHZhcnMgLCBkW2NvbG9yS2V5XVswXSAsIGNvbG9yTmFtZSwgY29sb3JLZXkgKVxuICAgICAgLy9cbiAgICAgIC8vICAgZC5kM3BsdXMuY29sb3JEZXB0aCA9IGNvbG9yRGVwdGhcbiAgICAgIC8vXG4gICAgICAvLyB9XG5cbiAgICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lRW5kKFwiZ3JvdXBpbmcgZGF0YSBieSBjb2xvclwiKVxuXG4gICAgICB2YXIgYXZhaWxhYmxlX3dpZHRoID0gdmFycy53aWR0aC52YWx1ZVxuXG4gICAgICBzcXVhcmVfc2l6ZSA9IHZhcnMubGVnZW5kLnNpemVcblxuICAgICAgdmFyIGtleV93aWR0aCA9IHNxdWFyZV9zaXplKmNvbG9ycy5sZW5ndGgrdmFycy51aS5wYWRkaW5nKihjb2xvcnMubGVuZ3RoKzEpXG5cbiAgICAgIGlmIChzcXVhcmVfc2l6ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cbiAgICAgICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWUoXCJjYWxjdWxhdGluZyBsZWdlbmQgc2l6ZVwiKVxuXG4gICAgICAgIGZvciAodmFyIGkgPSBzcXVhcmVfc2l6ZVsxXTsgaSA+PSBzcXVhcmVfc2l6ZVswXTsgaS0tKSB7XG4gICAgICAgICAga2V5X3dpZHRoID0gaSpjb2xvcnMubGVuZ3RoK3ZhcnMudWkucGFkZGluZyooY29sb3JzLmxlbmd0aCsxKVxuICAgICAgICAgIGlmIChhdmFpbGFibGVfd2lkdGggPj0ga2V5X3dpZHRoKSB7XG4gICAgICAgICAgICBzcXVhcmVfc2l6ZSA9IGlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lRW5kKFwiY2FsY3VsYXRpbmcgbGVnZW5kIHNpemVcIilcblxuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIHNxdWFyZV9zaXplICE9IFwibnVtYmVyXCIgJiYgc3F1YXJlX3NpemUgIT09IGZhbHNlKSB7XG4gICAgICAgIHNxdWFyZV9zaXplID0gMzBcbiAgICAgIH1cblxuICAgICAgaWYgKGF2YWlsYWJsZV93aWR0aCA8IGtleV93aWR0aCB8fCBjb2xvcnMubGVuZ3RoID09IDEpIHtcbiAgICAgICAga2V5X2Rpc3BsYXkgPSBmYWxzZVxuICAgICAgfVxuICAgICAgZWxzZSB7XG5cbiAgICAgICAga2V5X3dpZHRoIC09IHZhcnMudWkucGFkZGluZyoyXG5cbiAgICAgICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWUoXCJzb3J0aW5nIGxlZ2VuZFwiKVxuXG4gICAgICAgIHZhciBvcmRlciA9IHZhcnNbdmFycy5sZWdlbmQub3JkZXIudmFsdWVdLnZhbHVlXG5cbiAgICAgICAgZDNwbHVzLmFycmF5LnNvcnQoIGNvbG9ycyAsIG9yZGVyICwgdmFycy5sZWdlbmQub3JkZXIuc29ydC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICwgY29sb3JOYW1lICwgdmFycyApXG5cbiAgICAgICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWVFbmQoXCJzb3J0aW5nIGxlZ2VuZFwiKVxuXG4gICAgICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lKFwiZHJhd2luZyBsZWdlbmRcIilcblxuICAgICAgICBpZiAodmFycy5sZWdlbmQuYWxpZ24gPT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0X3ggPSB2YXJzLnVpLnBhZGRpbmdcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YXJzLmxlZ2VuZC5hbGlnbiA9PSBcImVuZFwiKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0X3ggPSBhdmFpbGFibGVfd2lkdGggLSB2YXJzLnVpLnBhZGRpbmcgLSBrZXlfd2lkdGhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgc3RhcnRfeCA9IGF2YWlsYWJsZV93aWR0aC8yIC0ga2V5X3dpZHRoLzJcbiAgICAgICAgfVxuXG4gICAgICAgIHZhcnMuZy5sZWdlbmQuc2VsZWN0QWxsKFwiZy5kM3BsdXNfc2NhbGVcIilcbiAgICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsMClcbiAgICAgICAgICAucmVtb3ZlKClcblxuICAgICAgICB2YXIga2V5cyA9IHZhcnMuZy5sZWdlbmQuc2VsZWN0QWxsKFwiZy5kM3BsdXNfY29sb3JcIilcbiAgICAgICAgICAuZGF0YShjb2xvcnMsZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICB2YXIgY29sID0gZmV0Y2hDb2xvcih2YXJzLGQsY29sb3JLZXkpXG4gICAgICAgICAgICAgICwgdmFsID0gZmV0Y2hWYWx1ZSh2YXJzLGQsY29sb3JOYW1lKVxuICAgICAgICAgICAgcmV0dXJuIGNvbCt2YWxcbiAgICAgICAgICB9KVxuXG4gICAgICAgIGZ1bmN0aW9uIHBvc2l0aW9uKGdyb3VwKSB7XG5cbiAgICAgICAgICBncm91cFxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIixmdW5jdGlvbihnLGkpe1xuICAgICAgICAgICAgICB2YXIgeCA9IHN0YXJ0X3ggKyAoaSoodmFycy51aS5wYWRkaW5nK3NxdWFyZV9zaXplKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiK3grXCIsXCIrdmFycy51aS5wYWRkaW5nK1wiKVwiXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzdHlsZShyZWN0KSB7XG5cbiAgICAgICAgICByZWN0XG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsc3F1YXJlX3NpemUpXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLHNxdWFyZV9zaXplKVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsZnVuY3Rpb24oZyl7XG5cbiAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMucGFyZW50Tm9kZSkuc2VsZWN0QWxsKFwidGV4dFwiKS5yZW1vdmUoKVxuXG4gICAgICAgICAgICAgIHZhciBkZXB0aCA9IFwiZGVwdGhcIiBpbiBnLmQzcGx1cyA/IGcuZDNwbHVzLmRlcHRoIDogdmFycy5kZXB0aC52YWx1ZVxuICAgICAgICAgICAgICAgICwgZGVwdGhJZCA9IHZhcnMuaWQubmVzdGluZ1tkZXB0aF1cbiAgICAgICAgICAgICAgICAsIGljb24gPSBmZXRjaFZhbHVlKCB2YXJzICwgZyAsIHZhcnMuaWNvbi52YWx1ZSAsIGRlcHRoSWQgKVxuICAgICAgICAgICAgICAgICwgY29sb3IgPSBmZXRjaENvbG9yKCB2YXJzICwgZyAsIGRlcHRoSWQgKVxuXG4gICAgICAgICAgICAgIGlmIChpY29uICYmIGljb24gIT09IFwibnVsbFwiKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2hvcnRfdXJsID0gZDNwbHVzLnN0cmluZy5zdHJpcChpY29uK1wiX1wiK2NvbG9yKVxuICAgICAgICAgICAgICAgICAgLCBpY29uU3R5bGUgPSB2YXJzLmljb24uc3R5bGUudmFsdWVcbiAgICAgICAgICAgICAgICAgICwgcGF0dGVybiA9IHZhcnMuZGVmcy5zZWxlY3RBbGwoXCJwYXR0ZXJuI1wiK3Nob3J0X3VybClcbiAgICAgICAgICAgICAgICAgICAgICAuZGF0YShbc2hvcnRfdXJsXSlcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaWNvblN0eWxlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaWNvbl9zdHlsZSA9IHZhcnMuaWNvbi5zdHlsZS52YWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkM3BsdXMub2JqZWN0LnZhbGlkYXRlKGljb25TdHlsZSkgJiYgaWNvblN0eWxlW2RlcHRoSWRdKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaWNvbl9zdHlsZSA9IGljb25TdHlsZVtkZXB0aElkXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpY29uX3N0eWxlID0gXCJkZWZhdWx0XCJcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBpY29uX3N0eWxlID09IFwia25vY2tvdXRcIiA/IGNvbG9yIDogXCJub25lXCJcblxuICAgICAgICAgICAgICAgIHBhdHRlcm4uc2VsZWN0KFwicmVjdFwiKS50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLGNvbG9yKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLHNxdWFyZV9zaXplKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIixzcXVhcmVfc2l6ZSlcblxuICAgICAgICAgICAgICAgIHBhdHRlcm4uc2VsZWN0KFwiaW1hZ2VcIikudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsc3F1YXJlX3NpemUpXG4gICAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLHNxdWFyZV9zaXplKVxuXG4gICAgICAgICAgICAgICAgdmFyIHBhdHRlcm5fZW50ZXIgPSBwYXR0ZXJuLmVudGVyKCkuYXBwZW5kKFwicGF0dGVyblwiKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoXCJpZFwiLHNob3J0X3VybClcbiAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIixzcXVhcmVfc2l6ZSlcbiAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsc3F1YXJlX3NpemUpXG5cbiAgICAgICAgICAgICAgICBwYXR0ZXJuX2VudGVyLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLGNvbG9yKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLHNxdWFyZV9zaXplKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIixzcXVhcmVfc2l6ZSlcblxuICAgICAgICAgICAgICAgIHBhdHRlcm5fZW50ZXIuYXBwZW5kKFwiaW1hZ2VcIilcbiAgICAgICAgICAgICAgICAgIC5hdHRyKFwieGxpbms6aHJlZlwiLGljb24pXG4gICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsc3F1YXJlX3NpemUpXG4gICAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLHNxdWFyZV9zaXplKVxuICAgICAgICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oZCl7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGljb24uaW5kZXhPZihcIi9cIikgPT0gMCB8fCBpY29uLmluZGV4T2Yod2luZG93LmxvY2F0aW9uLmhvc3RuYW1lKSA+PSAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICBkM3BsdXMudXRpbC5kYXRhdXJsKGljb24sZnVuY3Rpb24oYmFzZTY0KXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybi5zZWxlY3QoXCJpbWFnZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhsaW5rOmhyZWZcIixiYXNlNjQpXG5cbiAgICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuLnNlbGVjdChcImltYWdlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhsaW5rOmhyZWZcIixpY29uKVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgIHJldHVybiBcInVybCgjXCIrc2hvcnRfdXJsK1wiKVwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGQzLnNlbGVjdCh0aGlzLnBhcmVudE5vZGUpLmFwcGVuZChcInRleHRcIilcblxuICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZm9udC1zaXplXCIsdmFycy5sZWdlbmQuZm9udC5zaXplKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoXCJmb250LXdlaWdodFwiLHZhcnMubGVnZW5kLmZvbnQud2VpZ2h0KVxuICAgICAgICAgICAgICAgICAgLmF0dHIoXCJmb250LWZhbWlseVwiLHZhcnMubGVnZW5kLmZvbnQuZmFtaWx5LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIixcInN0YXJ0XCIpXG4gICAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIixkM3BsdXMuY29sb3IudGV4dChjb2xvcikpXG4gICAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwwKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsMClcbiAgICAgICAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKHQpe1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZEluZGV4ID0gdmFycy5pZC5uZXN0aW5nLmluZGV4T2YoY29sb3JLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgLCB0ZXh0ID0gaWRJbmRleCA+PSAwID8gZmV0Y2hUZXh0KHZhcnMsdCxpZEluZGV4KSA6IFt2YXJzLmZvcm1hdC52YWx1ZShmZXRjaFZhbHVlKHZhcnMsdCxjb2xvck5hbWUsY29sb3JLZXkpKV1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dC5sZW5ndGggPT09IDEgJiYgdGV4dFswXS5sZW5ndGgpIHtcblxuICAgICAgICAgICAgICAgICAgICAgIGQzcGx1cy50ZXh0d3JhcCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY29udGFpbmVyKCBkMy5zZWxlY3QodGhpcykgKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmhlaWdodCggc3F1YXJlX3NpemUgLSB2YXJzLnVpLnBhZGRpbmcgKiAyIClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXNpemUoIHZhcnMubGFiZWxzLnJlc2l6ZS52YWx1ZSApXG4gICAgICAgICAgICAgICAgICAgICAgICAudGV4dCggdGV4dFswXSApXG4gICAgICAgICAgICAgICAgICAgICAgICAud2lkdGgoIHNxdWFyZV9zaXplIC0gdmFycy51aS5wYWRkaW5nICogMiApXG4gICAgICAgICAgICAgICAgICAgICAgICAuZHJhdygpXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsZnVuY3Rpb24odCl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoID0gdGhpcy5nZXRCQm94KCkuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZiA9IHBhcnNlRmxvYXQoZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiZm9udC1zaXplXCIpLDEwKS81XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzcXVhcmVfc2l6ZS8yIC0gaC8yIC0gZGlmZi8yXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcInRzcGFuXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLGZ1bmN0aW9uKHQpe1xuICAgICAgICAgICAgICAgICAgICAgIHZhciB3ID0gdGhpcy5nZXRDb21wdXRlZFRleHRMZW5ndGgoKVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzcXVhcmVfc2l6ZS8yIC0gdy8yXG4gICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICBpZiAodGV4dC5zZWxlY3QoXCJ0c3BhblwiKS5lbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICB0ZXh0LnJlbW92ZSgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSlcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleV9lbnRlciA9IGtleXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLFwiZDNwbHVzX2NvbG9yXCIpXG4gICAgICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsMClcbiAgICAgICAgICAuY2FsbChwb3NpdGlvbilcblxuICAgICAgICBrZXlfZW50ZXJcbiAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLFwiZDNwbHVzX2NvbG9yXCIpXG4gICAgICAgICAgICAuY2FsbChzdHlsZSlcblxuICAgICAgICBpZiAoIWQzcGx1cy50b3VjaCkge1xuXG4gICAgICAgICAga2V5c1xuICAgICAgICAgICAgLm9uKGQzcGx1cy5ldnQub3ZlcixmdW5jdGlvbihkLGkpe1xuXG4gICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImN1cnNvclwiLFwicG9pbnRlclwiKVxuXG4gICAgICAgICAgICAgIHZhciB4ID0gc3RhcnRfeCArIChpKih2YXJzLnVpLnBhZGRpbmcrc3F1YXJlX3NpemUpKSxcbiAgICAgICAgICAgICAgICAgIHkgPSBkMy50cmFuc2Zvcm0oZDMuc2VsZWN0KHRoaXMucGFyZW50Tm9kZSkuYXR0cihcInRyYW5zZm9ybVwiKSkudHJhbnNsYXRlWzFdXG5cbiAgICAgICAgICAgICAgeCArPSBzcXVhcmVfc2l6ZS8yXG4gICAgICAgICAgICAgIHkgKz0gdmFycy51aS5wYWRkaW5nK3NxdWFyZV9zaXplLzJcblxuICAgICAgICAgICAgICB2YXIgaWRJbmRleCA9IHZhcnMuaWQubmVzdGluZy5pbmRleE9mKGNvbG9yS2V5KVxuICAgICAgICAgICAgICAgICwgdGl0bGUgPSBpZEluZGV4ID49IDAgPyBmZXRjaFRleHQodmFycyxkLGlkSW5kZXgpWzBdIDogdmFycy5mb3JtYXQudmFsdWUoZmV0Y2hWYWx1ZSh2YXJzLGQsY29sb3JOYW1lLGNvbG9yS2V5KSlcblxuICAgICAgICAgICAgICBkM3BsdXMudG9vbHRpcC5hcHAoe1xuICAgICAgICAgICAgICAgIFwiZGF0YVwiOiBkLFxuICAgICAgICAgICAgICAgIFwiZm9vdGVyXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwidmFyc1wiOiB2YXJzLFxuICAgICAgICAgICAgICAgIFwieFwiOiB4LFxuICAgICAgICAgICAgICAgIFwieVwiOiB5LFxuICAgICAgICAgICAgICAgIFwidGl0bGVcIjogdGl0bGUsXG4gICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogc3F1YXJlX3NpemUqLjRcbiAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihkM3BsdXMuZXZ0Lm91dCxmdW5jdGlvbihkKXtcbiAgICAgICAgICAgICAgZDNwbHVzLnRvb2x0aXAucmVtb3ZlKHZhcnMudHlwZS52YWx1ZSlcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGtleXMub3JkZXIoKVxuICAgICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwxKVxuICAgICAgICAgIC5jYWxsKHBvc2l0aW9uKVxuXG4gICAgICAgIGtleXMuc2VsZWN0QWxsKFwicmVjdC5kM3BsdXNfY29sb3JcIikudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAgICAgLmNhbGwoc3R5bGUpXG5cbiAgICAgICAga2V5cy5leGl0KClcbiAgICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsMClcbiAgICAgICAgICAucmVtb3ZlKClcblxuICAgICAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZUVuZChcImRyYXdpbmcgbGVnZW5kXCIpXG5cbiAgICAgIH1cblxuICAgIH1cbiAgICBlbHNlIGlmICh2YXJzLmNvbG9yLnZhbHVlU2NhbGUpIHtcblxuICAgICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIGQzcGx1cy5jb25zb2xlLnRpbWUoXCJkcmF3aW5nIGNvbG9yIHNjYWxlXCIpXG5cbiAgICAgIHZhcnMuZy5sZWdlbmQuc2VsZWN0QWxsKFwiZy5kM3BsdXNfY29sb3JcIilcbiAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwwKVxuICAgICAgICAucmVtb3ZlKClcblxuICAgICAgdmFyIHZhbHVlcyA9IHZhcnMuY29sb3IudmFsdWVTY2FsZS5kb21haW4oKSxcbiAgICAgICAgICBjb2xvcnMgPSB2YXJzLmNvbG9yLnZhbHVlU2NhbGUucmFuZ2UoKVxuXG4gICAgICBpZiAodmFsdWVzLmxlbmd0aCA8PSAyKSB7XG4gICAgICAgIHZhbHVlcyA9IGQzcGx1cy51dGlsLmJ1Y2tldHModmFsdWVzLDYpXG4gICAgICB9XG5cbiAgICAgIHZhciBzY2FsZSA9IHZhcnMuZy5sZWdlbmQuc2VsZWN0QWxsKFwiZy5kM3BsdXNfc2NhbGVcIilcbiAgICAgICAgLmRhdGEoW1wic2NhbGVcIl0pXG5cbiAgICAgIHNjYWxlLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsXCJkM3BsdXNfc2NhbGVcIilcbiAgICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsMClcblxuICAgICAgdmFyIGhlYXRtYXAgPSBzY2FsZS5zZWxlY3RBbGwoXCIjZDNwbHVzX2xlZ2VuZF9oZWF0bWFwXCIpXG4gICAgICAgIC5kYXRhKFtcImhlYXRtYXBcIl0pXG5cbiAgICAgIGhlYXRtYXAuZW50ZXIoKS5hcHBlbmQoXCJsaW5lYXJHcmFkaWVudFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwiZDNwbHVzX2xlZ2VuZF9oZWF0bWFwXCIpXG4gICAgICAgIC5hdHRyKFwieDFcIiwgXCIwJVwiKVxuICAgICAgICAuYXR0cihcInkxXCIsIFwiMCVcIilcbiAgICAgICAgLmF0dHIoXCJ4MlwiLCBcIjEwMCVcIilcbiAgICAgICAgLmF0dHIoXCJ5MlwiLCBcIjAlXCIpXG4gICAgICAgIC5hdHRyKFwic3ByZWFkTWV0aG9kXCIsIFwicGFkXCIpO1xuXG4gICAgICB2YXIgc3RvcHMgPSBoZWF0bWFwLnNlbGVjdEFsbChcInN0b3BcIilcbiAgICAgICAgLmRhdGEoZDMucmFuZ2UoMCxjb2xvcnMubGVuZ3RoKSlcblxuICAgICAgc3RvcHMuZW50ZXIoKS5hcHBlbmQoXCJzdG9wXCIpXG4gICAgICAgIC5hdHRyKFwic3RvcC1vcGFjaXR5XCIsMSlcblxuICAgICAgc3RvcHNcbiAgICAgICAgLmF0dHIoXCJvZmZzZXRcIixmdW5jdGlvbihpKXtcbiAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgoaS8oY29sb3JzLmxlbmd0aC0xKSkqMTAwKStcIiVcIlxuICAgICAgICB9KVxuICAgICAgICAuYXR0cihcInN0b3AtY29sb3JcIixmdW5jdGlvbihpKXtcbiAgICAgICAgICByZXR1cm4gY29sb3JzW2ldXG4gICAgICAgIH0pXG5cbiAgICAgIHN0b3BzLmV4aXQoKS5yZW1vdmUoKVxuXG4gICAgICB2YXIgZ3JhZGllbnQgPSBzY2FsZS5zZWxlY3RBbGwoXCJyZWN0I2dyYWRpZW50XCIpXG4gICAgICAgIC5kYXRhKFtcImdyYWRpZW50XCJdKVxuXG4gICAgICBncmFkaWVudC5lbnRlcigpLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLFwiZ3JhZGllbnRcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsZnVuY3Rpb24oZCl7XG4gICAgICAgICAgaWYgKHZhcnMubGVnZW5kLmFsaWduID09IFwibWlkZGxlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YXJzLndpZHRoLnZhbHVlLzJcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodmFycy5sZWdlbmQuYWxpZ24gPT0gXCJlbmRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhcnMud2lkdGgudmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJ5XCIsdmFycy51aS5wYWRkaW5nKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIDApXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHZhcnMubGVnZW5kLmdyYWRpZW50LmhlaWdodClcbiAgICAgICAgLmF0dHIoXCJzdHJva2VcIix2YXJzLmxlZ2VuZC5mb250LmNvbG9yKVxuICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLDEpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgXCJ1cmwoI2QzcGx1c19sZWdlbmRfaGVhdG1hcClcIilcblxuICAgICAgdmFyIHRleHQgPSBzY2FsZS5zZWxlY3RBbGwoXCJ0ZXh0LmQzcGx1c190aWNrXCIpXG4gICAgICAgIC5kYXRhKGQzLnJhbmdlKDAsdmFsdWVzLmxlbmd0aCkpXG5cbiAgICAgIHRleHQuZW50ZXIoKS5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIixcImQzcGx1c190aWNrXCIpXG4gICAgICAgIC5hdHRyKFwieFwiLGZ1bmN0aW9uKGQpe1xuICAgICAgICAgIGlmICh2YXJzLmxlZ2VuZC5hbGlnbiA9PSBcIm1pZGRsZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFycy53aWR0aC52YWx1ZS8yXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHZhcnMubGVnZW5kLmFsaWduID09IFwiZW5kXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YXJzLndpZHRoLnZhbHVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwieVwiLGZ1bmN0aW9uKGQpe1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldEJCb3goKS5oZWlnaHQrdmFycy5sZWdlbmQuZ3JhZGllbnQuaGVpZ2h0K3ZhcnMudWkucGFkZGluZyoyXG4gICAgICAgIH0pXG5cbiAgICAgIHZhciBsYWJlbF93aWR0aCA9IDBcblxuICAgICAgdGV4dFxuICAgICAgICAub3JkZXIoKVxuICAgICAgICAuYXR0cihcImZvbnQtd2VpZ2h0XCIsdmFycy5sZWdlbmQuZm9udC53ZWlnaHQpXG4gICAgICAgIC5hdHRyKFwiZm9udC1mYW1pbHlcIix2YXJzLmxlZ2VuZC5mb250LmZhbWlseS52YWx1ZSlcbiAgICAgICAgLmF0dHIoXCJmb250LXNpemVcIix2YXJzLmxlZ2VuZC5mb250LnNpemUpXG4gICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsdmFycy5sZWdlbmQuZm9udC5hbGlnbilcbiAgICAgICAgLmF0dHIoXCJmaWxsXCIsdmFycy5sZWdlbmQuZm9udC5jb2xvcilcbiAgICAgICAgLnRleHQoZnVuY3Rpb24oZCl7XG4gICAgICAgICAgcmV0dXJuIHZhcnMuZm9ybWF0LnZhbHVlKHZhbHVlc1tkXSxrZXkpXG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwieVwiLGZ1bmN0aW9uKGQpe1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldEJCb3goKS5oZWlnaHQrdmFycy5sZWdlbmQuZ3JhZGllbnQuaGVpZ2h0K3ZhcnMudWkucGFkZGluZyoyXG4gICAgICAgIH0pXG4gICAgICAgIC5lYWNoKGZ1bmN0aW9uKGQpe1xuICAgICAgICAgIHZhciB3ID0gdGhpcy5vZmZzZXRXaWR0aFxuICAgICAgICAgIGlmICh3ID4gbGFiZWxfd2lkdGgpIGxhYmVsX3dpZHRoID0gd1xuICAgICAgICB9KVxuXG4gICAgICBsYWJlbF93aWR0aCArPSB2YXJzLmxhYmVscy5wYWRkaW5nKjJcblxuICAgICAgdmFyIGtleV93aWR0aCA9IGxhYmVsX3dpZHRoICogKHZhbHVlcy5sZW5ndGgtMSlcblxuICAgICAgaWYgKGtleV93aWR0aCtsYWJlbF93aWR0aCA8IHZhcnMud2lkdGgudmFsdWUpIHtcblxuICAgICAgICBpZiAoa2V5X3dpZHRoK2xhYmVsX3dpZHRoIDwgdmFycy53aWR0aC52YWx1ZS8yKSB7XG4gICAgICAgICAga2V5X3dpZHRoID0gdmFycy53aWR0aC52YWx1ZS8yXG4gICAgICAgICAgbGFiZWxfd2lkdGggPSBrZXlfd2lkdGgvdmFsdWVzLmxlbmd0aFxuICAgICAgICAgIGtleV93aWR0aCAtPSBsYWJlbF93aWR0aFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhcnMubGVnZW5kLmFsaWduID09IFwic3RhcnRcIikge1xuICAgICAgICAgIHZhciBzdGFydF94ID0gdmFycy51aS5wYWRkaW5nXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFycy5sZWdlbmQuYWxpZ24gPT0gXCJlbmRcIikge1xuICAgICAgICAgIHZhciBzdGFydF94ID0gdmFycy53aWR0aC52YWx1ZSAtIHZhcnMudWkucGFkZGluZyAtIGtleV93aWR0aFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBzdGFydF94ID0gdmFycy53aWR0aC52YWx1ZS8yIC0ga2V5X3dpZHRoLzJcbiAgICAgICAgfVxuXG4gICAgICAgIHRleHQudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAgICAgLmF0dHIoXCJ4XCIsZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRfeCArIChsYWJlbF93aWR0aCpkKVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgdGV4dC5leGl0KCkudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsMClcbiAgICAgICAgICAucmVtb3ZlKClcblxuICAgICAgICB2YXIgdGlja3MgPSBzY2FsZS5zZWxlY3RBbGwoXCJyZWN0LmQzcGx1c190aWNrXCIpXG4gICAgICAgICAgLmRhdGEoZDMucmFuZ2UoMCx2YWx1ZXMubGVuZ3RoKSlcblxuICAgICAgICB0aWNrcy5lbnRlcigpLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAuYXR0cihcImNsYXNzXCIsXCJkM3BsdXNfdGlja1wiKVxuICAgICAgICAgIC5hdHRyKFwieFwiLGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgaWYgKHZhcnMubGVnZW5kLmFsaWduID09IFwibWlkZGxlXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhcnMud2lkdGgudmFsdWUvMlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFycy5sZWdlbmQuYWxpZ24gPT0gXCJlbmRcIikge1xuICAgICAgICAgICAgICByZXR1cm4gdmFycy53aWR0aC52YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuYXR0cihcInlcIix2YXJzLnVpLnBhZGRpbmcpXG4gICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLDApXG4gICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIix2YXJzLnVpLnBhZGRpbmcrdmFycy5sZWdlbmQuZ3JhZGllbnQuaGVpZ2h0KVxuICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLHZhcnMubGVnZW5kLmZvbnQuY29sb3IpXG5cbiAgICAgICAgdGlja3MudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAgICAgLmF0dHIoXCJ4XCIsZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICB2YXIgbW9kID0gZCA9PSAwID8gMSA6IDBcbiAgICAgICAgICAgIHJldHVybiBzdGFydF94ICsgKGxhYmVsX3dpZHRoKmQpIC0gbW9kXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuYXR0cihcInlcIix2YXJzLnVpLnBhZGRpbmcpXG4gICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLDEpXG4gICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIix2YXJzLnVpLnBhZGRpbmcrdmFycy5sZWdlbmQuZ3JhZGllbnQuaGVpZ2h0KVxuICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLHZhcnMubGVnZW5kLmZvbnQuY29sb3IpXG5cbiAgICAgICAgdGlja3MuZXhpdCgpLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwwKVxuICAgICAgICAgIC5yZW1vdmUoKVxuXG4gICAgICAgIGdyYWRpZW50LnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgICAgICAgIC5hdHRyKFwieFwiLGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgaWYgKHZhcnMubGVnZW5kLmFsaWduID09IFwibWlkZGxlXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhcnMud2lkdGgudmFsdWUvMiAtIGtleV93aWR0aC8yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YXJzLmxlZ2VuZC5hbGlnbiA9PSBcImVuZFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YXJzLndpZHRoLnZhbHVlIC0ga2V5X3dpZHRoIC0gdmFycy51aS5wYWRkaW5nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhcnMudWkucGFkZGluZ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmF0dHIoXCJ5XCIsdmFycy51aS5wYWRkaW5nKVxuICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwga2V5X3dpZHRoKVxuICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHZhcnMubGVnZW5kLmdyYWRpZW50LmhlaWdodClcblxuICAgICAgICBzY2FsZS50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwxKVxuXG4gICAgICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lRW5kKFwiZHJhd2luZyBjb2xvciBzY2FsZVwiKVxuXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAga2V5X2Rpc3BsYXkgPSBmYWxzZVxuICAgICAgfVxuXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAga2V5X2Rpc3BsYXkgPSBmYWxzZVxuICAgIH1cblxuICB9XG4gIGVsc2Uge1xuICAgIGtleV9kaXNwbGF5ID0gZmFsc2VcbiAgfVxuICBpZiAodmFycy5sZWdlbmQudmFsdWUgJiYga2V5ICYmIGtleV9kaXNwbGF5KSB7XG5cbiAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZShcInBvc2l0aW9uaW5nIGxlZ2VuZFwiKVxuXG4gICAgaWYgKHNxdWFyZV9zaXplKSB7XG4gICAgICB2YXIga2V5X2hlaWdodCA9IHNxdWFyZV9zaXplK3ZhcnMudWkucGFkZGluZ1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBrZXlfYm94ID0gdmFycy5nLmxlZ2VuZC5ub2RlKCkuZ2V0QkJveCgpLFxuICAgICAgICAgIGtleV9oZWlnaHQgPSBrZXlfYm94LmhlaWdodCtrZXlfYm94LnktdmFycy51aS5wYWRkaW5nXG4gICAgfVxuXG4gICAgaWYgKHZhcnMubWFyZ2luLmJvdHRvbSA9PT0gMCkge1xuICAgICAgdmFycy5tYXJnaW4uYm90dG9tICs9IHZhcnMudWkucGFkZGluZ1xuICAgIH1cbiAgICB2YXJzLm1hcmdpbi5ib3R0b20gKz0ga2V5X2hlaWdodFxuXG4gICAgdmFycy5nLmxlZ2VuZC50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGUoMCxcIisodmFycy5oZWlnaHQudmFsdWUtdmFycy5tYXJnaW4uYm90dG9tKStcIilcIilcblxuICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lRW5kKFwicG9zaXRpb25pbmcgbGVnZW5kXCIpXG5cbiAgfVxuICBlbHNlIHtcblxuICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lKFwiaGlkaW5nIGxlZ2VuZFwiKVxuXG4gICAgdmFycy5nLmxlZ2VuZC50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGUoMCxcIit2YXJzLmhlaWdodC52YWx1ZStcIilcIilcblxuICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lRW5kKFwiaGlkaW5nIGxlZ2VuZFwiKVxuXG4gIH1cblxuXG59XG4iLCIvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuLy8gQ3JlYXRlcyBDZW50ZXJlZCBTZXJ2ZXIgTWVzc2FnZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmQzcGx1cy51aS5tZXNzYWdlID0gZnVuY3Rpb24odmFycyxtZXNzYWdlKSB7XG5cbiAgdmFyIG1lc3NhZ2UgPSB2YXJzLm1lc3NhZ2VzLnZhbHVlID8gbWVzc2FnZSA6IG51bGwsXG4gICAgICBzaXplID0gbWVzc2FnZSA9PSB2YXJzLmludGVybmFsX2Vycm9yID8gXCJsYXJnZVwiIDogdmFycy5tZXNzYWdlcy5zdHlsZVxuXG4gIGlmIChzaXplID09IFwibGFyZ2VcIikge1xuICAgIHZhciBmb250ID0gdmFycy5tZXNzYWdlcyxcbiAgICAgICAgcG9zaXRpb24gPSBcImNlbnRlclwiXG4gIH1cbiAgZWxzZSB7XG5cbiAgICBpZiAodmFycy5mb290ZXIudmFsdWUpIHtcbiAgICAgIHZhciBmb250ID0gdmFycy5mb290ZXJcbiAgICB9XG4gICAgZWxzZSBpZiAodmFycy50aXRsZS52YWx1ZSkge1xuICAgICAgdmFyIGZvbnQgPSB2YXJzLnRpdGxlXG4gICAgfVxuICAgIGVsc2UgaWYgKHZhcnMudGl0bGUuc3ViLnZhbHVlKSB7XG4gICAgICB2YXIgZm9udCA9IHZhcnMudGl0bGUuc3ViXG4gICAgfVxuICAgIGVsc2UgaWYgKHZhcnMudGl0bGUudG90YWwudmFsdWUpIHtcbiAgICAgIHZhciBmb250ID0gdmFycy50aXRsZS50b3RhbFxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBmb250ID0gdmFycy50aXRsZS5zdWJcbiAgICB9XG5cbiAgICB2YXIgcG9zaXRpb24gPSBmb250LnBvc2l0aW9uXG5cbiAgfVxuXG4gIHZhciBmb250ID0ge1xuICAgIFwiY29sb3JcIjogZm9udC5mb250LmNvbG9yLFxuICAgIFwiZm9udC1mYW1pbHlcIjogZm9udC5mb250LmZhbWlseS52YWx1ZSxcbiAgICBcImZvbnQtd2VpZ2h0XCI6IGZvbnQuZm9udC53ZWlnaHQsXG4gICAgXCJmb250LXNpemVcIjogZm9udC5mb250LnNpemUrXCJweFwiLFxuICAgIFwicGFkZGluZ1wiOiBmb250LnBhZGRpbmcrXCJweFwiXG4gIH1cblxuICB2YXIgYmFja2dyb3VuZCA9IHZhcnMuYmFja2dyb3VuZC52YWx1ZSAhPSBcIm5vbmVcIiA/IHZhcnMuYmFja2dyb3VuZC52YWx1ZSA6IFwid2hpdGVcIlxuXG4gIGZ1bmN0aW9uIHN0eWxlKGVsZW0pIHtcblxuICAgIGVsZW1cbiAgICAgIC5zdHlsZShmb250KVxuICAgICAgLnN0eWxlKFwicG9zaXRpb25cIixcImFic29sdXRlXCIpXG4gICAgICAuc3R5bGUoXCJiYWNrZ3JvdW5kXCIsYmFja2dyb3VuZClcbiAgICAgIC5zdHlsZShcInRleHQtYWxpZ25cIixcImNlbnRlclwiKVxuICAgICAgLnN0eWxlKFwibGVmdFwiLGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbiA9PSBcImNlbnRlclwiID8gXCI1MCVcIiA6IFwiMHB4XCJcbiAgICAgIH0pXG4gICAgICAuc3R5bGUoXCJ3aWR0aFwiLGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbiA9PSBcImNlbnRlclwiID8gXCJhdXRvXCIgOiB2YXJzLndpZHRoLnZhbHVlK1wicHhcIlxuICAgICAgfSlcbiAgICAgIC5zdHlsZShcIm1hcmdpbi1sZWZ0XCIsZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIG9mZnNldCA9IHZhcnMud2lkdGgudmFsdWUtdmFycy53aWR0aC52aXpcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uID09IFwiY2VudGVyXCIgPyAtKHRoaXMub2Zmc2V0V2lkdGgvMitvZmZzZXQvMikrXCJweFwiIDogXCIwcHhcIlxuICAgICAgfSlcbiAgICAgIC5zdHlsZShcInRvcFwiLGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PSBcImNlbnRlclwiKSB7XG4gICAgICAgICAgcmV0dXJuIFwiNTAlXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9zaXRpb24gPT0gXCJ0b3BcIikge1xuICAgICAgICAgIHJldHVybiBcIjBweFwiXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFwiYXV0b1wiXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuc3R5bGUoXCJib3R0b21cIixmdW5jdGlvbigpe1xuICAgICAgICBpZiAocG9zaXRpb24gPT0gXCJib3R0b21cIikge1xuICAgICAgICAgIHJldHVybiBcIjBweFwiXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFwiYXV0b1wiXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuc3R5bGUoXCJtYXJnaW4tdG9wXCIsZnVuY3Rpb24oKXtcbiAgICAgICAgaWYgKHNpemUgPT0gXCJsYXJnZVwiKSB7XG4gICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMub2Zmc2V0SGVpZ2h0IHx8IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gICAgICAgICAgcmV0dXJuIC1oZWlnaHQvMitcInB4XCJcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCIwcHhcIlxuICAgICAgfSlcblxuICB9XG5cbiAgLy8gRW50ZXIgTWVzc2FnZSBHcm91cFxuICB2YXJzLmcubWVzc2FnZSA9IHZhcnMuY29udGFpbmVyLnZhbHVlLnNlbGVjdEFsbChcImRpdiNkM3BsdXNfbWVzc2FnZVwiKVxuICAgIC5kYXRhKFtcIm1lc3NhZ2VcIl0pXG5cbiAgdmFycy5nLm1lc3NhZ2UuZW50ZXIoKS5hcHBlbmQoXCJkaXZcIilcbiAgICAuYXR0cihcImlkXCIsXCJkM3BsdXNfbWVzc2FnZVwiKVxuICAgIC5hdHRyKFwib3BhY2l0eVwiLDApXG5cbiAgdmFyIG9wYWNpdHkgPSBtZXNzYWdlID8gMSA6IDAsXG4gICAgICB0ZXh0ID0gbWVzc2FnZSA/IG1lc3NhZ2UgOiB2YXJzLmcubWVzc2FnZS50ZXh0KCksXG4gICAgICBkaXNwbGF5ID0gbWVzc2FnZSA/IFwiaW5saW5lLWJsb2NrXCIgOiBcIm5vbmVcIlxuXG4gIHZhcnMuZy5tZXNzYWdlXG4gICAgLnRleHQodGV4dClcbiAgICAuc3R5bGUoXCJvcGFjaXR5XCIsb3BhY2l0eSlcbiAgICAuc3R5bGUoXCJkaXNwbGF5XCIsZGlzcGxheSlcbiAgICAuY2FsbChzdHlsZSlcblxufVxuIiwiLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4vLyBDcmVhdGVzIGNvbG9yIGtleVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmQzcGx1cy51aS50aW1lbGluZSA9IGZ1bmN0aW9uKHZhcnMpIHtcblxuICBpZiAoKCF2YXJzLmludGVybmFsX2Vycm9yIHx8ICF2YXJzLmRhdGEubWlzc2luZykgJiYgIXZhcnMuc21hbGwgJiYgdmFycy5kYXRhLnRpbWUgJiYgdmFycy5kYXRhLnRpbWUudmFsdWVzLmxlbmd0aCA+IDEgJiYgdmFycy50aW1lbGluZS52YWx1ZSkge1xuXG4gICAgdmFyIHllYXJzID0gW11cbiAgICB2YXJzLmRhdGEudGltZS52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbihkKXtcbiAgICAgIHllYXJzLnB1c2gobmV3IERhdGUoZCkpXG4gICAgfSlcblxuICAgIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lKFwiZHJhd2luZyB0aW1lbGluZVwiKVxuXG4gICAgdmFyIHRpbWVGb3JtYXQgPSB2YXJzLnRpbWUuZm9ybWF0LnZhbHVlIHx8IHZhcnMuZGF0YS50aW1lLmZvcm1hdFxuICAgICAgLCB0aW1lTXVsdGlGb3JtYXQgPSB2YXJzLnRpbWUuZm9ybWF0LnZhbHVlIHx8IHZhcnMuZGF0YS50aW1lLm11bHRpRm9ybWF0XG5cbiAgICBpZiAoKHZhcnMudGltZS52YWx1ZSA9PSB2YXJzLngudmFsdWUgJiYgdmFycy54LnNjYWxlLnZhbHVlID09IFwiY29udGludW91c1wiKSB8fCAodmFycy50aW1lLnZhbHVlID09IHZhcnMueS52YWx1ZSAmJiB2YXJzLnkuc2NhbGUudmFsdWUgPT0gXCJjb250aW51b3VzXCIpKSB7XG4gICAgICB2YXIgbWluX3JlcXVpcmVkID0gMlxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBtaW5fcmVxdWlyZWQgPSAxXG4gICAgfVxuXG4gICAgaWYgKHZhcnMudGltZS5zb2xvLnZhbHVlLmxlbmd0aCkge1xuICAgICAgdmFyIGluaXQgPSBkMy5leHRlbnQodmFycy50aW1lLnNvbG8udmFsdWUpXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGluaXRbaV0uY29uc3RydWN0b3IgIT09IERhdGUpIHtcbiAgICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKGluaXRbaV0udG9TdHJpbmcoKSlcbiAgICAgICAgICBkLnNldFRpbWUoIGQuZ2V0VGltZSgpICsgZC5nZXRUaW1lem9uZU9mZnNldCgpICogNjAgKiAxMDAwIClcbiAgICAgICAgICBpbml0W2ldID0gZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGluaXQgPSBkMy5leHRlbnQoeWVhcnMpXG4gICAgfVxuXG4gICAgdmFyIG1pbiA9IHllYXJzWzBdLFxuICAgICAgICBzdGFydCA9IG5ldyBEYXRlKGluaXRbMF0pLFxuICAgICAgICBlbmQgPSBuZXcgRGF0ZShpbml0WzFdKVxuXG4gICAgeWVhcnMgPSB2YXJzLmRhdGEudGltZS50aWNrc1xuICAgIHZhciB5ZWFyX3RpY2tzID0geWVhcnMuc2xpY2UoKVxuICAgIHZhciBkID0gbmV3IERhdGUobWluKVxuICAgIGRbXCJzZXRcIit2YXJzLmRhdGEudGltZS5zdGVwVHlwZV0oZFtcImdldFwiK3ZhcnMuZGF0YS50aW1lLnN0ZXBUeXBlXSgpICsgeWVhcnMubGVuZ3RoKVxuICAgIHllYXJfdGlja3MucHVzaChkKVxuXG4gICAgZW5kW1wic2V0XCIrdmFycy5kYXRhLnRpbWUuc3RlcFR5cGVdKGVuZFtcImdldFwiK3ZhcnMuZGF0YS50aW1lLnN0ZXBUeXBlXSgpICsgMSlcbiAgICBzdGFydCA9IGQzcGx1cy51dGlsLmNsb3Nlc3QoeWVhcl90aWNrcyxzdGFydClcbiAgICBlbmQgPSBkM3BsdXMudXRpbC5jbG9zZXN0KHllYXJfdGlja3MsZW5kKVxuXG4gICAgdmFyIHllYXJNUyA9IHllYXJfdGlja3Muc2xpY2UoMClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHllYXJNUy5sZW5ndGg7IGkrKykge1xuICAgICAgeWVhck1TW2ldID0geWVhck1TW2ldLmdldFRpbWUoKVxuICAgIH1cblxuICAgIHZhciBtaW5faW5kZXggPSB5ZWFyTVMuaW5kZXhPZihzdGFydC5nZXRUaW1lKCkpXG4gICAgICAsIG1heF9pbmRleCA9IHllYXJNUy5pbmRleE9mKGVuZC5nZXRUaW1lKCkpXG5cbiAgICB2YXIgYnJ1c2hlZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQgIT09IG51bGwpIHtcblxuICAgICAgICBicnVzaEV4dGVudCA9IGJydXNoLmV4dGVudCgpXG5cbiAgICAgICAgdmFyIG1pbl92YWwgPSBkM3BsdXMudXRpbC5jbG9zZXN0KHllYXJfdGlja3MsYnJ1c2hFeHRlbnRbMF0pLFxuICAgICAgICAgICAgbWF4X3ZhbCA9IGQzcGx1cy51dGlsLmNsb3Nlc3QoeWVhcl90aWNrcyxicnVzaEV4dGVudFsxXSlcblxuICAgICAgICBpZiAobWluX3ZhbCA9PT0gbWF4X3ZhbCkge1xuICAgICAgICAgIG1pbl9pbmRleCA9IHllYXJNUy5pbmRleE9mKG1pbl92YWwuZ2V0VGltZSgpKVxuICAgICAgICAgIGlmIChtaW5fdmFsIDwgYnJ1c2hFeHRlbnRbMF0gfHwgbWluX2luZGV4ID09PSAwKSB7XG4gICAgICAgICAgICBtYXhfdmFsID0geWVhcl90aWNrc1ttaW5faW5kZXggKyAxXVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1pbl92YWwgPSB5ZWFyX3RpY2tzW21pbl9pbmRleCAtIDFdXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBtaW5faW5kZXggPSB5ZWFyTVMuaW5kZXhPZihtaW5fdmFsLmdldFRpbWUoKSlcbiAgICAgICAgbWF4X2luZGV4ID0geWVhck1TLmluZGV4T2YobWF4X3ZhbC5nZXRUaW1lKCkpXG5cbiAgICAgICAgaWYgKG1heF9pbmRleC1taW5faW5kZXggPj0gbWluX3JlcXVpcmVkKSB7XG4gICAgICAgICAgdmFyIGV4dGVudCA9IFttaW5fdmFsLG1heF92YWxdXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWluX2luZGV4K21pbl9yZXF1aXJlZCA8PSB5ZWFycy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZXh0ZW50ID0gW21pbl92YWwseWVhcl90aWNrc1ttaW5faW5kZXgrbWluX3JlcXVpcmVkXV1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgIHZhciBleHRlbnQgPSBbbWluX3ZhbF1cbiAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBtaW5fcmVxdWlyZWQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKG1pbl9pbmRleCtpIDw9IHllYXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBleHRlbnQucHVzaCh5ZWFyX3RpY2tzW21pbl9pbmRleCtpXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBleHRlbnQudW5zaGlmdCh5ZWFyX3RpY2tzW21pbl9pbmRleC0oKG1pbl9pbmRleCtpKS0oeWVhcnMubGVuZ3RoKSldKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBleHRlbnQgPSBbZXh0ZW50WzBdLGV4dGVudFtleHRlbnQubGVuZ3RoLTFdXVxuICAgICAgICB9XG5cbiAgICAgICAgYnJ1c2hFeHRlbnQgPSBleHRlbnRcblxuICAgICAgICB0ZXh0LmF0dHIoXCJmaWxsXCIsdGV4dEZpbGwpXG5cbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYnJ1c2guZXh0ZW50KGV4dGVudCkpXG5cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgYnJ1c2hlbmQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKGQzLmV2ZW50LnNvdXJjZUV2ZW50ICE9PSBudWxsKSB7XG5cbiAgICAgICAgaWYgKHZhcnMudGltZS5zb2xvLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBzb2xvZCA9IGQzLmV4dGVudCh2YXJzLnRpbWUuc29sby52YWx1ZSlcbiAgICAgICAgICAgICwgb2xkX21pbiA9IHllYXJNUy5pbmRleE9mKGQzcGx1cy51dGlsLmNsb3Nlc3QoeWVhcl90aWNrcyxzb2xvZFswXSkuZ2V0VGltZSgpKVxuICAgICAgICAgICAgLCBvbGRfbWF4ID0geWVhck1TLmluZGV4T2YoZDNwbHVzLnV0aWwuY2xvc2VzdCh5ZWFyX3RpY2tzLHNvbG9kWzFdKS5nZXRUaW1lKCkpKzFcbiAgICAgICAgICAgICwgY2hhbmdlID0gb2xkX21pbiAhPT0gbWluX2luZGV4IHx8IG9sZF9tYXggIT09IG1heF9pbmRleFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBjaGFuZ2UgPSBtYXhfaW5kZXgtbWluX2luZGV4ICE9PSB5ZWFycy5sZW5ndGhcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFuZ2UpIHtcblxuICAgICAgICAgIGlmIChtYXhfaW5kZXgtbWluX2luZGV4ID09IHllYXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG5ld1llYXJzID0gW11cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHZhciBuZXdZZWFycyA9IGQzLnJhbmdlKG1pbl9pbmRleCxtYXhfaW5kZXgpXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oeSl7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSB2YXJzLmRhdGEudGltZS5kYXRhU3RlcHMuaW5kZXhPZih5KVxuICAgICAgICAgICAgICAgIHJldHVybiBpID49IDAgPyB2YXJzLmRhdGEudGltZS52YWx1ZXNbaV0gOiB5ZWFyc1t5XVxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFycy5zZWxmLnRpbWUoe1wic29sb1wiOiBuZXdZZWFyc30pLmRyYXcoKVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciB0ZXh0U3R5bGUgPSB7XG4gICAgICBcImZvbnQtd2VpZ2h0XCI6IHZhcnMudWkuZm9udC53ZWlnaHQsXG4gICAgICBcImZvbnQtZmFtaWx5XCI6IHZhcnMudWkuZm9udC5mYW1pbHkudmFsdWUsXG4gICAgICBcImZvbnQtc2l6ZVwiOiB2YXJzLnVpLmZvbnQuc2l6ZSxcbiAgICAgIFwidGV4dC1hbmNob3JcIjogXCJtaWRkbGVcIlxuICAgIH1cblxuICAgIHZhciB0aW1lRm9ybWF0dGVyID0gZnVuY3Rpb24odixpKSB7XG4gICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSB5ZWFycy5sZW5ndGgtMSkgcmV0dXJuIHRpbWVGb3JtYXQodilcbiAgICAgIGVsc2UgcmV0dXJuIHRpbWVNdWx0aUZvcm1hdCh2KVxuICAgIH1cblxuICAgIHZhciB0ZXh0U2l6ZXMgPSBkM3BsdXMuZm9udC5zaXplcyh5ZWFycy5tYXAodGltZUZvcm1hdHRlciksdGV4dFN0eWxlKVxuICAgICAgLCB5ZWFyV2lkdGhzID0gdGV4dFNpemVzLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC53aWR0aH0pXG4gICAgICAsIHllYXJfd2lkdGggPSBkMy5tYXgoeWVhcldpZHRocylcbiAgICAgICwgeWVhcl9oZWlnaHQgPSBkMy5tYXgodGV4dFNpemVzLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5oZWlnaHR9KSlcblxuICAgIHZhciBsYWJlbF93aWR0aCA9IHllYXJfd2lkdGgrdmFycy51aS5wYWRkaW5nKjIsXG4gICAgICAgIHRpbWVsaW5lSGVpZ2h0ID0geWVhcl9oZWlnaHQrdmFycy51aS5wYWRkaW5nKjJcbiAgICAgICAgdGltZWxpbmVfd2lkdGggPSBsYWJlbF93aWR0aCp5ZWFycy5sZW5ndGgsXG4gICAgICAgIGF2YWlsYWJsZV93aWR0aCA9IHZhcnMud2lkdGgudmFsdWUtdmFycy51aS5wYWRkaW5nKjIsXG4gICAgICAgIHRpY2tTdGVwID0gMSxcbiAgICAgICAgdGV4dFJvdGF0ZSA9IDBcblxuICAgIGlmICh0aW1lbGluZV93aWR0aCA+IGF2YWlsYWJsZV93aWR0aCkge1xuICAgICAgbGFiZWxfd2lkdGggPSB5ZWFyX2hlaWdodCt2YXJzLnVpLnBhZGRpbmcqMlxuICAgICAgdGltZWxpbmVIZWlnaHQgPSB5ZWFyX3dpZHRoK3ZhcnMudWkucGFkZGluZyoyXG4gICAgICB0aW1lbGluZV93aWR0aCA9IGxhYmVsX3dpZHRoKnllYXJzLmxlbmd0aFxuICAgICAgdGV4dFJvdGF0ZSA9IDkwXG4gICAgfVxuXG4gICAgdGltZWxpbmVIZWlnaHQgPSBkMy5tYXgoW3RpbWVsaW5lSGVpZ2h0LHZhcnMudGltZWxpbmUuaGVpZ2h0LnZhbHVlXSlcblxuICAgIHZhciBvbGRfd2lkdGggPSBsYWJlbF93aWR0aFxuICAgIGlmICh0aW1lbGluZV93aWR0aCA+IGF2YWlsYWJsZV93aWR0aCkge1xuICAgICAgdGltZWxpbmVfd2lkdGggPSBhdmFpbGFibGVfd2lkdGhcbiAgICAgIG9sZF93aWR0aCA9IGxhYmVsX3dpZHRoLXZhcnMudWkucGFkZGluZyoyXG4gICAgICBsYWJlbF93aWR0aCA9IHRpbWVsaW5lX3dpZHRoL3llYXJzLmxlbmd0aFxuICAgICAgaWYgKG9sZF93aWR0aCA+IGxhYmVsX3dpZHRoKSB7XG4gICAgICAgIHRpY2tTdGVwID0gTWF0aC5jZWlsKG9sZF93aWR0aC8odGltZWxpbmVfd2lkdGgveWVhcnMubGVuZ3RoKSlcbiAgICAgICAgZm9yICh0aWNrU3RlcDsgdGlja1N0ZXAgPCB5ZWFycy5sZW5ndGgtMTsgdGlja1N0ZXArKykge1xuICAgICAgICAgIGlmICgoeWVhcnMubGVuZ3RoLTEpJXRpY2tTdGVwID09IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZhcnMudGltZWxpbmUuYWxpZ24gPT0gXCJzdGFydFwiKSB7XG4gICAgICB2YXIgc3RhcnRfeCA9IHZhcnMudWkucGFkZGluZ1xuICAgIH1cbiAgICBlbHNlIGlmICh2YXJzLnRpbWVsaW5lLmFsaWduID09IFwiZW5kXCIpIHtcbiAgICAgIHZhciBzdGFydF94ID0gdmFycy53aWR0aC52YWx1ZSAtIHZhcnMudWkucGFkZGluZyAtIHRpbWVsaW5lX3dpZHRoXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0X3ggPSB2YXJzLndpZHRoLnZhbHVlLzIgLSB0aW1lbGluZV93aWR0aC8yXG4gICAgfVxuXG4gICAgdmFyIGJydXNoRXh0ZW50ID0gW3N0YXJ0LGVuZF1cblxuICAgIHZhciB0ZXh0RmlsbCA9IGZ1bmN0aW9uKGQpIHtcblxuICAgICAgaWYgKGQgPj0gYnJ1c2hFeHRlbnRbMF0gJiYgZCA8IGJydXNoRXh0ZW50WzFdKSB7XG4gICAgICAgIHZhciBvcGFjaXR5ID0gMVxuICAgICAgICAgICwgY29sb3IgPSBkM3BsdXMuY29sb3IudGV4dCh2YXJzLnVpLmNvbG9yLnByaW1hcnkudmFsdWUpXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIG9wYWNpdHkgPSAwLjVcbiAgICAgICAgICAsIGNvbG9yID0gZDNwbHVzLmNvbG9yLnRleHQodmFycy51aS5jb2xvci5zZWNvbmRhcnkudmFsdWUpXG4gICAgICB9XG5cbiAgICAgIHZhciBjb2xvciA9IGQzLnJnYihjb2xvcilcblxuICAgICAgcmV0dXJuIFwicmdiYShcIitjb2xvci5yK1wiLFwiK2NvbG9yLmcrXCIsXCIrY29sb3IuYitcIixcIitvcGFjaXR5K1wiKVwiXG5cbiAgICB9XG5cbiAgICB2YXIgYmFja2dyb3VuZCA9IHZhcnMuZy50aW1lbGluZS5zZWxlY3RBbGwoXCJyZWN0LmQzcGx1c190aW1lbGluZV9iYWNrZ3JvdW5kXCIpXG4gICAgICAuZGF0YShbXCJiYWNrZ3JvdW5kXCJdKVxuXG4gICAgYmFja2dyb3VuZC5lbnRlcigpLmFwcGVuZChcInJlY3RcIilcbiAgICAgIC5hdHRyKFwiY2xhc3NcIixcImQzcGx1c190aW1lbGluZV9iYWNrZ3JvdW5kXCIpXG4gICAgICAuYXR0cihcInNoYXBlLXJlbmRlcmluZ1wiLFwiY3Jpc3BFZGdlc1wiKVxuICAgICAgLmF0dHIoXCJ3aWR0aFwiLHRpbWVsaW5lX3dpZHRoKzIpXG4gICAgICAuYXR0cihcImhlaWdodFwiLHRpbWVsaW5lSGVpZ2h0KzIpXG4gICAgICAuYXR0cihcImZpbGxcIix2YXJzLnVpLmNvbG9yLnNlY29uZGFyeS52YWx1ZSlcbiAgICAgIC5hdHRyKFwieFwiLHN0YXJ0X3gtMSlcbiAgICAgIC5hdHRyKFwieVwiLHZhcnMudWkucGFkZGluZylcblxuICAgIGJhY2tncm91bmQudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAuYXR0cihcIndpZHRoXCIsdGltZWxpbmVfd2lkdGgrMilcbiAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsdGltZWxpbmVIZWlnaHQrMilcbiAgICAgIC5hdHRyKFwiZmlsbFwiLHZhcnMudWkuY29sb3Iuc2Vjb25kYXJ5LnZhbHVlKVxuICAgICAgLmF0dHIoXCJ4XCIsc3RhcnRfeC0xKVxuICAgICAgLmF0dHIoXCJ5XCIsdmFycy51aS5wYWRkaW5nKVxuXG4gICAgdmFyIHRpY2tzID0gdmFycy5nLnRpbWVsaW5lLnNlbGVjdEFsbChcImcjdGlja3NcIilcbiAgICAgIC5kYXRhKFtcInRpY2tzXCJdKVxuXG4gICAgdGlja3MuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgICAuYXR0cihcImlkXCIsXCJ0aWNrc1wiKVxuICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZShcIit2YXJzLndpZHRoLnZhbHVlLzIrXCIsXCIrdmFycy51aS5wYWRkaW5nK1wiKVwiKVxuXG4gICAgdmFyIGJydXNoX2dyb3VwID0gdmFycy5nLnRpbWVsaW5lLnNlbGVjdEFsbChcImcjYnJ1c2hcIilcbiAgICAgIC5kYXRhKFtcImJydXNoXCJdKVxuXG4gICAgYnJ1c2hfZ3JvdXAuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgICAuYXR0cihcImlkXCIsXCJicnVzaFwiKVxuXG4gICAgdmFyIGxhYmVscyA9IHZhcnMuZy50aW1lbGluZS5zZWxlY3RBbGwoXCJnI2xhYmVsc1wiKVxuICAgICAgLmRhdGEoW1wibGFiZWxzXCJdKVxuXG4gICAgbGFiZWxzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgICAgLmF0dHIoXCJpZFwiLFwibGFiZWxzXCIpXG5cbiAgICB2YXIgdGV4dCA9IGxhYmVscy5zZWxlY3RBbGwoXCJ0ZXh0XCIpXG4gICAgICAuZGF0YSh5ZWFycyxmdW5jdGlvbihkLGkpe1xuICAgICAgICByZXR1cm4gaVxuICAgICAgfSlcblxuICAgIHRleHQuZW50ZXIoKS5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAuYXR0cihcInlcIiwwKVxuICAgICAgLmF0dHIoXCJkeVwiLFwiMC41ZXhcIilcbiAgICAgIC5hdHRyKFwieFwiLDApXG5cbiAgICB0ZXh0XG4gICAgICAub3JkZXIoKVxuICAgICAgLmF0dHIodGV4dFN0eWxlKVxuICAgICAgLnRleHQoZnVuY3Rpb24oZCxpKXtcbiAgICAgICAgaWYgKGkgPT09IDAgfHwgaSA9PT0geWVhcnMubGVuZ3RoLTEpIHJldHVybiB0aW1lRm9ybWF0KGQpXG5cbiAgICAgICAgdmFyIHByZXYgPSAoaS0xKSV0aWNrU3RlcCA9PT0gMFxuICAgICAgICAgICwgbmV4dCA9IChpKzEpJXRpY2tTdGVwID09PSAwXG4gICAgICAgICAgLCBkYXRhID0gdmFycy5kYXRhLnRpbWUuZGF0YVN0ZXBzLmluZGV4T2YoaSkgPj0gMFxuICAgICAgICAgICwgZml0cyA9ICh5ZWFyV2lkdGhzW2ktMV0vMiArIHllYXJXaWR0aHNbaV0gKyB5ZWFyV2lkdGhzW2krMV0vMiArIHZhcnMudWkucGFkZGluZyo0KSA8IGxhYmVsX3dpZHRoKjJcblxuICAgICAgICByZXR1cm4gaSV0aWNrU3RlcCA9PT0gMCB8fCAoIXByZXYgJiYgIW5leHQgJiYgZGF0YSAmJiBvbGRfd2lkdGggPCBsYWJlbF93aWR0aCozKSA/IHRpbWVNdWx0aUZvcm1hdChkKSA6IFwiXCJcbiAgICAgIH0pXG4gICAgICAuYXR0cihcIm9wYWNpdHlcIixmdW5jdGlvbihkLGkpe1xuICAgICAgICByZXR1cm4gdmFycy5kYXRhLnRpbWUuZGF0YVN0ZXBzLmluZGV4T2YoaSkgPj0gMCA/IDEgOiAwLjRcbiAgICAgIH0pXG4gICAgICAuYXR0cihcImZpbGxcIix0ZXh0RmlsbClcbiAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsZnVuY3Rpb24oZCxpKXtcbiAgICAgICAgdmFyIHggPSBzdGFydF94ICsgKGxhYmVsX3dpZHRoKmkpICsgbGFiZWxfd2lkdGgvMlxuICAgICAgICAgICwgeSA9IHRpbWVsaW5lSGVpZ2h0LzIgKyB2YXJzLnVpLnBhZGRpbmcgKyAxXG5cbiAgICAgICAgLy8gdmFyIGRpZmYgPSBkaWZmID0gcGFyc2VGbG9hdChkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJmb250LXNpemVcIiksMTApLzRcbiAgICAgICAgLy8gdmFyIHkgPSB2YXJzLnVpLnBhZGRpbmcrdmFycy50aW1lbGluZS5oZWlnaHQvMit0aGlzLmdldEJCb3goKS5oZWlnaHQvMiAtIGRpZmZcblxuICAgICAgICBpZiAodGV4dFJvdGF0ZSkge1xuICAgICAgICAgIC8vIHggLT0gdmFycy51aS5wYWRkaW5nXG4gICAgICAgICAgLy8geSArPSB2YXJzLnVpLnBhZGRpbmdcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyB4ICs9IHZhcnMudWkucGFkZGluZ1xuICAgICAgICAgIC8vIHkgKz0gdmFycy51aS5wYWRkaW5nXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiK01hdGgucm91bmQoeCkrXCIsXCIrTWF0aC5yb3VuZCh5KStcIilyb3RhdGUoXCIrdGV4dFJvdGF0ZStcIilcIlxuICAgICAgfSlcblxuICAgIHRleHQuZXhpdCgpLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsMClcbiAgICAgIC5yZW1vdmUoKVxuXG4gICAgdmFyIHggPSBkMy50aW1lLnNjYWxlKClcbiAgICAgIC5kb21haW4oZDMuZXh0ZW50KHllYXJfdGlja3MpKVxuICAgICAgLnJhbmdlUm91bmQoWzAsdGltZWxpbmVfd2lkdGhdKVxuXG4gICAgdmFyIGJydXNoID0gZDMuc3ZnLmJydXNoKClcbiAgICAgIC54KHgpXG4gICAgICAuZXh0ZW50KGJydXNoRXh0ZW50KVxuICAgICAgLm9uKFwiYnJ1c2hcIiwgYnJ1c2hlZClcbiAgICAgIC5vbihcImJydXNoZW5kXCIsIGJydXNoZW5kKVxuXG4gICAgdGlja3NcbiAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGUoXCIrc3RhcnRfeCtcIixcIit2YXJzLnVpLnBhZGRpbmcrXCIpXCIpXG4gICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAuY2FsbChkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAub3JpZW50KFwidG9wXCIpXG4gICAgICAgIC50aWNrcyhmdW5jdGlvbigpe1xuICAgICAgICAgIHJldHVybiB5ZWFyX3RpY2tzXG4gICAgICAgIH0pXG4gICAgICAgIC50aWNrRm9ybWF0KFwiXCIpXG4gICAgICAgIC50aWNrU2l6ZSgtdGltZWxpbmVIZWlnaHQpXG4gICAgICAgIC50aWNrUGFkZGluZygwKSlcbiAgICAgICAgLnNlbGVjdEFsbChcInBhdGhcIikuYXR0cihcImZpbGxcIixcIm5vbmVcIilcblxuICAgIHRpY2tzLnNlbGVjdEFsbChcImxpbmVcIilcbiAgICAgIC5hdHRyKFwic3Ryb2tlXCIsdmFycy50aW1lbGluZS50aWNrKVxuICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwxKVxuICAgICAgLmF0dHIoXCJzaGFwZS1yZW5kZXJpbmdcIixcImNyaXNwRWRnZXNcIilcblxuICAgIGJydXNoX2dyb3VwXG4gICAgICAuYXR0cihcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlKFwiK3N0YXJ0X3grXCIsXCIrKHZhcnMudWkucGFkZGluZysxKStcIilcIilcbiAgICAgIC5hdHRyKFwib3BhY2l0eVwiLDEpXG4gICAgICAuY2FsbChicnVzaClcblxuICAgIHRleHQuYXR0cihcInBvaW50ZXItZXZlbnRzXCIsXCJub25lXCIpXG5cbiAgICBicnVzaF9ncm91cC5zZWxlY3RBbGwoXCJyZWN0LmJhY2tncm91bmRcIilcbiAgICAgIC5hdHRyKFwiZmlsbFwiLFwibm9uZVwiKVxuICAgICAgLy8gLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwxKVxuICAgICAgLy8gLmF0dHIoXCJzdHJva2VcIix2YXJzLnVpLmNvbG9yLnNlY29uZGFyeS52YWx1ZSlcbiAgICAgIC5zdHlsZShcInZpc2liaWxpdHlcIixcInZpc2libGVcIilcbiAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsdGltZWxpbmVIZWlnaHQpXG4gICAgICAuYXR0cihcInNoYXBlLXJlbmRlcmluZ1wiLFwiY3Jpc3BFZGdlc1wiKVxuICAgICAgLm9uKGQzcGx1cy5ldnQubW92ZSxmdW5jdGlvbigpe1xuICAgICAgICB2YXIgYyA9IHZhcnMudGltZWxpbmUuaG92ZXIudmFsdWVcbiAgICAgICAgaWYgKFtcImdyYWJcIixcImdyYWJiaW5nXCJdLmluZGV4T2YoYykgPj0gMCkgYyA9IGQzcGx1cy5wcmVmaXgoKStjXG4gICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImN1cnNvclwiLGMpXG4gICAgICB9KVxuXG4gICAgYnJ1c2hfZ3JvdXAuc2VsZWN0QWxsKFwicmVjdC5leHRlbnRcIilcbiAgICAgIC8vIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsMSlcbiAgICAgIC8vIC5hdHRyKFwic3Ryb2tlXCIsdmFycy51aS5jb2xvci5zZWNvbmRhcnkudmFsdWUpXG4gICAgICAuYXR0cihcImhlaWdodFwiLHRpbWVsaW5lSGVpZ2h0KVxuICAgICAgLmF0dHIoXCJmaWxsXCIsdmFycy51aS5jb2xvci5wcmltYXJ5LnZhbHVlKVxuICAgICAgLmF0dHIoXCJzaGFwZS1yZW5kZXJpbmdcIixcImNyaXNwRWRnZXNcIilcbiAgICAgIC5vbihkM3BsdXMuZXZ0Lm1vdmUsZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGMgPSB2YXJzLnRpbWVsaW5lLmhvdmVyLnZhbHVlXG4gICAgICAgIGlmIChbXCJncmFiXCIsXCJncmFiYmluZ1wiXS5pbmRleE9mKGMpID49IDApIGMgPSBkM3BsdXMucHJlZml4KCkrY1xuICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJjdXJzb3JcIixjKVxuICAgICAgfSlcblxuICAgIGlmICh2YXJzLnRpbWVsaW5lLmhhbmRsZXMudmFsdWUpIHtcblxuICAgICAgdmFyIGhhbmRsZXMgPSBicnVzaF9ncm91cC5zZWxlY3RBbGwoXCJnLnJlc2l6ZVwiKS5zZWxlY3RBbGwoXCJyZWN0LmQzcGx1c19oYW5kbGVcIilcbiAgICAgICAgLmRhdGEoW1wiZDNwbHVzX2hhbmRsZVwiXSlcblxuICAgICAgaGFuZGxlcy5lbnRlcigpLmluc2VydChcInJlY3RcIixcInJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLFwiZDNwbHVzX2hhbmRsZVwiKVxuXG4gICAgICBoYW5kbGVzXG4gICAgICAgIC5hdHRyKFwiZmlsbFwiLHZhcnMudGltZWxpbmUuaGFuZGxlcy5jb2xvcilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIixmdW5jdGlvbihkKXtcbiAgICAgICAgICB2YXIgbW9kID0gdGhpcy5wYXJlbnROb2RlLmNsYXNzTmFtZS5iYXNlVmFsID09PSBcInJlc2l6ZSBlXCIgPyAtdmFycy50aW1lbGluZS5oYW5kbGVzLnNpemUgOiAwXG4gICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiK21vZCtcIiwwKVwiXG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIix2YXJzLnRpbWVsaW5lLmhhbmRsZXMuc2l6ZSlcbiAgICAgICAgLnN0eWxlKFwidmlzaWJpbGl0eVwiLFwidmlzaWJsZVwiKVxuICAgICAgICAuYXR0cihcInNoYXBlLXJlbmRlcmluZ1wiLFwiY3Jpc3BFZGdlc1wiKVxuICAgICAgICAuYXR0cihcIm9wYWNpdHlcIix2YXJzLnRpbWVsaW5lLmhhbmRsZXMub3BhY2l0eSlcbiAgICAgICAgLm9uKGQzcGx1cy5ldnQub3ZlcixmdW5jdGlvbigpe1xuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zZWxlY3QoXCJyZWN0XCIpXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMudGltaW5nLm1vdXNlZXZlbnRzKVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsdmFycy50aW1lbGluZS5oYW5kbGVzLmhvdmVyKVxuICAgICAgICB9KVxuICAgICAgICAub24oZDNwbHVzLmV2dC5vdXQsZnVuY3Rpb24oKXtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc2VsZWN0KFwicmVjdFwiKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLnRpbWluZy5tb3VzZWV2ZW50cylcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLHZhcnMudGltZWxpbmUuaGFuZGxlcy5jb2xvcilcbiAgICAgICAgfSlcblxuICAgICAgYnJ1c2hfZ3JvdXAuc2VsZWN0QWxsKFwiZy5yZXNpemVcIikuc2VsZWN0QWxsKFwicmVjdFwiKVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLHRpbWVsaW5lSGVpZ2h0KVxuXG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICBicnVzaF9ncm91cC5zZWxlY3RBbGwoXCJnLnJlc2l6ZVwiKVxuICAgICAgICAucmVtb3ZlKClcblxuICAgIH1cblxuICAgIGlmICggdmFycy5tYXJnaW4uYm90dG9tID09PSAwICkge1xuICAgICAgdmFycy5tYXJnaW4uYm90dG9tICs9IHZhcnMudWkucGFkZGluZ1xuICAgIH1cblxuICAgIHZhciB0aW1lbGluZUJveCA9IHZhcnMuZy50aW1lbGluZS5ub2RlKCkuZ2V0QkJveCgpXG5cbiAgICB2YXJzLm1hcmdpbi5ib3R0b20gKz0gdGltZWxpbmVCb3guaGVpZ2h0K3RpbWVsaW5lQm94LnlcblxuICAgIHZhcnMuZy50aW1lbGluZS50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGUoMCxcIitNYXRoLnJvdW5kKHZhcnMuaGVpZ2h0LnZhbHVlLXZhcnMubWFyZ2luLmJvdHRvbS12YXJzLnVpLnBhZGRpbmcvMikrXCIpXCIpXG5cbiAgICB2YXJzLm1hcmdpbi5ib3R0b20gKz0gdmFycy51aS5wYWRkaW5nXG5cbiAgICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZShcImRyYXdpbmcgdGltZWxpbmVcIilcblxuICB9XG4gIGVsc2Uge1xuXG4gICAgdmFycy5nLnRpbWVsaW5lLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZSgwLFwiK3ZhcnMuaGVpZ2h0LnZhbHVlK1wiKVwiKVxuXG4gIH1cblxufVxuIiwidmFyIGZldGNoVmFsdWUgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9mZXRjaC92YWx1ZS5qc1wiKVxuLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIERyYXdzIGFwcHJvcHJpYXRlIHRpdGxlc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmQzcGx1cy51aS50aXRsZXMgPSBmdW5jdGlvbih2YXJzKSB7XG5cbiAgdmFyIHRvdGFsX2tleSA9IHZhcnMuc2l6ZS52YWx1ZSA/IHZhcnMuc2l6ZS52YWx1ZVxuICAgIDogdmFycy5jb2xvci50eXBlID09PSBcIm51bWJlclwiID8gdmFycy5jb2xvci52YWx1ZSA6IGZhbHNlXG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIElmIHRoZXJlIGlzIG5vIGRhdGEgb3IgdGhlIHRpdGxlIGJhciBpcyBub3QgbmVlZGVkLFxuICAvLyBzZXQgdGhlIHRvdGFsIHZhbHVlIHRvICdudWxsJ1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgaWYgKCF2YXJzLmRhdGEuYXBwIHx8ICF2YXJzLnRpdGxlLnRvdGFsLnZhbHVlIHx8IHZhcnMuc21hbGwpIHtcbiAgICB2YXIgdG90YWwgPSBmYWxzZVxuICB9XG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBPdGhlcndpc2UsIGxldCdzIGNhbGN1bGF0ZSBpdCFcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGVsc2UgaWYgKHRvdGFsX2tleSkge1xuXG4gICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIHtcbiAgICAgIGQzcGx1cy5jb25zb2xlLnRpbWUoXCJjYWxjdWxhdGluZyB0b3RhbCB2YWx1ZVwiKVxuICAgIH1cblxuICAgIGlmICh2YXJzLmZvY3VzLnZhbHVlLmxlbmd0aCkge1xuICAgICAgdmFyIHRvdGFsID0gdmFycy5kYXRhLmFwcC5maWx0ZXIoZnVuY3Rpb24oZCl7XG4gICAgICAgIHJldHVybiBkW3ZhcnMuaWQudmFsdWVdID09IHZhcnMuZm9jdXMudmFsdWVbMF1cbiAgICAgIH0pXG4gICAgICB0b3RhbCA9IGQzLnN1bSh0b3RhbCxmdW5jdGlvbihkKXtcbiAgICAgICAgcmV0dXJuIGZldGNoVmFsdWUodmFycyxkLHRvdGFsX2tleSlcbiAgICAgIH0pXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHRvdGFsID0gZDMuc3VtKHZhcnMuZGF0YS5wb29sLGZ1bmN0aW9uKGQpe1xuICAgICAgICByZXR1cm4gZmV0Y2hWYWx1ZSh2YXJzLGQsdG90YWxfa2V5KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAodG90YWwgPT09IDApIHtcbiAgICAgIHRvdGFsID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRvdGFsID09PSBcIm51bWJlclwiKSB7XG5cbiAgICAgIHZhciBwY3QgPSBcIlwiXG5cbiAgICAgIGlmICh2YXJzLmRhdGEubXV0ZS5sZW5ndGggfHwgdmFycy5kYXRhLnNvbG8ubGVuZ3RoIHx8IHZhcnMuZm9jdXMudmFsdWUubGVuZ3RoKSB7XG5cbiAgICAgICAgdmFyIG92ZXJhbGxfdG90YWwgPSBkMy5zdW0odmFycy5kYXRhLnZhbHVlLCBmdW5jdGlvbihkKXtcbiAgICAgICAgICBpZiAodmFycy50aW1lLnNvbG8udmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gdmFycy50aW1lLnNvbG8udmFsdWUuaW5kZXhPZihmZXRjaFZhbHVlKHZhcnMsZCx2YXJzLnRpbWUudmFsdWUpKSA+PSAwXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHZhcnMudGltZS5tdXRlLnZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHZhcnMudGltZS5zb2xvLnZhbHVlLmluZGV4T2YoZmV0Y2hWYWx1ZSh2YXJzLGQsdmFycy50aW1lLnZhbHVlKSkgPCAwXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaFZhbHVlKHZhcnMsZCx0b3RhbF9rZXkpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIGlmIChvdmVyYWxsX3RvdGFsID4gdG90YWwpIHtcblxuICAgICAgICAgIHZhciBwY3QgPSAodG90YWwvb3ZlcmFsbF90b3RhbCkqMTAwLFxuICAgICAgICAgICAgICBvdCA9IHZhcnMuZm9ybWF0LnZhbHVlKG92ZXJhbGxfdG90YWwsdmFycy5zaXplLnZhbHVlKVxuXG4gICAgICAgICAgdmFyIHBjdCA9IFwiIChcIit2YXJzLmZvcm1hdC52YWx1ZShwY3QsXCJzaGFyZVwiKStcIiUgb2YgXCIrb3QrXCIpXCJcblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRvdGFsID0gdmFycy5mb3JtYXQudmFsdWUodG90YWwsdmFycy5zaXplLnZhbHVlKVxuICAgICAgdmFyIG9iaiA9IHZhcnMudGl0bGUudG90YWwudmFsdWVcbiAgICAgICAgLCBwcmVmaXggPSBvYmoucHJlZml4IHx8IHZhcnMuZm9ybWF0LnZhbHVlKHZhcnMuZm9ybWF0LmxvY2FsZS52YWx1ZS51aS50b3RhbCkrXCI6IFwiXG4gICAgICB0b3RhbCA9IHByZWZpeCArIHRvdGFsXG4gICAgICBvYmouc3VmZml4ID8gdG90YWwgPSB0b3RhbCArIG9iai5zdWZmaXggOiBudWxsXG4gICAgICB0b3RhbCArPSBwY3RcblxuICAgIH1cblxuICAgIGlmICggdmFycy5kZXYudmFsdWUgKSB7XG4gICAgICBkM3BsdXMuY29uc29sZS50aW1lRW5kKFwiY2FsY3VsYXRpbmcgdG90YWwgdmFsdWVcIilcbiAgICB9XG5cbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgdG90YWwgPSBmYWxzZVxuICB9XG5cblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gSW5pdGlhbGl6ZSB0aXRsZXMgYW5kIGRldGVjdCBmb290ZXJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHZhciB0aXRsZV9kYXRhID0gW11cblxuICBpZiAodmFycy5mb290ZXIudmFsdWUpIHtcbiAgICB0aXRsZV9kYXRhLnB1c2goe1xuICAgICAgXCJsaW5rXCI6IHZhcnMuZm9vdGVyLmxpbmssXG4gICAgICBcInN0eWxlXCI6IHZhcnMuZm9vdGVyLFxuICAgICAgXCJ0eXBlXCI6IFwiZm9vdGVyXCIsXG4gICAgICBcInZhbHVlXCI6IHZhcnMuZm9vdGVyLnZhbHVlXG4gICAgfSlcbiAgfVxuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBJZiBub3QgaW4gXCJzbWFsbFwiIG1vZGUsIGRldGVjdCB0aXRsZXMgYXZhaWxhYmxlXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBpZiAoIXZhcnMuc21hbGwpIHtcblxuICAgIGlmICh2YXJzLnRpdGxlLnZhbHVlKSB7XG4gICAgICB0aXRsZV9kYXRhLnB1c2goe1xuICAgICAgICBcImxpbmtcIjogdmFycy50aXRsZS5saW5rLFxuICAgICAgICBcInN0eWxlXCI6IHZhcnMudGl0bGUsXG4gICAgICAgIFwidHlwZVwiOiBcInRpdGxlXCIsXG4gICAgICAgIFwidmFsdWVcIjogdmFycy50aXRsZS52YWx1ZVxuICAgICAgfSlcbiAgICB9XG4gICAgaWYgKHZhcnMudGl0bGUuc3ViLnZhbHVlKSB7XG4gICAgICB0aXRsZV9kYXRhLnB1c2goe1xuICAgICAgICBcImxpbmtcIjogdmFycy50aXRsZS5zdWIubGluayxcbiAgICAgICAgXCJzdHlsZVwiOiB2YXJzLnRpdGxlLnN1YixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3ViXCIsXG4gICAgICAgIFwidmFsdWVcIjogdmFycy50aXRsZS5zdWIudmFsdWVcbiAgICAgIH0pXG4gICAgfVxuICAgIGlmICh2YXJzLnRpdGxlLnRvdGFsLnZhbHVlICYmIHRvdGFsKSB7XG4gICAgICB0aXRsZV9kYXRhLnB1c2goe1xuICAgICAgICBcImxpbmtcIjogdmFycy50aXRsZS50b3RhbC5saW5rLFxuICAgICAgICBcInN0eWxlXCI6IHZhcnMudGl0bGUudG90YWwsXG4gICAgICAgIFwidHlwZVwiOiBcInRvdGFsXCIsXG4gICAgICAgIFwidmFsdWVcIjogdG90YWxcbiAgICAgIH0pXG4gICAgfVxuXG4gIH1cblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gVGl0bGUgcG9zaXRpb25pbmdcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGZ1bmN0aW9uIHBvc2l0aW9uKHRpdGxlKSB7XG5cbiAgICB0aXRsZVxuICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIixmdW5jdGlvbih0KXtcblxuICAgICAgICB2YXIgYWxpZ24gPSB0LnN0eWxlLmZvbnQuYWxpZ25cblxuICAgICAgICBpZiAoYWxpZ24gPT0gXCJjZW50ZXJcIikge1xuICAgICAgICAgIHJldHVybiBcIm1pZGRsZVwiXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGFsaWduID09IFwibGVmdFwiICYmICFkM3BsdXMucnRsKSB8fCAoYWxpZ24gPT0gXCJyaWdodFwiICYmIGQzcGx1cy5ydGwpKSB7XG4gICAgICAgICAgcmV0dXJuIFwic3RhcnRcIlxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChhbGlnbiA9PSBcImxlZnRcIiAmJiBkM3BsdXMucnRsKSB8fCAoYWxpZ24gPT0gXCJyaWdodFwiICYmICFkM3BsdXMucnRsKSkge1xuICAgICAgICAgIHJldHVybiBcImVuZFwiXG4gICAgICAgIH1cblxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwieFwiLGZ1bmN0aW9uKHQpe1xuXG4gICAgICAgIHZhciBhbGlnbiA9IHQuc3R5bGUuZm9udC5hbGlnblxuXG4gICAgICAgIGlmIChhbGlnbiA9PSBcImNlbnRlclwiKSB7XG4gICAgICAgICAgcmV0dXJuIHZhcnMud2lkdGgudmFsdWUvMlxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChhbGlnbiA9PSBcImxlZnRcIiAmJiAhZDNwbHVzLnJ0bCkgfHwgKGFsaWduID09IFwicmlnaHRcIiAmJiBkM3BsdXMucnRsKSkge1xuICAgICAgICAgIHJldHVybiB2YXJzLnBhZGRpbmdcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYWxpZ24gPT0gXCJsZWZ0XCIgJiYgZDNwbHVzLnJ0bCkgfHwgKGFsaWduID09IFwicmlnaHRcIiAmJiAhZDNwbHVzLnJ0bCkpIHtcbiAgICAgICAgICByZXR1cm4gdmFycy53aWR0aC52YWx1ZS12YXJzLnBhZGRpbmdcbiAgICAgICAgfVxuXG4gICAgICB9KVxuICAgICAgLmF0dHIoXCJ5XCIsMClcblxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIEVudGVyIFRpdGxlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgZnVuY3Rpb24gc3R5bGUodGl0bGUpIHtcblxuICAgIHRpdGxlXG4gICAgICAuYXR0cihcImZvbnQtc2l6ZVwiLGZ1bmN0aW9uKHQpe1xuICAgICAgICByZXR1cm4gdC5zdHlsZS5mb250LnNpemVcbiAgICAgIH0pXG4gICAgICAuYXR0cihcImZpbGxcIixmdW5jdGlvbih0KXtcbiAgICAgICAgcmV0dXJuIHQubGluayA/IHZhcnMubGlua3MuZm9udC5jb2xvciA6IHQuc3R5bGUuZm9udC5jb2xvclxuICAgICAgfSlcbiAgICAgIC5hdHRyKFwiZm9udC1mYW1pbHlcIixmdW5jdGlvbih0KXtcbiAgICAgICAgcmV0dXJuIHQubGluayA/IHZhcnMubGlua3MuZm9udC5mYW1pbHkudmFsdWUgOiB0LnN0eWxlLmZvbnQuZmFtaWx5LnZhbHVlXG4gICAgICB9KVxuICAgICAgLmF0dHIoXCJmb250LXdlaWdodFwiLGZ1bmN0aW9uKHQpe1xuICAgICAgICByZXR1cm4gdC5saW5rID8gdmFycy5saW5rcy5mb250LndlaWdodCA6IHQuc3R5bGUuZm9udC53ZWlnaHRcbiAgICAgIH0pXG4gICAgICAuc3R5bGUoXCJ0ZXh0LWRlY29yYXRpb25cIixmdW5jdGlvbih0KXtcbiAgICAgICAgcmV0dXJuIHQubGluayA/IHZhcnMubGlua3MuZm9udC5kZWNvcmF0aW9uLnZhbHVlIDogdC5zdHlsZS5mb250LmRlY29yYXRpb24udmFsdWVcbiAgICAgIH0pXG4gICAgICAuc3R5bGUoXCJ0ZXh0LXRyYW5zZm9ybVwiLGZ1bmN0aW9uKHQpe1xuICAgICAgICByZXR1cm4gdC5saW5rID8gdmFycy5saW5rcy5mb250LnRyYW5zZm9ybS52YWx1ZSA6IHQuc3R5bGUuZm9udC50cmFuc2Zvcm0udmFsdWVcbiAgICAgIH0pXG5cbiAgfVxuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBFbnRlciBUaXRsZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lKFwiZHJhd2luZyB0aXRsZXNcIilcbiAgdmFyIHRpdGxlcyA9IHZhcnMuc3ZnLnNlbGVjdEFsbChcImcuZDNwbHVzX3RpdGxlXCIpXG4gICAgLmRhdGEodGl0bGVfZGF0YSxmdW5jdGlvbih0KXtcbiAgICAgIHJldHVybiB0LnR5cGVcbiAgICB9KVxuXG4gIHZhciB0aXRsZVdpZHRoID0gdmFycy50aXRsZS53aWR0aCB8fCB2YXJzLndpZHRoLnZhbHVlXG5cbiAgdGl0bGVzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgIC5hdHRyKFwiY2xhc3NcIixcImQzcGx1c190aXRsZVwiKVxuICAgIC5hdHRyKFwib3BhY2l0eVwiLDApXG4gICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIixmdW5jdGlvbih0KXtcbiAgICAgIHZhciB5ID0gdC5zdHlsZS5wb3NpdGlvbiA9PSBcInRvcFwiID8gMCA6IHZhcnMuaGVpZ2h0LnZhbHVlXG4gICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoMCxcIit5K1wiKVwiXG4gICAgfSlcbiAgICAuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgLmNhbGwocG9zaXRpb24pXG4gICAgICAuY2FsbChzdHlsZSlcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gV3JhcCB0ZXh0IGFuZCBjYWxjdWxhdGUgcG9zaXRpb25zLCB0aGVuIHRyYW5zaXRpb24gc3R5bGUgYW5kIG9wYWNpdHlcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHRpdGxlc1xuICAgIC5lYWNoKGZ1bmN0aW9uKGQpe1xuXG4gICAgICBkM3BsdXMudGV4dHdyYXAoKVxuICAgICAgICAuY29udGFpbmVyKCBkMy5zZWxlY3QodGhpcykuc2VsZWN0KFwidGV4dFwiKSApXG4gICAgICAgIC5oZWlnaHQoIHZhcnMuaGVpZ2h0LnZhbHVlIC8gOCApXG4gICAgICAgIC5zaXplKGZhbHNlKVxuICAgICAgICAudGV4dCggZC52YWx1ZSApXG4gICAgICAgIC53aWR0aCggdGl0bGVXaWR0aCApXG4gICAgICAgIC5kcmF3KClcblxuICAgICAgZC55ID0gdmFycy5tYXJnaW5bZC5zdHlsZS5wb3NpdGlvbl1cbiAgICAgIHZhcnMubWFyZ2luW2Quc3R5bGUucG9zaXRpb25dICs9IHRoaXMuZ2V0QkJveCgpLmhlaWdodCArIGQuc3R5bGUucGFkZGluZyoyXG5cbiAgICB9KVxuICAgIC5vbihkM3BsdXMuZXZ0Lm92ZXIsZnVuY3Rpb24odCl7XG4gICAgICBpZiAodC5saW5rKSB7XG4gICAgICAgIGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy50aW1pbmcubW91c2VldmVudHMpXG4gICAgICAgICAgLnN0eWxlKFwiY3Vyc29yXCIsXCJwb2ludGVyXCIpXG4gICAgICAgICAgLnNlbGVjdChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLHZhcnMubGlua3MuaG92ZXIuY29sb3IpXG4gICAgICAgICAgICAuYXR0cihcImZvbnQtZmFtaWx5XCIsdmFycy5saW5rcy5ob3Zlci5mYW1pbHkudmFsdWUpXG4gICAgICAgICAgICAuYXR0cihcImZvbnQtd2VpZ2h0XCIsdmFycy5saW5rcy5ob3Zlci53ZWlnaHQpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWRlY29yYXRpb25cIix2YXJzLmxpbmtzLmhvdmVyLmRlY29yYXRpb24udmFsdWUpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LXRyYW5zZm9ybVwiLHZhcnMubGlua3MuaG92ZXIudHJhbnNmb3JtLnZhbHVlKVxuICAgICAgfVxuICAgIH0pXG4gICAgLm9uKGQzcGx1cy5ldnQub3V0LGZ1bmN0aW9uKHQpe1xuICAgICAgaWYgKHQubGluaykge1xuICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMudGltaW5nLm1vdXNlZXZlbnRzKVxuICAgICAgICAgIC5zdHlsZShcImN1cnNvclwiLFwiYXV0b1wiKVxuICAgICAgICAgIC5zZWxlY3QoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuY2FsbChzdHlsZSlcbiAgICAgIH1cbiAgICB9KVxuICAgIC5vbihkM3BsdXMuZXZ0LmNsaWNrLGZ1bmN0aW9uKHQpe1xuICAgICAgaWYgKHQubGluaykge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdC5saW5rLmNoYXJBdCgwKSAhPSBcIi9cIiA/IFwiX2JsYW5rXCIgOiBcIl9zZWxmXCJcbiAgICAgICAgd2luZG93Lm9wZW4odC5saW5rLHRhcmdldClcbiAgICAgIH1cbiAgICB9KVxuICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odmFycy5kcmF3LnRpbWluZylcbiAgICAgIC5hdHRyKFwib3BhY2l0eVwiLDEpXG4gICAgICAuYXR0cihcInRyYW5zZm9ybVwiLGZ1bmN0aW9uKHQpe1xuICAgICAgICB2YXIgcG9zID0gdC5zdHlsZS5wb3NpdGlvbixcbiAgICAgICAgICAgIHkgPSBwb3MgPT0gXCJ0b3BcIiA/IDArdC55IDogdmFycy5oZWlnaHQudmFsdWUtdC55XG4gICAgICAgIGlmIChwb3MgPT0gXCJib3R0b21cIikge1xuICAgICAgICAgIHkgLT0gdGhpcy5nZXRCQm94KCkuaGVpZ2h0K3Quc3R5bGUucGFkZGluZ1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHkgKz0gdC5zdHlsZS5wYWRkaW5nXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKDAsXCIreStcIilcIlxuICAgICAgfSlcbiAgICAgIC5zZWxlY3QoXCJ0ZXh0XCIpXG4gICAgICAgIC5jYWxsKHBvc2l0aW9uKVxuICAgICAgICAuY2FsbChzdHlsZSlcblxuICAvL15eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8gRXhpdCB1bnVzZWQgdGl0bGVzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB0aXRsZXMuZXhpdCgpLnRyYW5zaXRpb24oKS5kdXJhdGlvbih2YXJzLmRyYXcudGltaW5nKVxuICAgIC5hdHRyKFwib3BhY2l0eVwiLDApXG4gICAgLnJlbW92ZSgpXG5cbiAgaWYgKCB2YXJzLm1hcmdpbi50b3AgPiAwICkge1xuICAgIHZhcnMubWFyZ2luLnRvcCArPSB2YXJzLnRpdGxlLnBhZGRpbmdcbiAgfVxuXG4gIGlmICggdmFycy5tYXJnaW4uYm90dG9tID4gMCApIHtcbiAgICB2YXJzLm1hcmdpbi5ib3R0b20gKz0gdmFycy50aXRsZS5wYWRkaW5nXG4gIH1cblxuICB2YXIgbWluID0gdmFycy50aXRsZS5oZWlnaHRcbiAgaWYgKG1pbiAmJiB2YXJzLm1hcmdpblt2YXJzLnRpdGxlLnBvc2l0aW9uXSA8IG1pbikge1xuICAgIHZhcnMubWFyZ2luW3ZhcnMudGl0bGUucG9zaXRpb25dID0gbWluXG4gIH1cblxuICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZUVuZChcImRyYXdpbmcgdGl0bGVzXCIpXG5cbn1cbiIsImQzcGx1cy52aXogPSBmdW5jdGlvbigpIHtcblxuICB2YXIgdmFycyA9IHtcbiAgICBcImdcIiAgICAgOiB7XCJhcHBzXCI6IHt9IH0sXG4gICAgXCJ0eXBlc1wiIDoge1xuICAgICAgXCJidWJibGVzXCI6ICByZXF1aXJlKFwiLi90eXBlcy9idWJibGVzLmpzXCIpLFxuICAgICAgXCJjaGFydFwiOiAgICByZXF1aXJlKFwiLi90eXBlcy9jaGFydC5qc1wiKSxcbiAgICAgIFwiZ2VvX21hcFwiOiAgcmVxdWlyZShcIi4vdHlwZXMvZ2VvX21hcC5qc1wiKSxcbiAgICAgIFwibGluZVwiOiAgICAgcmVxdWlyZShcIi4vdHlwZXMvbGluZS5qc1wiKSxcbiAgICAgIFwibmV0d29ya1wiOiAgcmVxdWlyZShcIi4vdHlwZXMvbmV0d29yay5qc1wiKSxcbiAgICAgIFwicGF0aHNcIjogICAgcmVxdWlyZShcIi4vdHlwZXMvcGF0aHMuY29mZmVlXCIpLFxuICAgICAgXCJyaW5nc1wiOiAgICByZXF1aXJlKFwiLi90eXBlcy9yaW5ncy5qc1wiKSxcbiAgICAgIFwic2NhdHRlclwiOiAgcmVxdWlyZShcIi4vdHlwZXMvc2NhdHRlci5qc1wiKSxcbiAgICAgIFwic3RhY2tlZFwiOiAgcmVxdWlyZShcIi4vdHlwZXMvc3RhY2tlZC5qc1wiKSxcbiAgICAgIFwidHJlZV9tYXBcIjogcmVxdWlyZShcIi4vdHlwZXMvdHJlZV9tYXAuanNcIilcbiAgICB9LFxuICAgIFwic2hlbGxcIiA6IFwidml6XCJcbiAgfVxuXG4gIC8vXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLyBNYWluIGRyYXdpbmcgZnVuY3Rpb25cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHZhcnMuc2VsZiA9IGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXJzLmRyYXcuZnJvemVuID0gdHJ1ZVxuICAgICAgdmFycy5pbnRlcm5hbF9lcnJvciA9IG51bGxcbiAgICAgIGQzcGx1cy5kcmF3LmNvbnRhaW5lcih2YXJzKVxuXG4gICAgICBpZiAoICEoXCJ0aW1pbmdcIiBpbiB2YXJzLmRyYXcpICkge1xuICAgICAgICB2YXJzLmRyYXcudGltaW5nID0gdmFycy50aW1pbmcudHJhbnNpdGlvbnNcbiAgICAgIH1cblxuICAgICAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAgIC8vIERldGVybWluZSBpZiBpbiBcInNtYWxsXCIgbW9kZVxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIHZhciBzbWFsbF93aWR0aCA9IHZhcnMud2lkdGgudmFsdWUgPD0gdmFycy53aWR0aC5zbWFsbCxcbiAgICAgICAgICBzbWFsbF9oZWlnaHQgPSB2YXJzLmhlaWdodC52YWx1ZSA8PSB2YXJzLmhlaWdodC5zbWFsbFxuICAgICAgdmFycy5zbWFsbCA9IHNtYWxsX3dpZHRoIHx8IHNtYWxsX2hlaWdodFxuXG4gICAgICB2YXIgbGFzdE1lc3NhZ2UgPSBmYWxzZVxuXG4gICAgICBpZiAodmFycy5lcnJvci52YWx1ZSkge1xuXG4gICAgICAgIHZhciB0aW1pbmcgPSB2YXJzLmRyYXcudGltaW5nXG5cbiAgICAgICAgdmFycy5ncm91cC50cmFuc2l0aW9uKCkuZHVyYXRpb24odGltaW5nKVxuICAgICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLDApXG4gICAgICAgIHZhcnMuZy5kYXRhLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0aW1pbmcpXG4gICAgICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsMClcbiAgICAgICAgdmFycy5nLmVkZ2VzLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0aW1pbmcpXG4gICAgICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsMClcblxuICAgICAgICB2YXJzLm1lc3NhZ2VzLnN0eWxlID0gXCJsYXJnZVwiXG4gICAgICAgIHZhciBtZXNzYWdlID0gdmFycy5lcnJvci52YWx1ZSA9PT0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICA/IHZhcnMuZm9ybWF0LnZhbHVlKHZhcnMuZm9ybWF0LmxvY2FsZS52YWx1ZS51aS5lcnJvcilcbiAgICAgICAgICAgICAgICAgICAgOiB2YXJzLmVycm9yLnZhbHVlXG5cbiAgICAgICAgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlXG4gICAgICAgIGQzcGx1cy51aS5tZXNzYWdlKHZhcnMsbWVzc2FnZSlcblxuICAgICAgfVxuICAgICAgZWxzZSB7XG5cbiAgICAgICAgdmFyIHN0ZXBzID0gZDNwbHVzLmRyYXcuc3RlcHMoIHZhcnMgKVxuICAgICAgICAgICwgc3RlcCAgPSBmYWxzZVxuXG4gICAgICAgIHZhcnMuY29udGFpbmVyLnZhbHVlLnN0eWxlKFwiY3Vyc29yXCIsXCJ3YWl0XCIpXG4gICAgICAgIHZhcnMubWVzc2FnZXMuc3R5bGUgPSB2YXJzLmdyb3VwICYmIHZhcnMuZ3JvdXAuYXR0cihcIm9wYWNpdHlcIikgPT09IFwiMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcInNtYWxsXCIgOiBcImxhcmdlXCJcblxuICAgICAgICB2YXIgbmV4dFN0ZXAgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIGlmICggc3RlcHMubGVuZ3RoICkge1xuICAgICAgICAgICAgcnVuU3RlcCgpXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICB2YXJzLm1ldGhvZEdyb3VwID0gZmFsc2VcbiAgICAgICAgICAgIGlmICggdmFycy5kZXYudmFsdWUgKSB7XG4gICAgICAgICAgICAgIGQzcGx1cy5jb25zb2xlLnRpbWVFbmQoXCJ0b3RhbCBkcmF3IHRpbWVcIilcbiAgICAgICAgICAgICAgZDNwbHVzLmNvbnNvbGUuZ3JvdXBFbmQoKVxuICAgICAgICAgICAgICBkM3BsdXMuY29uc29sZS5sb2coXCJcXG5cIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhcnMuY29udGFpbmVyLnZhbHVlLnN0eWxlKFwiY3Vyc29yXCIsXCJhdXRvXCIpXG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBydW5GdW5jdGlvbiA9IGZ1bmN0aW9uKCBuYW1lICkge1xuXG4gICAgICAgICAgdmFyIG5hbWUgPSBuYW1lIHx8IFwiZnVuY3Rpb25cIlxuXG4gICAgICAgICAgaWYgKCBzdGVwW25hbWVdIGluc3RhbmNlb2YgQXJyYXkgKSB7XG4gICAgICAgICAgICBzdGVwW25hbWVdLmZvckVhY2goZnVuY3Rpb24oZil7XG4gICAgICAgICAgICAgIGYoIHZhcnMgLCBuZXh0U3RlcCApXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICggdHlwZW9mIHN0ZXBbbmFtZV0gPT0gXCJmdW5jdGlvblwiICkge1xuICAgICAgICAgICAgc3RlcFtuYW1lXSggdmFycyAsIG5leHRTdGVwIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoICFzdGVwLndhaXQgKSB7XG4gICAgICAgICAgICBuZXh0U3RlcCgpXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBydW5TdGVwKCkge1xuXG4gICAgICAgICAgc3RlcCA9IHN0ZXBzLnNoaWZ0KClcblxuICAgICAgICAgIHZhciBzYW1lID0gdmFycy5nLm1lc3NhZ2UgJiYgbGFzdE1lc3NhZ2UgPT09IHN0ZXAubWVzc2FnZSxcbiAgICAgICAgICAgICAgcnVuID0gXCJjaGVja1wiIGluIHN0ZXAgPyBzdGVwLmNoZWNrIDogdHJ1ZVxuXG4gICAgICAgICAgaWYgKCB0eXBlb2YgcnVuID09PSBcImZ1bmN0aW9uXCIgKSB7XG4gICAgICAgICAgICBydW4gPSBydW4oIHZhcnMgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICggcnVuICkge1xuXG4gICAgICAgICAgICBpZiAoICFzYW1lICYmIHZhcnMuZHJhdy51cGRhdGUgKSB7XG5cbiAgICAgICAgICAgICAgaWYgKCB2YXJzLmRldi52YWx1ZSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGxhc3RNZXNzYWdlICE9PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgIGQzcGx1cy5jb25zb2xlLmdyb3VwRW5kKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZDNwbHVzLmNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoc3RlcC5tZXNzYWdlKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbGFzdE1lc3NhZ2UgPSB0eXBlb2YgdmFycy5tZXNzYWdlcy52YWx1ZSA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IHZhcnMubWVzc2FnZXMudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzdGVwLm1lc3NhZ2VcblxuICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHR5cGVvZiB2YXJzLm1lc3NhZ2VzLnZhbHVlID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gdmFycy5tZXNzYWdlcy52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IHZhcnMuZm9ybWF0LnZhbHVlKHN0ZXAubWVzc2FnZSlcblxuICAgICAgICAgICAgICBkM3BsdXMudWkubWVzc2FnZSh2YXJzLG1lc3NhZ2UpXG5cbiAgICAgICAgICAgICAgc2V0VGltZW91dCggcnVuRnVuY3Rpb24gLCAxMCApXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgIHJ1bkZ1bmN0aW9uKClcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBpZiAoIFwib3RoZXJ3aXNlXCIgaW4gc3RlcCApIHtcblxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgICAgICBydW5GdW5jdGlvbiggXCJvdGhlcndpc2VcIiApXG5cbiAgICAgICAgICAgICAgfSwxMClcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgbmV4dFN0ZXAoKVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJ1blN0ZXAoKVxuXG4gICAgICB9XG5cbiAgICB9KVxuXG4gICAgcmV0dXJuIHZhcnMuc2VsZlxuICB9XG5cbiAgLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vIERlZmluZSBtZXRob2RzIGFuZCBleHBvc2UgcHVibGljIHZhcmlhYmxlcy5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHZhciBtZXRob2RzID0gWyBcImFjdGl2ZVwiICwgXCJhZ2dzXCIgLCBcImF0dHJzXCIgLCBcImF4ZXNcIiAsIFwiY29sb3JcIiAsIFwiY29udGFpbmVyXCJcbiAgICAgICAgICAgICAgICAsIFwiY29vcmRzXCIgLCBcImNzdlwiICwgXCJkYXRhXCIgLCBcImRlcHRoXCIgLCBcImRlc2NzXCIgLCBcImRldlwiXG4gICAgICAgICAgICAgICAgLCBcImRyYXdcIiAsIFwiZWRnZXNcIiAsIFwiZXJyb3JcIiAsIFwiZm9jdXNcIiAsIFwiZm9vdGVyXCIgLCBcImZvcm1hdFwiXG4gICAgICAgICAgICAgICAgLCBcImhlaWdodFwiICwgXCJoaXN0b3J5XCIgLCBcImljb25cIiAsIFwiaWRcIiAsIFwibGFiZWxzXCJcbiAgICAgICAgICAgICAgICAsIFwibGVnZW5kXCIgLCBcIm1hcmdpblwiICwgXCJtZXNzYWdlc1wiICwgXCJub2Rlc1wiICwgXCJvcmRlclwiXG4gICAgICAgICAgICAgICAgLCBcInNoYXBlXCIgLCBcInNpemVcIiAsIFwic3R5bGVcIiAsIFwidGVtcFwiICwgXCJ0ZXh0XCIgLCBcInRpbWVcIlxuICAgICAgICAgICAgICAgICwgXCJ0aW1lbGluZVwiICwgXCJ0aXRsZVwiICwgXCJ0b29sdGlwXCIgLCBcInRvdGFsXCIgLCBcInR5cGVcIiAsIFwidWlcIlxuICAgICAgICAgICAgICAgICwgXCJ3aWR0aFwiICwgXCJ4XCIgLCBcInlcIiAsIFwiem9vbVwiIF1cbiAgICAsIHN0eWxlcyAgPSBbIFwiYXhlc1wiICwgXCJiYWNrZ3JvdW5kXCIgLCBcImNvbG9yXCIgLCBcImNvb3Jkc1wiICwgXCJkYXRhXCIgLCBcImVkZ2VzXCJcbiAgICAgICAgICAgICAgICAsIFwiZm9udFwiICwgXCJmb290ZXJcIiAsIFwiaGVpZ2h0XCIgLCBcImxhYmVsc1wiICwgXCJsZWdlbmRcIiAsIFwibGlua3NcIlxuICAgICAgICAgICAgICAgICwgXCJtZXNzYWdlc1wiICwgXCJub2Rlc1wiICwgXCJzaGFwZVwiICwgXCJ0aW1lbGluZVwiICwgXCJ0aW1pbmdcIlxuICAgICAgICAgICAgICAgICwgXCJ0aXRsZVwiICwgXCJ0b29sdGlwXCIgLCBcInVpXCIgLCBcIndpZHRoIFwiXVxuICBkM3BsdXMubWV0aG9kKCB2YXJzICwgbWV0aG9kcyAsIHN0eWxlcyApXG5cbiAgcmV0dXJuIHZhcnMuc2VsZlxuXG59XG4iLCJkM3BsdXMuem9vbS5ib3VuZHMgPSBmdW5jdGlvbiggdmFycyAsIGIgLCB0aW1pbmcgKSB7XG5cbiAgaWYgKCFiKSB7XG4gICAgdmFyIGIgPSB2YXJzLnpvb20uYm91bmRzXG4gIH1cblxuICBpZiAodHlwZW9mIHRpbWluZyAhPT0gXCJudW1iZXJcIikge1xuICAgIHZhciB0aW1pbmcgPSB2YXJzLnRpbWluZy50cmFuc2l0aW9uc1xuICB9XG5cbiAgdmFycy56b29tLnNpemUgPSB7XG4gICAgXCJoZWlnaHRcIjogYlsxXVsxXS1iWzBdWzFdLFxuICAgIFwid2lkdGhcIjogYlsxXVswXS1iWzBdWzBdXG4gIH1cblxuICB2YXIgZml0ID0gdmFycy5jb29yZHMuZml0LnZhbHVlXG4gIGlmIChmaXQgPT0gXCJhdXRvXCIgfHwgdmFycy50eXBlc1t2YXJzLnR5cGUudmFsdWVdLnJlcXVpcmVtZW50cy5pbmRleE9mKFwiY29vcmRzXCIpIDwgMCkge1xuICAgIHZhciBhc3BlY3QgPSBkMy5tYXgoW3ZhcnMuem9vbS5zaXplLndpZHRoL3ZhcnMud2lkdGgudml6LHZhcnMuem9vbS5zaXplLmhlaWdodC92YXJzLmhlaWdodC52aXpdKVxuICB9XG4gIGVsc2Uge1xuICAgIHZhciBhc3BlY3QgPSB2YXJzLnpvb20uc2l6ZVtmaXRdL3ZhcnNbXCJhcHBfXCIrZml0XVxuICB9XG5cbiAgdmFyIG1pbiA9IGQzLm1pbihbdmFycy53aWR0aC52aXosdmFycy5oZWlnaHQudml6XSlcblxuICB2YXIgc2NhbGUgPSAoKG1pbi0odmFycy5jb29yZHMucGFkZGluZyoyKSkgLyBtaW4pIC8gYXNwZWN0XG5cbiAgdmFyIGV4dGVudCA9IHZhcnMuem9vbS5iZWhhdmlvci5zY2FsZUV4dGVudCgpXG5cbiAgaWYgKGV4dGVudFswXSA9PSBleHRlbnRbMV0gfHwgYiA9PSB2YXJzLnpvb20uYm91bmRzKSB7XG4gICAgdmFycy56b29tLmJlaGF2aW9yLnNjYWxlRXh0ZW50KFtzY2FsZSxzY2FsZSoxNl0pXG4gIH1cblxuICB2YXIgbWF4X3NjYWxlID0gdmFycy56b29tLmJlaGF2aW9yLnNjYWxlRXh0ZW50KClbMV1cbiAgaWYgKHNjYWxlID4gbWF4X3NjYWxlKSB7XG4gICAgc2NhbGUgPSBtYXhfc2NhbGVcbiAgfVxuICB2YXJzLnpvb20uc2NhbGUgPSBzY2FsZVxuXG4gIHZhciB0cmFuc2xhdGUgPSBbXVxuXG4gIHRyYW5zbGF0ZVswXSA9IHZhcnMud2lkdGgudml6LzItKHZhcnMuem9vbS5zaXplLndpZHRoKnNjYWxlKS8yLShiWzBdWzBdKnNjYWxlKVxuICB0cmFuc2xhdGVbMV0gPSB2YXJzLmhlaWdodC52aXovMi0odmFycy56b29tLnNpemUuaGVpZ2h0KnNjYWxlKS8yLShiWzBdWzFdKnNjYWxlKVxuXG4gIHZhcnMuem9vbS50cmFuc2xhdGUgPSB0cmFuc2xhdGVcbiAgdmFycy56b29tLmJlaGF2aW9yLnRyYW5zbGF0ZSh0cmFuc2xhdGUpLnNjYWxlKHNjYWxlKVxuXG4gIHZhcnMuem9vbS5zaXplID0ge1xuICAgIFwiaGVpZ2h0XCI6IHZhcnMuem9vbS5ib3VuZHNbMV1bMV0tdmFycy56b29tLmJvdW5kc1swXVsxXSxcbiAgICBcIndpZHRoXCI6IHZhcnMuem9vbS5ib3VuZHNbMV1bMF0tdmFycy56b29tLmJvdW5kc1swXVswXVxuICB9XG5cbiAgZDNwbHVzLnpvb20udHJhbnNmb3JtKHZhcnMsdGltaW5nKVxuXG59XG4iLCJkM3BsdXMuem9vbS5jb250cm9scyA9IGZ1bmN0aW9uKCkge1xuXG4gIGQzLnNlbGVjdChcIiNkM3BsdXMudXRpbHN0cy56b29tX2NvbnRyb2xzXCIpLnJlbW92ZSgpXG4gIFxuICBpZiAoIXZhcnMuc21hbGwpIHtcbiAgICAvLyBDcmVhdGUgWm9vbSBDb250cm9sc1xuICAgIHZhciB6b29tX2VudGVyID0gdmFycy5jb250YWluZXIudmFsdWUuYXBwZW5kKFwiZGl2XCIpXG4gICAgICAuYXR0cihcImlkXCIsXCJkM3BsdXMudXRpbHN0cy56b29tX2NvbnRyb2xzXCIpXG4gICAgICAuc3R5bGUoXCJ0b3BcIiwodmFycy5tYXJnaW4udG9wKzUpK1wicHhcIilcblxuICAgIHpvb21fZW50ZXIuYXBwZW5kKFwiZGl2XCIpXG4gICAgICAuYXR0cihcImlkXCIsXCJ6b29tX2luXCIpXG4gICAgICAuYXR0cihcInVuc2VsZWN0YWJsZVwiLFwib25cIilcbiAgICAgIC5vbihkM3BsdXMuZXZ0LmNsaWNrLGZ1bmN0aW9uKCl7IHZhcnMuem9vbShcImluXCIpIH0pXG4gICAgICAudGV4dChcIitcIilcblxuICAgIHpvb21fZW50ZXIuYXBwZW5kKFwiZGl2XCIpXG4gICAgICAuYXR0cihcImlkXCIsXCJ6b29tX291dFwiKVxuICAgICAgLmF0dHIoXCJ1bnNlbGVjdGFibGVcIixcIm9uXCIpXG4gICAgICAub24oZDNwbHVzLmV2dC5jbGljayxmdW5jdGlvbigpeyB2YXJzLnpvb20oXCJvdXRcIikgfSlcbiAgICAgIC50ZXh0KFwiLVwiKVxuXG4gICAgem9vbV9lbnRlci5hcHBlbmQoXCJkaXZcIilcbiAgICAgIC5hdHRyKFwiaWRcIixcInpvb21fcmVzZXRcIilcbiAgICAgIC5hdHRyKFwidW5zZWxlY3RhYmxlXCIsXCJvblwiKVxuICAgICAgLm9uKGQzcGx1cy5ldnQuY2xpY2ssZnVuY3Rpb24oKXtcbiAgICAgICAgdmFycy56b29tKFwicmVzZXRcIilcbiAgICAgICAgdmFycy5kcmF3LnVwZGF0ZSgpXG4gICAgICB9KVxuICAgICAgLmh0bWwoXCJcXCYjODYzNDtcIilcbiAgfVxuXG4gIC8qIE9sZCBTdHlsZXNcblxuICAjem9vbV9jb250cm9scyB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogNXB4O1xuICAgIGxlZnQ6IDVweDtcbiAgICB6LWluZGV4OiA1MDtcbiAgfVxuXG4gICN6b29tX2luLCAjem9vbV9vdXQsICN6b29tX3Jlc2V0IHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmZmZmO1xuICAgIGJhY2tncm91bmQtcG9zaXRpb246IDUwJSA1MCU7XG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbiAgICAtd2Via2l0LWJveC1zaGFkb3c6IDAgMXB4IDNweCByZ2JhKDAsIDAsIDAsIDAuMjUpO1xuICAgICAgIC1tb3otYm94LXNoYWRvdzogMCAxcHggM3B4IHJnYmEoMCwgMCwgMCwgMC4yNSk7XG4gICAgICAgICAgICBib3gtc2hhZG93OiAwIDFweCAzcHggcmdiYSgwLCAwLCAwLCAwLjI1KTtcbiAgICBjb2xvcjogIzMzMzMzMztcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBoZWlnaHQ6IDE4cHg7XG4gICAgbWFyZ2luLWJvdHRvbTogNXB4O1xuICAgIG9wYWNpdHk6IDAuNzU7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIHdpZHRoOiAxOHB4O1xuICAgIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogbm9uZTtcbiAgICAgICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xuICB9XG5cbiAgI3pvb21faW46aG92ZXIsICN6b29tX291dDpob3ZlciwgI3pvb21fcmVzZXQ6aG92ZXIge1xuICAgIG9wYWNpdHk6IDE7XG4gIH1cblxuICAjem9vbV9pbiB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGZvbnQ6IG5vcm1hbCAxOHB4LzIwcHggQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZjtcbiAgfVxuXG4gICN6b29tX291dCB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGZvbnQ6IG5vcm1hbCAyMnB4LzE2cHggVGFob21hLCBWZXJkYW5hLCBzYW5zLXNlcmlmO1xuICB9XG5cbiAgI3pvb21fcmVzZXQge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBmb250OiBib2xkIDE1cHgvMTlweCBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO1xuICB9XG5cbiAgKi9cblxufVxuIiwiLy9eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbi8vIFNldHMgbGFiZWwgb3BhY2l0eSBiYXNlZCBvbiB6b29tXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZDNwbHVzLnpvb20ubGFiZWxzID0gZnVuY3Rpb24odmFycykge1xuXG4gIHZhciBtYXhfc2NhbGUgPSB2YXJzLnpvb20uYmVoYXZpb3Iuc2NhbGVFeHRlbnQoKVsxXVxuXG4gIGlmICggdmFycy5kZXYudmFsdWUgKSBkM3BsdXMuY29uc29sZS50aW1lKFwiZGV0ZXJtaW5pbmcgbGFiZWwgdmlzaWJpbGl0eVwiKVxuXG4gIGlmICh2YXJzLmRyYXcudGltaW5nKSB7XG5cbiAgICB2YXJzLmcudml6LnNlbGVjdEFsbChcInRleHQuZDNwbHVzX2xhYmVsXCIpXG4gICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHZhcnMuZHJhdy50aW1pbmcpXG4gICAgICAuYXR0cihcIm9wYWNpdHlcIixmdW5jdGlvbihkKXtcbiAgICAgICAgaWYgKCFkKSB2YXIgZCA9IHtcInNjYWxlXCI6IG1heF9zY2FsZX1cbiAgICAgICAgdmFyIHNpemUgPSBwYXJzZUZsb2F0KGQzLnNlbGVjdCh0aGlzKS5hdHRyKFwiZm9udC1zaXplXCIpLDEwKVxuICAgICAgICBkLnZpc2libGUgPSBzaXplL2Quc2NhbGUqdmFycy56b29tLnNjYWxlID49IDdcbiAgICAgICAgcmV0dXJuIGQudmlzaWJsZSA/IDEgOiAwXG4gICAgICB9KVxuXG4gIH1cbiAgZWxzZSB7XG5cbiAgICB2YXJzLmcudml6LnNlbGVjdEFsbChcInRleHQuZDNwbHVzX2xhYmVsXCIpXG4gICAgICAuYXR0cihcIm9wYWNpdHlcIixmdW5jdGlvbihkKXtcbiAgICAgICAgaWYgKCFkKSB2YXIgZCA9IHtcInNjYWxlXCI6IG1heF9zY2FsZX1cbiAgICAgICAgdmFyIHNpemUgPSBwYXJzZUZsb2F0KGQzLnNlbGVjdCh0aGlzKS5hdHRyKFwiZm9udC1zaXplXCIpLDEwKVxuICAgICAgICBkLnZpc2libGUgPSBzaXplL2Quc2NhbGUqdmFycy56b29tLnNjYWxlID49IDdcbiAgICAgICAgcmV0dXJuIGQudmlzaWJsZSA/IDEgOiAwXG4gICAgICB9KVxuXG4gIH1cblxuICBpZiAoIHZhcnMuZGV2LnZhbHVlICkgZDNwbHVzLmNvbnNvbGUudGltZUVuZChcImRldGVybWluaW5nIGxhYmVsIHZpc2liaWxpdHlcIilcblxufVxuIiwiZDNwbHVzLnpvb20ubW91c2UgPSBmdW5jdGlvbih2YXJzKSB7XG5cbiAgdmFyIHRyYW5zbGF0ZSA9IGQzLmV2ZW50LnRyYW5zbGF0ZSxcbiAgICAgIHNjYWxlID0gZDMuZXZlbnQuc2NhbGUsXG4gICAgICBsaW1pdHMgPSB2YXJzLnpvb20uYm91bmRzLFxuICAgICAgeG9mZnNldCA9ICh2YXJzLndpZHRoLnZpei0odmFycy56b29tLnNpemUud2lkdGgqc2NhbGUpKS8yLFxuICAgICAgeG1pbiA9IHhvZmZzZXQgPiAwID8geG9mZnNldCA6IDAsXG4gICAgICB4bWF4ID0geG9mZnNldCA+IDAgPyB2YXJzLndpZHRoLnZpei14b2Zmc2V0IDogdmFycy53aWR0aC52aXosXG4gICAgICB5b2Zmc2V0ID0gKHZhcnMuaGVpZ2h0LnZpei0odmFycy56b29tLnNpemUuaGVpZ2h0KnNjYWxlKSkvMixcbiAgICAgIHltaW4gPSB5b2Zmc2V0ID4gMCA/IHlvZmZzZXQgOiAwLFxuICAgICAgeW1heCA9IHlvZmZzZXQgPiAwID8gdmFycy5oZWlnaHQudml6LXlvZmZzZXQgOiB2YXJzLmhlaWdodC52aXpcblxuICAvLyBBdXRvIGNlbnRlciB2aXN1YWxpemF0aW9uXG4gIGlmICh0cmFuc2xhdGVbMF0rbGltaXRzWzBdWzBdKnNjYWxlID4geG1pbikge1xuICAgIHRyYW5zbGF0ZVswXSA9IC1saW1pdHNbMF1bMF0qc2NhbGUreG1pblxuICB9XG4gIGVsc2UgaWYgKHRyYW5zbGF0ZVswXStsaW1pdHNbMV1bMF0qc2NhbGUgPCB4bWF4KSB7XG4gICAgdHJhbnNsYXRlWzBdID0geG1heC0obGltaXRzWzFdWzBdKnNjYWxlKVxuICB9XG5cbiAgaWYgKHRyYW5zbGF0ZVsxXStsaW1pdHNbMF1bMV0qc2NhbGUgPiB5bWluKSB7XG4gICAgdHJhbnNsYXRlWzFdID0gLWxpbWl0c1swXVsxXSpzY2FsZSt5bWluXG4gIH1cbiAgZWxzZSBpZiAodHJhbnNsYXRlWzFdK2xpbWl0c1sxXVsxXSpzY2FsZSA8IHltYXgpIHtcbiAgICB0cmFuc2xhdGVbMV0gPSB5bWF4LShsaW1pdHNbMV1bMV0qc2NhbGUpXG4gIH1cblxuICB2YXJzLnpvb20uYmVoYXZpb3IudHJhbnNsYXRlKHRyYW5zbGF0ZSkuc2NhbGUoc2NhbGUpXG5cbiAgdmFycy56b29tLnRyYW5zbGF0ZSA9IHRyYW5zbGF0ZVxuICB2YXJzLnpvb20uc2NhbGUgPSBzY2FsZVxuXG4gIGlmIChkMy5ldmVudC5zb3VyY2VFdmVudC50eXBlID09IFwid2hlZWxcIikge1xuICAgIHZhciBkZWxheSA9IHZhcnMuZHJhdy50aW1pbmcgPyAxMDAgOiAyNTBcbiAgICBjbGVhclRpbWVvdXQodmFycy56b29tLndoZWVsKVxuICAgIHZhcnMuem9vbS53aGVlbCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIGQzcGx1cy56b29tLmxhYmVscyh2YXJzKVxuICAgIH0sZGVsYXkpXG4gIH1cbiAgZWxzZSB7XG4gICAgZDNwbHVzLnpvb20ubGFiZWxzKHZhcnMpXG4gIH1cblxuICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQudHlwZSA9PT0gXCJkYmxjbGlja1wiKSB7XG4gICAgZDNwbHVzLnpvb20udHJhbnNmb3JtKHZhcnMsdmFycy50aW1pbmcudHJhbnNpdGlvbnMpXG4gIH1cbiAgZWxzZSB7XG4gICAgZDNwbHVzLnpvb20udHJhbnNmb3JtKHZhcnMsMClcbiAgfVxuXG59XG4iLCJkM3BsdXMuem9vbS50cmFuc2Zvcm0gPSBmdW5jdGlvbih2YXJzLHRpbWluZykge1xuXG4gIGlmICh0eXBlb2YgdGltaW5nICE9PSBcIm51bWJlclwiKSB7XG4gICAgdmFyIHRpbWluZyA9IHZhcnMudGltaW5nLnRyYW5zaXRpb25zXG4gIH1cblxuICB2YXIgdHJhbnNsYXRlID0gdmFycy56b29tLnRyYW5zbGF0ZVxuICAgICwgc2NhbGUgPSB2YXJzLnpvb20uc2NhbGVcblxuICBpZiAodGltaW5nKSB7XG4gICAgdmFycy5nLnZpei50cmFuc2l0aW9uKCkuZHVyYXRpb24odGltaW5nKVxuICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZShcIit0cmFuc2xhdGUrXCIpc2NhbGUoXCIrc2NhbGUrXCIpXCIpXG5cbiAgfVxuICBlbHNlIHtcblxuICAgIHZhcnMuZy52aXpcbiAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGUoXCIrdHJhbnNsYXRlK1wiKXNjYWxlKFwiK3NjYWxlK1wiKVwiKVxuXG4gIH1cblxufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MlxuXG4vKipcbiAqIElmIGBUWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIE5vdGU6XG4gKlxuICogLSBJbXBsZW1lbnRhdGlvbiBtdXN0IHN1cHBvcnQgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMuXG4gKiAgIEZpcmVmb3ggNC0yOSBsYWNrZWQgc3VwcG9ydCwgZml4ZWQgaW4gRmlyZWZveCAzMCsuXG4gKiAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG4gKlxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYFRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleSB3aWxsXG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCB3aWxsIHdvcmsgY29ycmVjdGx5LlxuICovXG52YXIgVFlQRURfQVJSQVlfU1VQUE9SVCA9IChmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcigwKVxuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgYXJyLmZvbyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH1cbiAgICByZXR1cm4gNDIgPT09IGFyci5mb28oKSAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBuZXcgVWludDhBcnJheSgxKS5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSkoKVxuXG4vKipcbiAqIENsYXNzOiBCdWZmZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGFyZSBhdWdtZW50ZWRcbiAqIHdpdGggZnVuY3Rpb24gcHJvcGVydGllcyBmb3IgYWxsIHRoZSBub2RlIGBCdWZmZXJgIEFQSSBmdW5jdGlvbnMuIFdlIHVzZVxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xuICogYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcbiAqIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pXG5cbiAgdmFyIHR5cGUgPSB0eXBlb2Ygc3ViamVjdFxuXG4gIC8vIEZpbmQgdGhlIGxlbmd0aFxuICB2YXIgbGVuZ3RoXG4gIGlmICh0eXBlID09PSAnbnVtYmVyJylcbiAgICBsZW5ndGggPSBzdWJqZWN0ID4gMCA/IHN1YmplY3QgPj4+IDAgOiAwXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0JylcbiAgICAgIHN1YmplY3QgPSBiYXNlNjRjbGVhbihzdWJqZWN0KVxuICAgIGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIHN1YmplY3QgIT09IG51bGwpIHsgLy8gYXNzdW1lIG9iamVjdCBpcyBhcnJheS1saWtlXG4gICAgaWYgKHN1YmplY3QudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShzdWJqZWN0LmRhdGEpKVxuICAgICAgc3ViamVjdCA9IHN1YmplY3QuZGF0YVxuICAgIGxlbmd0aCA9ICtzdWJqZWN0Lmxlbmd0aCA+IDAgPyBNYXRoLmZsb29yKCtzdWJqZWN0Lmxlbmd0aCkgOiAwXG4gIH0gZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbmVlZHMgdG8gYmUgYSBudW1iZXIsIGFycmF5IG9yIHN0cmluZy4nKVxuXG4gIHZhciBidWZcbiAgaWYgKFRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBQcmVmZXJyZWQ6IFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgYnVmID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBUSElTIGluc3RhbmNlIG9mIEJ1ZmZlciAoY3JlYXRlZCBieSBgbmV3YClcbiAgICBidWYgPSB0aGlzXG4gICAgYnVmLmxlbmd0aCA9IGxlbmd0aFxuICAgIGJ1Zi5faXNCdWZmZXIgPSB0cnVlXG4gIH1cblxuICB2YXIgaVxuICBpZiAoVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2Ygc3ViamVjdC5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgIC8vIFNwZWVkIG9wdGltaXphdGlvbiAtLSB1c2Ugc2V0IGlmIHdlJ3JlIGNvcHlpbmcgZnJvbSBhIHR5cGVkIGFycmF5XG4gICAgYnVmLl9zZXQoc3ViamVjdClcbiAgfSBlbHNlIGlmIChpc0FycmF5aXNoKHN1YmplY3QpKSB7XG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0LnJlYWRVSW50OChpKVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGJ1ZltpXSA9ICgoc3ViamVjdFtpXSAlIDI1NikgKyAyNTYpICUgMjU2XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmICFUWVBFRF9BUlJBWV9TVVBQT1JUICYmICFub1plcm8pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IDBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbi8vIFNUQVRJQyBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICB2YXIgcmV0XG4gIHN0ciA9IHN0ci50b1N0cmluZygpXG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgJ3V0ZjgnKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggLyAyXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoICogMlxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiAobGlzdCwgdG90YWxMZW5ndGgpIHtcbiAgYXNzZXJ0KGlzQXJyYXkobGlzdCksICdVc2FnZTogQnVmZmVyLmNvbmNhdChsaXN0WywgbGVuZ3RoXSknKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKHRvdGFsTGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICB0b3RhbExlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdG90YWxMZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcih0b3RhbExlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIGFzc2VydChCdWZmZXIuaXNCdWZmZXIoYSkgJiYgQnVmZmVyLmlzQnVmZmVyKGIpLCAnQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW4gJiYgYVtpXSA9PT0gYltpXTsgaSsrKSB7fVxuICBpZiAoaSAhPT0gbGVuKSB7XG4gICAgeCA9IGFbaV1cbiAgICB5ID0gYltpXVxuICB9XG4gIGlmICh4IDwgeSkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmICh5IDwgeCkge1xuICAgIHJldHVybiAxXG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuLy8gQlVGRkVSIElOU1RBTkNFIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgYXNzZXJ0KHN0ckxlbiAlIDIgPT09IDAsICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBhc3NlcnQoIWlzTmFOKGJ5dGUpLCAnSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gdXRmMTZsZVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcbiAgc3RhcnQgPSBOdW1iZXIoc3RhcnQpIHx8IDBcbiAgZW5kID0gKGVuZCA9PT0gdW5kZWZpbmVkKSA/IHNlbGYubGVuZ3RoIDogTnVtYmVyKGVuZClcblxuICAvLyBGYXN0cGF0aCBlbXB0eSBzdHJpbmdzXG4gIGlmIChlbmQgPT09IHN0YXJ0KVxuICAgIHJldHVybiAnJ1xuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBoZXhTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gYXNjaWlTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gYmluYXJ5U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSB1dGYxNmxlU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChiKSB7XG4gIGFzc2VydChCdWZmZXIuaXNCdWZmZXIoYiksICdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChiKSB7XG4gIGFzc2VydChCdWZmZXIuaXNCdWZmZXIoYiksICdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpc1xuXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICghdGFyZ2V0X3N0YXJ0KSB0YXJnZXRfc3RhcnQgPSAwXG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgc291cmNlLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBhc3NlcnQoZW5kID49IHN0YXJ0LCAnc291cmNlRW5kIDwgc291cmNlU3RhcnQnKVxuICBhc3NlcnQodGFyZ2V0X3N0YXJ0ID49IDAgJiYgdGFyZ2V0X3N0YXJ0IDwgdGFyZ2V0Lmxlbmd0aCxcbiAgICAgICd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCBzb3VyY2UubGVuZ3RoLCAnc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChlbmQgPj0gMCAmJiBlbmQgPD0gc291cmNlLmxlbmd0aCwgJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpXG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydClcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0ICsgc3RhcnRcblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAobGVuIDwgMTAwIHx8ICFUWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0X3N0YXJ0KVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmVzID0gJydcbiAgdmFyIHRtcCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChidWZbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgICAgIHRtcCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcCArPSAnJScgKyBidWZbaV0udG9TdHJpbmcoMTYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcClcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBiaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBhc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZClcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuO1xuICAgIGlmIChzdGFydCA8IDApXG4gICAgICBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMClcbiAgICAgIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydClcbiAgICBlbmQgPSBzdGFydFxuXG4gIGlmIChUWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgdmFyIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZCwgdHJ1ZSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgICByZXR1cm4gbmV3QnVmXG4gIH1cbn1cblxuLy8gYGdldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbmZ1bmN0aW9uIHJlYWRVSW50MTYgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsXG4gIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICB2YWwgPSBidWZbb2Zmc2V0XVxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXSA8PCA4XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gYnVmW29mZnNldF0gPDwgOFxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiByZWFkVUludDMyIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbFxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgaWYgKG9mZnNldCArIDIgPCBsZW4pXG4gICAgICB2YWwgPSBidWZbb2Zmc2V0ICsgMl0gPDwgMTZcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV0gPDwgOFxuICAgIHZhbCB8PSBidWZbb2Zmc2V0XVxuICAgIGlmIChvZmZzZXQgKyAzIDwgbGVuKVxuICAgICAgdmFsID0gdmFsICsgKGJ1ZltvZmZzZXQgKyAzXSA8PCAyNCA+Pj4gMClcbiAgfSBlbHNlIHtcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCA9IGJ1ZltvZmZzZXQgKyAxXSA8PCAxNlxuICAgIGlmIChvZmZzZXQgKyAyIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAyXSA8PCA4XG4gICAgaWYgKG9mZnNldCArIDMgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDNdXG4gICAgdmFsID0gdmFsICsgKGJ1ZltvZmZzZXRdIDw8IDI0ID4+PiAwKVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICB2YXIgbmVnID0gdGhpc1tvZmZzZXRdICYgMHg4MFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gcmVhZEludDE2IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbCA9IHJlYWRVSW50MTYoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgdHJ1ZSlcbiAgdmFyIG5lZyA9IHZhbCAmIDB4ODAwMFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZmZmIC0gdmFsICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gcmVhZEludDMyIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbCA9IHJlYWRVSW50MzIoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgdHJ1ZSlcbiAgdmFyIG5lZyA9IHZhbCAmIDB4ODAwMDAwMDBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmZmZmZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiByZWFkRmxvYXQgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRmxvYXQodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRmxvYXQodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHJlYWREb3VibGUgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZilcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVyblxuXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIHdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZilcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4obGVuIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAgICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmZmZmZilcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4obGVuIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZiwgLTB4ODApXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIHRoaXMud3JpdGVVSW50OCh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydClcbiAgZWxzZVxuICAgIHRoaXMud3JpdGVVSW50OCgweGZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIG5vQXNzZXJ0KVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiB3cml0ZUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZiwgLTB4ODAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIHdyaXRlVUludDE2KGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIHdyaXRlVUludDE2KGJ1ZiwgMHhmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICB3cml0ZVVJbnQzMihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICB3cml0ZVVJbnQzMihidWYsIDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyA3IDwgYnVmLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGFzc2VydChlbmQgPj0gc3RhcnQsICdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBhc3NlcnQoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHRoaXMubGVuZ3RoLCAnc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChlbmQgPj0gMCAmJiBlbmQgPD0gdGhpcy5sZW5ndGgsICdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gdXRmOFRvQnl0ZXModmFsdWUudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3V0ID0gW11cbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSB0b0hleCh0aGlzW2ldKVxuICAgIGlmIChpID09PSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTKSB7XG4gICAgICBvdXRbaSArIDFdID0gJy4uLidcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+J1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKHRoaXMpKS5idWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBidWZbaV0gPSB0aGlzW2ldXG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmLmJ1ZmZlclxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IGdldC9zZXQgbWV0aG9kcyBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9nZXQgPSBhcnIuZ2V0XG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmVxdWFscyA9IEJQLmVxdWFsc1xuICBhcnIuY29tcGFyZSA9IEJQLmNvbXBhcmVcbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLXpdL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiBpc0FycmF5IChzdWJqZWN0KSB7XG4gIHJldHVybiAoQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoc3ViamVjdCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ViamVjdCkgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgfSkoc3ViamVjdClcbn1cblxuZnVuY3Rpb24gaXNBcnJheWlzaCAoc3ViamVjdCkge1xuICByZXR1cm4gaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYiA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGIgPD0gMHg3Rikge1xuICAgICAgYnl0ZUFycmF5LnB1c2goYilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gaVxuICAgICAgaWYgKGIgPj0gMHhEODAwICYmIGIgPD0gMHhERkZGKSBpKytcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5zbGljZShzdGFydCwgaSsxKSkuc3Vic3RyKDEpLnNwbGl0KCclJylcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKykge1xuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KHN0cilcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpXG4gICAgICBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyIChzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKSAvLyBVVEYgOCBpbnZhbGlkIGNoYXJcbiAgfVxufVxuXG4vKlxuICogV2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgYSB2YWxpZCBpbnRlZ2VyLiBUaGlzIG1lYW5zIHRoYXQgaXRcbiAqIGlzIG5vbi1uZWdhdGl2ZS4gSXQgaGFzIG5vIGZyYWN0aW9uYWwgY29tcG9uZW50IGFuZCB0aGF0IGl0IGRvZXMgbm90XG4gKiBleGNlZWQgdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ1aW50ICh2YWx1ZSwgbWF4KSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA+PSAwLCAnc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSB2YWx1ZSBmb3IgdHlwZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmc2ludCAodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmSUVFRTc1NCAodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAodGVzdCwgbWVzc2FnZSkge1xuICBpZiAoIXRlc3QpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdGYWlsZWQgYXNzZXJ0aW9uJylcbn1cbiIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIG5CaXRzID0gLTcsXG4gICAgICBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNMRSA/IC0xIDogMSxcbiAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG59O1xuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGMsXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApLFxuICAgICAgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzTEUgPyAxIDogLTEsXG4gICAgICBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcblxuICBlID0gKGUgPDwgbUxlbikgfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCk7XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvaGVhcCcpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjYuM1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgSGVhcCwgZGVmYXVsdENtcCwgZmxvb3IsIGhlYXBpZnksIGhlYXBwb3AsIGhlYXBwdXNoLCBoZWFwcHVzaHBvcCwgaGVhcHJlcGxhY2UsIGluc29ydCwgbWluLCBubGFyZ2VzdCwgbnNtYWxsZXN0LCB1cGRhdGVJdGVtLCBfc2lmdGRvd24sIF9zaWZ0dXA7XG5cbiAgZmxvb3IgPSBNYXRoLmZsb29yLCBtaW4gPSBNYXRoLm1pbjtcblxuICAvKiBcbiAgRGVmYXVsdCBjb21wYXJpc29uIGZ1bmN0aW9uIHRvIGJlIHVzZWRcbiAgKi9cblxuXG4gIGRlZmF1bHRDbXAgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgaWYgKHggPCB5KSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmICh4ID4geSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xuXG4gIC8qIFxuICBJbnNlcnQgaXRlbSB4IGluIGxpc3QgYSwgYW5kIGtlZXAgaXQgc29ydGVkIGFzc3VtaW5nIGEgaXMgc29ydGVkLlxuICBcbiAgSWYgeCBpcyBhbHJlYWR5IGluIGEsIGluc2VydCBpdCB0byB0aGUgcmlnaHQgb2YgdGhlIHJpZ2h0bW9zdCB4LlxuICBcbiAgT3B0aW9uYWwgYXJncyBsbyAoZGVmYXVsdCAwKSBhbmQgaGkgKGRlZmF1bHQgYS5sZW5ndGgpIGJvdW5kIHRoZSBzbGljZVxuICBvZiBhIHRvIGJlIHNlYXJjaGVkLlxuICAqL1xuXG5cbiAgaW5zb3J0ID0gZnVuY3Rpb24oYSwgeCwgbG8sIGhpLCBjbXApIHtcbiAgICB2YXIgbWlkO1xuICAgIGlmIChsbyA9PSBudWxsKSB7XG4gICAgICBsbyA9IDA7XG4gICAgfVxuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgaWYgKGxvIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsbyBtdXN0IGJlIG5vbi1uZWdhdGl2ZScpO1xuICAgIH1cbiAgICBpZiAoaGkgPT0gbnVsbCkge1xuICAgICAgaGkgPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgIG1pZCA9IGZsb29yKChsbyArIGhpKSAvIDIpO1xuICAgICAgaWYgKGNtcCh4LCBhW21pZF0pIDwgMCkge1xuICAgICAgICBoaSA9IG1pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvID0gbWlkICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChbXS5zcGxpY2UuYXBwbHkoYSwgW2xvLCBsbyAtIGxvXS5jb25jYXQoeCkpLCB4KTtcbiAgfTtcblxuICAvKlxuICBQdXNoIGl0ZW0gb250byBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXG4gICovXG5cblxuICBoZWFwcHVzaCA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGFycmF5LnB1c2goaXRlbSk7XG4gICAgcmV0dXJuIF9zaWZ0ZG93bihhcnJheSwgMCwgYXJyYXkubGVuZ3RoIC0gMSwgY21wKTtcbiAgfTtcblxuICAvKlxuICBQb3AgdGhlIHNtYWxsZXN0IGl0ZW0gb2ZmIHRoZSBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXG4gICovXG5cblxuICBoZWFwcG9wID0gZnVuY3Rpb24oYXJyYXksIGNtcCkge1xuICAgIHZhciBsYXN0ZWx0LCByZXR1cm5pdGVtO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgbGFzdGVsdCA9IGFycmF5LnBvcCgpO1xuICAgIGlmIChhcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybml0ZW0gPSBhcnJheVswXTtcbiAgICAgIGFycmF5WzBdID0gbGFzdGVsdDtcbiAgICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybml0ZW0gPSBsYXN0ZWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuaXRlbTtcbiAgfTtcblxuICAvKlxuICBQb3AgYW5kIHJldHVybiB0aGUgY3VycmVudCBzbWFsbGVzdCB2YWx1ZSwgYW5kIGFkZCB0aGUgbmV3IGl0ZW0uXG4gIFxuICBUaGlzIGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gaGVhcHBvcCgpIGZvbGxvd2VkIGJ5IGhlYXBwdXNoKCksIGFuZCBjYW4gYmUgXG4gIG1vcmUgYXBwcm9wcmlhdGUgd2hlbiB1c2luZyBhIGZpeGVkIHNpemUgaGVhcC4gTm90ZSB0aGF0IHRoZSB2YWx1ZVxuICByZXR1cm5lZCBtYXkgYmUgbGFyZ2VyIHRoYW4gaXRlbSEgVGhhdCBjb25zdHJhaW5zIHJlYXNvbmFibGUgdXNlIG9mXG4gIHRoaXMgcm91dGluZSB1bmxlc3Mgd3JpdHRlbiBhcyBwYXJ0IG9mIGEgY29uZGl0aW9uYWwgcmVwbGFjZW1lbnQ6XG4gICAgICBpZiBpdGVtID4gYXJyYXlbMF1cbiAgICAgICAgaXRlbSA9IGhlYXByZXBsYWNlKGFycmF5LCBpdGVtKVxuICAqL1xuXG5cbiAgaGVhcHJlcGxhY2UgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgdmFyIHJldHVybml0ZW07XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICByZXR1cm5pdGVtID0gYXJyYXlbMF07XG4gICAgYXJyYXlbMF0gPSBpdGVtO1xuICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgcmV0dXJuIHJldHVybml0ZW07XG4gIH07XG5cbiAgLypcbiAgRmFzdCB2ZXJzaW9uIG9mIGEgaGVhcHB1c2ggZm9sbG93ZWQgYnkgYSBoZWFwcG9wLlxuICAqL1xuXG5cbiAgaGVhcHB1c2hwb3AgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgdmFyIF9yZWY7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBpZiAoYXJyYXkubGVuZ3RoICYmIGNtcChhcnJheVswXSwgaXRlbSkgPCAwKSB7XG4gICAgICBfcmVmID0gW2FycmF5WzBdLCBpdGVtXSwgaXRlbSA9IF9yZWZbMF0sIGFycmF5WzBdID0gX3JlZlsxXTtcbiAgICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9O1xuXG4gIC8qXG4gIFRyYW5zZm9ybSBsaXN0IGludG8gYSBoZWFwLCBpbi1wbGFjZSwgaW4gTyhhcnJheS5sZW5ndGgpIHRpbWUuXG4gICovXG5cblxuICBoZWFwaWZ5ID0gZnVuY3Rpb24oYXJyYXksIGNtcCkge1xuICAgIHZhciBpLCBfaSwgX2osIF9sZW4sIF9yZWYsIF9yZWYxLCBfcmVzdWx0cywgX3Jlc3VsdHMxO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgX3JlZjEgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBfcmVzdWx0czEgPSBbXTtcbiAgICAgIGZvciAodmFyIF9qID0gMCwgX3JlZiA9IGZsb29yKGFycmF5Lmxlbmd0aCAvIDIpOyAwIDw9IF9yZWYgPyBfaiA8IF9yZWYgOiBfaiA+IF9yZWY7IDAgPD0gX3JlZiA/IF9qKysgOiBfai0tKXsgX3Jlc3VsdHMxLnB1c2goX2opOyB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHMxO1xuICAgIH0pLmFwcGx5KHRoaXMpLnJldmVyc2UoKTtcbiAgICBfcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGkgPSBfcmVmMVtfaV07XG4gICAgICBfcmVzdWx0cy5wdXNoKF9zaWZ0dXAoYXJyYXksIGksIGNtcCkpO1xuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH07XG5cbiAgLypcbiAgVXBkYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZ2l2ZW4gaXRlbSBpbiB0aGUgaGVhcC5cbiAgVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIGl0ZW0gaXMgYmVpbmcgbW9kaWZpZWQuXG4gICovXG5cblxuICB1cGRhdGVJdGVtID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIHZhciBwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBwb3MgPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF9zaWZ0ZG93bihhcnJheSwgMCwgcG9zLCBjbXApO1xuICAgIHJldHVybiBfc2lmdHVwKGFycmF5LCBwb3MsIGNtcCk7XG4gIH07XG5cbiAgLypcbiAgRmluZCB0aGUgbiBsYXJnZXN0IGVsZW1lbnRzIGluIGEgZGF0YXNldC5cbiAgKi9cblxuXG4gIG5sYXJnZXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGNtcCkge1xuICAgIHZhciBlbGVtLCByZXN1bHQsIF9pLCBfbGVuLCBfcmVmO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgcmVzdWx0ID0gYXJyYXkuc2xpY2UoMCwgbik7XG4gICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBoZWFwaWZ5KHJlc3VsdCwgY21wKTtcbiAgICBfcmVmID0gYXJyYXkuc2xpY2Uobik7XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBlbGVtID0gX3JlZltfaV07XG4gICAgICBoZWFwcHVzaHBvcChyZXN1bHQsIGVsZW0sIGNtcCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuc29ydChjbXApLnJldmVyc2UoKTtcbiAgfTtcblxuICAvKlxuICBGaW5kIHRoZSBuIHNtYWxsZXN0IGVsZW1lbnRzIGluIGEgZGF0YXNldC5cbiAgKi9cblxuXG4gIG5zbWFsbGVzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBjbXApIHtcbiAgICB2YXIgZWxlbSwgaSwgbG9zLCByZXN1bHQsIF9pLCBfaiwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgaWYgKG4gKiAxMCA8PSBhcnJheS5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdCA9IGFycmF5LnNsaWNlKDAsIG4pLnNvcnQoY21wKTtcbiAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgbG9zID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgIF9yZWYgPSBhcnJheS5zbGljZShuKTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBlbGVtID0gX3JlZltfaV07XG4gICAgICAgIGlmIChjbXAoZWxlbSwgbG9zKSA8IDApIHtcbiAgICAgICAgICBpbnNvcnQocmVzdWx0LCBlbGVtLCAwLCBudWxsLCBjbXApO1xuICAgICAgICAgIHJlc3VsdC5wb3AoKTtcbiAgICAgICAgICBsb3MgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBoZWFwaWZ5KGFycmF5LCBjbXApO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChpID0gX2ogPSAwLCBfcmVmMSA9IG1pbihuLCBhcnJheS5sZW5ndGgpOyAwIDw9IF9yZWYxID8gX2ogPCBfcmVmMSA6IF9qID4gX3JlZjE7IGkgPSAwIDw9IF9yZWYxID8gKytfaiA6IC0tX2opIHtcbiAgICAgIF9yZXN1bHRzLnB1c2goaGVhcHBvcChhcnJheSwgY21wKSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuICBfc2lmdGRvd24gPSBmdW5jdGlvbihhcnJheSwgc3RhcnRwb3MsIHBvcywgY21wKSB7XG4gICAgdmFyIG5ld2l0ZW0sIHBhcmVudCwgcGFyZW50cG9zO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgbmV3aXRlbSA9IGFycmF5W3Bvc107XG4gICAgd2hpbGUgKHBvcyA+IHN0YXJ0cG9zKSB7XG4gICAgICBwYXJlbnRwb3MgPSAocG9zIC0gMSkgPj4gMTtcbiAgICAgIHBhcmVudCA9IGFycmF5W3BhcmVudHBvc107XG4gICAgICBpZiAoY21wKG5ld2l0ZW0sIHBhcmVudCkgPCAwKSB7XG4gICAgICAgIGFycmF5W3Bvc10gPSBwYXJlbnQ7XG4gICAgICAgIHBvcyA9IHBhcmVudHBvcztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5W3Bvc10gPSBuZXdpdGVtO1xuICB9O1xuXG4gIF9zaWZ0dXAgPSBmdW5jdGlvbihhcnJheSwgcG9zLCBjbXApIHtcbiAgICB2YXIgY2hpbGRwb3MsIGVuZHBvcywgbmV3aXRlbSwgcmlnaHRwb3MsIHN0YXJ0cG9zO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgZW5kcG9zID0gYXJyYXkubGVuZ3RoO1xuICAgIHN0YXJ0cG9zID0gcG9zO1xuICAgIG5ld2l0ZW0gPSBhcnJheVtwb3NdO1xuICAgIGNoaWxkcG9zID0gMiAqIHBvcyArIDE7XG4gICAgd2hpbGUgKGNoaWxkcG9zIDwgZW5kcG9zKSB7XG4gICAgICByaWdodHBvcyA9IGNoaWxkcG9zICsgMTtcbiAgICAgIGlmIChyaWdodHBvcyA8IGVuZHBvcyAmJiAhKGNtcChhcnJheVtjaGlsZHBvc10sIGFycmF5W3JpZ2h0cG9zXSkgPCAwKSkge1xuICAgICAgICBjaGlsZHBvcyA9IHJpZ2h0cG9zO1xuICAgICAgfVxuICAgICAgYXJyYXlbcG9zXSA9IGFycmF5W2NoaWxkcG9zXTtcbiAgICAgIHBvcyA9IGNoaWxkcG9zO1xuICAgICAgY2hpbGRwb3MgPSAyICogcG9zICsgMTtcbiAgICB9XG4gICAgYXJyYXlbcG9zXSA9IG5ld2l0ZW07XG4gICAgcmV0dXJuIF9zaWZ0ZG93bihhcnJheSwgc3RhcnRwb3MsIHBvcywgY21wKTtcbiAgfTtcblxuICBIZWFwID0gKGZ1bmN0aW9uKCkge1xuICAgIEhlYXAucHVzaCA9IGhlYXBwdXNoO1xuXG4gICAgSGVhcC5wb3AgPSBoZWFwcG9wO1xuXG4gICAgSGVhcC5yZXBsYWNlID0gaGVhcHJlcGxhY2U7XG5cbiAgICBIZWFwLnB1c2hwb3AgPSBoZWFwcHVzaHBvcDtcblxuICAgIEhlYXAuaGVhcGlmeSA9IGhlYXBpZnk7XG5cbiAgICBIZWFwLm5sYXJnZXN0ID0gbmxhcmdlc3Q7XG5cbiAgICBIZWFwLm5zbWFsbGVzdCA9IG5zbWFsbGVzdDtcblxuICAgIGZ1bmN0aW9uIEhlYXAoY21wKSB7XG4gICAgICB0aGlzLmNtcCA9IGNtcCAhPSBudWxsID8gY21wIDogZGVmYXVsdENtcDtcbiAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICB9XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGhlYXBwdXNoKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaGVhcHBvcCh0aGlzLm5vZGVzLCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzWzBdO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmluZGV4T2YoeCkgIT09IC0xO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGhlYXByZXBsYWNlKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucHVzaHBvcCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBoZWFwcHVzaHBvcCh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmhlYXBpZnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBoZWFwaWZ5KHRoaXMubm9kZXMsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUudXBkYXRlSXRlbSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB1cGRhdGVJdGVtKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzID0gW107XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGggPT09IDA7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBoZWFwO1xuICAgICAgaGVhcCA9IG5ldyBIZWFwKCk7XG4gICAgICBoZWFwLm5vZGVzID0gdGhpcy5ub2Rlcy5zbGljZSgwKTtcbiAgICAgIHJldHVybiBoZWFwO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5zbGljZSgwKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuaW5zZXJ0ID0gSGVhcC5wcm90b3R5cGUucHVzaDtcblxuICAgIEhlYXAucHJvdG90eXBlLnRvcCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XG5cbiAgICBIZWFwLnByb3RvdHlwZS5mcm9udCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XG5cbiAgICBIZWFwLnByb3RvdHlwZS5oYXMgPSBIZWFwLnByb3RvdHlwZS5jb250YWlucztcblxuICAgIEhlYXAucHJvdG90eXBlLmNvcHkgPSBIZWFwLnByb3RvdHlwZS5jbG9uZTtcblxuICAgIHJldHVybiBIZWFwO1xuXG4gIH0pKCk7XG5cbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlICE9PSBudWxsID8gbW9kdWxlLmV4cG9ydHMgOiB2b2lkIDApIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEhlYXA7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LkhlYXAgPSBIZWFwO1xuICB9XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG51bWVyaWMgPSAodHlwZW9mIGV4cG9ydHMgPT09IFwidW5kZWZpbmVkXCIpPyhmdW5jdGlvbiBudW1lcmljKCkge30pOihleHBvcnRzKTtcbmlmKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHsgZ2xvYmFsLm51bWVyaWMgPSBudW1lcmljOyB9XG5cbm51bWVyaWMudmVyc2lvbiA9IFwiMS4yLjZcIjtcblxuLy8gMS4gVXRpbGl0eSBmdW5jdGlvbnNcbm51bWVyaWMuYmVuY2ggPSBmdW5jdGlvbiBiZW5jaCAoZixpbnRlcnZhbCkge1xuICAgIHZhciB0MSx0MixuLGk7XG4gICAgaWYodHlwZW9mIGludGVydmFsID09PSBcInVuZGVmaW5lZFwiKSB7IGludGVydmFsID0gMTU7IH1cbiAgICBuID0gMC41O1xuICAgIHQxID0gbmV3IERhdGUoKTtcbiAgICB3aGlsZSgxKSB7XG4gICAgICAgIG4qPTI7XG4gICAgICAgIGZvcihpPW47aT4zO2ktPTQpIHsgZigpOyBmKCk7IGYoKTsgZigpOyB9XG4gICAgICAgIHdoaWxlKGk+MCkgeyBmKCk7IGktLTsgfVxuICAgICAgICB0MiA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGlmKHQyLXQxID4gaW50ZXJ2YWwpIGJyZWFrO1xuICAgIH1cbiAgICBmb3IoaT1uO2k+MztpLT00KSB7IGYoKTsgZigpOyBmKCk7IGYoKTsgfVxuICAgIHdoaWxlKGk+MCkgeyBmKCk7IGktLTsgfVxuICAgIHQyID0gbmV3IERhdGUoKTtcbiAgICByZXR1cm4gMTAwMCooMypuLTEpLyh0Mi10MSk7XG59XG5cbm51bWVyaWMuX215SW5kZXhPZiA9IChmdW5jdGlvbiBfbXlJbmRleE9mKHcpIHtcbiAgICB2YXIgbiA9IHRoaXMubGVuZ3RoLGs7XG4gICAgZm9yKGs9MDtrPG47KytrKSBpZih0aGlzW2tdPT09dykgcmV0dXJuIGs7XG4gICAgcmV0dXJuIC0xO1xufSk7XG5udW1lcmljLm15SW5kZXhPZiA9IChBcnJheS5wcm90b3R5cGUuaW5kZXhPZik/QXJyYXkucHJvdG90eXBlLmluZGV4T2Y6bnVtZXJpYy5fbXlJbmRleE9mO1xuXG5udW1lcmljLkZ1bmN0aW9uID0gRnVuY3Rpb247XG5udW1lcmljLnByZWNpc2lvbiA9IDQ7XG5udW1lcmljLmxhcmdlQXJyYXkgPSA1MDtcblxubnVtZXJpYy5wcmV0dHlQcmludCA9IGZ1bmN0aW9uIHByZXR0eVByaW50KHgpIHtcbiAgICBmdW5jdGlvbiBmbXRudW0oeCkge1xuICAgICAgICBpZih4ID09PSAwKSB7IHJldHVybiAnMCc7IH1cbiAgICAgICAgaWYoaXNOYU4oeCkpIHsgcmV0dXJuICdOYU4nOyB9XG4gICAgICAgIGlmKHg8MCkgeyByZXR1cm4gJy0nK2ZtdG51bSgteCk7IH1cbiAgICAgICAgaWYoaXNGaW5pdGUoeCkpIHtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IE1hdGguZmxvb3IoTWF0aC5sb2coeCkgLyBNYXRoLmxvZygxMCkpO1xuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSB4IC8gTWF0aC5wb3coMTAsc2NhbGUpO1xuICAgICAgICAgICAgdmFyIGJhc2ljID0gbm9ybWFsaXplZC50b1ByZWNpc2lvbihudW1lcmljLnByZWNpc2lvbik7XG4gICAgICAgICAgICBpZihwYXJzZUZsb2F0KGJhc2ljKSA9PT0gMTApIHsgc2NhbGUrKzsgbm9ybWFsaXplZCA9IDE7IGJhc2ljID0gbm9ybWFsaXplZC50b1ByZWNpc2lvbihudW1lcmljLnByZWNpc2lvbik7IH1cbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGJhc2ljKS50b1N0cmluZygpKydlJytzY2FsZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnSW5maW5pdHknO1xuICAgIH1cbiAgICB2YXIgcmV0ID0gW107XG4gICAgZnVuY3Rpb24gZm9vKHgpIHtcbiAgICAgICAgdmFyIGs7XG4gICAgICAgIGlmKHR5cGVvZiB4ID09PSBcInVuZGVmaW5lZFwiKSB7IHJldC5wdXNoKEFycmF5KG51bWVyaWMucHJlY2lzaW9uKzgpLmpvaW4oJyAnKSk7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICBpZih0eXBlb2YgeCA9PT0gXCJzdHJpbmdcIikgeyByZXQucHVzaCgnXCInK3grJ1wiJyk7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICBpZih0eXBlb2YgeCA9PT0gXCJib29sZWFuXCIpIHsgcmV0LnB1c2goeC50b1N0cmluZygpKTsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIGlmKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGZtdG51bSh4KTtcbiAgICAgICAgICAgIHZhciBiID0geC50b1ByZWNpc2lvbihudW1lcmljLnByZWNpc2lvbik7XG4gICAgICAgICAgICB2YXIgYyA9IHBhcnNlRmxvYXQoeC50b1N0cmluZygpKS50b1N0cmluZygpO1xuICAgICAgICAgICAgdmFyIGQgPSBbYSxiLGMscGFyc2VGbG9hdChiKS50b1N0cmluZygpLHBhcnNlRmxvYXQoYykudG9TdHJpbmcoKV07XG4gICAgICAgICAgICBmb3Ioaz0xO2s8ZC5sZW5ndGg7aysrKSB7IGlmKGRba10ubGVuZ3RoIDwgYS5sZW5ndGgpIGEgPSBkW2tdOyB9XG4gICAgICAgICAgICByZXQucHVzaChBcnJheShudW1lcmljLnByZWNpc2lvbis4LWEubGVuZ3RoKS5qb2luKCcgJykrYSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCA9PT0gbnVsbCkgeyByZXQucHVzaChcIm51bGxcIik7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICBpZih0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiKSB7IFxuICAgICAgICAgICAgcmV0LnB1c2goeC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHZhciBmbGFnID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IoayBpbiB4KSB7IGlmKHguaGFzT3duUHJvcGVydHkoaykpIHsgXG4gICAgICAgICAgICAgICAgaWYoZmxhZykgcmV0LnB1c2goJyxcXG4nKTtcbiAgICAgICAgICAgICAgICBlbHNlIHJldC5wdXNoKCdcXG57Jyk7XG4gICAgICAgICAgICAgICAgZmxhZyA9IHRydWU7IFxuICAgICAgICAgICAgICAgIHJldC5wdXNoKGspOyBcbiAgICAgICAgICAgICAgICByZXQucHVzaCgnOiBcXG4nKTsgXG4gICAgICAgICAgICAgICAgZm9vKHhba10pOyBcbiAgICAgICAgICAgIH0gfVxuICAgICAgICAgICAgaWYoZmxhZykgcmV0LnB1c2goJ31cXG4nKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKHggaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgaWYoeC5sZW5ndGggPiBudW1lcmljLmxhcmdlQXJyYXkpIHsgcmV0LnB1c2goJy4uLkxhcmdlIEFycmF5Li4uJyk7IHJldHVybiB0cnVlOyB9XG4gICAgICAgICAgICB2YXIgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0LnB1c2goJ1snKTtcbiAgICAgICAgICAgIGZvcihrPTA7azx4Lmxlbmd0aDtrKyspIHsgaWYoaz4wKSB7IHJldC5wdXNoKCcsJyk7IGlmKGZsYWcpIHJldC5wdXNoKCdcXG4gJyk7IH0gZmxhZyA9IGZvbyh4W2tdKTsgfVxuICAgICAgICAgICAgcmV0LnB1c2goJ10nKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldC5wdXNoKCd7Jyk7XG4gICAgICAgIHZhciBmbGFnID0gZmFsc2U7XG4gICAgICAgIGZvcihrIGluIHgpIHsgaWYoeC5oYXNPd25Qcm9wZXJ0eShrKSkgeyBpZihmbGFnKSByZXQucHVzaCgnLFxcbicpOyBmbGFnID0gdHJ1ZTsgcmV0LnB1c2goayk7IHJldC5wdXNoKCc6IFxcbicpOyBmb28oeFtrXSk7IH0gfVxuICAgICAgICByZXQucHVzaCgnfScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9vKHgpO1xuICAgIHJldHVybiByZXQuam9pbignJyk7XG59XG5cbm51bWVyaWMucGFyc2VEYXRlID0gZnVuY3Rpb24gcGFyc2VEYXRlKGQpIHtcbiAgICBmdW5jdGlvbiBmb28oZCkge1xuICAgICAgICBpZih0eXBlb2YgZCA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIERhdGUucGFyc2UoZC5yZXBsYWNlKC8tL2csJy8nKSk7IH1cbiAgICAgICAgaWYoIShkIGluc3RhbmNlb2YgQXJyYXkpKSB7IHRocm93IG5ldyBFcnJvcihcInBhcnNlRGF0ZTogcGFyYW1ldGVyIG11c3QgYmUgYXJyYXlzIG9mIHN0cmluZ3NcIik7IH1cbiAgICAgICAgdmFyIHJldCA9IFtdLGs7XG4gICAgICAgIGZvcihrPTA7azxkLmxlbmd0aDtrKyspIHsgcmV0W2tdID0gZm9vKGRba10pOyB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHJldHVybiBmb28oZCk7XG59XG5cbm51bWVyaWMucGFyc2VGbG9hdCA9IGZ1bmN0aW9uIHBhcnNlRmxvYXRfKGQpIHtcbiAgICBmdW5jdGlvbiBmb28oZCkge1xuICAgICAgICBpZih0eXBlb2YgZCA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIHBhcnNlRmxvYXQoZCk7IH1cbiAgICAgICAgaWYoIShkIGluc3RhbmNlb2YgQXJyYXkpKSB7IHRocm93IG5ldyBFcnJvcihcInBhcnNlRmxvYXQ6IHBhcmFtZXRlciBtdXN0IGJlIGFycmF5cyBvZiBzdHJpbmdzXCIpOyB9XG4gICAgICAgIHZhciByZXQgPSBbXSxrO1xuICAgICAgICBmb3Ioaz0wO2s8ZC5sZW5ndGg7aysrKSB7IHJldFtrXSA9IGZvbyhkW2tdKTsgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICByZXR1cm4gZm9vKGQpO1xufVxuXG5udW1lcmljLnBhcnNlQ1NWID0gZnVuY3Rpb24gcGFyc2VDU1YodCkge1xuICAgIHZhciBmb28gPSB0LnNwbGl0KCdcXG4nKTtcbiAgICB2YXIgaixrO1xuICAgIHZhciByZXQgPSBbXTtcbiAgICB2YXIgcGF0ID0gLygoW14nXCIsXSopfCgnW14nXSonKXwoXCJbXlwiXSpcIikpLC9nO1xuICAgIHZhciBwYXRudW0gPSAvXlxccyooKFsrLV0/WzAtOV0rKFxcLlswLTldKik/KGVbKy1dP1swLTldKyk/KXwoWystXT9bMC05XSooXFwuWzAtOV0rKT8oZVsrLV0/WzAtOV0rKT8pKVxccyokLztcbiAgICB2YXIgc3RyaXBwZXIgPSBmdW5jdGlvbihuKSB7IHJldHVybiBuLnN1YnN0cigwLG4ubGVuZ3RoLTEpOyB9XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICBmb3Ioaz0wO2s8Zm9vLmxlbmd0aDtrKyspIHtcbiAgICAgIHZhciBiYXIgPSAoZm9vW2tdK1wiLFwiKS5tYXRjaChwYXQpLGJhejtcbiAgICAgIGlmKGJhci5sZW5ndGg+MCkge1xuICAgICAgICAgIHJldFtjb3VudF0gPSBbXTtcbiAgICAgICAgICBmb3Ioaj0wO2o8YmFyLmxlbmd0aDtqKyspIHtcbiAgICAgICAgICAgICAgYmF6ID0gc3RyaXBwZXIoYmFyW2pdKTtcbiAgICAgICAgICAgICAgaWYocGF0bnVtLnRlc3QoYmF6KSkgeyByZXRbY291bnRdW2pdID0gcGFyc2VGbG9hdChiYXopOyB9XG4gICAgICAgICAgICAgIGVsc2UgcmV0W2NvdW50XVtqXSA9IGJhejtcbiAgICAgICAgICB9XG4gICAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy50b0NTViA9IGZ1bmN0aW9uIHRvQ1NWKEEpIHtcbiAgICB2YXIgcyA9IG51bWVyaWMuZGltKEEpO1xuICAgIHZhciBpLGosbSxuLHJvdyxyZXQ7XG4gICAgbSA9IHNbMF07XG4gICAgbiA9IHNbMV07XG4gICAgcmV0ID0gW107XG4gICAgZm9yKGk9MDtpPG07aSsrKSB7XG4gICAgICAgIHJvdyA9IFtdO1xuICAgICAgICBmb3Ioaj0wO2o8bTtqKyspIHsgcm93W2pdID0gQVtpXVtqXS50b1N0cmluZygpOyB9XG4gICAgICAgIHJldFtpXSA9IHJvdy5qb2luKCcsICcpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0LmpvaW4oJ1xcbicpKydcXG4nO1xufVxuXG5udW1lcmljLmdldFVSTCA9IGZ1bmN0aW9uIGdldFVSTCh1cmwpIHtcbiAgICB2YXIgY2xpZW50ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgY2xpZW50Lm9wZW4oXCJHRVRcIix1cmwsZmFsc2UpO1xuICAgIGNsaWVudC5zZW5kKCk7XG4gICAgcmV0dXJuIGNsaWVudDtcbn1cblxubnVtZXJpYy5pbWFnZVVSTCA9IGZ1bmN0aW9uIGltYWdlVVJMKGltZykge1xuICAgIGZ1bmN0aW9uIGJhc2U2NChBKSB7XG4gICAgICAgIHZhciBuID0gQS5sZW5ndGgsIGkseCx5LHoscCxxLHIscztcbiAgICAgICAgdmFyIGtleSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIjtcbiAgICAgICAgdmFyIHJldCA9IFwiXCI7XG4gICAgICAgIGZvcihpPTA7aTxuO2krPTMpIHtcbiAgICAgICAgICAgIHggPSBBW2ldO1xuICAgICAgICAgICAgeSA9IEFbaSsxXTtcbiAgICAgICAgICAgIHogPSBBW2krMl07XG4gICAgICAgICAgICBwID0geCA+PiAyO1xuICAgICAgICAgICAgcSA9ICgoeCAmIDMpIDw8IDQpICsgKHkgPj4gNCk7XG4gICAgICAgICAgICByID0gKCh5ICYgMTUpIDw8IDIpICsgKHogPj4gNik7XG4gICAgICAgICAgICBzID0geiAmIDYzO1xuICAgICAgICAgICAgaWYoaSsxPj1uKSB7IHIgPSBzID0gNjQ7IH1cbiAgICAgICAgICAgIGVsc2UgaWYoaSsyPj1uKSB7IHMgPSA2NDsgfVxuICAgICAgICAgICAgcmV0ICs9IGtleS5jaGFyQXQocCkgKyBrZXkuY2hhckF0KHEpICsga2V5LmNoYXJBdChyKSArIGtleS5jaGFyQXQocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyYzMyQXJyYXkgKGEsZnJvbSx0bykge1xuICAgICAgICBpZih0eXBlb2YgZnJvbSA9PT0gXCJ1bmRlZmluZWRcIikgeyBmcm9tID0gMDsgfVxuICAgICAgICBpZih0eXBlb2YgdG8gPT09IFwidW5kZWZpbmVkXCIpIHsgdG8gPSBhLmxlbmd0aDsgfVxuICAgICAgICB2YXIgdGFibGUgPSBbMHgwMDAwMDAwMCwgMHg3NzA3MzA5NiwgMHhFRTBFNjEyQywgMHg5OTA5NTFCQSwgMHgwNzZEQzQxOSwgMHg3MDZBRjQ4RiwgMHhFOTYzQTUzNSwgMHg5RTY0OTVBMyxcbiAgICAgICAgICAgICAgICAgICAgIDB4MEVEQjg4MzIsIDB4NzlEQ0I4QTQsIDB4RTBENUU5MUUsIDB4OTdEMkQ5ODgsIDB4MDlCNjRDMkIsIDB4N0VCMTdDQkQsIDB4RTdCODJEMDcsIDB4OTBCRjFEOTEsIFxuICAgICAgICAgICAgICAgICAgICAgMHgxREI3MTA2NCwgMHg2QUIwMjBGMiwgMHhGM0I5NzE0OCwgMHg4NEJFNDFERSwgMHgxQURBRDQ3RCwgMHg2RERERTRFQiwgMHhGNEQ0QjU1MSwgMHg4M0QzODVDNyxcbiAgICAgICAgICAgICAgICAgICAgIDB4MTM2Qzk4NTYsIDB4NjQ2QkE4QzAsIDB4RkQ2MkY5N0EsIDB4OEE2NUM5RUMsIDB4MTQwMTVDNEYsIDB4NjMwNjZDRDksIDB4RkEwRjNENjMsIDB4OEQwODBERjUsIFxuICAgICAgICAgICAgICAgICAgICAgMHgzQjZFMjBDOCwgMHg0QzY5MTA1RSwgMHhENTYwNDFFNCwgMHhBMjY3NzE3MiwgMHgzQzAzRTREMSwgMHg0QjA0RDQ0NywgMHhEMjBEODVGRCwgMHhBNTBBQjU2QiwgXG4gICAgICAgICAgICAgICAgICAgICAweDM1QjVBOEZBLCAweDQyQjI5ODZDLCAweERCQkJDOUQ2LCAweEFDQkNGOTQwLCAweDMyRDg2Q0UzLCAweDQ1REY1Qzc1LCAweERDRDYwRENGLCAweEFCRDEzRDU5LCBcbiAgICAgICAgICAgICAgICAgICAgIDB4MjZEOTMwQUMsIDB4NTFERTAwM0EsIDB4QzhENzUxODAsIDB4QkZEMDYxMTYsIDB4MjFCNEY0QjUsIDB4NTZCM0M0MjMsIDB4Q0ZCQTk1OTksIDB4QjhCREE1MEYsXG4gICAgICAgICAgICAgICAgICAgICAweDI4MDJCODlFLCAweDVGMDU4ODA4LCAweEM2MENEOUIyLCAweEIxMEJFOTI0LCAweDJGNkY3Qzg3LCAweDU4Njg0QzExLCAweEMxNjExREFCLCAweEI2NjYyRDNELFxuICAgICAgICAgICAgICAgICAgICAgMHg3NkRDNDE5MCwgMHgwMURCNzEwNiwgMHg5OEQyMjBCQywgMHhFRkQ1MTAyQSwgMHg3MUIxODU4OSwgMHgwNkI2QjUxRiwgMHg5RkJGRTRBNSwgMHhFOEI4RDQzMyxcbiAgICAgICAgICAgICAgICAgICAgIDB4NzgwN0M5QTIsIDB4MEYwMEY5MzQsIDB4OTYwOUE4OEUsIDB4RTEwRTk4MTgsIDB4N0Y2QTBEQkIsIDB4MDg2RDNEMkQsIDB4OTE2NDZDOTcsIDB4RTY2MzVDMDEsIFxuICAgICAgICAgICAgICAgICAgICAgMHg2QjZCNTFGNCwgMHgxQzZDNjE2MiwgMHg4NTY1MzBEOCwgMHhGMjYyMDA0RSwgMHg2QzA2OTVFRCwgMHgxQjAxQTU3QiwgMHg4MjA4RjRDMSwgMHhGNTBGQzQ1NywgXG4gICAgICAgICAgICAgICAgICAgICAweDY1QjBEOUM2LCAweDEyQjdFOTUwLCAweDhCQkVCOEVBLCAweEZDQjk4ODdDLCAweDYyREQxRERGLCAweDE1REEyRDQ5LCAweDhDRDM3Q0YzLCAweEZCRDQ0QzY1LCBcbiAgICAgICAgICAgICAgICAgICAgIDB4NERCMjYxNTgsIDB4M0FCNTUxQ0UsIDB4QTNCQzAwNzQsIDB4RDRCQjMwRTIsIDB4NEFERkE1NDEsIDB4M0REODk1RDcsIDB4QTREMUM0NkQsIDB4RDNENkY0RkIsIFxuICAgICAgICAgICAgICAgICAgICAgMHg0MzY5RTk2QSwgMHgzNDZFRDlGQywgMHhBRDY3ODg0NiwgMHhEQTYwQjhEMCwgMHg0NDA0MkQ3MywgMHgzMzAzMURFNSwgMHhBQTBBNEM1RiwgMHhERDBEN0NDOSwgXG4gICAgICAgICAgICAgICAgICAgICAweDUwMDU3MTNDLCAweDI3MDI0MUFBLCAweEJFMEIxMDEwLCAweEM5MEMyMDg2LCAweDU3NjhCNTI1LCAweDIwNkY4NUIzLCAweEI5NjZENDA5LCAweENFNjFFNDlGLCBcbiAgICAgICAgICAgICAgICAgICAgIDB4NUVERUY5MEUsIDB4MjlEOUM5OTgsIDB4QjBEMDk4MjIsIDB4QzdEN0E4QjQsIDB4NTlCMzNEMTcsIDB4MkVCNDBEODEsIDB4QjdCRDVDM0IsIDB4QzBCQTZDQUQsIFxuICAgICAgICAgICAgICAgICAgICAgMHhFREI4ODMyMCwgMHg5QUJGQjNCNiwgMHgwM0I2RTIwQywgMHg3NEIxRDI5QSwgMHhFQUQ1NDczOSwgMHg5REQyNzdBRiwgMHgwNERCMjYxNSwgMHg3M0RDMTY4MywgXG4gICAgICAgICAgICAgICAgICAgICAweEUzNjMwQjEyLCAweDk0NjQzQjg0LCAweDBENkQ2QTNFLCAweDdBNkE1QUE4LCAweEU0MEVDRjBCLCAweDkzMDlGRjlELCAweDBBMDBBRTI3LCAweDdEMDc5RUIxLCBcbiAgICAgICAgICAgICAgICAgICAgIDB4RjAwRjkzNDQsIDB4ODcwOEEzRDIsIDB4MUUwMUYyNjgsIDB4NjkwNkMyRkUsIDB4Rjc2MjU3NUQsIDB4ODA2NTY3Q0IsIDB4MTk2QzM2NzEsIDB4NkU2QjA2RTcsIFxuICAgICAgICAgICAgICAgICAgICAgMHhGRUQ0MUI3NiwgMHg4OUQzMkJFMCwgMHgxMERBN0E1QSwgMHg2N0RENEFDQywgMHhGOUI5REY2RiwgMHg4RUJFRUZGOSwgMHgxN0I3QkU0MywgMHg2MEIwOEVENSwgXG4gICAgICAgICAgICAgICAgICAgICAweEQ2RDZBM0U4LCAweEExRDE5MzdFLCAweDM4RDhDMkM0LCAweDRGREZGMjUyLCAweEQxQkI2N0YxLCAweEE2QkM1NzY3LCAweDNGQjUwNkRELCAweDQ4QjIzNjRCLCBcbiAgICAgICAgICAgICAgICAgICAgIDB4RDgwRDJCREEsIDB4QUYwQTFCNEMsIDB4MzYwMzRBRjYsIDB4NDEwNDdBNjAsIDB4REY2MEVGQzMsIDB4QTg2N0RGNTUsIDB4MzE2RThFRUYsIDB4NDY2OUJFNzksIFxuICAgICAgICAgICAgICAgICAgICAgMHhDQjYxQjM4QywgMHhCQzY2ODMxQSwgMHgyNTZGRDJBMCwgMHg1MjY4RTIzNiwgMHhDQzBDNzc5NSwgMHhCQjBCNDcwMywgMHgyMjAyMTZCOSwgMHg1NTA1MjYyRiwgXG4gICAgICAgICAgICAgICAgICAgICAweEM1QkEzQkJFLCAweEIyQkQwQjI4LCAweDJCQjQ1QTkyLCAweDVDQjM2QTA0LCAweEMyRDdGRkE3LCAweEI1RDBDRjMxLCAweDJDRDk5RThCLCAweDVCREVBRTFELCBcbiAgICAgICAgICAgICAgICAgICAgIDB4OUI2NEMyQjAsIDB4RUM2M0YyMjYsIDB4NzU2QUEzOUMsIDB4MDI2RDkzMEEsIDB4OUMwOTA2QTksIDB4RUIwRTM2M0YsIDB4NzIwNzY3ODUsIDB4MDUwMDU3MTMsIFxuICAgICAgICAgICAgICAgICAgICAgMHg5NUJGNEE4MiwgMHhFMkI4N0ExNCwgMHg3QkIxMkJBRSwgMHgwQ0I2MUIzOCwgMHg5MkQyOEU5QiwgMHhFNUQ1QkUwRCwgMHg3Q0RDRUZCNywgMHgwQkRCREYyMSwgXG4gICAgICAgICAgICAgICAgICAgICAweDg2RDNEMkQ0LCAweEYxRDRFMjQyLCAweDY4RERCM0Y4LCAweDFGREE4MzZFLCAweDgxQkUxNkNELCAweEY2QjkyNjVCLCAweDZGQjA3N0UxLCAweDE4Qjc0Nzc3LCBcbiAgICAgICAgICAgICAgICAgICAgIDB4ODgwODVBRTYsIDB4RkYwRjZBNzAsIDB4NjYwNjNCQ0EsIDB4MTEwMTBCNUMsIDB4OEY2NTlFRkYsIDB4Rjg2MkFFNjksIDB4NjE2QkZGRDMsIDB4MTY2Q0NGNDUsIFxuICAgICAgICAgICAgICAgICAgICAgMHhBMDBBRTI3OCwgMHhENzBERDJFRSwgMHg0RTA0ODM1NCwgMHgzOTAzQjNDMiwgMHhBNzY3MjY2MSwgMHhEMDYwMTZGNywgMHg0OTY5NDc0RCwgMHgzRTZFNzdEQiwgXG4gICAgICAgICAgICAgICAgICAgICAweEFFRDE2QTRBLCAweEQ5RDY1QURDLCAweDQwREYwQjY2LCAweDM3RDgzQkYwLCAweEE5QkNBRTUzLCAweERFQkI5RUM1LCAweDQ3QjJDRjdGLCAweDMwQjVGRkU5LCBcbiAgICAgICAgICAgICAgICAgICAgIDB4QkRCREYyMUMsIDB4Q0FCQUMyOEEsIDB4NTNCMzkzMzAsIDB4MjRCNEEzQTYsIDB4QkFEMDM2MDUsIDB4Q0RENzA2OTMsIDB4NTRERTU3MjksIDB4MjNEOTY3QkYsIFxuICAgICAgICAgICAgICAgICAgICAgMHhCMzY2N0EyRSwgMHhDNDYxNEFCOCwgMHg1RDY4MUIwMiwgMHgyQTZGMkI5NCwgMHhCNDBCQkUzNywgMHhDMzBDOEVBMSwgMHg1QTA1REYxQiwgMHgyRDAyRUY4RF07XG4gICAgIFxuICAgICAgICB2YXIgY3JjID0gLTEsIHkgPSAwLCBuID0gYS5sZW5ndGgsaTtcblxuICAgICAgICBmb3IgKGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgeSA9IChjcmMgXiBhW2ldKSAmIDB4RkY7XG4gICAgICAgICAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRhYmxlW3ldO1xuICAgICAgICB9XG4gICAgIFxuICAgICAgICByZXR1cm4gY3JjIF4gKC0xKTtcbiAgICB9XG5cbiAgICB2YXIgaCA9IGltZ1swXS5sZW5ndGgsIHcgPSBpbWdbMF1bMF0ubGVuZ3RoLCBzMSwgczIsIG5leHQsayxsZW5ndGgsYSxiLGksaixhZGxlcjMyLGNyYzMyO1xuICAgIHZhciBzdHJlYW0gPSBbXG4gICAgICAgICAgICAgICAgICAxMzcsIDgwLCA3OCwgNzEsIDEzLCAxMCwgMjYsIDEwLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAwOiBQTkcgc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgICAwLDAsMCwxMywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICA4OiBJSERSIENodW5rIGxlbmd0aFxuICAgICAgICAgICAgICAgICAgNzMsIDcyLCA2OCwgODIsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxMjogXCJJSERSXCIgXG4gICAgICAgICAgICAgICAgICAodyA+PiAyNCkgJiAyNTUsICh3ID4+IDE2KSAmIDI1NSwgKHcgPj4gOCkgJiAyNTUsIHcmMjU1LCAgIC8vIDE2OiBXaWR0aFxuICAgICAgICAgICAgICAgICAgKGggPj4gMjQpICYgMjU1LCAoaCA+PiAxNikgJiAyNTUsIChoID4+IDgpICYgMjU1LCBoJjI1NSwgICAvLyAyMDogSGVpZ2h0XG4gICAgICAgICAgICAgICAgICA4LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDI0OiBiaXQgZGVwdGhcbiAgICAgICAgICAgICAgICAgIDIsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMjU6IFJHQlxuICAgICAgICAgICAgICAgICAgMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyNjogZGVmbGF0ZVxuICAgICAgICAgICAgICAgICAgMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyNzogbm8gZmlsdGVyXG4gICAgICAgICAgICAgICAgICAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDI4OiBubyBpbnRlcmxhY2VcbiAgICAgICAgICAgICAgICAgIC0xLC0yLC0zLC00LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMjk6IENSQ1xuICAgICAgICAgICAgICAgICAgLTUsLTYsLTcsLTgsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAzMzogSURBVCBDaHVuayBsZW5ndGhcbiAgICAgICAgICAgICAgICAgIDczLCA2OCwgNjUsIDg0LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMzc6IFwiSURBVFwiXG4gICAgICAgICAgICAgICAgICAvLyBSRkMgMTk1MCBoZWFkZXIgc3RhcnRzIGhlcmVcbiAgICAgICAgICAgICAgICAgIDgsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gNDE6IFJGQzE5NTAgQ01GXG4gICAgICAgICAgICAgICAgICAyOSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDQyOiBSRkMxOTUwIEZMR1xuICAgICAgICAgICAgICAgICAgXTtcbiAgICBjcmMzMiA9IGNyYzMyQXJyYXkoc3RyZWFtLDEyLDI5KTtcbiAgICBzdHJlYW1bMjldID0gKGNyYzMyPj4yNCkmMjU1O1xuICAgIHN0cmVhbVszMF0gPSAoY3JjMzI+PjE2KSYyNTU7XG4gICAgc3RyZWFtWzMxXSA9IChjcmMzMj4+OCkmMjU1O1xuICAgIHN0cmVhbVszMl0gPSAoY3JjMzIpJjI1NTtcbiAgICBzMSA9IDE7XG4gICAgczIgPSAwO1xuICAgIGZvcihpPTA7aTxoO2krKykge1xuICAgICAgICBpZihpPGgtMSkgeyBzdHJlYW0ucHVzaCgwKTsgfVxuICAgICAgICBlbHNlIHsgc3RyZWFtLnB1c2goMSk7IH1cbiAgICAgICAgYSA9ICgzKncrMSsoaT09PTApKSYyNTU7IGIgPSAoKDMqdysxKyhpPT09MCkpPj44KSYyNTU7XG4gICAgICAgIHN0cmVhbS5wdXNoKGEpOyBzdHJlYW0ucHVzaChiKTtcbiAgICAgICAgc3RyZWFtLnB1c2goKH5hKSYyNTUpOyBzdHJlYW0ucHVzaCgofmIpJjI1NSk7XG4gICAgICAgIGlmKGk9PT0wKSBzdHJlYW0ucHVzaCgwKTtcbiAgICAgICAgZm9yKGo9MDtqPHc7aisrKSB7XG4gICAgICAgICAgICBmb3Ioaz0wO2s8MztrKyspIHtcbiAgICAgICAgICAgICAgICBhID0gaW1nW2tdW2ldW2pdO1xuICAgICAgICAgICAgICAgIGlmKGE+MjU1KSBhID0gMjU1O1xuICAgICAgICAgICAgICAgIGVsc2UgaWYoYTwwKSBhPTA7XG4gICAgICAgICAgICAgICAgZWxzZSBhID0gTWF0aC5yb3VuZChhKTtcbiAgICAgICAgICAgICAgICBzMSA9IChzMSArIGEgKSU2NTUyMTtcbiAgICAgICAgICAgICAgICBzMiA9IChzMiArIHMxKSU2NTUyMTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucHVzaChhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0ucHVzaCgwKTtcbiAgICB9XG4gICAgYWRsZXIzMiA9IChzMjw8MTYpK3MxO1xuICAgIHN0cmVhbS5wdXNoKChhZGxlcjMyPj4yNCkmMjU1KTtcbiAgICBzdHJlYW0ucHVzaCgoYWRsZXIzMj4+MTYpJjI1NSk7XG4gICAgc3RyZWFtLnB1c2goKGFkbGVyMzI+PjgpJjI1NSk7XG4gICAgc3RyZWFtLnB1c2goKGFkbGVyMzIpJjI1NSk7XG4gICAgbGVuZ3RoID0gc3RyZWFtLmxlbmd0aCAtIDQxO1xuICAgIHN0cmVhbVszM10gPSAobGVuZ3RoPj4yNCkmMjU1O1xuICAgIHN0cmVhbVszNF0gPSAobGVuZ3RoPj4xNikmMjU1O1xuICAgIHN0cmVhbVszNV0gPSAobGVuZ3RoPj44KSYyNTU7XG4gICAgc3RyZWFtWzM2XSA9IChsZW5ndGgpJjI1NTtcbiAgICBjcmMzMiA9IGNyYzMyQXJyYXkoc3RyZWFtLDM3KTtcbiAgICBzdHJlYW0ucHVzaCgoY3JjMzI+PjI0KSYyNTUpO1xuICAgIHN0cmVhbS5wdXNoKChjcmMzMj4+MTYpJjI1NSk7XG4gICAgc3RyZWFtLnB1c2goKGNyYzMyPj44KSYyNTUpO1xuICAgIHN0cmVhbS5wdXNoKChjcmMzMikmMjU1KTtcbiAgICBzdHJlYW0ucHVzaCgwKTtcbiAgICBzdHJlYW0ucHVzaCgwKTtcbiAgICBzdHJlYW0ucHVzaCgwKTtcbiAgICBzdHJlYW0ucHVzaCgwKTtcbi8vICAgIGEgPSBzdHJlYW0ubGVuZ3RoO1xuICAgIHN0cmVhbS5wdXNoKDczKTsgIC8vIElcbiAgICBzdHJlYW0ucHVzaCg2OSk7ICAvLyBFXG4gICAgc3RyZWFtLnB1c2goNzgpOyAgLy8gTlxuICAgIHN0cmVhbS5wdXNoKDY4KTsgIC8vIERcbiAgICBzdHJlYW0ucHVzaCgxNzQpOyAvLyBDUkMxXG4gICAgc3RyZWFtLnB1c2goNjYpOyAgLy8gQ1JDMlxuICAgIHN0cmVhbS5wdXNoKDk2KTsgIC8vIENSQzNcbiAgICBzdHJlYW0ucHVzaCgxMzApOyAvLyBDUkM0XG4gICAgcmV0dXJuICdkYXRhOmltYWdlL3BuZztiYXNlNjQsJytiYXNlNjQoc3RyZWFtKTtcbn1cblxuLy8gMi4gTGluZWFyIGFsZ2VicmEgd2l0aCBBcnJheXMuXG5udW1lcmljLl9kaW0gPSBmdW5jdGlvbiBfZGltKHgpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgd2hpbGUodHlwZW9mIHggPT09IFwib2JqZWN0XCIpIHsgcmV0LnB1c2goeC5sZW5ndGgpOyB4ID0geFswXTsgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuZGltID0gZnVuY3Rpb24gZGltKHgpIHtcbiAgICB2YXIgeSx6O1xuICAgIGlmKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHkgPSB4WzBdO1xuICAgICAgICBpZih0eXBlb2YgeSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgeiA9IHlbMF07XG4gICAgICAgICAgICBpZih0eXBlb2YgeiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1lcmljLl9kaW0oeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3gubGVuZ3RoLHkubGVuZ3RoXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3gubGVuZ3RoXTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuXG5udW1lcmljLm1hcHJlZHVjZSA9IGZ1bmN0aW9uIG1hcHJlZHVjZShib2R5LGluaXQpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24oJ3gnLCdhY2N1bScsJ19zJywnX2snLFxuICAgICAgICAgICAgJ2lmKHR5cGVvZiBhY2N1bSA9PT0gXCJ1bmRlZmluZWRcIikgYWNjdW0gPSAnK2luaXQrJztcXG4nK1xuICAgICAgICAgICAgJ2lmKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7IHZhciB4aSA9IHg7ICcrYm9keSsnOyByZXR1cm4gYWNjdW07IH1cXG4nK1xuICAgICAgICAgICAgJ2lmKHR5cGVvZiBfcyA9PT0gXCJ1bmRlZmluZWRcIikgX3MgPSBudW1lcmljLmRpbSh4KTtcXG4nK1xuICAgICAgICAgICAgJ2lmKHR5cGVvZiBfayA9PT0gXCJ1bmRlZmluZWRcIikgX2sgPSAwO1xcbicrXG4gICAgICAgICAgICAndmFyIF9uID0gX3NbX2tdO1xcbicrXG4gICAgICAgICAgICAndmFyIGkseGk7XFxuJytcbiAgICAgICAgICAgICdpZihfayA8IF9zLmxlbmd0aC0xKSB7XFxuJytcbiAgICAgICAgICAgICcgICAgZm9yKGk9X24tMTtpPj0wO2ktLSkge1xcbicrXG4gICAgICAgICAgICAnICAgICAgICBhY2N1bSA9IGFyZ3VtZW50cy5jYWxsZWUoeFtpXSxhY2N1bSxfcyxfaysxKTtcXG4nK1xuICAgICAgICAgICAgJyAgICB9JytcbiAgICAgICAgICAgICcgICAgcmV0dXJuIGFjY3VtO1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICAnZm9yKGk9X24tMTtpPj0xO2ktPTIpIHsgXFxuJytcbiAgICAgICAgICAgICcgICAgeGkgPSB4W2ldO1xcbicrXG4gICAgICAgICAgICAnICAgICcrYm9keSsnO1xcbicrXG4gICAgICAgICAgICAnICAgIHhpID0geFtpLTFdO1xcbicrXG4gICAgICAgICAgICAnICAgICcrYm9keSsnO1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICAnaWYoaSA9PT0gMCkge1xcbicrXG4gICAgICAgICAgICAnICAgIHhpID0geFtpXTtcXG4nK1xuICAgICAgICAgICAgJyAgICAnK2JvZHkrJ1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICAncmV0dXJuIGFjY3VtOydcbiAgICAgICAgICAgICk7XG59XG5udW1lcmljLm1hcHJlZHVjZTIgPSBmdW5jdGlvbiBtYXByZWR1Y2UyKGJvZHksc2V0dXApIHtcbiAgICByZXR1cm4gRnVuY3Rpb24oJ3gnLFxuICAgICAgICAgICAgJ3ZhciBuID0geC5sZW5ndGg7XFxuJytcbiAgICAgICAgICAgICd2YXIgaSx4aTtcXG4nK3NldHVwKyc7XFxuJytcbiAgICAgICAgICAgICdmb3IoaT1uLTE7aSE9PS0xOy0taSkgeyBcXG4nK1xuICAgICAgICAgICAgJyAgICB4aSA9IHhbaV07XFxuJytcbiAgICAgICAgICAgICcgICAgJytib2R5Kyc7XFxuJytcbiAgICAgICAgICAgICd9XFxuJytcbiAgICAgICAgICAgICdyZXR1cm4gYWNjdW07J1xuICAgICAgICAgICAgKTtcbn1cblxuXG5udW1lcmljLnNhbWUgPSBmdW5jdGlvbiBzYW1lKHgseSkge1xuICAgIHZhciBpLG47XG4gICAgaWYoISh4IGluc3RhbmNlb2YgQXJyYXkpIHx8ICEoeSBpbnN0YW5jZW9mIEFycmF5KSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBuID0geC5sZW5ndGg7XG4gICAgaWYobiAhPT0geS5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZm9yKGk9MDtpPG47aSsrKSB7XG4gICAgICAgIGlmKHhbaV0gPT09IHlbaV0pIHsgY29udGludWU7IH1cbiAgICAgICAgaWYodHlwZW9mIHhbaV0gPT09IFwib2JqZWN0XCIpIHsgaWYoIXNhbWUoeFtpXSx5W2ldKSkgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIGVsc2UgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbm51bWVyaWMucmVwID0gZnVuY3Rpb24gcmVwKHMsdixrKSB7XG4gICAgaWYodHlwZW9mIGsgPT09IFwidW5kZWZpbmVkXCIpIHsgaz0wOyB9XG4gICAgdmFyIG4gPSBzW2tdLCByZXQgPSBBcnJheShuKSwgaTtcbiAgICBpZihrID09PSBzLmxlbmd0aC0xKSB7XG4gICAgICAgIGZvcihpPW4tMjtpPj0wO2ktPTIpIHsgcmV0W2krMV0gPSB2OyByZXRbaV0gPSB2OyB9XG4gICAgICAgIGlmKGk9PT0tMSkgeyByZXRbMF0gPSB2OyB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZvcihpPW4tMTtpPj0wO2ktLSkgeyByZXRbaV0gPSBudW1lcmljLnJlcChzLHYsaysxKTsgfVxuICAgIHJldHVybiByZXQ7XG59XG5cblxubnVtZXJpYy5kb3RNTXNtYWxsID0gZnVuY3Rpb24gZG90TU1zbWFsbCh4LHkpIHtcbiAgICB2YXIgaSxqLGsscCxxLHIscmV0LGZvbyxiYXIsd29vLGkwLGswLHAwLHIwO1xuICAgIHAgPSB4Lmxlbmd0aDsgcSA9IHkubGVuZ3RoOyByID0geVswXS5sZW5ndGg7XG4gICAgcmV0ID0gQXJyYXkocCk7XG4gICAgZm9yKGk9cC0xO2k+PTA7aS0tKSB7XG4gICAgICAgIGZvbyA9IEFycmF5KHIpO1xuICAgICAgICBiYXIgPSB4W2ldO1xuICAgICAgICBmb3Ioaz1yLTE7az49MDtrLS0pIHtcbiAgICAgICAgICAgIHdvbyA9IGJhcltxLTFdKnlbcS0xXVtrXTtcbiAgICAgICAgICAgIGZvcihqPXEtMjtqPj0xO2otPTIpIHtcbiAgICAgICAgICAgICAgICBpMCA9IGotMTtcbiAgICAgICAgICAgICAgICB3b28gKz0gYmFyW2pdKnlbal1ba10gKyBiYXJbaTBdKnlbaTBdW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoaj09PTApIHsgd29vICs9IGJhclswXSp5WzBdW2tdOyB9XG4gICAgICAgICAgICBmb29ba10gPSB3b287XG4gICAgICAgIH1cbiAgICAgICAgcmV0W2ldID0gZm9vO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxubnVtZXJpYy5fZ2V0Q29sID0gZnVuY3Rpb24gX2dldENvbChBLGoseCkge1xuICAgIHZhciBuID0gQS5sZW5ndGgsIGk7XG4gICAgZm9yKGk9bi0xO2k+MDstLWkpIHtcbiAgICAgICAgeFtpXSA9IEFbaV1bal07XG4gICAgICAgIC0taTtcbiAgICAgICAgeFtpXSA9IEFbaV1bal07XG4gICAgfVxuICAgIGlmKGk9PT0wKSB4WzBdID0gQVswXVtqXTtcbn1cbm51bWVyaWMuZG90TU1iaWcgPSBmdW5jdGlvbiBkb3RNTWJpZyh4LHkpe1xuICAgIHZhciBnYyA9IG51bWVyaWMuX2dldENvbCwgcCA9IHkubGVuZ3RoLCB2ID0gQXJyYXkocCk7XG4gICAgdmFyIG0gPSB4Lmxlbmd0aCwgbiA9IHlbMF0ubGVuZ3RoLCBBID0gbmV3IEFycmF5KG0pLCB4ajtcbiAgICB2YXIgVlYgPSBudW1lcmljLmRvdFZWO1xuICAgIHZhciBpLGosayx6O1xuICAgIC0tcDtcbiAgICAtLW07XG4gICAgZm9yKGk9bTtpIT09LTE7LS1pKSBBW2ldID0gQXJyYXkobik7XG4gICAgLS1uO1xuICAgIGZvcihpPW47aSE9PS0xOy0taSkge1xuICAgICAgICBnYyh5LGksdik7XG4gICAgICAgIGZvcihqPW07aiE9PS0xOy0taikge1xuICAgICAgICAgICAgej0wO1xuICAgICAgICAgICAgeGogPSB4W2pdO1xuICAgICAgICAgICAgQVtqXVtpXSA9IFZWKHhqLHYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBO1xufVxuXG5udW1lcmljLmRvdE1WID0gZnVuY3Rpb24gZG90TVYoeCx5KSB7XG4gICAgdmFyIHAgPSB4Lmxlbmd0aCwgcSA9IHkubGVuZ3RoLGk7XG4gICAgdmFyIHJldCA9IEFycmF5KHApLCBkb3RWViA9IG51bWVyaWMuZG90VlY7XG4gICAgZm9yKGk9cC0xO2k+PTA7aS0tKSB7IHJldFtpXSA9IGRvdFZWKHhbaV0seSk7IH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLmRvdFZNID0gZnVuY3Rpb24gZG90Vk0oeCx5KSB7XG4gICAgdmFyIGksaixrLHAscSxyLHJldCxmb28sYmFyLHdvbyxpMCxrMCxwMCxyMCxzMSxzMixzMyxiYXosYWNjdW07XG4gICAgcCA9IHgubGVuZ3RoOyBxID0geVswXS5sZW5ndGg7XG4gICAgcmV0ID0gQXJyYXkocSk7XG4gICAgZm9yKGs9cS0xO2s+PTA7ay0tKSB7XG4gICAgICAgIHdvbyA9IHhbcC0xXSp5W3AtMV1ba107XG4gICAgICAgIGZvcihqPXAtMjtqPj0xO2otPTIpIHtcbiAgICAgICAgICAgIGkwID0gai0xO1xuICAgICAgICAgICAgd29vICs9IHhbal0qeVtqXVtrXSArIHhbaTBdKnlbaTBdW2tdO1xuICAgICAgICB9XG4gICAgICAgIGlmKGo9PT0wKSB7IHdvbyArPSB4WzBdKnlbMF1ba107IH1cbiAgICAgICAgcmV0W2tdID0gd29vO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLmRvdFZWID0gZnVuY3Rpb24gZG90VlYoeCx5KSB7XG4gICAgdmFyIGksbj14Lmxlbmd0aCxpMSxyZXQgPSB4W24tMV0qeVtuLTFdO1xuICAgIGZvcihpPW4tMjtpPj0xO2ktPTIpIHtcbiAgICAgICAgaTEgPSBpLTE7XG4gICAgICAgIHJldCArPSB4W2ldKnlbaV0gKyB4W2kxXSp5W2kxXTtcbiAgICB9XG4gICAgaWYoaT09PTApIHsgcmV0ICs9IHhbMF0qeVswXTsgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuZG90ID0gZnVuY3Rpb24gZG90KHgseSkge1xuICAgIHZhciBkID0gbnVtZXJpYy5kaW07XG4gICAgc3dpdGNoKGQoeCkubGVuZ3RoKjEwMDArZCh5KS5sZW5ndGgpIHtcbiAgICBjYXNlIDIwMDI6XG4gICAgICAgIGlmKHkubGVuZ3RoIDwgMTApIHJldHVybiBudW1lcmljLmRvdE1Nc21hbGwoeCx5KTtcbiAgICAgICAgZWxzZSByZXR1cm4gbnVtZXJpYy5kb3RNTWJpZyh4LHkpO1xuICAgIGNhc2UgMjAwMTogcmV0dXJuIG51bWVyaWMuZG90TVYoeCx5KTtcbiAgICBjYXNlIDEwMDI6IHJldHVybiBudW1lcmljLmRvdFZNKHgseSk7XG4gICAgY2FzZSAxMDAxOiByZXR1cm4gbnVtZXJpYy5kb3RWVih4LHkpO1xuICAgIGNhc2UgMTAwMDogcmV0dXJuIG51bWVyaWMubXVsVlMoeCx5KTtcbiAgICBjYXNlIDE6IHJldHVybiBudW1lcmljLm11bFNWKHgseSk7XG4gICAgY2FzZSAwOiByZXR1cm4geCp5O1xuICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignbnVtZXJpYy5kb3Qgb25seSB3b3JrcyBvbiB2ZWN0b3JzIGFuZCBtYXRyaWNlcycpO1xuICAgIH1cbn1cblxubnVtZXJpYy5kaWFnID0gZnVuY3Rpb24gZGlhZyhkKSB7XG4gICAgdmFyIGksaTEsaixuID0gZC5sZW5ndGgsIEEgPSBBcnJheShuKSwgQWk7XG4gICAgZm9yKGk9bi0xO2k+PTA7aS0tKSB7XG4gICAgICAgIEFpID0gQXJyYXkobik7XG4gICAgICAgIGkxID0gaSsyO1xuICAgICAgICBmb3Ioaj1uLTE7aj49aTE7ai09Mikge1xuICAgICAgICAgICAgQWlbal0gPSAwO1xuICAgICAgICAgICAgQWlbai0xXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaj5pKSB7IEFpW2pdID0gMDsgfVxuICAgICAgICBBaVtpXSA9IGRbaV07XG4gICAgICAgIGZvcihqPWktMTtqPj0xO2otPTIpIHtcbiAgICAgICAgICAgIEFpW2pdID0gMDtcbiAgICAgICAgICAgIEFpW2otMV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmKGo9PT0wKSB7IEFpWzBdID0gMDsgfVxuICAgICAgICBBW2ldID0gQWk7XG4gICAgfVxuICAgIHJldHVybiBBO1xufVxubnVtZXJpYy5nZXREaWFnID0gZnVuY3Rpb24oQSkge1xuICAgIHZhciBuID0gTWF0aC5taW4oQS5sZW5ndGgsQVswXS5sZW5ndGgpLGkscmV0ID0gQXJyYXkobik7XG4gICAgZm9yKGk9bi0xO2k+PTE7LS1pKSB7XG4gICAgICAgIHJldFtpXSA9IEFbaV1baV07XG4gICAgICAgIC0taTtcbiAgICAgICAgcmV0W2ldID0gQVtpXVtpXTtcbiAgICB9XG4gICAgaWYoaT09PTApIHtcbiAgICAgICAgcmV0WzBdID0gQVswXVswXTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5pZGVudGl0eSA9IGZ1bmN0aW9uIGlkZW50aXR5KG4pIHsgcmV0dXJuIG51bWVyaWMuZGlhZyhudW1lcmljLnJlcChbbl0sMSkpOyB9XG5udW1lcmljLnBvaW50d2lzZSA9IGZ1bmN0aW9uIHBvaW50d2lzZShwYXJhbXMsYm9keSxzZXR1cCkge1xuICAgIGlmKHR5cGVvZiBzZXR1cCA9PT0gXCJ1bmRlZmluZWRcIikgeyBzZXR1cCA9IFwiXCI7IH1cbiAgICB2YXIgZnVuID0gW107XG4gICAgdmFyIGs7XG4gICAgdmFyIGF2ZWMgPSAvXFxbaVxcXSQvLHAsdGhldmVjID0gJyc7XG4gICAgdmFyIGhhdmVyZXQgPSBmYWxzZTtcbiAgICBmb3Ioaz0wO2s8cGFyYW1zLmxlbmd0aDtrKyspIHtcbiAgICAgICAgaWYoYXZlYy50ZXN0KHBhcmFtc1trXSkpIHtcbiAgICAgICAgICAgIHAgPSBwYXJhbXNba10uc3Vic3RyaW5nKDAscGFyYW1zW2tdLmxlbmd0aC0zKTtcbiAgICAgICAgICAgIHRoZXZlYyA9IHA7XG4gICAgICAgIH0gZWxzZSB7IHAgPSBwYXJhbXNba107IH1cbiAgICAgICAgaWYocD09PSdyZXQnKSBoYXZlcmV0ID0gdHJ1ZTtcbiAgICAgICAgZnVuLnB1c2gocCk7XG4gICAgfVxuICAgIGZ1bltwYXJhbXMubGVuZ3RoXSA9ICdfcyc7XG4gICAgZnVuW3BhcmFtcy5sZW5ndGgrMV0gPSAnX2snO1xuICAgIGZ1bltwYXJhbXMubGVuZ3RoKzJdID0gKFxuICAgICAgICAgICAgJ2lmKHR5cGVvZiBfcyA9PT0gXCJ1bmRlZmluZWRcIikgX3MgPSBudW1lcmljLmRpbSgnK3RoZXZlYysnKTtcXG4nK1xuICAgICAgICAgICAgJ2lmKHR5cGVvZiBfayA9PT0gXCJ1bmRlZmluZWRcIikgX2sgPSAwO1xcbicrXG4gICAgICAgICAgICAndmFyIF9uID0gX3NbX2tdO1xcbicrXG4gICAgICAgICAgICAndmFyIGknKyhoYXZlcmV0PycnOicsIHJldCA9IEFycmF5KF9uKScpKyc7XFxuJytcbiAgICAgICAgICAgICdpZihfayA8IF9zLmxlbmd0aC0xKSB7XFxuJytcbiAgICAgICAgICAgICcgICAgZm9yKGk9X24tMTtpPj0wO2ktLSkgcmV0W2ldID0gYXJndW1lbnRzLmNhbGxlZSgnK3BhcmFtcy5qb2luKCcsJykrJyxfcyxfaysxKTtcXG4nK1xuICAgICAgICAgICAgJyAgICByZXR1cm4gcmV0O1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICBzZXR1cCsnXFxuJytcbiAgICAgICAgICAgICdmb3IoaT1fbi0xO2khPT0tMTstLWkpIHtcXG4nK1xuICAgICAgICAgICAgJyAgICAnK2JvZHkrJ1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICAncmV0dXJuIHJldDsnXG4gICAgICAgICAgICApO1xuICAgIHJldHVybiBGdW5jdGlvbi5hcHBseShudWxsLGZ1bik7XG59XG5udW1lcmljLnBvaW50d2lzZTIgPSBmdW5jdGlvbiBwb2ludHdpc2UyKHBhcmFtcyxib2R5LHNldHVwKSB7XG4gICAgaWYodHlwZW9mIHNldHVwID09PSBcInVuZGVmaW5lZFwiKSB7IHNldHVwID0gXCJcIjsgfVxuICAgIHZhciBmdW4gPSBbXTtcbiAgICB2YXIgaztcbiAgICB2YXIgYXZlYyA9IC9cXFtpXFxdJC8scCx0aGV2ZWMgPSAnJztcbiAgICB2YXIgaGF2ZXJldCA9IGZhbHNlO1xuICAgIGZvcihrPTA7azxwYXJhbXMubGVuZ3RoO2srKykge1xuICAgICAgICBpZihhdmVjLnRlc3QocGFyYW1zW2tdKSkge1xuICAgICAgICAgICAgcCA9IHBhcmFtc1trXS5zdWJzdHJpbmcoMCxwYXJhbXNba10ubGVuZ3RoLTMpO1xuICAgICAgICAgICAgdGhldmVjID0gcDtcbiAgICAgICAgfSBlbHNlIHsgcCA9IHBhcmFtc1trXTsgfVxuICAgICAgICBpZihwPT09J3JldCcpIGhhdmVyZXQgPSB0cnVlO1xuICAgICAgICBmdW4ucHVzaChwKTtcbiAgICB9XG4gICAgZnVuW3BhcmFtcy5sZW5ndGhdID0gKFxuICAgICAgICAgICAgJ3ZhciBfbiA9ICcrdGhldmVjKycubGVuZ3RoO1xcbicrXG4gICAgICAgICAgICAndmFyIGknKyhoYXZlcmV0PycnOicsIHJldCA9IEFycmF5KF9uKScpKyc7XFxuJytcbiAgICAgICAgICAgIHNldHVwKydcXG4nK1xuICAgICAgICAgICAgJ2ZvcihpPV9uLTE7aSE9PS0xOy0taSkge1xcbicrXG4gICAgICAgICAgICBib2R5KydcXG4nK1xuICAgICAgICAgICAgJ31cXG4nK1xuICAgICAgICAgICAgJ3JldHVybiByZXQ7J1xuICAgICAgICAgICAgKTtcbiAgICByZXR1cm4gRnVuY3Rpb24uYXBwbHkobnVsbCxmdW4pO1xufVxubnVtZXJpYy5fYmlmb3JlYWNoID0gKGZ1bmN0aW9uIF9iaWZvcmVhY2goeCx5LHMsayxmKSB7XG4gICAgaWYoayA9PT0gcy5sZW5ndGgtMSkgeyBmKHgseSk7IHJldHVybjsgfVxuICAgIHZhciBpLG49c1trXTtcbiAgICBmb3IoaT1uLTE7aT49MDtpLS0pIHsgX2JpZm9yZWFjaCh0eXBlb2YgeD09PVwib2JqZWN0XCI/eFtpXTp4LHR5cGVvZiB5PT09XCJvYmplY3RcIj95W2ldOnkscyxrKzEsZik7IH1cbn0pO1xubnVtZXJpYy5fYmlmb3JlYWNoMiA9IChmdW5jdGlvbiBfYmlmb3JlYWNoMih4LHkscyxrLGYpIHtcbiAgICBpZihrID09PSBzLmxlbmd0aC0xKSB7IHJldHVybiBmKHgseSk7IH1cbiAgICB2YXIgaSxuPXNba10scmV0ID0gQXJyYXkobik7XG4gICAgZm9yKGk9bi0xO2k+PTA7LS1pKSB7IHJldFtpXSA9IF9iaWZvcmVhY2gyKHR5cGVvZiB4PT09XCJvYmplY3RcIj94W2ldOngsdHlwZW9mIHk9PT1cIm9iamVjdFwiP3lbaV06eSxzLGsrMSxmKTsgfVxuICAgIHJldHVybiByZXQ7XG59KTtcbm51bWVyaWMuX2ZvcmVhY2ggPSAoZnVuY3Rpb24gX2ZvcmVhY2goeCxzLGssZikge1xuICAgIGlmKGsgPT09IHMubGVuZ3RoLTEpIHsgZih4KTsgcmV0dXJuOyB9XG4gICAgdmFyIGksbj1zW2tdO1xuICAgIGZvcihpPW4tMTtpPj0wO2ktLSkgeyBfZm9yZWFjaCh4W2ldLHMsaysxLGYpOyB9XG59KTtcbm51bWVyaWMuX2ZvcmVhY2gyID0gKGZ1bmN0aW9uIF9mb3JlYWNoMih4LHMsayxmKSB7XG4gICAgaWYoayA9PT0gcy5sZW5ndGgtMSkgeyByZXR1cm4gZih4KTsgfVxuICAgIHZhciBpLG49c1trXSwgcmV0ID0gQXJyYXkobik7XG4gICAgZm9yKGk9bi0xO2k+PTA7aS0tKSB7IHJldFtpXSA9IF9mb3JlYWNoMih4W2ldLHMsaysxLGYpOyB9XG4gICAgcmV0dXJuIHJldDtcbn0pO1xuXG4vKm51bWVyaWMuYW55ViA9IG51bWVyaWMubWFwcmVkdWNlKCdpZih4aSkgcmV0dXJuIHRydWU7JywnZmFsc2UnKTtcbm51bWVyaWMuYWxsViA9IG51bWVyaWMubWFwcmVkdWNlKCdpZigheGkpIHJldHVybiBmYWxzZTsnLCd0cnVlJyk7XG5udW1lcmljLmFueSA9IGZ1bmN0aW9uKHgpIHsgaWYodHlwZW9mIHgubGVuZ3RoID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4geDsgcmV0dXJuIG51bWVyaWMuYW55Vih4KTsgfVxubnVtZXJpYy5hbGwgPSBmdW5jdGlvbih4KSB7IGlmKHR5cGVvZiB4Lmxlbmd0aCA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIHg7IHJldHVybiBudW1lcmljLmFsbFYoeCk7IH0qL1xuXG5udW1lcmljLm9wczIgPSB7XG4gICAgICAgIGFkZDogJysnLFxuICAgICAgICBzdWI6ICctJyxcbiAgICAgICAgbXVsOiAnKicsXG4gICAgICAgIGRpdjogJy8nLFxuICAgICAgICBtb2Q6ICclJyxcbiAgICAgICAgYW5kOiAnJiYnLFxuICAgICAgICBvcjogICd8fCcsXG4gICAgICAgIGVxOiAgJz09PScsXG4gICAgICAgIG5lcTogJyE9PScsXG4gICAgICAgIGx0OiAgJzwnLFxuICAgICAgICBndDogICc+JyxcbiAgICAgICAgbGVxOiAnPD0nLFxuICAgICAgICBnZXE6ICc+PScsXG4gICAgICAgIGJhbmQ6ICcmJyxcbiAgICAgICAgYm9yOiAnfCcsXG4gICAgICAgIGJ4b3I6ICdeJyxcbiAgICAgICAgbHNoaWZ0OiAnPDwnLFxuICAgICAgICByc2hpZnQ6ICc+PicsXG4gICAgICAgIHJyc2hpZnQ6ICc+Pj4nXG59O1xubnVtZXJpYy5vcHNlcSA9IHtcbiAgICAgICAgYWRkZXE6ICcrPScsXG4gICAgICAgIHN1YmVxOiAnLT0nLFxuICAgICAgICBtdWxlcTogJyo9JyxcbiAgICAgICAgZGl2ZXE6ICcvPScsXG4gICAgICAgIG1vZGVxOiAnJT0nLFxuICAgICAgICBsc2hpZnRlcTogJzw8PScsXG4gICAgICAgIHJzaGlmdGVxOiAnPj49JyxcbiAgICAgICAgcnJzaGlmdGVxOiAnPj4+PScsXG4gICAgICAgIGJhbmRlcTogJyY9JyxcbiAgICAgICAgYm9yZXE6ICd8PScsXG4gICAgICAgIGJ4b3JlcTogJ149J1xufTtcbm51bWVyaWMubWF0aGZ1bnMgPSBbJ2FicycsJ2Fjb3MnLCdhc2luJywnYXRhbicsJ2NlaWwnLCdjb3MnLFxuICAgICAgICAgICAgICAgICAgICAnZXhwJywnZmxvb3InLCdsb2cnLCdyb3VuZCcsJ3NpbicsJ3NxcnQnLCd0YW4nLFxuICAgICAgICAgICAgICAgICAgICAnaXNOYU4nLCdpc0Zpbml0ZSddO1xubnVtZXJpYy5tYXRoZnVuczIgPSBbJ2F0YW4yJywncG93JywnbWF4JywnbWluJ107XG5udW1lcmljLm9wczEgPSB7XG4gICAgICAgIG5lZzogJy0nLFxuICAgICAgICBub3Q6ICchJyxcbiAgICAgICAgYm5vdDogJ34nLFxuICAgICAgICBjbG9uZTogJydcbn07XG5udW1lcmljLm1hcHJlZHVjZXJzID0ge1xuICAgICAgICBhbnk6IFsnaWYoeGkpIHJldHVybiB0cnVlOycsJ3ZhciBhY2N1bSA9IGZhbHNlOyddLFxuICAgICAgICBhbGw6IFsnaWYoIXhpKSByZXR1cm4gZmFsc2U7JywndmFyIGFjY3VtID0gdHJ1ZTsnXSxcbiAgICAgICAgc3VtOiBbJ2FjY3VtICs9IHhpOycsJ3ZhciBhY2N1bSA9IDA7J10sXG4gICAgICAgIHByb2Q6IFsnYWNjdW0gKj0geGk7JywndmFyIGFjY3VtID0gMTsnXSxcbiAgICAgICAgbm9ybTJTcXVhcmVkOiBbJ2FjY3VtICs9IHhpKnhpOycsJ3ZhciBhY2N1bSA9IDA7J10sXG4gICAgICAgIG5vcm1pbmY6IFsnYWNjdW0gPSBtYXgoYWNjdW0sYWJzKHhpKSk7JywndmFyIGFjY3VtID0gMCwgbWF4ID0gTWF0aC5tYXgsIGFicyA9IE1hdGguYWJzOyddLFxuICAgICAgICBub3JtMTogWydhY2N1bSArPSBhYnMoeGkpJywndmFyIGFjY3VtID0gMCwgYWJzID0gTWF0aC5hYnM7J10sXG4gICAgICAgIHN1cDogWydhY2N1bSA9IG1heChhY2N1bSx4aSk7JywndmFyIGFjY3VtID0gLUluZmluaXR5LCBtYXggPSBNYXRoLm1heDsnXSxcbiAgICAgICAgaW5mOiBbJ2FjY3VtID0gbWluKGFjY3VtLHhpKTsnLCd2YXIgYWNjdW0gPSBJbmZpbml0eSwgbWluID0gTWF0aC5taW47J11cbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGksbztcbiAgICBmb3IoaT0wO2k8bnVtZXJpYy5tYXRoZnVuczIubGVuZ3RoOysraSkge1xuICAgICAgICBvID0gbnVtZXJpYy5tYXRoZnVuczJbaV07XG4gICAgICAgIG51bWVyaWMub3BzMltvXSA9IG87XG4gICAgfVxuICAgIGZvcihpIGluIG51bWVyaWMub3BzMikge1xuICAgICAgICBpZihudW1lcmljLm9wczIuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIG8gPSBudW1lcmljLm9wczJbaV07XG4gICAgICAgICAgICB2YXIgY29kZSwgY29kZWVxLCBzZXR1cCA9ICcnO1xuICAgICAgICAgICAgaWYobnVtZXJpYy5teUluZGV4T2YuY2FsbChudW1lcmljLm1hdGhmdW5zMixpKSE9PS0xKSB7XG4gICAgICAgICAgICAgICAgc2V0dXAgPSAndmFyICcrbysnID0gTWF0aC4nK28rJztcXG4nO1xuICAgICAgICAgICAgICAgIGNvZGUgPSBmdW5jdGlvbihyLHgseSkgeyByZXR1cm4gcisnID0gJytvKycoJyt4KycsJyt5KycpJzsgfTtcbiAgICAgICAgICAgICAgICBjb2RlZXEgPSBmdW5jdGlvbih4LHkpIHsgcmV0dXJuIHgrJyA9ICcrbysnKCcreCsnLCcreSsnKSc7IH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBmdW5jdGlvbihyLHgseSkgeyByZXR1cm4gcisnID0gJyt4KycgJytvKycgJyt5OyB9O1xuICAgICAgICAgICAgICAgIGlmKG51bWVyaWMub3BzZXEuaGFzT3duUHJvcGVydHkoaSsnZXEnKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlZXEgPSBmdW5jdGlvbih4LHkpIHsgcmV0dXJuIHgrJyAnK28rJz0gJyt5OyB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGVlcSA9IGZ1bmN0aW9uKHgseSkgeyByZXR1cm4geCsnID0gJyt4KycgJytvKycgJyt5OyB9OyAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtZXJpY1tpKydWViddID0gbnVtZXJpYy5wb2ludHdpc2UyKFsneFtpXScsJ3lbaV0nXSxjb2RlKCdyZXRbaV0nLCd4W2ldJywneVtpXScpLHNldHVwKTtcbiAgICAgICAgICAgIG51bWVyaWNbaSsnU1YnXSA9IG51bWVyaWMucG9pbnR3aXNlMihbJ3gnLCd5W2ldJ10sY29kZSgncmV0W2ldJywneCcsJ3lbaV0nKSxzZXR1cCk7XG4gICAgICAgICAgICBudW1lcmljW2krJ1ZTJ10gPSBudW1lcmljLnBvaW50d2lzZTIoWyd4W2ldJywneSddLGNvZGUoJ3JldFtpXScsJ3hbaV0nLCd5Jyksc2V0dXApO1xuICAgICAgICAgICAgbnVtZXJpY1tpXSA9IEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAndmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBpLCB4ID0gYXJndW1lbnRzWzBdLCB5O1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgVlYgPSBudW1lcmljLicraSsnVlYsIFZTID0gbnVtZXJpYy4nK2krJ1ZTLCBTViA9IG51bWVyaWMuJytpKydTVjtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIGRpbSA9IG51bWVyaWMuZGltO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICdmb3IoaT0xO2khPT1uOysraSkgeyBcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnICB5ID0gYXJndW1lbnRzW2ldO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICcgIGlmKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiKSB7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJyAgICAgIGlmKHR5cGVvZiB5ID09PSBcIm9iamVjdFwiKSB4ID0gbnVtZXJpYy5fYmlmb3JlYWNoMih4LHksZGltKHgpLDAsVlYpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICcgICAgICBlbHNlIHggPSBudW1lcmljLl9iaWZvcmVhY2gyKHgseSxkaW0oeCksMCxWUyk7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJyAgfSBlbHNlIGlmKHR5cGVvZiB5ID09PSBcIm9iamVjdFwiKSB4ID0gbnVtZXJpYy5fYmlmb3JlYWNoMih4LHksZGltKHkpLDAsU1YpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICcgIGVsc2UgJytjb2RlZXEoJ3gnLCd5JykrJ1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd9XFxucmV0dXJuIHg7XFxuJyk7XG4gICAgICAgICAgICBudW1lcmljW29dID0gbnVtZXJpY1tpXTtcbiAgICAgICAgICAgIG51bWVyaWNbaSsnZXFWJ10gPSBudW1lcmljLnBvaW50d2lzZTIoWydyZXRbaV0nLCd4W2ldJ10sIGNvZGVlcSgncmV0W2ldJywneFtpXScpLHNldHVwKTtcbiAgICAgICAgICAgIG51bWVyaWNbaSsnZXFTJ10gPSBudW1lcmljLnBvaW50d2lzZTIoWydyZXRbaV0nLCd4J10sIGNvZGVlcSgncmV0W2ldJywneCcpLHNldHVwKTtcbiAgICAgICAgICAgIG51bWVyaWNbaSsnZXEnXSA9IEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAndmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBpLCB4ID0gYXJndW1lbnRzWzBdLCB5O1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgViA9IG51bWVyaWMuJytpKydlcVYsIFMgPSBudW1lcmljLicraSsnZXFTXFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ3ZhciBzID0gbnVtZXJpYy5kaW0oeCk7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ2ZvcihpPTE7aSE9PW47KytpKSB7IFxcbicrXG4gICAgICAgICAgICAgICAgICAgICcgIHkgPSBhcmd1bWVudHNbaV07XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJyAgaWYodHlwZW9mIHkgPT09IFwib2JqZWN0XCIpIG51bWVyaWMuX2JpZm9yZWFjaCh4LHkscywwLFYpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICcgIGVsc2UgbnVtZXJpYy5fYmlmb3JlYWNoKHgseSxzLDAsUyk7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ31cXG5yZXR1cm4geDtcXG4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IoaT0wO2k8bnVtZXJpYy5tYXRoZnVuczIubGVuZ3RoOysraSkge1xuICAgICAgICBvID0gbnVtZXJpYy5tYXRoZnVuczJbaV07XG4gICAgICAgIGRlbGV0ZSBudW1lcmljLm9wczJbb107XG4gICAgfVxuICAgIGZvcihpPTA7aTxudW1lcmljLm1hdGhmdW5zLmxlbmd0aDsrK2kpIHtcbiAgICAgICAgbyA9IG51bWVyaWMubWF0aGZ1bnNbaV07XG4gICAgICAgIG51bWVyaWMub3BzMVtvXSA9IG87XG4gICAgfVxuICAgIGZvcihpIGluIG51bWVyaWMub3BzMSkge1xuICAgICAgICBpZihudW1lcmljLm9wczEuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIHNldHVwID0gJyc7XG4gICAgICAgICAgICBvID0gbnVtZXJpYy5vcHMxW2ldO1xuICAgICAgICAgICAgaWYobnVtZXJpYy5teUluZGV4T2YuY2FsbChudW1lcmljLm1hdGhmdW5zLGkpIT09LTEpIHtcbiAgICAgICAgICAgICAgICBpZihNYXRoLmhhc093blByb3BlcnR5KG8pKSBzZXR1cCA9ICd2YXIgJytvKycgPSBNYXRoLicrbysnO1xcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW1lcmljW2krJ2VxViddID0gbnVtZXJpYy5wb2ludHdpc2UyKFsncmV0W2ldJ10sJ3JldFtpXSA9ICcrbysnKHJldFtpXSk7JyxzZXR1cCk7XG4gICAgICAgICAgICBudW1lcmljW2krJ2VxJ10gPSBGdW5jdGlvbigneCcsXG4gICAgICAgICAgICAgICAgICAgICdpZih0eXBlb2YgeCAhPT0gXCJvYmplY3RcIikgcmV0dXJuICcrbysneFxcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgaTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIFYgPSBudW1lcmljLicraSsnZXFWO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgcyA9IG51bWVyaWMuZGltKHgpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICdudW1lcmljLl9mb3JlYWNoKHgscywwLFYpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICdyZXR1cm4geDtcXG4nKTtcbiAgICAgICAgICAgIG51bWVyaWNbaSsnViddID0gbnVtZXJpYy5wb2ludHdpc2UyKFsneFtpXSddLCdyZXRbaV0gPSAnK28rJyh4W2ldKTsnLHNldHVwKTtcbiAgICAgICAgICAgIG51bWVyaWNbaV0gPSBGdW5jdGlvbigneCcsXG4gICAgICAgICAgICAgICAgICAgICdpZih0eXBlb2YgeCAhPT0gXCJvYmplY3RcIikgcmV0dXJuICcrbysnKHgpXFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ3ZhciBpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgViA9IG51bWVyaWMuJytpKydWO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgcyA9IG51bWVyaWMuZGltKHgpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICdyZXR1cm4gbnVtZXJpYy5fZm9yZWFjaDIoeCxzLDAsVik7XFxuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKGk9MDtpPG51bWVyaWMubWF0aGZ1bnMubGVuZ3RoOysraSkge1xuICAgICAgICBvID0gbnVtZXJpYy5tYXRoZnVuc1tpXTtcbiAgICAgICAgZGVsZXRlIG51bWVyaWMub3BzMVtvXTtcbiAgICB9XG4gICAgZm9yKGkgaW4gbnVtZXJpYy5tYXByZWR1Y2Vycykge1xuICAgICAgICBpZihudW1lcmljLm1hcHJlZHVjZXJzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBvID0gbnVtZXJpYy5tYXByZWR1Y2Vyc1tpXTtcbiAgICAgICAgICAgIG51bWVyaWNbaSsnViddID0gbnVtZXJpYy5tYXByZWR1Y2UyKG9bMF0sb1sxXSk7XG4gICAgICAgICAgICBudW1lcmljW2ldID0gRnVuY3Rpb24oJ3gnLCdzJywnaycsXG4gICAgICAgICAgICAgICAgICAgIG9bMV0rXG4gICAgICAgICAgICAgICAgICAgICdpZih0eXBlb2YgeCAhPT0gXCJvYmplY3RcIikgeycrXG4gICAgICAgICAgICAgICAgICAgICcgICAgeGkgPSB4O1xcbicrXG4gICAgICAgICAgICAgICAgICAgIG9bMF0rJztcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnICAgIHJldHVybiBhY2N1bTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnfScrXG4gICAgICAgICAgICAgICAgICAgICdpZih0eXBlb2YgcyA9PT0gXCJ1bmRlZmluZWRcIikgcyA9IG51bWVyaWMuZGltKHgpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICdpZih0eXBlb2YgayA9PT0gXCJ1bmRlZmluZWRcIikgayA9IDA7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ2lmKGsgPT09IHMubGVuZ3RoLTEpIHJldHVybiBudW1lcmljLicraSsnVih4KTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIHhpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgbiA9IHgubGVuZ3RoLCBpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICdmb3IoaT1uLTE7aSE9PS0xOy0taSkge1xcbicrXG4gICAgICAgICAgICAgICAgICAgICcgICB4aSA9IGFyZ3VtZW50cy5jYWxsZWUoeFtpXSk7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgb1swXSsnO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd9XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ3JldHVybiBhY2N1bTtcXG4nKTtcbiAgICAgICAgfVxuICAgIH1cbn0oKSk7XG5cbm51bWVyaWMudHJ1bmNWViA9IG51bWVyaWMucG9pbnR3aXNlKFsneFtpXScsJ3lbaV0nXSwncmV0W2ldID0gcm91bmQoeFtpXS95W2ldKSp5W2ldOycsJ3ZhciByb3VuZCA9IE1hdGgucm91bmQ7Jyk7XG5udW1lcmljLnRydW5jVlMgPSBudW1lcmljLnBvaW50d2lzZShbJ3hbaV0nLCd5J10sJ3JldFtpXSA9IHJvdW5kKHhbaV0veSkqeTsnLCd2YXIgcm91bmQgPSBNYXRoLnJvdW5kOycpO1xubnVtZXJpYy50cnVuY1NWID0gbnVtZXJpYy5wb2ludHdpc2UoWyd4JywneVtpXSddLCdyZXRbaV0gPSByb3VuZCh4L3lbaV0pKnlbaV07JywndmFyIHJvdW5kID0gTWF0aC5yb3VuZDsnKTtcbm51bWVyaWMudHJ1bmMgPSBmdW5jdGlvbiB0cnVuYyh4LHkpIHtcbiAgICBpZih0eXBlb2YgeCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZih0eXBlb2YgeSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIG51bWVyaWMudHJ1bmNWVih4LHkpO1xuICAgICAgICByZXR1cm4gbnVtZXJpYy50cnVuY1ZTKHgseSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIG51bWVyaWMudHJ1bmNTVih4LHkpO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHgveSkqeTtcbn1cblxubnVtZXJpYy5pbnYgPSBmdW5jdGlvbiBpbnYoeCkge1xuICAgIHZhciBzID0gbnVtZXJpYy5kaW0oeCksIGFicyA9IE1hdGguYWJzLCBtID0gc1swXSwgbiA9IHNbMV07XG4gICAgdmFyIEEgPSBudW1lcmljLmNsb25lKHgpLCBBaSwgQWo7XG4gICAgdmFyIEkgPSBudW1lcmljLmlkZW50aXR5KG0pLCBJaSwgSWo7XG4gICAgdmFyIGksaixrLHg7XG4gICAgZm9yKGo9MDtqPG47KytqKSB7XG4gICAgICAgIHZhciBpMCA9IC0xO1xuICAgICAgICB2YXIgdjAgPSAtMTtcbiAgICAgICAgZm9yKGk9ajtpIT09bTsrK2kpIHsgayA9IGFicyhBW2ldW2pdKTsgaWYoaz52MCkgeyBpMCA9IGk7IHYwID0gazsgfSB9XG4gICAgICAgIEFqID0gQVtpMF07IEFbaTBdID0gQVtqXTsgQVtqXSA9IEFqO1xuICAgICAgICBJaiA9IElbaTBdOyBJW2kwXSA9IElbal07IElbal0gPSBJajtcbiAgICAgICAgeCA9IEFqW2pdO1xuICAgICAgICBmb3Ioaz1qO2shPT1uOysraykgICAgQWpba10gLz0geDsgXG4gICAgICAgIGZvcihrPW4tMTtrIT09LTE7LS1rKSBJaltrXSAvPSB4O1xuICAgICAgICBmb3IoaT1tLTE7aSE9PS0xOy0taSkge1xuICAgICAgICAgICAgaWYoaSE9PWopIHtcbiAgICAgICAgICAgICAgICBBaSA9IEFbaV07XG4gICAgICAgICAgICAgICAgSWkgPSBJW2ldO1xuICAgICAgICAgICAgICAgIHggPSBBaVtqXTtcbiAgICAgICAgICAgICAgICBmb3Ioaz1qKzE7ayE9PW47KytrKSAgQWlba10gLT0gQWpba10qeDtcbiAgICAgICAgICAgICAgICBmb3Ioaz1uLTE7az4wOy0taykgeyBJaVtrXSAtPSBJaltrXSp4OyAtLWs7IElpW2tdIC09IElqW2tdKng7IH1cbiAgICAgICAgICAgICAgICBpZihrPT09MCkgSWlbMF0gLT0gSWpbMF0qeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSTtcbn1cblxubnVtZXJpYy5kZXQgPSBmdW5jdGlvbiBkZXQoeCkge1xuICAgIHZhciBzID0gbnVtZXJpYy5kaW0oeCk7XG4gICAgaWYocy5sZW5ndGggIT09IDIgfHwgc1swXSAhPT0gc1sxXSkgeyB0aHJvdyBuZXcgRXJyb3IoJ251bWVyaWM6IGRldCgpIG9ubHkgd29ya3Mgb24gc3F1YXJlIG1hdHJpY2VzJyk7IH1cbiAgICB2YXIgbiA9IHNbMF0sIHJldCA9IDEsaSxqLGssQSA9IG51bWVyaWMuY2xvbmUoeCksQWosQWksYWxwaGEsdGVtcCxrMSxrMixrMztcbiAgICBmb3Ioaj0wO2o8bi0xO2orKykge1xuICAgICAgICBrPWo7XG4gICAgICAgIGZvcihpPWorMTtpPG47aSsrKSB7IGlmKE1hdGguYWJzKEFbaV1bal0pID4gTWF0aC5hYnMoQVtrXVtqXSkpIHsgayA9IGk7IH0gfVxuICAgICAgICBpZihrICE9PSBqKSB7XG4gICAgICAgICAgICB0ZW1wID0gQVtrXTsgQVtrXSA9IEFbal07IEFbal0gPSB0ZW1wO1xuICAgICAgICAgICAgcmV0ICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIEFqID0gQVtqXTtcbiAgICAgICAgZm9yKGk9aisxO2k8bjtpKyspIHtcbiAgICAgICAgICAgIEFpID0gQVtpXTtcbiAgICAgICAgICAgIGFscGhhID0gQWlbal0vQWpbal07XG4gICAgICAgICAgICBmb3Ioaz1qKzE7azxuLTE7ays9Mikge1xuICAgICAgICAgICAgICAgIGsxID0gaysxO1xuICAgICAgICAgICAgICAgIEFpW2tdIC09IEFqW2tdKmFscGhhO1xuICAgICAgICAgICAgICAgIEFpW2sxXSAtPSBBaltrMV0qYWxwaGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihrIT09bikgeyBBaVtrXSAtPSBBaltrXSphbHBoYTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmKEFqW2pdID09PSAwKSB7IHJldHVybiAwOyB9XG4gICAgICAgIHJldCAqPSBBaltqXTtcbiAgICB9XG4gICAgcmV0dXJuIHJldCpBW2pdW2pdO1xufVxuXG5udW1lcmljLnRyYW5zcG9zZSA9IGZ1bmN0aW9uIHRyYW5zcG9zZSh4KSB7XG4gICAgdmFyIGksaixtID0geC5sZW5ndGgsbiA9IHhbMF0ubGVuZ3RoLCByZXQ9QXJyYXkobiksQTAsQTEsQmo7XG4gICAgZm9yKGo9MDtqPG47aisrKSByZXRbal0gPSBBcnJheShtKTtcbiAgICBmb3IoaT1tLTE7aT49MTtpLT0yKSB7XG4gICAgICAgIEExID0geFtpXTtcbiAgICAgICAgQTAgPSB4W2ktMV07XG4gICAgICAgIGZvcihqPW4tMTtqPj0xOy0taikge1xuICAgICAgICAgICAgQmogPSByZXRbal07IEJqW2ldID0gQTFbal07IEJqW2ktMV0gPSBBMFtqXTtcbiAgICAgICAgICAgIC0tajtcbiAgICAgICAgICAgIEJqID0gcmV0W2pdOyBCaltpXSA9IEExW2pdOyBCaltpLTFdID0gQTBbal07XG4gICAgICAgIH1cbiAgICAgICAgaWYoaj09PTApIHtcbiAgICAgICAgICAgIEJqID0gcmV0WzBdOyBCaltpXSA9IEExWzBdOyBCaltpLTFdID0gQTBbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYoaT09PTApIHtcbiAgICAgICAgQTAgPSB4WzBdO1xuICAgICAgICBmb3Ioaj1uLTE7aj49MTstLWopIHtcbiAgICAgICAgICAgIHJldFtqXVswXSA9IEEwW2pdO1xuICAgICAgICAgICAgLS1qO1xuICAgICAgICAgICAgcmV0W2pdWzBdID0gQTBbal07XG4gICAgICAgIH1cbiAgICAgICAgaWYoaj09PTApIHsgcmV0WzBdWzBdID0gQTBbMF07IH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbm51bWVyaWMubmVndHJhbnNwb3NlID0gZnVuY3Rpb24gbmVndHJhbnNwb3NlKHgpIHtcbiAgICB2YXIgaSxqLG0gPSB4Lmxlbmd0aCxuID0geFswXS5sZW5ndGgsIHJldD1BcnJheShuKSxBMCxBMSxCajtcbiAgICBmb3Ioaj0wO2o8bjtqKyspIHJldFtqXSA9IEFycmF5KG0pO1xuICAgIGZvcihpPW0tMTtpPj0xO2ktPTIpIHtcbiAgICAgICAgQTEgPSB4W2ldO1xuICAgICAgICBBMCA9IHhbaS0xXTtcbiAgICAgICAgZm9yKGo9bi0xO2o+PTE7LS1qKSB7XG4gICAgICAgICAgICBCaiA9IHJldFtqXTsgQmpbaV0gPSAtQTFbal07IEJqW2ktMV0gPSAtQTBbal07XG4gICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICBCaiA9IHJldFtqXTsgQmpbaV0gPSAtQTFbal07IEJqW2ktMV0gPSAtQTBbal07XG4gICAgICAgIH1cbiAgICAgICAgaWYoaj09PTApIHtcbiAgICAgICAgICAgIEJqID0gcmV0WzBdOyBCaltpXSA9IC1BMVswXTsgQmpbaS0xXSA9IC1BMFswXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZihpPT09MCkge1xuICAgICAgICBBMCA9IHhbMF07XG4gICAgICAgIGZvcihqPW4tMTtqPj0xOy0taikge1xuICAgICAgICAgICAgcmV0W2pdWzBdID0gLUEwW2pdO1xuICAgICAgICAgICAgLS1qO1xuICAgICAgICAgICAgcmV0W2pdWzBdID0gLUEwW2pdO1xuICAgICAgICB9XG4gICAgICAgIGlmKGo9PT0wKSB7IHJldFswXVswXSA9IC1BMFswXTsgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLl9yYW5kb20gPSBmdW5jdGlvbiBfcmFuZG9tKHMsaykge1xuICAgIHZhciBpLG49c1trXSxyZXQ9QXJyYXkobiksIHJuZDtcbiAgICBpZihrID09PSBzLmxlbmd0aC0xKSB7XG4gICAgICAgIHJuZCA9IE1hdGgucmFuZG9tO1xuICAgICAgICBmb3IoaT1uLTE7aT49MTtpLT0yKSB7XG4gICAgICAgICAgICByZXRbaV0gPSBybmQoKTtcbiAgICAgICAgICAgIHJldFtpLTFdID0gcm5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaT09PTApIHsgcmV0WzBdID0gcm5kKCk7IH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZm9yKGk9bi0xO2k+PTA7aS0tKSByZXRbaV0gPSBfcmFuZG9tKHMsaysxKTtcbiAgICByZXR1cm4gcmV0O1xufVxubnVtZXJpYy5yYW5kb20gPSBmdW5jdGlvbiByYW5kb20ocykgeyByZXR1cm4gbnVtZXJpYy5fcmFuZG9tKHMsMCk7IH1cblxubnVtZXJpYy5ub3JtMiA9IGZ1bmN0aW9uIG5vcm0yKHgpIHsgcmV0dXJuIE1hdGguc3FydChudW1lcmljLm5vcm0yU3F1YXJlZCh4KSk7IH1cblxubnVtZXJpYy5saW5zcGFjZSA9IGZ1bmN0aW9uIGxpbnNwYWNlKGEsYixuKSB7XG4gICAgaWYodHlwZW9mIG4gPT09IFwidW5kZWZpbmVkXCIpIG4gPSBNYXRoLm1heChNYXRoLnJvdW5kKGItYSkrMSwxKTtcbiAgICBpZihuPDIpIHsgcmV0dXJuIG49PT0xP1thXTpbXTsgfVxuICAgIHZhciBpLHJldCA9IEFycmF5KG4pO1xuICAgIG4tLTtcbiAgICBmb3IoaT1uO2k+PTA7aS0tKSB7IHJldFtpXSA9IChpKmIrKG4taSkqYSkvbjsgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuZ2V0QmxvY2sgPSBmdW5jdGlvbiBnZXRCbG9jayh4LGZyb20sdG8pIHtcbiAgICB2YXIgcyA9IG51bWVyaWMuZGltKHgpO1xuICAgIGZ1bmN0aW9uIGZvbyh4LGspIHtcbiAgICAgICAgdmFyIGksYSA9IGZyb21ba10sIG4gPSB0b1trXS1hLCByZXQgPSBBcnJheShuKTtcbiAgICAgICAgaWYoayA9PT0gcy5sZW5ndGgtMSkge1xuICAgICAgICAgICAgZm9yKGk9bjtpPj0wO2ktLSkgeyByZXRbaV0gPSB4W2krYV07IH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGk9bjtpPj0wO2ktLSkgeyByZXRbaV0gPSBmb28oeFtpK2FdLGsrMSk7IH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgcmV0dXJuIGZvbyh4LDApO1xufVxuXG5udW1lcmljLnNldEJsb2NrID0gZnVuY3Rpb24gc2V0QmxvY2soeCxmcm9tLHRvLEIpIHtcbiAgICB2YXIgcyA9IG51bWVyaWMuZGltKHgpO1xuICAgIGZ1bmN0aW9uIGZvbyh4LHksaykge1xuICAgICAgICB2YXIgaSxhID0gZnJvbVtrXSwgbiA9IHRvW2tdLWE7XG4gICAgICAgIGlmKGsgPT09IHMubGVuZ3RoLTEpIHsgZm9yKGk9bjtpPj0wO2ktLSkgeyB4W2krYV0gPSB5W2ldOyB9IH1cbiAgICAgICAgZm9yKGk9bjtpPj0wO2ktLSkgeyBmb28oeFtpK2FdLHlbaV0saysxKTsgfVxuICAgIH1cbiAgICBmb28oeCxCLDApO1xuICAgIHJldHVybiB4O1xufVxuXG5udW1lcmljLmdldFJhbmdlID0gZnVuY3Rpb24gZ2V0UmFuZ2UoQSxJLEopIHtcbiAgICB2YXIgbSA9IEkubGVuZ3RoLCBuID0gSi5sZW5ndGg7XG4gICAgdmFyIGksajtcbiAgICB2YXIgQiA9IEFycmF5KG0pLCBCaSwgQUk7XG4gICAgZm9yKGk9bS0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgQltpXSA9IEFycmF5KG4pO1xuICAgICAgICBCaSA9IEJbaV07XG4gICAgICAgIEFJID0gQVtJW2ldXTtcbiAgICAgICAgZm9yKGo9bi0xO2ohPT0tMTstLWopIEJpW2pdID0gQUlbSltqXV07XG4gICAgfVxuICAgIHJldHVybiBCO1xufVxuXG5udW1lcmljLmJsb2NrTWF0cml4ID0gZnVuY3Rpb24gYmxvY2tNYXRyaXgoWCkge1xuICAgIHZhciBzID0gbnVtZXJpYy5kaW0oWCk7XG4gICAgaWYocy5sZW5ndGg8NCkgcmV0dXJuIG51bWVyaWMuYmxvY2tNYXRyaXgoW1hdKTtcbiAgICB2YXIgbT1zWzBdLG49c1sxXSxNLE4saSxqLFhpajtcbiAgICBNID0gMDsgTiA9IDA7XG4gICAgZm9yKGk9MDtpPG07KytpKSBNKz1YW2ldWzBdLmxlbmd0aDtcbiAgICBmb3Ioaj0wO2o8bjsrK2opIE4rPVhbMF1bal1bMF0ubGVuZ3RoO1xuICAgIHZhciBaID0gQXJyYXkoTSk7XG4gICAgZm9yKGk9MDtpPE07KytpKSBaW2ldID0gQXJyYXkoTik7XG4gICAgdmFyIEk9MCxKLFpJLGssbCxYaWprO1xuICAgIGZvcihpPTA7aTxtOysraSkge1xuICAgICAgICBKPU47XG4gICAgICAgIGZvcihqPW4tMTtqIT09LTE7LS1qKSB7XG4gICAgICAgICAgICBYaWogPSBYW2ldW2pdO1xuICAgICAgICAgICAgSiAtPSBYaWpbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yKGs9WGlqLmxlbmd0aC0xO2shPT0tMTstLWspIHtcbiAgICAgICAgICAgICAgICBYaWprID0gWGlqW2tdO1xuICAgICAgICAgICAgICAgIFpJID0gWltJK2tdO1xuICAgICAgICAgICAgICAgIGZvcihsID0gWGlqay5sZW5ndGgtMTtsIT09LTE7LS1sKSBaSVtKK2xdID0gWGlqa1tsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBJICs9IFhbaV1bMF0ubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gWjtcbn1cblxubnVtZXJpYy50ZW5zb3IgPSBmdW5jdGlvbiB0ZW5zb3IoeCx5KSB7XG4gICAgaWYodHlwZW9mIHggPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHkgPT09IFwibnVtYmVyXCIpIHJldHVybiBudW1lcmljLm11bCh4LHkpO1xuICAgIHZhciBzMSA9IG51bWVyaWMuZGltKHgpLCBzMiA9IG51bWVyaWMuZGltKHkpO1xuICAgIGlmKHMxLmxlbmd0aCAhPT0gMSB8fCBzMi5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1lcmljOiB0ZW5zb3IgcHJvZHVjdCBpcyBvbmx5IGRlZmluZWQgZm9yIHZlY3RvcnMnKTtcbiAgICB9XG4gICAgdmFyIG0gPSBzMVswXSwgbiA9IHMyWzBdLCBBID0gQXJyYXkobSksIEFpLCBpLGoseGk7XG4gICAgZm9yKGk9bS0xO2k+PTA7aS0tKSB7XG4gICAgICAgIEFpID0gQXJyYXkobik7XG4gICAgICAgIHhpID0geFtpXTtcbiAgICAgICAgZm9yKGo9bi0xO2o+PTM7LS1qKSB7XG4gICAgICAgICAgICBBaVtqXSA9IHhpICogeVtqXTtcbiAgICAgICAgICAgIC0tajtcbiAgICAgICAgICAgIEFpW2pdID0geGkgKiB5W2pdO1xuICAgICAgICAgICAgLS1qO1xuICAgICAgICAgICAgQWlbal0gPSB4aSAqIHlbal07XG4gICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICBBaVtqXSA9IHhpICogeVtqXTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZShqPj0wKSB7IEFpW2pdID0geGkgKiB5W2pdOyAtLWo7IH1cbiAgICAgICAgQVtpXSA9IEFpO1xuICAgIH1cbiAgICByZXR1cm4gQTtcbn1cblxuLy8gMy4gVGhlIFRlbnNvciB0eXBlIFRcbm51bWVyaWMuVCA9IGZ1bmN0aW9uIFQoeCx5KSB7IHRoaXMueCA9IHg7IHRoaXMueSA9IHk7IH1cbm51bWVyaWMudCA9IGZ1bmN0aW9uIHQoeCx5KSB7IHJldHVybiBuZXcgbnVtZXJpYy5UKHgseSk7IH1cblxubnVtZXJpYy5UYmlub3AgPSBmdW5jdGlvbiBUYmlub3AocnIscmMsY3IsY2Msc2V0dXApIHtcbiAgICB2YXIgaW8gPSBudW1lcmljLmluZGV4T2Y7XG4gICAgaWYodHlwZW9mIHNldHVwICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciBrO1xuICAgICAgICBzZXR1cCA9ICcnO1xuICAgICAgICBmb3IoayBpbiBudW1lcmljKSB7XG4gICAgICAgICAgICBpZihudW1lcmljLmhhc093blByb3BlcnR5KGspICYmIChyci5pbmRleE9mKGspPj0wIHx8IHJjLmluZGV4T2Yoayk+PTAgfHwgY3IuaW5kZXhPZihrKT49MCB8fCBjYy5pbmRleE9mKGspPj0wKSAmJiBrLmxlbmd0aD4xKSB7XG4gICAgICAgICAgICAgICAgc2V0dXAgKz0gJ3ZhciAnK2srJyA9IG51bWVyaWMuJytrKyc7XFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gRnVuY3Rpb24oWyd5J10sXG4gICAgICAgICAgICAndmFyIHggPSB0aGlzO1xcbicrXG4gICAgICAgICAgICAnaWYoISh5IGluc3RhbmNlb2YgbnVtZXJpYy5UKSkgeyB5ID0gbmV3IG51bWVyaWMuVCh5KTsgfVxcbicrXG4gICAgICAgICAgICBzZXR1cCsnXFxuJytcbiAgICAgICAgICAgICdpZih4LnkpIHsnK1xuICAgICAgICAgICAgJyAgaWYoeS55KSB7JytcbiAgICAgICAgICAgICcgICAgcmV0dXJuIG5ldyBudW1lcmljLlQoJytjYysnKTtcXG4nK1xuICAgICAgICAgICAgJyAgfVxcbicrXG4gICAgICAgICAgICAnICByZXR1cm4gbmV3IG51bWVyaWMuVCgnK2NyKycpO1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICAnaWYoeS55KSB7XFxuJytcbiAgICAgICAgICAgICcgIHJldHVybiBuZXcgbnVtZXJpYy5UKCcrcmMrJyk7XFxuJytcbiAgICAgICAgICAgICd9XFxuJytcbiAgICAgICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVCgnK3JyKycpO1xcbidcbiAgICApO1xufVxuXG5udW1lcmljLlQucHJvdG90eXBlLmFkZCA9IG51bWVyaWMuVGJpbm9wKFxuICAgICAgICAnYWRkKHgueCx5LngpJyxcbiAgICAgICAgJ2FkZCh4LngseS54KSx5LnknLFxuICAgICAgICAnYWRkKHgueCx5LngpLHgueScsXG4gICAgICAgICdhZGQoeC54LHkueCksYWRkKHgueSx5LnkpJyk7XG5udW1lcmljLlQucHJvdG90eXBlLnN1YiA9IG51bWVyaWMuVGJpbm9wKFxuICAgICAgICAnc3ViKHgueCx5LngpJyxcbiAgICAgICAgJ3N1Yih4LngseS54KSxuZWcoeS55KScsXG4gICAgICAgICdzdWIoeC54LHkueCkseC55JyxcbiAgICAgICAgJ3N1Yih4LngseS54KSxzdWIoeC55LHkueSknKTtcbm51bWVyaWMuVC5wcm90b3R5cGUubXVsID0gbnVtZXJpYy5UYmlub3AoXG4gICAgICAgICdtdWwoeC54LHkueCknLFxuICAgICAgICAnbXVsKHgueCx5LngpLG11bCh4LngseS55KScsXG4gICAgICAgICdtdWwoeC54LHkueCksbXVsKHgueSx5LngpJyxcbiAgICAgICAgJ3N1YihtdWwoeC54LHkueCksbXVsKHgueSx5LnkpKSxhZGQobXVsKHgueCx5LnkpLG11bCh4LnkseS54KSknKTtcblxubnVtZXJpYy5ULnByb3RvdHlwZS5yZWNpcHJvY2FsID0gZnVuY3Rpb24gcmVjaXByb2NhbCgpIHtcbiAgICB2YXIgbXVsID0gbnVtZXJpYy5tdWwsIGRpdiA9IG51bWVyaWMuZGl2O1xuICAgIGlmKHRoaXMueSkge1xuICAgICAgICB2YXIgZCA9IG51bWVyaWMuYWRkKG11bCh0aGlzLngsdGhpcy54KSxtdWwodGhpcy55LHRoaXMueSkpO1xuICAgICAgICByZXR1cm4gbmV3IG51bWVyaWMuVChkaXYodGhpcy54LGQpLGRpdihudW1lcmljLm5lZyh0aGlzLnkpLGQpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUKGRpdigxLHRoaXMueCkpO1xufVxubnVtZXJpYy5ULnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiBkaXYoeSkge1xuICAgIGlmKCEoeSBpbnN0YW5jZW9mIG51bWVyaWMuVCkpIHkgPSBuZXcgbnVtZXJpYy5UKHkpO1xuICAgIGlmKHkueSkgeyByZXR1cm4gdGhpcy5tdWwoeS5yZWNpcHJvY2FsKCkpOyB9XG4gICAgdmFyIGRpdiA9IG51bWVyaWMuZGl2O1xuICAgIGlmKHRoaXMueSkgeyByZXR1cm4gbmV3IG51bWVyaWMuVChkaXYodGhpcy54LHkueCksZGl2KHRoaXMueSx5LngpKTsgfVxuICAgIHJldHVybiBuZXcgbnVtZXJpYy5UKGRpdih0aGlzLngseS54KSk7XG59XG5udW1lcmljLlQucHJvdG90eXBlLmRvdCA9IG51bWVyaWMuVGJpbm9wKFxuICAgICAgICAnZG90KHgueCx5LngpJyxcbiAgICAgICAgJ2RvdCh4LngseS54KSxkb3QoeC54LHkueSknLFxuICAgICAgICAnZG90KHgueCx5LngpLGRvdCh4LnkseS54KScsXG4gICAgICAgICdzdWIoZG90KHgueCx5LngpLGRvdCh4LnkseS55KSksYWRkKGRvdCh4LngseS55KSxkb3QoeC55LHkueCkpJ1xuICAgICAgICApO1xubnVtZXJpYy5ULnByb3RvdHlwZS50cmFuc3Bvc2UgPSBmdW5jdGlvbiB0cmFuc3Bvc2UoKSB7XG4gICAgdmFyIHQgPSBudW1lcmljLnRyYW5zcG9zZSwgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcbiAgICBpZih5KSB7IHJldHVybiBuZXcgbnVtZXJpYy5UKHQoeCksdCh5KSk7IH1cbiAgICByZXR1cm4gbmV3IG51bWVyaWMuVCh0KHgpKTtcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUudHJhbnNqdWdhdGUgPSBmdW5jdGlvbiB0cmFuc2p1Z2F0ZSgpIHtcbiAgICB2YXIgdCA9IG51bWVyaWMudHJhbnNwb3NlLCB4ID0gdGhpcy54LCB5ID0gdGhpcy55O1xuICAgIGlmKHkpIHsgcmV0dXJuIG5ldyBudW1lcmljLlQodCh4KSxudW1lcmljLm5lZ3RyYW5zcG9zZSh5KSk7IH1cbiAgICByZXR1cm4gbmV3IG51bWVyaWMuVCh0KHgpKTtcbn1cbm51bWVyaWMuVHVub3AgPSBmdW5jdGlvbiBUdW5vcChyLGMscykge1xuICAgIGlmKHR5cGVvZiBzICE9PSBcInN0cmluZ1wiKSB7IHMgPSAnJzsgfVxuICAgIHJldHVybiBGdW5jdGlvbihcbiAgICAgICAgICAgICd2YXIgeCA9IHRoaXM7XFxuJytcbiAgICAgICAgICAgIHMrJ1xcbicrXG4gICAgICAgICAgICAnaWYoeC55KSB7JytcbiAgICAgICAgICAgICcgICcrYysnO1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICByKyc7XFxuJ1xuICAgICk7XG59XG5cbm51bWVyaWMuVC5wcm90b3R5cGUuZXhwID0gbnVtZXJpYy5UdW5vcChcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKGV4KScsXG4gICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVChtdWwoY29zKHgueSksZXgpLG11bChzaW4oeC55KSxleCkpJyxcbiAgICAgICAgJ3ZhciBleCA9IG51bWVyaWMuZXhwKHgueCksIGNvcyA9IG51bWVyaWMuY29zLCBzaW4gPSBudW1lcmljLnNpbiwgbXVsID0gbnVtZXJpYy5tdWw7Jyk7XG5udW1lcmljLlQucHJvdG90eXBlLmNvbmogPSBudW1lcmljLlR1bm9wKFxuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQoeC54KTsnLFxuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQoeC54LG51bWVyaWMubmVnKHgueSkpOycpO1xubnVtZXJpYy5ULnByb3RvdHlwZS5uZWcgPSBudW1lcmljLlR1bm9wKFxuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQobmVnKHgueCkpOycsXG4gICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVChuZWcoeC54KSxuZWcoeC55KSk7JyxcbiAgICAgICAgJ3ZhciBuZWcgPSBudW1lcmljLm5lZzsnKTtcbm51bWVyaWMuVC5wcm90b3R5cGUuc2luID0gbnVtZXJpYy5UdW5vcChcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKG51bWVyaWMuc2luKHgueCkpJyxcbiAgICAgICAgJ3JldHVybiB4LmV4cCgpLnN1Yih4Lm5lZygpLmV4cCgpKS5kaXYobmV3IG51bWVyaWMuVCgwLDIpKTsnKTtcbm51bWVyaWMuVC5wcm90b3R5cGUuY29zID0gbnVtZXJpYy5UdW5vcChcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKG51bWVyaWMuY29zKHgueCkpJyxcbiAgICAgICAgJ3JldHVybiB4LmV4cCgpLmFkZCh4Lm5lZygpLmV4cCgpKS5kaXYoMik7Jyk7XG5udW1lcmljLlQucHJvdG90eXBlLmFicyA9IG51bWVyaWMuVHVub3AoXG4gICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVChudW1lcmljLmFicyh4LngpKTsnLFxuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQobnVtZXJpYy5zcXJ0KG51bWVyaWMuYWRkKG11bCh4LngseC54KSxtdWwoeC55LHgueSkpKSk7JyxcbiAgICAgICAgJ3ZhciBtdWwgPSBudW1lcmljLm11bDsnKTtcbm51bWVyaWMuVC5wcm90b3R5cGUubG9nID0gbnVtZXJpYy5UdW5vcChcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKG51bWVyaWMubG9nKHgueCkpOycsXG4gICAgICAgICd2YXIgdGhldGEgPSBuZXcgbnVtZXJpYy5UKG51bWVyaWMuYXRhbjIoeC55LHgueCkpLCByID0geC5hYnMoKTtcXG4nK1xuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQobnVtZXJpYy5sb2coci54KSx0aGV0YS54KTsnKTtcbm51bWVyaWMuVC5wcm90b3R5cGUubm9ybTIgPSBudW1lcmljLlR1bm9wKFxuICAgICAgICAncmV0dXJuIG51bWVyaWMubm9ybTIoeC54KTsnLFxuICAgICAgICAndmFyIGYgPSBudW1lcmljLm5vcm0yU3F1YXJlZDtcXG4nK1xuICAgICAgICAncmV0dXJuIE1hdGguc3FydChmKHgueCkrZih4LnkpKTsnKTtcbm51bWVyaWMuVC5wcm90b3R5cGUuaW52ID0gZnVuY3Rpb24gaW52KCkge1xuICAgIHZhciBBID0gdGhpcztcbiAgICBpZih0eXBlb2YgQS55ID09PSBcInVuZGVmaW5lZFwiKSB7IHJldHVybiBuZXcgbnVtZXJpYy5UKG51bWVyaWMuaW52KEEueCkpOyB9XG4gICAgdmFyIG4gPSBBLngubGVuZ3RoLCBpLCBqLCBrO1xuICAgIHZhciBSeCA9IG51bWVyaWMuaWRlbnRpdHkobiksUnkgPSBudW1lcmljLnJlcChbbixuXSwwKTtcbiAgICB2YXIgQXggPSBudW1lcmljLmNsb25lKEEueCksIEF5ID0gbnVtZXJpYy5jbG9uZShBLnkpO1xuICAgIHZhciBBaXgsIEFpeSwgQWp4LCBBanksIFJpeCwgUml5LCBSangsIFJqeTtcbiAgICB2YXIgaSxqLGssZCxkMSxheCxheSxieCxieSx0ZW1wO1xuICAgIGZvcihpPTA7aTxuO2krKykge1xuICAgICAgICBheCA9IEF4W2ldW2ldOyBheSA9IEF5W2ldW2ldO1xuICAgICAgICBkID0gYXgqYXgrYXkqYXk7XG4gICAgICAgIGsgPSBpO1xuICAgICAgICBmb3Ioaj1pKzE7ajxuO2orKykge1xuICAgICAgICAgICAgYXggPSBBeFtqXVtpXTsgYXkgPSBBeVtqXVtpXTtcbiAgICAgICAgICAgIGQxID0gYXgqYXgrYXkqYXk7XG4gICAgICAgICAgICBpZihkMSA+IGQpIHsgaz1qOyBkID0gZDE7IH1cbiAgICAgICAgfVxuICAgICAgICBpZihrIT09aSkge1xuICAgICAgICAgICAgdGVtcCA9IEF4W2ldOyBBeFtpXSA9IEF4W2tdOyBBeFtrXSA9IHRlbXA7XG4gICAgICAgICAgICB0ZW1wID0gQXlbaV07IEF5W2ldID0gQXlba107IEF5W2tdID0gdGVtcDtcbiAgICAgICAgICAgIHRlbXAgPSBSeFtpXTsgUnhbaV0gPSBSeFtrXTsgUnhba10gPSB0ZW1wO1xuICAgICAgICAgICAgdGVtcCA9IFJ5W2ldOyBSeVtpXSA9IFJ5W2tdOyBSeVtrXSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgQWl4ID0gQXhbaV07IEFpeSA9IEF5W2ldO1xuICAgICAgICBSaXggPSBSeFtpXTsgUml5ID0gUnlbaV07XG4gICAgICAgIGF4ID0gQWl4W2ldOyBheSA9IEFpeVtpXTtcbiAgICAgICAgZm9yKGo9aSsxO2o8bjtqKyspIHtcbiAgICAgICAgICAgIGJ4ID0gQWl4W2pdOyBieSA9IEFpeVtqXTtcbiAgICAgICAgICAgIEFpeFtqXSA9IChieCpheCtieSpheSkvZDtcbiAgICAgICAgICAgIEFpeVtqXSA9IChieSpheC1ieCpheSkvZDtcbiAgICAgICAgfVxuICAgICAgICBmb3Ioaj0wO2o8bjtqKyspIHtcbiAgICAgICAgICAgIGJ4ID0gUml4W2pdOyBieSA9IFJpeVtqXTtcbiAgICAgICAgICAgIFJpeFtqXSA9IChieCpheCtieSpheSkvZDtcbiAgICAgICAgICAgIFJpeVtqXSA9IChieSpheC1ieCpheSkvZDtcbiAgICAgICAgfVxuICAgICAgICBmb3Ioaj1pKzE7ajxuO2orKykge1xuICAgICAgICAgICAgQWp4ID0gQXhbal07IEFqeSA9IEF5W2pdO1xuICAgICAgICAgICAgUmp4ID0gUnhbal07IFJqeSA9IFJ5W2pdO1xuICAgICAgICAgICAgYXggPSBBanhbaV07IGF5ID0gQWp5W2ldO1xuICAgICAgICAgICAgZm9yKGs9aSsxO2s8bjtrKyspIHtcbiAgICAgICAgICAgICAgICBieCA9IEFpeFtrXTsgYnkgPSBBaXlba107XG4gICAgICAgICAgICAgICAgQWp4W2tdIC09IGJ4KmF4LWJ5KmF5O1xuICAgICAgICAgICAgICAgIEFqeVtrXSAtPSBieSpheCtieCpheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcihrPTA7azxuO2srKykge1xuICAgICAgICAgICAgICAgIGJ4ID0gUml4W2tdOyBieSA9IFJpeVtrXTtcbiAgICAgICAgICAgICAgICBSanhba10gLT0gYngqYXgtYnkqYXk7XG4gICAgICAgICAgICAgICAgUmp5W2tdIC09IGJ5KmF4K2J4KmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvcihpPW4tMTtpPjA7aS0tKSB7XG4gICAgICAgIFJpeCA9IFJ4W2ldOyBSaXkgPSBSeVtpXTtcbiAgICAgICAgZm9yKGo9aS0xO2o+PTA7ai0tKSB7XG4gICAgICAgICAgICBSanggPSBSeFtqXTsgUmp5ID0gUnlbal07XG4gICAgICAgICAgICBheCA9IEF4W2pdW2ldOyBheSA9IEF5W2pdW2ldO1xuICAgICAgICAgICAgZm9yKGs9bi0xO2s+PTA7ay0tKSB7XG4gICAgICAgICAgICAgICAgYnggPSBSaXhba107IGJ5ID0gUml5W2tdO1xuICAgICAgICAgICAgICAgIFJqeFtrXSAtPSBheCpieCAtIGF5KmJ5O1xuICAgICAgICAgICAgICAgIFJqeVtrXSAtPSBheCpieSArIGF5KmJ4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgbnVtZXJpYy5UKFJ4LFJ5KTtcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KGkpIHtcbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgayA9IDAsIGlrLCBuID0gaS5sZW5ndGg7XG4gICAgaWYoeSkge1xuICAgICAgICB3aGlsZShrPG4pIHtcbiAgICAgICAgICAgIGlrID0gaVtrXTtcbiAgICAgICAgICAgIHggPSB4W2lrXTtcbiAgICAgICAgICAgIHkgPSB5W2lrXTtcbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IG51bWVyaWMuVCh4LHkpO1xuICAgIH1cbiAgICB3aGlsZShrPG4pIHtcbiAgICAgICAgaWsgPSBpW2tdO1xuICAgICAgICB4ID0geFtpa107XG4gICAgICAgIGsrKztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlQoeCk7XG59XG5udW1lcmljLlQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldChpLHYpIHtcbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgayA9IDAsIGlrLCBuID0gaS5sZW5ndGgsIHZ4ID0gdi54LCB2eSA9IHYueTtcbiAgICBpZihuPT09MCkge1xuICAgICAgICBpZih2eSkgeyB0aGlzLnkgPSB2eTsgfVxuICAgICAgICBlbHNlIGlmKHkpIHsgdGhpcy55ID0gdW5kZWZpbmVkOyB9XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZih2eSkge1xuICAgICAgICBpZih5KSB7IC8qIG9rICovIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5ID0gbnVtZXJpYy5yZXAobnVtZXJpYy5kaW0oeCksMCk7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlKGs8bi0xKSB7XG4gICAgICAgICAgICBpayA9IGlba107XG4gICAgICAgICAgICB4ID0geFtpa107XG4gICAgICAgICAgICB5ID0geVtpa107XG4gICAgICAgICAgICBrKys7XG4gICAgICAgIH1cbiAgICAgICAgaWsgPSBpW2tdO1xuICAgICAgICB4W2lrXSA9IHZ4O1xuICAgICAgICB5W2lrXSA9IHZ5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYoeSkge1xuICAgICAgICB3aGlsZShrPG4tMSkge1xuICAgICAgICAgICAgaWsgPSBpW2tdO1xuICAgICAgICAgICAgeCA9IHhbaWtdO1xuICAgICAgICAgICAgeSA9IHlbaWtdO1xuICAgICAgICAgICAgaysrO1xuICAgICAgICB9XG4gICAgICAgIGlrID0gaVtrXTtcbiAgICAgICAgeFtpa10gPSB2eDtcbiAgICAgICAgaWYodnggaW5zdGFuY2VvZiBBcnJheSkgeVtpa10gPSBudW1lcmljLnJlcChudW1lcmljLmRpbSh2eCksMCk7XG4gICAgICAgIGVsc2UgeVtpa10gPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd2hpbGUoazxuLTEpIHtcbiAgICAgICAgaWsgPSBpW2tdO1xuICAgICAgICB4ID0geFtpa107XG4gICAgICAgIGsrKztcbiAgICB9XG4gICAgaWsgPSBpW2tdO1xuICAgIHhbaWtdID0gdng7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5udW1lcmljLlQucHJvdG90eXBlLmdldFJvd3MgPSBmdW5jdGlvbiBnZXRSb3dzKGkwLGkxKSB7XG4gICAgdmFyIG4gPSBpMS1pMCsxLCBqO1xuICAgIHZhciByeCA9IEFycmF5KG4pLCByeSwgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcbiAgICBmb3Ioaj1pMDtqPD1pMTtqKyspIHsgcnhbai1pMF0gPSB4W2pdOyB9XG4gICAgaWYoeSkge1xuICAgICAgICByeSA9IEFycmF5KG4pO1xuICAgICAgICBmb3Ioaj1pMDtqPD1pMTtqKyspIHsgcnlbai1pMF0gPSB5W2pdOyB9XG4gICAgICAgIHJldHVybiBuZXcgbnVtZXJpYy5UKHJ4LHJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlQocngpO1xufVxubnVtZXJpYy5ULnByb3RvdHlwZS5zZXRSb3dzID0gZnVuY3Rpb24gc2V0Um93cyhpMCxpMSxBKSB7XG4gICAgdmFyIGo7XG4gICAgdmFyIHJ4ID0gdGhpcy54LCByeSA9IHRoaXMueSwgeCA9IEEueCwgeSA9IEEueTtcbiAgICBmb3Ioaj1pMDtqPD1pMTtqKyspIHsgcnhbal0gPSB4W2otaTBdOyB9XG4gICAgaWYoeSkge1xuICAgICAgICBpZighcnkpIHsgcnkgPSBudW1lcmljLnJlcChudW1lcmljLmRpbShyeCksMCk7IHRoaXMueSA9IHJ5OyB9XG4gICAgICAgIGZvcihqPWkwO2o8PWkxO2orKykgeyByeVtqXSA9IHlbai1pMF07IH1cbiAgICB9IGVsc2UgaWYocnkpIHtcbiAgICAgICAgZm9yKGo9aTA7ajw9aTE7aisrKSB7IHJ5W2pdID0gbnVtZXJpYy5yZXAoW3hbai1pMF0ubGVuZ3RoXSwwKTsgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUuZ2V0Um93ID0gZnVuY3Rpb24gZ2V0Um93KGspIHtcbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcbiAgICBpZih5KSB7IHJldHVybiBuZXcgbnVtZXJpYy5UKHhba10seVtrXSk7IH1cbiAgICByZXR1cm4gbmV3IG51bWVyaWMuVCh4W2tdKTtcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUuc2V0Um93ID0gZnVuY3Rpb24gc2V0Um93KGksdikge1xuICAgIHZhciByeCA9IHRoaXMueCwgcnkgPSB0aGlzLnksIHggPSB2LngsIHkgPSB2Lnk7XG4gICAgcnhbaV0gPSB4O1xuICAgIGlmKHkpIHtcbiAgICAgICAgaWYoIXJ5KSB7IHJ5ID0gbnVtZXJpYy5yZXAobnVtZXJpYy5kaW0ocngpLDApOyB0aGlzLnkgPSByeTsgfVxuICAgICAgICByeVtpXSA9IHk7XG4gICAgfSBlbHNlIGlmKHJ5KSB7XG4gICAgICAgIHJ5ID0gbnVtZXJpYy5yZXAoW3gubGVuZ3RoXSwwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbm51bWVyaWMuVC5wcm90b3R5cGUuZ2V0QmxvY2sgPSBmdW5jdGlvbiBnZXRCbG9jayhmcm9tLHRvKSB7XG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIGIgPSBudW1lcmljLmdldEJsb2NrO1xuICAgIGlmKHkpIHsgcmV0dXJuIG5ldyBudW1lcmljLlQoYih4LGZyb20sdG8pLGIoeSxmcm9tLHRvKSk7IH1cbiAgICByZXR1cm4gbmV3IG51bWVyaWMuVChiKHgsZnJvbSx0bykpO1xufVxubnVtZXJpYy5ULnByb3RvdHlwZS5zZXRCbG9jayA9IGZ1bmN0aW9uIHNldEJsb2NrKGZyb20sdG8sQSkge1xuICAgIGlmKCEoQSBpbnN0YW5jZW9mIG51bWVyaWMuVCkpIEEgPSBuZXcgbnVtZXJpYy5UKEEpO1xuICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCBiID0gbnVtZXJpYy5zZXRCbG9jaywgQXggPSBBLngsIEF5ID0gQS55O1xuICAgIGlmKEF5KSB7XG4gICAgICAgIGlmKCF5KSB7IHRoaXMueSA9IG51bWVyaWMucmVwKG51bWVyaWMuZGltKHRoaXMpLDApOyB5ID0gdGhpcy55OyB9XG4gICAgICAgIGIoeCxmcm9tLHRvLEF4KTtcbiAgICAgICAgYih5LGZyb20sdG8sQXkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYih4LGZyb20sdG8sQXgpO1xuICAgIGlmKHkpIGIoeSxmcm9tLHRvLG51bWVyaWMucmVwKG51bWVyaWMuZGltKEF4KSwwKSk7XG59XG5udW1lcmljLlQucmVwID0gZnVuY3Rpb24gcmVwKHMsdikge1xuICAgIHZhciBUID0gbnVtZXJpYy5UO1xuICAgIGlmKCEodiBpbnN0YW5jZW9mIFQpKSB2ID0gbmV3IFQodik7XG4gICAgdmFyIHggPSB2LngsIHkgPSB2LnksIHIgPSBudW1lcmljLnJlcDtcbiAgICBpZih5KSByZXR1cm4gbmV3IFQocihzLHgpLHIocyx5KSk7XG4gICAgcmV0dXJuIG5ldyBUKHIocyx4KSk7XG59XG5udW1lcmljLlQuZGlhZyA9IGZ1bmN0aW9uIGRpYWcoZCkge1xuICAgIGlmKCEoZCBpbnN0YW5jZW9mIG51bWVyaWMuVCkpIGQgPSBuZXcgbnVtZXJpYy5UKGQpO1xuICAgIHZhciB4ID0gZC54LCB5ID0gZC55LCBkaWFnID0gbnVtZXJpYy5kaWFnO1xuICAgIGlmKHkpIHJldHVybiBuZXcgbnVtZXJpYy5UKGRpYWcoeCksZGlhZyh5KSk7XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlQoZGlhZyh4KSk7XG59XG5udW1lcmljLlQuZWlnID0gZnVuY3Rpb24gZWlnKCkge1xuICAgIGlmKHRoaXMueSkgeyB0aHJvdyBuZXcgRXJyb3IoJ2VpZzogbm90IGltcGxlbWVudGVkIGZvciBjb21wbGV4IG1hdHJpY2VzLicpOyB9XG4gICAgcmV0dXJuIG51bWVyaWMuZWlnKHRoaXMueCk7XG59XG5udW1lcmljLlQuaWRlbnRpdHkgPSBmdW5jdGlvbiBpZGVudGl0eShuKSB7IHJldHVybiBuZXcgbnVtZXJpYy5UKG51bWVyaWMuaWRlbnRpdHkobikpOyB9XG5udW1lcmljLlQucHJvdG90eXBlLmdldERpYWcgPSBmdW5jdGlvbiBnZXREaWFnKCkge1xuICAgIHZhciBuID0gbnVtZXJpYztcbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcbiAgICBpZih5KSB7IHJldHVybiBuZXcgbi5UKG4uZ2V0RGlhZyh4KSxuLmdldERpYWcoeSkpOyB9XG4gICAgcmV0dXJuIG5ldyBuLlQobi5nZXREaWFnKHgpKTtcbn1cblxuLy8gNC4gRWlnZW52YWx1ZXMgb2YgcmVhbCBtYXRyaWNlc1xuXG5udW1lcmljLmhvdXNlID0gZnVuY3Rpb24gaG91c2UoeCkge1xuICAgIHZhciB2ID0gbnVtZXJpYy5jbG9uZSh4KTtcbiAgICB2YXIgcyA9IHhbMF0gPj0gMCA/IDEgOiAtMTtcbiAgICB2YXIgYWxwaGEgPSBzKm51bWVyaWMubm9ybTIoeCk7XG4gICAgdlswXSArPSBhbHBoYTtcbiAgICB2YXIgZm9vID0gbnVtZXJpYy5ub3JtMih2KTtcbiAgICBpZihmb28gPT09IDApIHsgLyogdGhpcyBzaG91bGQgbm90IGhhcHBlbiAqLyB0aHJvdyBuZXcgRXJyb3IoJ2VpZzogaW50ZXJuYWwgZXJyb3InKTsgfVxuICAgIHJldHVybiBudW1lcmljLmRpdih2LGZvbyk7XG59XG5cbm51bWVyaWMudG9VcHBlckhlc3NlbmJlcmcgPSBmdW5jdGlvbiB0b1VwcGVySGVzc2VuYmVyZyhtZSkge1xuICAgIHZhciBzID0gbnVtZXJpYy5kaW0obWUpO1xuICAgIGlmKHMubGVuZ3RoICE9PSAyIHx8IHNbMF0gIT09IHNbMV0pIHsgdGhyb3cgbmV3IEVycm9yKCdudW1lcmljOiB0b1VwcGVySGVzc2VuYmVyZygpIG9ubHkgd29ya3Mgb24gc3F1YXJlIG1hdHJpY2VzJyk7IH1cbiAgICB2YXIgbSA9IHNbMF0sIGksaixrLHgsdixBID0gbnVtZXJpYy5jbG9uZShtZSksQixDLEFpLENpLFEgPSBudW1lcmljLmlkZW50aXR5KG0pLFFpO1xuICAgIGZvcihqPTA7ajxtLTI7aisrKSB7XG4gICAgICAgIHggPSBBcnJheShtLWotMSk7XG4gICAgICAgIGZvcihpPWorMTtpPG07aSsrKSB7IHhbaS1qLTFdID0gQVtpXVtqXTsgfVxuICAgICAgICBpZihudW1lcmljLm5vcm0yKHgpPjApIHtcbiAgICAgICAgICAgIHYgPSBudW1lcmljLmhvdXNlKHgpO1xuICAgICAgICAgICAgQiA9IG51bWVyaWMuZ2V0QmxvY2soQSxbaisxLGpdLFttLTEsbS0xXSk7XG4gICAgICAgICAgICBDID0gbnVtZXJpYy50ZW5zb3IodixudW1lcmljLmRvdCh2LEIpKTtcbiAgICAgICAgICAgIGZvcihpPWorMTtpPG07aSsrKSB7IEFpID0gQVtpXTsgQ2kgPSBDW2ktai0xXTsgZm9yKGs9ajtrPG07aysrKSBBaVtrXSAtPSAyKkNpW2stal07IH1cbiAgICAgICAgICAgIEIgPSBudW1lcmljLmdldEJsb2NrKEEsWzAsaisxXSxbbS0xLG0tMV0pO1xuICAgICAgICAgICAgQyA9IG51bWVyaWMudGVuc29yKG51bWVyaWMuZG90KEIsdiksdik7XG4gICAgICAgICAgICBmb3IoaT0wO2k8bTtpKyspIHsgQWkgPSBBW2ldOyBDaSA9IENbaV07IGZvcihrPWorMTtrPG07aysrKSBBaVtrXSAtPSAyKkNpW2stai0xXTsgfVxuICAgICAgICAgICAgQiA9IEFycmF5KG0tai0xKTtcbiAgICAgICAgICAgIGZvcihpPWorMTtpPG07aSsrKSBCW2ktai0xXSA9IFFbaV07XG4gICAgICAgICAgICBDID0gbnVtZXJpYy50ZW5zb3IodixudW1lcmljLmRvdCh2LEIpKTtcbiAgICAgICAgICAgIGZvcihpPWorMTtpPG07aSsrKSB7IFFpID0gUVtpXTsgQ2kgPSBDW2ktai0xXTsgZm9yKGs9MDtrPG07aysrKSBRaVtrXSAtPSAyKkNpW2tdOyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtIOkEsIFE6UX07XG59XG5cbm51bWVyaWMuZXBzaWxvbiA9IDIuMjIwNDQ2MDQ5MjUwMzEzZS0xNjtcblxubnVtZXJpYy5RUkZyYW5jaXMgPSBmdW5jdGlvbihILG1heGl0ZXIpIHtcbiAgICBpZih0eXBlb2YgbWF4aXRlciA9PT0gXCJ1bmRlZmluZWRcIikgeyBtYXhpdGVyID0gMTAwMDA7IH1cbiAgICBIID0gbnVtZXJpYy5jbG9uZShIKTtcbiAgICB2YXIgSDAgPSBudW1lcmljLmNsb25lKEgpO1xuICAgIHZhciBzID0gbnVtZXJpYy5kaW0oSCksbT1zWzBdLHgsdixhLGIsYyxkLGRldCx0ciwgSGxvYywgUSA9IG51bWVyaWMuaWRlbnRpdHkobSksIFFpLCBIaSwgQiwgQywgQ2ksaSxqLGssaXRlcjtcbiAgICBpZihtPDMpIHsgcmV0dXJuIHtROlEsIEI6WyBbMCxtLTFdIF19OyB9XG4gICAgdmFyIGVwc2lsb24gPSBudW1lcmljLmVwc2lsb247XG4gICAgZm9yKGl0ZXI9MDtpdGVyPG1heGl0ZXI7aXRlcisrKSB7XG4gICAgICAgIGZvcihqPTA7ajxtLTE7aisrKSB7XG4gICAgICAgICAgICBpZihNYXRoLmFicyhIW2orMV1bal0pIDwgZXBzaWxvbiooTWF0aC5hYnMoSFtqXVtqXSkrTWF0aC5hYnMoSFtqKzFdW2orMV0pKSkge1xuICAgICAgICAgICAgICAgIHZhciBRSDEgPSBudW1lcmljLlFSRnJhbmNpcyhudW1lcmljLmdldEJsb2NrKEgsWzAsMF0sW2osal0pLG1heGl0ZXIpO1xuICAgICAgICAgICAgICAgIHZhciBRSDIgPSBudW1lcmljLlFSRnJhbmNpcyhudW1lcmljLmdldEJsb2NrKEgsW2orMSxqKzFdLFttLTEsbS0xXSksbWF4aXRlcik7XG4gICAgICAgICAgICAgICAgQiA9IEFycmF5KGorMSk7XG4gICAgICAgICAgICAgICAgZm9yKGk9MDtpPD1qO2krKykgeyBCW2ldID0gUVtpXTsgfVxuICAgICAgICAgICAgICAgIEMgPSBudW1lcmljLmRvdChRSDEuUSxCKTtcbiAgICAgICAgICAgICAgICBmb3IoaT0wO2k8PWo7aSsrKSB7IFFbaV0gPSBDW2ldOyB9XG4gICAgICAgICAgICAgICAgQiA9IEFycmF5KG0tai0xKTtcbiAgICAgICAgICAgICAgICBmb3IoaT1qKzE7aTxtO2krKykgeyBCW2ktai0xXSA9IFFbaV07IH1cbiAgICAgICAgICAgICAgICBDID0gbnVtZXJpYy5kb3QoUUgyLlEsQik7XG4gICAgICAgICAgICAgICAgZm9yKGk9aisxO2k8bTtpKyspIHsgUVtpXSA9IENbaS1qLTFdOyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtROlEsQjpRSDEuQi5jb25jYXQobnVtZXJpYy5hZGQoUUgyLkIsaisxKSl9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGEgPSBIW20tMl1bbS0yXTsgYiA9IEhbbS0yXVttLTFdO1xuICAgICAgICBjID0gSFttLTFdW20tMl07IGQgPSBIW20tMV1bbS0xXTtcbiAgICAgICAgdHIgPSBhK2Q7XG4gICAgICAgIGRldCA9IChhKmQtYipjKTtcbiAgICAgICAgSGxvYyA9IG51bWVyaWMuZ2V0QmxvY2soSCwgWzAsMF0sIFsyLDJdKTtcbiAgICAgICAgaWYodHIqdHI+PTQqZGV0KSB7XG4gICAgICAgICAgICB2YXIgczEsczI7XG4gICAgICAgICAgICBzMSA9IDAuNSoodHIrTWF0aC5zcXJ0KHRyKnRyLTQqZGV0KSk7XG4gICAgICAgICAgICBzMiA9IDAuNSoodHItTWF0aC5zcXJ0KHRyKnRyLTQqZGV0KSk7XG4gICAgICAgICAgICBIbG9jID0gbnVtZXJpYy5hZGQobnVtZXJpYy5zdWIobnVtZXJpYy5kb3QoSGxvYyxIbG9jKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1lcmljLm11bChIbG9jLHMxK3MyKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtZXJpYy5kaWFnKG51bWVyaWMucmVwKFszXSxzMSpzMikpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEhsb2MgPSBudW1lcmljLmFkZChudW1lcmljLnN1YihudW1lcmljLmRvdChIbG9jLEhsb2MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWVyaWMubXVsKEhsb2MsdHIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1lcmljLmRpYWcobnVtZXJpYy5yZXAoWzNdLGRldCkpKTtcbiAgICAgICAgfVxuICAgICAgICB4ID0gW0hsb2NbMF1bMF0sSGxvY1sxXVswXSxIbG9jWzJdWzBdXTtcbiAgICAgICAgdiA9IG51bWVyaWMuaG91c2UoeCk7XG4gICAgICAgIEIgPSBbSFswXSxIWzFdLEhbMl1dO1xuICAgICAgICBDID0gbnVtZXJpYy50ZW5zb3IodixudW1lcmljLmRvdCh2LEIpKTtcbiAgICAgICAgZm9yKGk9MDtpPDM7aSsrKSB7IEhpID0gSFtpXTsgQ2kgPSBDW2ldOyBmb3Ioaz0wO2s8bTtrKyspIEhpW2tdIC09IDIqQ2lba107IH1cbiAgICAgICAgQiA9IG51bWVyaWMuZ2V0QmxvY2soSCwgWzAsMF0sW20tMSwyXSk7XG4gICAgICAgIEMgPSBudW1lcmljLnRlbnNvcihudW1lcmljLmRvdChCLHYpLHYpO1xuICAgICAgICBmb3IoaT0wO2k8bTtpKyspIHsgSGkgPSBIW2ldOyBDaSA9IENbaV07IGZvcihrPTA7azwzO2srKykgSGlba10gLT0gMipDaVtrXTsgfVxuICAgICAgICBCID0gW1FbMF0sUVsxXSxRWzJdXTtcbiAgICAgICAgQyA9IG51bWVyaWMudGVuc29yKHYsbnVtZXJpYy5kb3QodixCKSk7XG4gICAgICAgIGZvcihpPTA7aTwzO2krKykgeyBRaSA9IFFbaV07IENpID0gQ1tpXTsgZm9yKGs9MDtrPG07aysrKSBRaVtrXSAtPSAyKkNpW2tdOyB9XG4gICAgICAgIHZhciBKO1xuICAgICAgICBmb3Ioaj0wO2o8bS0yO2orKykge1xuICAgICAgICAgICAgZm9yKGs9ajtrPD1qKzE7aysrKSB7XG4gICAgICAgICAgICAgICAgaWYoTWF0aC5hYnMoSFtrKzFdW2tdKSA8IGVwc2lsb24qKE1hdGguYWJzKEhba11ba10pK01hdGguYWJzKEhbaysxXVtrKzFdKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFFIMSA9IG51bWVyaWMuUVJGcmFuY2lzKG51bWVyaWMuZ2V0QmxvY2soSCxbMCwwXSxbayxrXSksbWF4aXRlcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBRSDIgPSBudW1lcmljLlFSRnJhbmNpcyhudW1lcmljLmdldEJsb2NrKEgsW2srMSxrKzFdLFttLTEsbS0xXSksbWF4aXRlcik7XG4gICAgICAgICAgICAgICAgICAgIEIgPSBBcnJheShrKzEpO1xuICAgICAgICAgICAgICAgICAgICBmb3IoaT0wO2k8PWs7aSsrKSB7IEJbaV0gPSBRW2ldOyB9XG4gICAgICAgICAgICAgICAgICAgIEMgPSBudW1lcmljLmRvdChRSDEuUSxCKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGk9MDtpPD1rO2krKykgeyBRW2ldID0gQ1tpXTsgfVxuICAgICAgICAgICAgICAgICAgICBCID0gQXJyYXkobS1rLTEpO1xuICAgICAgICAgICAgICAgICAgICBmb3IoaT1rKzE7aTxtO2krKykgeyBCW2ktay0xXSA9IFFbaV07IH1cbiAgICAgICAgICAgICAgICAgICAgQyA9IG51bWVyaWMuZG90KFFIMi5RLEIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IoaT1rKzE7aTxtO2krKykgeyBRW2ldID0gQ1tpLWstMV07IH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtROlEsQjpRSDEuQi5jb25jYXQobnVtZXJpYy5hZGQoUUgyLkIsaysxKSl9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEogPSBNYXRoLm1pbihtLTEsaiszKTtcbiAgICAgICAgICAgIHggPSBBcnJheShKLWopO1xuICAgICAgICAgICAgZm9yKGk9aisxO2k8PUo7aSsrKSB7IHhbaS1qLTFdID0gSFtpXVtqXTsgfVxuICAgICAgICAgICAgdiA9IG51bWVyaWMuaG91c2UoeCk7XG4gICAgICAgICAgICBCID0gbnVtZXJpYy5nZXRCbG9jayhILCBbaisxLGpdLFtKLG0tMV0pO1xuICAgICAgICAgICAgQyA9IG51bWVyaWMudGVuc29yKHYsbnVtZXJpYy5kb3QodixCKSk7XG4gICAgICAgICAgICBmb3IoaT1qKzE7aTw9SjtpKyspIHsgSGkgPSBIW2ldOyBDaSA9IENbaS1qLTFdOyBmb3Ioaz1qO2s8bTtrKyspIEhpW2tdIC09IDIqQ2lbay1qXTsgfVxuICAgICAgICAgICAgQiA9IG51bWVyaWMuZ2V0QmxvY2soSCwgWzAsaisxXSxbbS0xLEpdKTtcbiAgICAgICAgICAgIEMgPSBudW1lcmljLnRlbnNvcihudW1lcmljLmRvdChCLHYpLHYpO1xuICAgICAgICAgICAgZm9yKGk9MDtpPG07aSsrKSB7IEhpID0gSFtpXTsgQ2kgPSBDW2ldOyBmb3Ioaz1qKzE7azw9SjtrKyspIEhpW2tdIC09IDIqQ2lbay1qLTFdOyB9XG4gICAgICAgICAgICBCID0gQXJyYXkoSi1qKTtcbiAgICAgICAgICAgIGZvcihpPWorMTtpPD1KO2krKykgQltpLWotMV0gPSBRW2ldO1xuICAgICAgICAgICAgQyA9IG51bWVyaWMudGVuc29yKHYsbnVtZXJpYy5kb3QodixCKSk7XG4gICAgICAgICAgICBmb3IoaT1qKzE7aTw9SjtpKyspIHsgUWkgPSBRW2ldOyBDaSA9IENbaS1qLTFdOyBmb3Ioaz0wO2s8bTtrKyspIFFpW2tdIC09IDIqQ2lba107IH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWVyaWM6IGVpZ2VudmFsdWUgaXRlcmF0aW9uIGRvZXMgbm90IGNvbnZlcmdlIC0tIGluY3JlYXNlIG1heGl0ZXI/Jyk7XG59XG5cbm51bWVyaWMuZWlnID0gZnVuY3Rpb24gZWlnKEEsbWF4aXRlcikge1xuICAgIHZhciBRSCA9IG51bWVyaWMudG9VcHBlckhlc3NlbmJlcmcoQSk7XG4gICAgdmFyIFFCID0gbnVtZXJpYy5RUkZyYW5jaXMoUUguSCxtYXhpdGVyKTtcbiAgICB2YXIgVCA9IG51bWVyaWMuVDtcbiAgICB2YXIgbiA9IEEubGVuZ3RoLGksayxmbGFnID0gZmFsc2UsQiA9IFFCLkIsSCA9IG51bWVyaWMuZG90KFFCLlEsbnVtZXJpYy5kb3QoUUguSCxudW1lcmljLnRyYW5zcG9zZShRQi5RKSkpO1xuICAgIHZhciBRID0gbmV3IFQobnVtZXJpYy5kb3QoUUIuUSxRSC5RKSksUTA7XG4gICAgdmFyIG0gPSBCLmxlbmd0aCxqO1xuICAgIHZhciBhLGIsYyxkLHAxLHAyLGRpc2MseCx5LHAscSxuMSxuMjtcbiAgICB2YXIgc3FydCA9IE1hdGguc3FydDtcbiAgICBmb3Ioaz0wO2s8bTtrKyspIHtcbiAgICAgICAgaSA9IEJba11bMF07XG4gICAgICAgIGlmKGkgPT09IEJba11bMV0pIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGogPSBpKzE7XG4gICAgICAgICAgICBhID0gSFtpXVtpXTtcbiAgICAgICAgICAgIGIgPSBIW2ldW2pdO1xuICAgICAgICAgICAgYyA9IEhbal1baV07XG4gICAgICAgICAgICBkID0gSFtqXVtqXTtcbiAgICAgICAgICAgIGlmKGIgPT09IDAgJiYgYyA9PT0gMCkgY29udGludWU7XG4gICAgICAgICAgICBwMSA9IC1hLWQ7XG4gICAgICAgICAgICBwMiA9IGEqZC1iKmM7XG4gICAgICAgICAgICBkaXNjID0gcDEqcDEtNCpwMjtcbiAgICAgICAgICAgIGlmKGRpc2M+PTApIHtcbiAgICAgICAgICAgICAgICBpZihwMTwwKSB4ID0gLTAuNSoocDEtc3FydChkaXNjKSk7XG4gICAgICAgICAgICAgICAgZWxzZSAgICAgeCA9IC0wLjUqKHAxK3NxcnQoZGlzYykpO1xuICAgICAgICAgICAgICAgIG4xID0gKGEteCkqKGEteCkrYipiO1xuICAgICAgICAgICAgICAgIG4yID0gYypjKyhkLXgpKihkLXgpO1xuICAgICAgICAgICAgICAgIGlmKG4xPm4yKSB7XG4gICAgICAgICAgICAgICAgICAgIG4xID0gc3FydChuMSk7XG4gICAgICAgICAgICAgICAgICAgIHAgPSAoYS14KS9uMTtcbiAgICAgICAgICAgICAgICAgICAgcSA9IGIvbjE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbjIgPSBzcXJ0KG4yKTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IGMvbjI7XG4gICAgICAgICAgICAgICAgICAgIHEgPSAoZC14KS9uMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUTAgPSBuZXcgVChbW3EsLXBdLFtwLHFdXSk7XG4gICAgICAgICAgICAgICAgUS5zZXRSb3dzKGksaixRMC5kb3QoUS5nZXRSb3dzKGksaikpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeCA9IC0wLjUqcDE7XG4gICAgICAgICAgICAgICAgeSA9IDAuNSpzcXJ0KC1kaXNjKTtcbiAgICAgICAgICAgICAgICBuMSA9IChhLXgpKihhLXgpK2IqYjtcbiAgICAgICAgICAgICAgICBuMiA9IGMqYysoZC14KSooZC14KTtcbiAgICAgICAgICAgICAgICBpZihuMT5uMikge1xuICAgICAgICAgICAgICAgICAgICBuMSA9IHNxcnQobjEreSp5KTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IChhLXgpL24xO1xuICAgICAgICAgICAgICAgICAgICBxID0gYi9uMTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHkgLz0gbjE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbjIgPSBzcXJ0KG4yK3kqeSk7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBjL24yO1xuICAgICAgICAgICAgICAgICAgICBxID0gKGQteCkvbjI7XG4gICAgICAgICAgICAgICAgICAgIHggPSB5L24yO1xuICAgICAgICAgICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUTAgPSBuZXcgVChbW3EsLXBdLFtwLHFdXSxbW3gseV0sW3ksLXhdXSk7XG4gICAgICAgICAgICAgICAgUS5zZXRSb3dzKGksaixRMC5kb3QoUS5nZXRSb3dzKGksaikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgUiA9IFEuZG90KEEpLmRvdChRLnRyYW5zanVnYXRlKCkpLCBuID0gQS5sZW5ndGgsIEUgPSBudW1lcmljLlQuaWRlbnRpdHkobik7XG4gICAgZm9yKGo9MDtqPG47aisrKSB7XG4gICAgICAgIGlmKGo+MCkge1xuICAgICAgICAgICAgZm9yKGs9ai0xO2s+PTA7ay0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIFJrID0gUi5nZXQoW2ssa10pLCBSaiA9IFIuZ2V0KFtqLGpdKTtcbiAgICAgICAgICAgICAgICBpZihudW1lcmljLm5lcShSay54LFJqLngpIHx8IG51bWVyaWMubmVxKFJrLnksUmoueSkpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IFIuZ2V0Um93KGspLmdldEJsb2NrKFtrXSxbai0xXSk7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBFLmdldFJvdyhqKS5nZXRCbG9jayhba10sW2otMV0pO1xuICAgICAgICAgICAgICAgICAgICBFLnNldChbaixrXSwoUi5nZXQoW2ssal0pLm5lZygpLnN1Yih4LmRvdCh5KSkpLmRpdihSay5zdWIoUmopKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgRS5zZXRSb3coaixFLmdldFJvdyhrKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3Ioaj0wO2o8bjtqKyspIHtcbiAgICAgICAgeCA9IEUuZ2V0Um93KGopO1xuICAgICAgICBFLnNldFJvdyhqLHguZGl2KHgubm9ybTIoKSkpO1xuICAgIH1cbiAgICBFID0gRS50cmFuc3Bvc2UoKTtcbiAgICBFID0gUS50cmFuc2p1Z2F0ZSgpLmRvdChFKTtcbiAgICByZXR1cm4geyBsYW1iZGE6Ui5nZXREaWFnKCksIEU6RSB9O1xufTtcblxuLy8gNS4gQ29tcHJlc3NlZCBDb2x1bW4gU3RvcmFnZSBtYXRyaWNlc1xubnVtZXJpYy5jY3NTcGFyc2UgPSBmdW5jdGlvbiBjY3NTcGFyc2UoQSkge1xuICAgIHZhciBtID0gQS5sZW5ndGgsbixmb28sIGksaiwgY291bnRzID0gW107XG4gICAgZm9yKGk9bS0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgZm9vID0gQVtpXTtcbiAgICAgICAgZm9yKGogaW4gZm9vKSB7XG4gICAgICAgICAgICBqID0gcGFyc2VJbnQoaik7XG4gICAgICAgICAgICB3aGlsZShqPj1jb3VudHMubGVuZ3RoKSBjb3VudHNbY291bnRzLmxlbmd0aF0gPSAwO1xuICAgICAgICAgICAgaWYoZm9vW2pdIT09MCkgY291bnRzW2pdKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIG4gPSBjb3VudHMubGVuZ3RoO1xuICAgIHZhciBBaSA9IEFycmF5KG4rMSk7XG4gICAgQWlbMF0gPSAwO1xuICAgIGZvcihpPTA7aTxuOysraSkgQWlbaSsxXSA9IEFpW2ldICsgY291bnRzW2ldO1xuICAgIHZhciBBaiA9IEFycmF5KEFpW25dKSwgQXYgPSBBcnJheShBaVtuXSk7XG4gICAgZm9yKGk9bS0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgZm9vID0gQVtpXTtcbiAgICAgICAgZm9yKGogaW4gZm9vKSB7XG4gICAgICAgICAgICBpZihmb29bal0hPT0wKSB7XG4gICAgICAgICAgICAgICAgY291bnRzW2pdLS07XG4gICAgICAgICAgICAgICAgQWpbQWlbal0rY291bnRzW2pdXSA9IGk7XG4gICAgICAgICAgICAgICAgQXZbQWlbal0rY291bnRzW2pdXSA9IGZvb1tqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW0FpLEFqLEF2XTtcbn1cbm51bWVyaWMuY2NzRnVsbCA9IGZ1bmN0aW9uIGNjc0Z1bGwoQSkge1xuICAgIHZhciBBaSA9IEFbMF0sIEFqID0gQVsxXSwgQXYgPSBBWzJdLCBzID0gbnVtZXJpYy5jY3NEaW0oQSksIG0gPSBzWzBdLCBuID0gc1sxXSwgaSxqLGowLGoxLGs7XG4gICAgdmFyIEIgPSBudW1lcmljLnJlcChbbSxuXSwwKTtcbiAgICBmb3IoaT0wO2k8bjtpKyspIHtcbiAgICAgICAgajAgPSBBaVtpXTtcbiAgICAgICAgajEgPSBBaVtpKzFdO1xuICAgICAgICBmb3Ioaj1qMDtqPGoxOysraikgeyBCW0FqW2pdXVtpXSA9IEF2W2pdOyB9XG4gICAgfVxuICAgIHJldHVybiBCO1xufVxubnVtZXJpYy5jY3NUU29sdmUgPSBmdW5jdGlvbiBjY3NUU29sdmUoQSxiLHgsYmoseGopIHtcbiAgICB2YXIgQWkgPSBBWzBdLCBBaiA9IEFbMV0sIEF2ID0gQVsyXSxtID0gQWkubGVuZ3RoLTEsIG1heCA9IE1hdGgubWF4LG49MDtcbiAgICBpZih0eXBlb2YgYmogPT09IFwidW5kZWZpbmVkXCIpIHggPSBudW1lcmljLnJlcChbbV0sMCk7XG4gICAgaWYodHlwZW9mIGJqID09PSBcInVuZGVmaW5lZFwiKSBiaiA9IG51bWVyaWMubGluc3BhY2UoMCx4Lmxlbmd0aC0xKTtcbiAgICBpZih0eXBlb2YgeGogPT09IFwidW5kZWZpbmVkXCIpIHhqID0gW107XG4gICAgZnVuY3Rpb24gZGZzKGopIHtcbiAgICAgICAgdmFyIGs7XG4gICAgICAgIGlmKHhbal0gIT09IDApIHJldHVybjtcbiAgICAgICAgeFtqXSA9IDE7XG4gICAgICAgIGZvcihrPUFpW2pdO2s8QWlbaisxXTsrK2spIGRmcyhBaltrXSk7XG4gICAgICAgIHhqW25dID0gajtcbiAgICAgICAgKytuO1xuICAgIH1cbiAgICB2YXIgaSxqLGowLGoxLGssbCxsMCxsMSxhO1xuICAgIGZvcihpPWJqLmxlbmd0aC0xO2khPT0tMTstLWkpIHsgZGZzKGJqW2ldKTsgfVxuICAgIHhqLmxlbmd0aCA9IG47XG4gICAgZm9yKGk9eGoubGVuZ3RoLTE7aSE9PS0xOy0taSkgeyB4W3hqW2ldXSA9IDA7IH1cbiAgICBmb3IoaT1iai5sZW5ndGgtMTtpIT09LTE7LS1pKSB7IGogPSBialtpXTsgeFtqXSA9IGJbal07IH1cbiAgICBmb3IoaT14ai5sZW5ndGgtMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIGogPSB4altpXTtcbiAgICAgICAgajAgPSBBaVtqXTtcbiAgICAgICAgajEgPSBtYXgoQWlbaisxXSxqMCk7XG4gICAgICAgIGZvcihrPWowO2shPT1qMTsrK2spIHsgaWYoQWpba10gPT09IGopIHsgeFtqXSAvPSBBdltrXTsgYnJlYWs7IH0gfVxuICAgICAgICBhID0geFtqXTtcbiAgICAgICAgZm9yKGs9ajA7ayE9PWoxOysraykge1xuICAgICAgICAgICAgbCA9IEFqW2tdO1xuICAgICAgICAgICAgaWYobCAhPT0gaikgeFtsXSAtPSBhKkF2W2tdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB4O1xufVxubnVtZXJpYy5jY3NERlMgPSBmdW5jdGlvbiBjY3NERlMobikge1xuICAgIHRoaXMuayA9IEFycmF5KG4pO1xuICAgIHRoaXMuazEgPSBBcnJheShuKTtcbiAgICB0aGlzLmogPSBBcnJheShuKTtcbn1cbm51bWVyaWMuY2NzREZTLnByb3RvdHlwZS5kZnMgPSBmdW5jdGlvbiBkZnMoSixBaSxBaix4LHhqLFBpbnYpIHtcbiAgICB2YXIgbSA9IDAsZm9vLG49eGoubGVuZ3RoO1xuICAgIHZhciBrID0gdGhpcy5rLCBrMSA9IHRoaXMuazEsIGogPSB0aGlzLmosa20sazExO1xuICAgIGlmKHhbSl0hPT0wKSByZXR1cm47XG4gICAgeFtKXSA9IDE7XG4gICAgalswXSA9IEo7XG4gICAga1swXSA9IGttID0gQWlbSl07XG4gICAgazFbMF0gPSBrMTEgPSBBaVtKKzFdO1xuICAgIHdoaWxlKDEpIHtcbiAgICAgICAgaWYoa20gPj0gazExKSB7XG4gICAgICAgICAgICB4altuXSA9IGpbbV07XG4gICAgICAgICAgICBpZihtPT09MCkgcmV0dXJuO1xuICAgICAgICAgICAgKytuO1xuICAgICAgICAgICAgLS1tO1xuICAgICAgICAgICAga20gPSBrW21dO1xuICAgICAgICAgICAgazExID0gazFbbV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb28gPSBQaW52W0FqW2ttXV07XG4gICAgICAgICAgICBpZih4W2Zvb10gPT09IDApIHtcbiAgICAgICAgICAgICAgICB4W2Zvb10gPSAxO1xuICAgICAgICAgICAgICAgIGtbbV0gPSBrbTtcbiAgICAgICAgICAgICAgICArK207XG4gICAgICAgICAgICAgICAgalttXSA9IGZvbztcbiAgICAgICAgICAgICAgICBrbSA9IEFpW2Zvb107XG4gICAgICAgICAgICAgICAgazFbbV0gPSBrMTEgPSBBaVtmb28rMV07XG4gICAgICAgICAgICB9IGVsc2UgKytrbTtcbiAgICAgICAgfVxuICAgIH1cbn1cbm51bWVyaWMuY2NzTFBTb2x2ZSA9IGZ1bmN0aW9uIGNjc0xQU29sdmUoQSxCLHgseGosSSxQaW52LGRmcykge1xuICAgIHZhciBBaSA9IEFbMF0sIEFqID0gQVsxXSwgQXYgPSBBWzJdLG0gPSBBaS5sZW5ndGgtMSwgbj0wO1xuICAgIHZhciBCaSA9IEJbMF0sIEJqID0gQlsxXSwgQnYgPSBCWzJdO1xuICAgIFxuICAgIHZhciBpLGkwLGkxLGosSixqMCxqMSxrLGwsbDAsbDEsYTtcbiAgICBpMCA9IEJpW0ldO1xuICAgIGkxID0gQmlbSSsxXTtcbiAgICB4ai5sZW5ndGggPSAwO1xuICAgIGZvcihpPWkwO2k8aTE7KytpKSB7IGRmcy5kZnMoUGludltCaltpXV0sQWksQWoseCx4aixQaW52KTsgfVxuICAgIGZvcihpPXhqLmxlbmd0aC0xO2khPT0tMTstLWkpIHsgeFt4altpXV0gPSAwOyB9XG4gICAgZm9yKGk9aTA7aSE9PWkxOysraSkgeyBqID0gUGludltCaltpXV07IHhbal0gPSBCdltpXTsgfVxuICAgIGZvcihpPXhqLmxlbmd0aC0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgaiA9IHhqW2ldO1xuICAgICAgICBqMCA9IEFpW2pdO1xuICAgICAgICBqMSA9IEFpW2orMV07XG4gICAgICAgIGZvcihrPWowO2s8ajE7KytrKSB7IGlmKFBpbnZbQWpba11dID09PSBqKSB7IHhbal0gLz0gQXZba107IGJyZWFrOyB9IH1cbiAgICAgICAgYSA9IHhbal07XG4gICAgICAgIGZvcihrPWowO2s8ajE7KytrKSB7XG4gICAgICAgICAgICBsID0gUGludltBaltrXV07XG4gICAgICAgICAgICBpZihsICE9PSBqKSB4W2xdIC09IGEqQXZba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHg7XG59XG5udW1lcmljLmNjc0xVUDEgPSBmdW5jdGlvbiBjY3NMVVAxKEEsdGhyZXNob2xkKSB7XG4gICAgdmFyIG0gPSBBWzBdLmxlbmd0aC0xO1xuICAgIHZhciBMID0gW251bWVyaWMucmVwKFttKzFdLDApLFtdLFtdXSwgVSA9IFtudW1lcmljLnJlcChbbSsxXSwgMCksW10sW11dO1xuICAgIHZhciBMaSA9IExbMF0sIExqID0gTFsxXSwgTHYgPSBMWzJdLCBVaSA9IFVbMF0sIFVqID0gVVsxXSwgVXYgPSBVWzJdO1xuICAgIHZhciB4ID0gbnVtZXJpYy5yZXAoW21dLDApLCB4aiA9IG51bWVyaWMucmVwKFttXSwwKTtcbiAgICB2YXIgaSxqLGssajAsajEsYSxlLGMsZCxLO1xuICAgIHZhciBzb2wgPSBudW1lcmljLmNjc0xQU29sdmUsIG1heCA9IE1hdGgubWF4LCBhYnMgPSBNYXRoLmFicztcbiAgICB2YXIgUCA9IG51bWVyaWMubGluc3BhY2UoMCxtLTEpLFBpbnYgPSBudW1lcmljLmxpbnNwYWNlKDAsbS0xKTtcbiAgICB2YXIgZGZzID0gbmV3IG51bWVyaWMuY2NzREZTKG0pO1xuICAgIGlmKHR5cGVvZiB0aHJlc2hvbGQgPT09IFwidW5kZWZpbmVkXCIpIHsgdGhyZXNob2xkID0gMTsgfVxuICAgIGZvcihpPTA7aTxtOysraSkge1xuICAgICAgICBzb2woTCxBLHgseGosaSxQaW52LGRmcyk7XG4gICAgICAgIGEgPSAtMTtcbiAgICAgICAgZSA9IC0xO1xuICAgICAgICBmb3Ioaj14ai5sZW5ndGgtMTtqIT09LTE7LS1qKSB7XG4gICAgICAgICAgICBrID0geGpbal07XG4gICAgICAgICAgICBpZihrIDw9IGkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgYyA9IGFicyh4W2tdKTtcbiAgICAgICAgICAgIGlmKGMgPiBhKSB7IGUgPSBrOyBhID0gYzsgfVxuICAgICAgICB9XG4gICAgICAgIGlmKGFicyh4W2ldKTx0aHJlc2hvbGQqYSkge1xuICAgICAgICAgICAgaiA9IFBbaV07XG4gICAgICAgICAgICBhID0gUFtlXTtcbiAgICAgICAgICAgIFBbaV0gPSBhOyBQaW52W2FdID0gaTtcbiAgICAgICAgICAgIFBbZV0gPSBqOyBQaW52W2pdID0gZTtcbiAgICAgICAgICAgIGEgPSB4W2ldOyB4W2ldID0geFtlXTsgeFtlXSA9IGE7XG4gICAgICAgIH1cbiAgICAgICAgYSA9IExpW2ldO1xuICAgICAgICBlID0gVWlbaV07XG4gICAgICAgIGQgPSB4W2ldO1xuICAgICAgICBMalthXSA9IFBbaV07XG4gICAgICAgIEx2W2FdID0gMTtcbiAgICAgICAgKythO1xuICAgICAgICBmb3Ioaj14ai5sZW5ndGgtMTtqIT09LTE7LS1qKSB7XG4gICAgICAgICAgICBrID0geGpbal07XG4gICAgICAgICAgICBjID0geFtrXTtcbiAgICAgICAgICAgIHhqW2pdID0gMDtcbiAgICAgICAgICAgIHhba10gPSAwO1xuICAgICAgICAgICAgaWYoazw9aSkgeyBValtlXSA9IGs7IFV2W2VdID0gYzsgICArK2U7IH1cbiAgICAgICAgICAgIGVsc2UgICAgIHsgTGpbYV0gPSBQW2tdOyBMdlthXSA9IGMvZDsgKythOyB9XG4gICAgICAgIH1cbiAgICAgICAgTGlbaSsxXSA9IGE7XG4gICAgICAgIFVpW2krMV0gPSBlO1xuICAgIH1cbiAgICBmb3Ioaj1Mai5sZW5ndGgtMTtqIT09LTE7LS1qKSB7IExqW2pdID0gUGludltMaltqXV07IH1cbiAgICByZXR1cm4ge0w6TCwgVTpVLCBQOlAsIFBpbnY6UGludn07XG59XG5udW1lcmljLmNjc0RGUzAgPSBmdW5jdGlvbiBjY3NERlMwKG4pIHtcbiAgICB0aGlzLmsgPSBBcnJheShuKTtcbiAgICB0aGlzLmsxID0gQXJyYXkobik7XG4gICAgdGhpcy5qID0gQXJyYXkobik7XG59XG5udW1lcmljLmNjc0RGUzAucHJvdG90eXBlLmRmcyA9IGZ1bmN0aW9uIGRmcyhKLEFpLEFqLHgseGosUGludixQKSB7XG4gICAgdmFyIG0gPSAwLGZvbyxuPXhqLmxlbmd0aDtcbiAgICB2YXIgayA9IHRoaXMuaywgazEgPSB0aGlzLmsxLCBqID0gdGhpcy5qLGttLGsxMTtcbiAgICBpZih4W0pdIT09MCkgcmV0dXJuO1xuICAgIHhbSl0gPSAxO1xuICAgIGpbMF0gPSBKO1xuICAgIGtbMF0gPSBrbSA9IEFpW1BpbnZbSl1dO1xuICAgIGsxWzBdID0gazExID0gQWlbUGludltKXSsxXTtcbiAgICB3aGlsZSgxKSB7XG4gICAgICAgIGlmKGlzTmFOKGttKSkgdGhyb3cgbmV3IEVycm9yKFwiT3chXCIpO1xuICAgICAgICBpZihrbSA+PSBrMTEpIHtcbiAgICAgICAgICAgIHhqW25dID0gUGludltqW21dXTtcbiAgICAgICAgICAgIGlmKG09PT0wKSByZXR1cm47XG4gICAgICAgICAgICArK247XG4gICAgICAgICAgICAtLW07XG4gICAgICAgICAgICBrbSA9IGtbbV07XG4gICAgICAgICAgICBrMTEgPSBrMVttXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvbyA9IEFqW2ttXTtcbiAgICAgICAgICAgIGlmKHhbZm9vXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHhbZm9vXSA9IDE7XG4gICAgICAgICAgICAgICAga1ttXSA9IGttO1xuICAgICAgICAgICAgICAgICsrbTtcbiAgICAgICAgICAgICAgICBqW21dID0gZm9vO1xuICAgICAgICAgICAgICAgIGZvbyA9IFBpbnZbZm9vXTtcbiAgICAgICAgICAgICAgICBrbSA9IEFpW2Zvb107XG4gICAgICAgICAgICAgICAgazFbbV0gPSBrMTEgPSBBaVtmb28rMV07XG4gICAgICAgICAgICB9IGVsc2UgKytrbTtcbiAgICAgICAgfVxuICAgIH1cbn1cbm51bWVyaWMuY2NzTFBTb2x2ZTAgPSBmdW5jdGlvbiBjY3NMUFNvbHZlMChBLEIseSx4aixJLFBpbnYsUCxkZnMpIHtcbiAgICB2YXIgQWkgPSBBWzBdLCBBaiA9IEFbMV0sIEF2ID0gQVsyXSxtID0gQWkubGVuZ3RoLTEsIG49MDtcbiAgICB2YXIgQmkgPSBCWzBdLCBCaiA9IEJbMV0sIEJ2ID0gQlsyXTtcbiAgICBcbiAgICB2YXIgaSxpMCxpMSxqLEosajAsajEsayxsLGwwLGwxLGE7XG4gICAgaTAgPSBCaVtJXTtcbiAgICBpMSA9IEJpW0krMV07XG4gICAgeGoubGVuZ3RoID0gMDtcbiAgICBmb3IoaT1pMDtpPGkxOysraSkgeyBkZnMuZGZzKEJqW2ldLEFpLEFqLHkseGosUGludixQKTsgfVxuICAgIGZvcihpPXhqLmxlbmd0aC0xO2khPT0tMTstLWkpIHsgaiA9IHhqW2ldOyB5W1Bbal1dID0gMDsgfVxuICAgIGZvcihpPWkwO2khPT1pMTsrK2kpIHsgaiA9IEJqW2ldOyB5W2pdID0gQnZbaV07IH1cbiAgICBmb3IoaT14ai5sZW5ndGgtMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIGogPSB4altpXTtcbiAgICAgICAgbCA9IFBbal07XG4gICAgICAgIGowID0gQWlbal07XG4gICAgICAgIGoxID0gQWlbaisxXTtcbiAgICAgICAgZm9yKGs9ajA7azxqMTsrK2spIHsgaWYoQWpba10gPT09IGwpIHsgeVtsXSAvPSBBdltrXTsgYnJlYWs7IH0gfVxuICAgICAgICBhID0geVtsXTtcbiAgICAgICAgZm9yKGs9ajA7azxqMTsrK2spIHlbQWpba11dIC09IGEqQXZba107XG4gICAgICAgIHlbbF0gPSBhO1xuICAgIH1cbn1cbm51bWVyaWMuY2NzTFVQMCA9IGZ1bmN0aW9uIGNjc0xVUDAoQSx0aHJlc2hvbGQpIHtcbiAgICB2YXIgbSA9IEFbMF0ubGVuZ3RoLTE7XG4gICAgdmFyIEwgPSBbbnVtZXJpYy5yZXAoW20rMV0sMCksW10sW11dLCBVID0gW251bWVyaWMucmVwKFttKzFdLCAwKSxbXSxbXV07XG4gICAgdmFyIExpID0gTFswXSwgTGogPSBMWzFdLCBMdiA9IExbMl0sIFVpID0gVVswXSwgVWogPSBVWzFdLCBVdiA9IFVbMl07XG4gICAgdmFyIHkgPSBudW1lcmljLnJlcChbbV0sMCksIHhqID0gbnVtZXJpYy5yZXAoW21dLDApO1xuICAgIHZhciBpLGosayxqMCxqMSxhLGUsYyxkLEs7XG4gICAgdmFyIHNvbCA9IG51bWVyaWMuY2NzTFBTb2x2ZTAsIG1heCA9IE1hdGgubWF4LCBhYnMgPSBNYXRoLmFicztcbiAgICB2YXIgUCA9IG51bWVyaWMubGluc3BhY2UoMCxtLTEpLFBpbnYgPSBudW1lcmljLmxpbnNwYWNlKDAsbS0xKTtcbiAgICB2YXIgZGZzID0gbmV3IG51bWVyaWMuY2NzREZTMChtKTtcbiAgICBpZih0eXBlb2YgdGhyZXNob2xkID09PSBcInVuZGVmaW5lZFwiKSB7IHRocmVzaG9sZCA9IDE7IH1cbiAgICBmb3IoaT0wO2k8bTsrK2kpIHtcbiAgICAgICAgc29sKEwsQSx5LHhqLGksUGludixQLGRmcyk7XG4gICAgICAgIGEgPSAtMTtcbiAgICAgICAgZSA9IC0xO1xuICAgICAgICBmb3Ioaj14ai5sZW5ndGgtMTtqIT09LTE7LS1qKSB7XG4gICAgICAgICAgICBrID0geGpbal07XG4gICAgICAgICAgICBpZihrIDw9IGkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgYyA9IGFicyh5W1Bba11dKTtcbiAgICAgICAgICAgIGlmKGMgPiBhKSB7IGUgPSBrOyBhID0gYzsgfVxuICAgICAgICB9XG4gICAgICAgIGlmKGFicyh5W1BbaV1dKTx0aHJlc2hvbGQqYSkge1xuICAgICAgICAgICAgaiA9IFBbaV07XG4gICAgICAgICAgICBhID0gUFtlXTtcbiAgICAgICAgICAgIFBbaV0gPSBhOyBQaW52W2FdID0gaTtcbiAgICAgICAgICAgIFBbZV0gPSBqOyBQaW52W2pdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBhID0gTGlbaV07XG4gICAgICAgIGUgPSBVaVtpXTtcbiAgICAgICAgZCA9IHlbUFtpXV07XG4gICAgICAgIExqW2FdID0gUFtpXTtcbiAgICAgICAgTHZbYV0gPSAxO1xuICAgICAgICArK2E7XG4gICAgICAgIGZvcihqPXhqLmxlbmd0aC0xO2ohPT0tMTstLWopIHtcbiAgICAgICAgICAgIGsgPSB4altqXTtcbiAgICAgICAgICAgIGMgPSB5W1Bba11dO1xuICAgICAgICAgICAgeGpbal0gPSAwO1xuICAgICAgICAgICAgeVtQW2tdXSA9IDA7XG4gICAgICAgICAgICBpZihrPD1pKSB7IFVqW2VdID0gazsgVXZbZV0gPSBjOyAgICsrZTsgfVxuICAgICAgICAgICAgZWxzZSAgICAgeyBMalthXSA9IFBba107IEx2W2FdID0gYy9kOyArK2E7IH1cbiAgICAgICAgfVxuICAgICAgICBMaVtpKzFdID0gYTtcbiAgICAgICAgVWlbaSsxXSA9IGU7XG4gICAgfVxuICAgIGZvcihqPUxqLmxlbmd0aC0xO2ohPT0tMTstLWopIHsgTGpbal0gPSBQaW52W0xqW2pdXTsgfVxuICAgIHJldHVybiB7TDpMLCBVOlUsIFA6UCwgUGludjpQaW52fTtcbn1cbm51bWVyaWMuY2NzTFVQID0gbnVtZXJpYy5jY3NMVVAwO1xuXG5udW1lcmljLmNjc0RpbSA9IGZ1bmN0aW9uIGNjc0RpbShBKSB7IHJldHVybiBbbnVtZXJpYy5zdXAoQVsxXSkrMSxBWzBdLmxlbmd0aC0xXTsgfVxubnVtZXJpYy5jY3NHZXRCbG9jayA9IGZ1bmN0aW9uIGNjc0dldEJsb2NrKEEsaSxqKSB7XG4gICAgdmFyIHMgPSBudW1lcmljLmNjc0RpbShBKSxtPXNbMF0sbj1zWzFdO1xuICAgIGlmKHR5cGVvZiBpID09PSBcInVuZGVmaW5lZFwiKSB7IGkgPSBudW1lcmljLmxpbnNwYWNlKDAsbS0xKTsgfVxuICAgIGVsc2UgaWYodHlwZW9mIGkgPT09IFwibnVtYmVyXCIpIHsgaSA9IFtpXTsgfVxuICAgIGlmKHR5cGVvZiBqID09PSBcInVuZGVmaW5lZFwiKSB7IGogPSBudW1lcmljLmxpbnNwYWNlKDAsbi0xKTsgfVxuICAgIGVsc2UgaWYodHlwZW9mIGogPT09IFwibnVtYmVyXCIpIHsgaiA9IFtqXTsgfVxuICAgIHZhciBwLHAwLHAxLFAgPSBpLmxlbmd0aCxxLFEgPSBqLmxlbmd0aCxyLGpxLGlwO1xuICAgIHZhciBCaSA9IG51bWVyaWMucmVwKFtuXSwwKSwgQmo9W10sIEJ2PVtdLCBCID0gW0JpLEJqLEJ2XTtcbiAgICB2YXIgQWkgPSBBWzBdLCBBaiA9IEFbMV0sIEF2ID0gQVsyXTtcbiAgICB2YXIgeCA9IG51bWVyaWMucmVwKFttXSwwKSxjb3VudD0wLGZsYWdzID0gbnVtZXJpYy5yZXAoW21dLDApO1xuICAgIGZvcihxPTA7cTxROysrcSkge1xuICAgICAgICBqcSA9IGpbcV07XG4gICAgICAgIHZhciBxMCA9IEFpW2pxXTtcbiAgICAgICAgdmFyIHExID0gQWlbanErMV07XG4gICAgICAgIGZvcihwPXEwO3A8cTE7KytwKSB7XG4gICAgICAgICAgICByID0gQWpbcF07XG4gICAgICAgICAgICBmbGFnc1tyXSA9IDE7XG4gICAgICAgICAgICB4W3JdID0gQXZbcF07XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHA9MDtwPFA7KytwKSB7XG4gICAgICAgICAgICBpcCA9IGlbcF07XG4gICAgICAgICAgICBpZihmbGFnc1tpcF0pIHtcbiAgICAgICAgICAgICAgICBCaltjb3VudF0gPSBwO1xuICAgICAgICAgICAgICAgIEJ2W2NvdW50XSA9IHhbaVtwXV07XG4gICAgICAgICAgICAgICAgKytjb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IocD1xMDtwPHExOysrcCkge1xuICAgICAgICAgICAgciA9IEFqW3BdO1xuICAgICAgICAgICAgZmxhZ3Nbcl0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIEJpW3ErMV0gPSBjb3VudDtcbiAgICB9XG4gICAgcmV0dXJuIEI7XG59XG5cbm51bWVyaWMuY2NzRG90ID0gZnVuY3Rpb24gY2NzRG90KEEsQikge1xuICAgIHZhciBBaSA9IEFbMF0sIEFqID0gQVsxXSwgQXYgPSBBWzJdO1xuICAgIHZhciBCaSA9IEJbMF0sIEJqID0gQlsxXSwgQnYgPSBCWzJdO1xuICAgIHZhciBzQSA9IG51bWVyaWMuY2NzRGltKEEpLCBzQiA9IG51bWVyaWMuY2NzRGltKEIpO1xuICAgIHZhciBtID0gc0FbMF0sIG4gPSBzQVsxXSwgbyA9IHNCWzFdO1xuICAgIHZhciB4ID0gbnVtZXJpYy5yZXAoW21dLDApLCBmbGFncyA9IG51bWVyaWMucmVwKFttXSwwKSwgeGogPSBBcnJheShtKTtcbiAgICB2YXIgQ2kgPSBudW1lcmljLnJlcChbb10sMCksIENqID0gW10sIEN2ID0gW10sIEMgPSBbQ2ksQ2osQ3ZdO1xuICAgIHZhciBpLGosayxqMCxqMSxpMCxpMSxsLHAsYSxiO1xuICAgIGZvcihrPTA7ayE9PW87KytrKSB7XG4gICAgICAgIGowID0gQmlba107XG4gICAgICAgIGoxID0gQmlbaysxXTtcbiAgICAgICAgcCA9IDA7XG4gICAgICAgIGZvcihqPWowO2o8ajE7KytqKSB7XG4gICAgICAgICAgICBhID0gQmpbal07XG4gICAgICAgICAgICBiID0gQnZbal07XG4gICAgICAgICAgICBpMCA9IEFpW2FdO1xuICAgICAgICAgICAgaTEgPSBBaVthKzFdO1xuICAgICAgICAgICAgZm9yKGk9aTA7aTxpMTsrK2kpIHtcbiAgICAgICAgICAgICAgICBsID0gQWpbaV07XG4gICAgICAgICAgICAgICAgaWYoZmxhZ3NbbF09PT0wKSB7XG4gICAgICAgICAgICAgICAgICAgIHhqW3BdID0gbDtcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3NbbF0gPSAxO1xuICAgICAgICAgICAgICAgICAgICBwID0gcCsxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB4W2xdID0geFtsXSArIEF2W2ldKmI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgajAgPSBDaVtrXTtcbiAgICAgICAgajEgPSBqMCtwO1xuICAgICAgICBDaVtrKzFdID0gajE7XG4gICAgICAgIGZvcihqPXAtMTtqIT09LTE7LS1qKSB7XG4gICAgICAgICAgICBiID0gajArajtcbiAgICAgICAgICAgIGkgPSB4altqXTtcbiAgICAgICAgICAgIENqW2JdID0gaTtcbiAgICAgICAgICAgIEN2W2JdID0geFtpXTtcbiAgICAgICAgICAgIGZsYWdzW2ldID0gMDtcbiAgICAgICAgICAgIHhbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIENpW2srMV0gPSBDaVtrXStwO1xuICAgIH1cbiAgICByZXR1cm4gQztcbn1cblxubnVtZXJpYy5jY3NMVVBTb2x2ZSA9IGZ1bmN0aW9uIGNjc0xVUFNvbHZlKExVUCxCKSB7XG4gICAgdmFyIEwgPSBMVVAuTCwgVSA9IExVUC5VLCBQID0gTFVQLlA7XG4gICAgdmFyIEJpID0gQlswXTtcbiAgICB2YXIgZmxhZyA9IGZhbHNlO1xuICAgIGlmKHR5cGVvZiBCaSAhPT0gXCJvYmplY3RcIikgeyBCID0gW1swLEIubGVuZ3RoXSxudW1lcmljLmxpbnNwYWNlKDAsQi5sZW5ndGgtMSksQl07IEJpID0gQlswXTsgZmxhZyA9IHRydWU7IH1cbiAgICB2YXIgQmogPSBCWzFdLCBCdiA9IEJbMl07XG4gICAgdmFyIG4gPSBMWzBdLmxlbmd0aC0xLCBtID0gQmkubGVuZ3RoLTE7XG4gICAgdmFyIHggPSBudW1lcmljLnJlcChbbl0sMCksIHhqID0gQXJyYXkobik7XG4gICAgdmFyIGIgPSBudW1lcmljLnJlcChbbl0sMCksIGJqID0gQXJyYXkobik7XG4gICAgdmFyIFhpID0gbnVtZXJpYy5yZXAoW20rMV0sMCksIFhqID0gW10sIFh2ID0gW107XG4gICAgdmFyIHNvbCA9IG51bWVyaWMuY2NzVFNvbHZlO1xuICAgIHZhciBpLGosajAsajEsayxKLE49MDtcbiAgICBmb3IoaT0wO2k8bTsrK2kpIHtcbiAgICAgICAgayA9IDA7XG4gICAgICAgIGowID0gQmlbaV07XG4gICAgICAgIGoxID0gQmlbaSsxXTtcbiAgICAgICAgZm9yKGo9ajA7ajxqMTsrK2opIHsgXG4gICAgICAgICAgICBKID0gTFVQLlBpbnZbQmpbal1dO1xuICAgICAgICAgICAgYmpba10gPSBKO1xuICAgICAgICAgICAgYltKXSA9IEJ2W2pdO1xuICAgICAgICAgICAgKytrO1xuICAgICAgICB9XG4gICAgICAgIGJqLmxlbmd0aCA9IGs7XG4gICAgICAgIHNvbChMLGIseCxiaix4aik7XG4gICAgICAgIGZvcihqPWJqLmxlbmd0aC0xO2ohPT0tMTstLWopIGJbYmpbal1dID0gMDtcbiAgICAgICAgc29sKFUseCxiLHhqLGJqKTtcbiAgICAgICAgaWYoZmxhZykgcmV0dXJuIGI7XG4gICAgICAgIGZvcihqPXhqLmxlbmd0aC0xO2ohPT0tMTstLWopIHhbeGpbal1dID0gMDtcbiAgICAgICAgZm9yKGo9YmoubGVuZ3RoLTE7aiE9PS0xOy0taikge1xuICAgICAgICAgICAgSiA9IGJqW2pdO1xuICAgICAgICAgICAgWGpbTl0gPSBKO1xuICAgICAgICAgICAgWHZbTl0gPSBiW0pdO1xuICAgICAgICAgICAgYltKXSA9IDA7XG4gICAgICAgICAgICArK047XG4gICAgICAgIH1cbiAgICAgICAgWGlbaSsxXSA9IE47XG4gICAgfVxuICAgIHJldHVybiBbWGksWGosWHZdO1xufVxuXG5udW1lcmljLmNjc2Jpbm9wID0gZnVuY3Rpb24gY2NzYmlub3AoYm9keSxzZXR1cCkge1xuICAgIGlmKHR5cGVvZiBzZXR1cCA9PT0gXCJ1bmRlZmluZWRcIikgc2V0dXA9Jyc7XG4gICAgcmV0dXJuIEZ1bmN0aW9uKCdYJywnWScsXG4gICAgICAgICAgICAndmFyIFhpID0gWFswXSwgWGogPSBYWzFdLCBYdiA9IFhbMl07XFxuJytcbiAgICAgICAgICAgICd2YXIgWWkgPSBZWzBdLCBZaiA9IFlbMV0sIFl2ID0gWVsyXTtcXG4nK1xuICAgICAgICAgICAgJ3ZhciBuID0gWGkubGVuZ3RoLTEsbSA9IE1hdGgubWF4KG51bWVyaWMuc3VwKFhqKSxudW1lcmljLnN1cChZaikpKzE7XFxuJytcbiAgICAgICAgICAgICd2YXIgWmkgPSBudW1lcmljLnJlcChbbisxXSwwKSwgWmogPSBbXSwgWnYgPSBbXTtcXG4nK1xuICAgICAgICAgICAgJ3ZhciB4ID0gbnVtZXJpYy5yZXAoW21dLDApLHkgPSBudW1lcmljLnJlcChbbV0sMCk7XFxuJytcbiAgICAgICAgICAgICd2YXIgeGsseWssems7XFxuJytcbiAgICAgICAgICAgICd2YXIgaSxqLGowLGoxLGsscD0wO1xcbicrXG4gICAgICAgICAgICBzZXR1cCtcbiAgICAgICAgICAgICdmb3IoaT0wO2k8bjsrK2kpIHtcXG4nK1xuICAgICAgICAgICAgJyAgajAgPSBYaVtpXTsgajEgPSBYaVtpKzFdO1xcbicrXG4gICAgICAgICAgICAnICBmb3Ioaj1qMDtqIT09ajE7KytqKSB7XFxuJytcbiAgICAgICAgICAgICcgICAgayA9IFhqW2pdO1xcbicrXG4gICAgICAgICAgICAnICAgIHhba10gPSAxO1xcbicrXG4gICAgICAgICAgICAnICAgIFpqW3BdID0gaztcXG4nK1xuICAgICAgICAgICAgJyAgICArK3A7XFxuJytcbiAgICAgICAgICAgICcgIH1cXG4nK1xuICAgICAgICAgICAgJyAgajAgPSBZaVtpXTsgajEgPSBZaVtpKzFdO1xcbicrXG4gICAgICAgICAgICAnICBmb3Ioaj1qMDtqIT09ajE7KytqKSB7XFxuJytcbiAgICAgICAgICAgICcgICAgayA9IFlqW2pdO1xcbicrXG4gICAgICAgICAgICAnICAgIHlba10gPSBZdltqXTtcXG4nK1xuICAgICAgICAgICAgJyAgICBpZih4W2tdID09PSAwKSB7XFxuJytcbiAgICAgICAgICAgICcgICAgICBaaltwXSA9IGs7XFxuJytcbiAgICAgICAgICAgICcgICAgICArK3A7XFxuJytcbiAgICAgICAgICAgICcgICAgfVxcbicrXG4gICAgICAgICAgICAnICB9XFxuJytcbiAgICAgICAgICAgICcgIFppW2krMV0gPSBwO1xcbicrXG4gICAgICAgICAgICAnICBqMCA9IFhpW2ldOyBqMSA9IFhpW2krMV07XFxuJytcbiAgICAgICAgICAgICcgIGZvcihqPWowO2ohPT1qMTsrK2opIHhbWGpbal1dID0gWHZbal07XFxuJytcbiAgICAgICAgICAgICcgIGowID0gWmlbaV07IGoxID0gWmlbaSsxXTtcXG4nK1xuICAgICAgICAgICAgJyAgZm9yKGo9ajA7aiE9PWoxOysraikge1xcbicrXG4gICAgICAgICAgICAnICAgIGsgPSBaaltqXTtcXG4nK1xuICAgICAgICAgICAgJyAgICB4ayA9IHhba107XFxuJytcbiAgICAgICAgICAgICcgICAgeWsgPSB5W2tdO1xcbicrXG4gICAgICAgICAgICBib2R5KydcXG4nK1xuICAgICAgICAgICAgJyAgICBadltqXSA9IHprO1xcbicrXG4gICAgICAgICAgICAnICB9XFxuJytcbiAgICAgICAgICAgICcgIGowID0gWGlbaV07IGoxID0gWGlbaSsxXTtcXG4nK1xuICAgICAgICAgICAgJyAgZm9yKGo9ajA7aiE9PWoxOysraikgeFtYaltqXV0gPSAwO1xcbicrXG4gICAgICAgICAgICAnICBqMCA9IFlpW2ldOyBqMSA9IFlpW2krMV07XFxuJytcbiAgICAgICAgICAgICcgIGZvcihqPWowO2ohPT1qMTsrK2opIHlbWWpbal1dID0gMDtcXG4nK1xuICAgICAgICAgICAgJ31cXG4nK1xuICAgICAgICAgICAgJ3JldHVybiBbWmksWmosWnZdOydcbiAgICAgICAgICAgICk7XG59O1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgdmFyIGssQSxCLEM7XG4gICAgZm9yKGsgaW4gbnVtZXJpYy5vcHMyKSB7XG4gICAgICAgIGlmKGlzRmluaXRlKGV2YWwoJzEnK251bWVyaWMub3BzMltrXSsnMCcpKSkgQSA9ICdbWVswXSxZWzFdLG51bWVyaWMuJytrKycoWCxZWzJdKV0nO1xuICAgICAgICBlbHNlIEEgPSAnTmFOJztcbiAgICAgICAgaWYoaXNGaW5pdGUoZXZhbCgnMCcrbnVtZXJpYy5vcHMyW2tdKycxJykpKSBCID0gJ1tYWzBdLFhbMV0sbnVtZXJpYy4nK2srJyhYWzJdLFkpXSc7XG4gICAgICAgIGVsc2UgQiA9ICdOYU4nO1xuICAgICAgICBpZihpc0Zpbml0ZShldmFsKCcxJytudW1lcmljLm9wczJba10rJzAnKSkgJiYgaXNGaW5pdGUoZXZhbCgnMCcrbnVtZXJpYy5vcHMyW2tdKycxJykpKSBDID0gJ251bWVyaWMuY2NzJytrKydNTShYLFkpJztcbiAgICAgICAgZWxzZSBDID0gJ05hTic7XG4gICAgICAgIG51bWVyaWNbJ2NjcycraysnTU0nXSA9IG51bWVyaWMuY2NzYmlub3AoJ3prID0geGsgJytudW1lcmljLm9wczJba10rJ3lrOycpO1xuICAgICAgICBudW1lcmljWydjY3MnK2tdID0gRnVuY3Rpb24oJ1gnLCdZJyxcbiAgICAgICAgICAgICAgICAnaWYodHlwZW9mIFggPT09IFwibnVtYmVyXCIpIHJldHVybiAnK0ErJztcXG4nK1xuICAgICAgICAgICAgICAgICdpZih0eXBlb2YgWSA9PT0gXCJudW1iZXJcIikgcmV0dXJuICcrQisnO1xcbicrXG4gICAgICAgICAgICAgICAgJ3JldHVybiAnK0MrJztcXG4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICB9XG59KCkpO1xuXG5udW1lcmljLmNjc1NjYXR0ZXIgPSBmdW5jdGlvbiBjY3NTY2F0dGVyKEEpIHtcbiAgICB2YXIgQWkgPSBBWzBdLCBBaiA9IEFbMV0sIEF2ID0gQVsyXTtcbiAgICB2YXIgbiA9IG51bWVyaWMuc3VwKEFqKSsxLG09QWkubGVuZ3RoO1xuICAgIHZhciBSaSA9IG51bWVyaWMucmVwKFtuXSwwKSxSaj1BcnJheShtKSwgUnYgPSBBcnJheShtKTtcbiAgICB2YXIgY291bnRzID0gbnVtZXJpYy5yZXAoW25dLDApLGk7XG4gICAgZm9yKGk9MDtpPG07KytpKSBjb3VudHNbQWpbaV1dKys7XG4gICAgZm9yKGk9MDtpPG47KytpKSBSaVtpKzFdID0gUmlbaV0gKyBjb3VudHNbaV07XG4gICAgdmFyIHB0ciA9IFJpLnNsaWNlKDApLGssQWlpO1xuICAgIGZvcihpPTA7aTxtOysraSkge1xuICAgICAgICBBaWkgPSBBaltpXTtcbiAgICAgICAgayA9IHB0cltBaWldO1xuICAgICAgICBSaltrXSA9IEFpW2ldO1xuICAgICAgICBSdltrXSA9IEF2W2ldO1xuICAgICAgICBwdHJbQWlpXT1wdHJbQWlpXSsxO1xuICAgIH1cbiAgICByZXR1cm4gW1JpLFJqLFJ2XTtcbn1cblxubnVtZXJpYy5jY3NHYXRoZXIgPSBmdW5jdGlvbiBjY3NHYXRoZXIoQSkge1xuICAgIHZhciBBaSA9IEFbMF0sIEFqID0gQVsxXSwgQXYgPSBBWzJdO1xuICAgIHZhciBuID0gQWkubGVuZ3RoLTEsbSA9IEFqLmxlbmd0aDtcbiAgICB2YXIgUmkgPSBBcnJheShtKSwgUmogPSBBcnJheShtKSwgUnYgPSBBcnJheShtKTtcbiAgICB2YXIgaSxqLGowLGoxLHA7XG4gICAgcD0wO1xuICAgIGZvcihpPTA7aTxuOysraSkge1xuICAgICAgICBqMCA9IEFpW2ldO1xuICAgICAgICBqMSA9IEFpW2krMV07XG4gICAgICAgIGZvcihqPWowO2ohPT1qMTsrK2opIHtcbiAgICAgICAgICAgIFJqW3BdID0gaTtcbiAgICAgICAgICAgIFJpW3BdID0gQWpbal07XG4gICAgICAgICAgICBSdltwXSA9IEF2W2pdO1xuICAgICAgICAgICAgKytwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbUmksUmosUnZdO1xufVxuXG4vLyBUaGUgZm9sbG93aW5nIHNwYXJzZSBsaW5lYXIgYWxnZWJyYSByb3V0aW5lcyBhcmUgZGVwcmVjYXRlZC5cblxubnVtZXJpYy5zZGltID0gZnVuY3Rpb24gZGltKEEscmV0LGspIHtcbiAgICBpZih0eXBlb2YgcmV0ID09PSBcInVuZGVmaW5lZFwiKSB7IHJldCA9IFtdOyB9XG4gICAgaWYodHlwZW9mIEEgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXQ7XG4gICAgaWYodHlwZW9mIGsgPT09IFwidW5kZWZpbmVkXCIpIHsgaz0wOyB9XG4gICAgaWYoIShrIGluIHJldCkpIHsgcmV0W2tdID0gMDsgfVxuICAgIGlmKEEubGVuZ3RoID4gcmV0W2tdKSByZXRba10gPSBBLmxlbmd0aDtcbiAgICB2YXIgaTtcbiAgICBmb3IoaSBpbiBBKSB7XG4gICAgICAgIGlmKEEuaGFzT3duUHJvcGVydHkoaSkpIGRpbShBW2ldLHJldCxrKzEpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxubnVtZXJpYy5zY2xvbmUgPSBmdW5jdGlvbiBjbG9uZShBLGssbikge1xuICAgIGlmKHR5cGVvZiBrID09PSBcInVuZGVmaW5lZFwiKSB7IGs9MDsgfVxuICAgIGlmKHR5cGVvZiBuID09PSBcInVuZGVmaW5lZFwiKSB7IG4gPSBudW1lcmljLnNkaW0oQSkubGVuZ3RoOyB9XG4gICAgdmFyIGkscmV0ID0gQXJyYXkoQS5sZW5ndGgpO1xuICAgIGlmKGsgPT09IG4tMSkge1xuICAgICAgICBmb3IoaSBpbiBBKSB7IGlmKEEuaGFzT3duUHJvcGVydHkoaSkpIHJldFtpXSA9IEFbaV07IH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZm9yKGkgaW4gQSkge1xuICAgICAgICBpZihBLmhhc093blByb3BlcnR5KGkpKSByZXRbaV0gPSBjbG9uZShBW2ldLGsrMSxuKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5zZGlhZyA9IGZ1bmN0aW9uIGRpYWcoZCkge1xuICAgIHZhciBuID0gZC5sZW5ndGgsaSxyZXQgPSBBcnJheShuKSxpMSxpMixpMztcbiAgICBmb3IoaT1uLTE7aT49MTtpLT0yKSB7XG4gICAgICAgIGkxID0gaS0xO1xuICAgICAgICByZXRbaV0gPSBbXTsgcmV0W2ldW2ldID0gZFtpXTtcbiAgICAgICAgcmV0W2kxXSA9IFtdOyByZXRbaTFdW2kxXSA9IGRbaTFdO1xuICAgIH1cbiAgICBpZihpPT09MCkgeyByZXRbMF0gPSBbXTsgcmV0WzBdWzBdID0gZFtpXTsgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuc2lkZW50aXR5ID0gZnVuY3Rpb24gaWRlbnRpdHkobikgeyByZXR1cm4gbnVtZXJpYy5zZGlhZyhudW1lcmljLnJlcChbbl0sMSkpOyB9XG5cbm51bWVyaWMuc3RyYW5zcG9zZSA9IGZ1bmN0aW9uIHRyYW5zcG9zZShBKSB7XG4gICAgdmFyIHJldCA9IFtdLCBuID0gQS5sZW5ndGgsIGksaixBaTtcbiAgICBmb3IoaSBpbiBBKSB7XG4gICAgICAgIGlmKCEoQS5oYXNPd25Qcm9wZXJ0eShpKSkpIGNvbnRpbnVlO1xuICAgICAgICBBaSA9IEFbaV07XG4gICAgICAgIGZvcihqIGluIEFpKSB7XG4gICAgICAgICAgICBpZighKEFpLmhhc093blByb3BlcnR5KGopKSkgY29udGludWU7XG4gICAgICAgICAgICBpZih0eXBlb2YgcmV0W2pdICE9PSBcIm9iamVjdFwiKSB7IHJldFtqXSA9IFtdOyB9XG4gICAgICAgICAgICByZXRbal1baV0gPSBBaVtqXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLnNMVVAgPSBmdW5jdGlvbiBMVVAoQSx0b2wpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZnVuY3Rpb24gbnVtZXJpYy5zTFVQIGhhZCBhIGJ1ZyBpbiBpdCBhbmQgaGFzIGJlZW4gcmVtb3ZlZC4gUGxlYXNlIHVzZSB0aGUgbmV3IG51bWVyaWMuY2NzTFVQIGZ1bmN0aW9uIGluc3RlYWQuXCIpO1xufTtcblxubnVtZXJpYy5zZG90TU0gPSBmdW5jdGlvbiBkb3RNTShBLEIpIHtcbiAgICB2YXIgcCA9IEEubGVuZ3RoLCBxID0gQi5sZW5ndGgsIEJUID0gbnVtZXJpYy5zdHJhbnNwb3NlKEIpLCByID0gQlQubGVuZ3RoLCBBaSwgQlRrO1xuICAgIHZhciBpLGosayxhY2N1bTtcbiAgICB2YXIgcmV0ID0gQXJyYXkocCkscmV0aTtcbiAgICBmb3IoaT1wLTE7aT49MDtpLS0pIHtcbiAgICAgICAgcmV0aSA9IFtdO1xuICAgICAgICBBaSA9IEFbaV07XG4gICAgICAgIGZvcihrPXItMTtrPj0wO2stLSkge1xuICAgICAgICAgICAgYWNjdW0gPSAwO1xuICAgICAgICAgICAgQlRrID0gQlRba107XG4gICAgICAgICAgICBmb3IoaiBpbiBBaSkge1xuICAgICAgICAgICAgICAgIGlmKCEoQWkuaGFzT3duUHJvcGVydHkoaikpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZihqIGluIEJUaykgeyBhY2N1bSArPSBBaVtqXSpCVGtbal07IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGFjY3VtKSByZXRpW2tdID0gYWNjdW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0W2ldID0gcmV0aTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5zZG90TVYgPSBmdW5jdGlvbiBkb3RNVihBLHgpIHtcbiAgICB2YXIgcCA9IEEubGVuZ3RoLCBBaSwgaSxqO1xuICAgIHZhciByZXQgPSBBcnJheShwKSwgYWNjdW07XG4gICAgZm9yKGk9cC0xO2k+PTA7aS0tKSB7XG4gICAgICAgIEFpID0gQVtpXTtcbiAgICAgICAgYWNjdW0gPSAwO1xuICAgICAgICBmb3IoaiBpbiBBaSkge1xuICAgICAgICAgICAgaWYoIShBaS5oYXNPd25Qcm9wZXJ0eShqKSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYoeFtqXSkgYWNjdW0gKz0gQWlbal0qeFtqXTtcbiAgICAgICAgfVxuICAgICAgICBpZihhY2N1bSkgcmV0W2ldID0gYWNjdW07XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuc2RvdFZNID0gZnVuY3Rpb24gZG90TVYoeCxBKSB7XG4gICAgdmFyIGksaixBaSxhbHBoYTtcbiAgICB2YXIgcmV0ID0gW10sIGFjY3VtO1xuICAgIGZvcihpIGluIHgpIHtcbiAgICAgICAgaWYoIXguaGFzT3duUHJvcGVydHkoaSkpIGNvbnRpbnVlO1xuICAgICAgICBBaSA9IEFbaV07XG4gICAgICAgIGFscGhhID0geFtpXTtcbiAgICAgICAgZm9yKGogaW4gQWkpIHtcbiAgICAgICAgICAgIGlmKCFBaS5oYXNPd25Qcm9wZXJ0eShqKSkgY29udGludWU7XG4gICAgICAgICAgICBpZighcmV0W2pdKSB7IHJldFtqXSA9IDA7IH1cbiAgICAgICAgICAgIHJldFtqXSArPSBhbHBoYSpBaVtqXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLnNkb3RWViA9IGZ1bmN0aW9uIGRvdFZWKHgseSkge1xuICAgIHZhciBpLHJldD0wO1xuICAgIGZvcihpIGluIHgpIHsgaWYoeFtpXSAmJiB5W2ldKSByZXQrPSB4W2ldKnlbaV07IH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLnNkb3QgPSBmdW5jdGlvbiBkb3QoQSxCKSB7XG4gICAgdmFyIG0gPSBudW1lcmljLnNkaW0oQSkubGVuZ3RoLCBuID0gbnVtZXJpYy5zZGltKEIpLmxlbmd0aDtcbiAgICB2YXIgayA9IG0qMTAwMCtuO1xuICAgIHN3aXRjaChrKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gQSpCO1xuICAgIGNhc2UgMTAwMTogcmV0dXJuIG51bWVyaWMuc2RvdFZWKEEsQik7XG4gICAgY2FzZSAyMDAxOiByZXR1cm4gbnVtZXJpYy5zZG90TVYoQSxCKTtcbiAgICBjYXNlIDEwMDI6IHJldHVybiBudW1lcmljLnNkb3RWTShBLEIpO1xuICAgIGNhc2UgMjAwMjogcmV0dXJuIG51bWVyaWMuc2RvdE1NKEEsQik7XG4gICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdudW1lcmljLnNkb3Qgbm90IGltcGxlbWVudGVkIGZvciB0ZW5zb3JzIG9mIG9yZGVyICcrbSsnIGFuZCAnK24pO1xuICAgIH1cbn1cblxubnVtZXJpYy5zc2NhdHRlciA9IGZ1bmN0aW9uIHNjYXR0ZXIoVikge1xuICAgIHZhciBuID0gVlswXS5sZW5ndGgsIFZpaiwgaSwgaiwgbSA9IFYubGVuZ3RoLCBBID0gW10sIEFqO1xuICAgIGZvcihpPW4tMTtpPj0wOy0taSkge1xuICAgICAgICBpZighVlttLTFdW2ldKSBjb250aW51ZTtcbiAgICAgICAgQWogPSBBO1xuICAgICAgICBmb3Ioaj0wO2o8bS0yO2orKykge1xuICAgICAgICAgICAgVmlqID0gVltqXVtpXTtcbiAgICAgICAgICAgIGlmKCFBaltWaWpdKSBBaltWaWpdID0gW107XG4gICAgICAgICAgICBBaiA9IEFqW1Zpal07XG4gICAgICAgIH1cbiAgICAgICAgQWpbVltqXVtpXV0gPSBWW2orMV1baV07XG4gICAgfVxuICAgIHJldHVybiBBO1xufVxuXG5udW1lcmljLnNnYXRoZXIgPSBmdW5jdGlvbiBnYXRoZXIoQSxyZXQsaykge1xuICAgIGlmKHR5cGVvZiByZXQgPT09IFwidW5kZWZpbmVkXCIpIHJldCA9IFtdO1xuICAgIGlmKHR5cGVvZiBrID09PSBcInVuZGVmaW5lZFwiKSBrID0gW107XG4gICAgdmFyIG4saSxBaTtcbiAgICBuID0gay5sZW5ndGg7XG4gICAgZm9yKGkgaW4gQSkge1xuICAgICAgICBpZihBLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBrW25dID0gcGFyc2VJbnQoaSk7XG4gICAgICAgICAgICBBaSA9IEFbaV07XG4gICAgICAgICAgICBpZih0eXBlb2YgQWkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBpZihBaSkge1xuICAgICAgICAgICAgICAgICAgICBpZihyZXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IoaT1uKzE7aT49MDstLWkpIHJldFtpXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvcihpPW47aT49MDstLWkpIHJldFtpXS5wdXNoKGtbaV0pO1xuICAgICAgICAgICAgICAgICAgICByZXRbbisxXS5wdXNoKEFpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgZ2F0aGVyKEFpLHJldCxrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZihrLmxlbmd0aD5uKSBrLnBvcCgpO1xuICAgIHJldHVybiByZXQ7XG59XG5cbi8vIDYuIENvb3JkaW5hdGUgbWF0cmljZXNcbm51bWVyaWMuY0xVID0gZnVuY3Rpb24gTFUoQSkge1xuICAgIHZhciBJID0gQVswXSwgSiA9IEFbMV0sIFYgPSBBWzJdO1xuICAgIHZhciBwID0gSS5sZW5ndGgsIG09MCwgaSxqLGssYSxiLGM7XG4gICAgZm9yKGk9MDtpPHA7aSsrKSBpZihJW2ldPm0pIG09SVtpXTtcbiAgICBtKys7XG4gICAgdmFyIEwgPSBBcnJheShtKSwgVSA9IEFycmF5KG0pLCBsZWZ0ID0gbnVtZXJpYy5yZXAoW21dLEluZmluaXR5KSwgcmlnaHQgPSBudW1lcmljLnJlcChbbV0sLUluZmluaXR5KTtcbiAgICB2YXIgVWksIFVqLGFscGhhO1xuICAgIGZvcihrPTA7azxwO2srKykge1xuICAgICAgICBpID0gSVtrXTtcbiAgICAgICAgaiA9IEpba107XG4gICAgICAgIGlmKGo8bGVmdFtpXSkgbGVmdFtpXSA9IGo7XG4gICAgICAgIGlmKGo+cmlnaHRbaV0pIHJpZ2h0W2ldID0gajtcbiAgICB9XG4gICAgZm9yKGk9MDtpPG0tMTtpKyspIHsgaWYocmlnaHRbaV0gPiByaWdodFtpKzFdKSByaWdodFtpKzFdID0gcmlnaHRbaV07IH1cbiAgICBmb3IoaT1tLTE7aT49MTtpLS0pIHsgaWYobGVmdFtpXTxsZWZ0W2ktMV0pIGxlZnRbaS0xXSA9IGxlZnRbaV07IH1cbiAgICB2YXIgY291bnRMID0gMCwgY291bnRVID0gMDtcbiAgICBmb3IoaT0wO2k8bTtpKyspIHtcbiAgICAgICAgVVtpXSA9IG51bWVyaWMucmVwKFtyaWdodFtpXS1sZWZ0W2ldKzFdLDApO1xuICAgICAgICBMW2ldID0gbnVtZXJpYy5yZXAoW2ktbGVmdFtpXV0sMCk7XG4gICAgICAgIGNvdW50TCArPSBpLWxlZnRbaV0rMTtcbiAgICAgICAgY291bnRVICs9IHJpZ2h0W2ldLWkrMTtcbiAgICB9XG4gICAgZm9yKGs9MDtrPHA7aysrKSB7IGkgPSBJW2tdOyBVW2ldW0pba10tbGVmdFtpXV0gPSBWW2tdOyB9XG4gICAgZm9yKGk9MDtpPG0tMTtpKyspIHtcbiAgICAgICAgYSA9IGktbGVmdFtpXTtcbiAgICAgICAgVWkgPSBVW2ldO1xuICAgICAgICBmb3Ioaj1pKzE7bGVmdFtqXTw9aSAmJiBqPG07aisrKSB7XG4gICAgICAgICAgICBiID0gaS1sZWZ0W2pdO1xuICAgICAgICAgICAgYyA9IHJpZ2h0W2ldLWk7XG4gICAgICAgICAgICBVaiA9IFVbal07XG4gICAgICAgICAgICBhbHBoYSA9IFVqW2JdL1VpW2FdO1xuICAgICAgICAgICAgaWYoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICBmb3Ioaz0xO2s8PWM7aysrKSB7IFVqW2srYl0gLT0gYWxwaGEqVWlbaythXTsgfVxuICAgICAgICAgICAgICAgIExbal1baS1sZWZ0W2pdXSA9IGFscGhhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBVaSA9IFtdLCBVaiA9IFtdLCBVdiA9IFtdLCBMaSA9IFtdLCBMaiA9IFtdLCBMdiA9IFtdO1xuICAgIHZhciBwLHEsZm9vO1xuICAgIHA9MDsgcT0wO1xuICAgIGZvcihpPTA7aTxtO2krKykge1xuICAgICAgICBhID0gbGVmdFtpXTtcbiAgICAgICAgYiA9IHJpZ2h0W2ldO1xuICAgICAgICBmb28gPSBVW2ldO1xuICAgICAgICBmb3Ioaj1pO2o8PWI7aisrKSB7XG4gICAgICAgICAgICBpZihmb29bai1hXSkge1xuICAgICAgICAgICAgICAgIFVpW3BdID0gaTtcbiAgICAgICAgICAgICAgICBValtwXSA9IGo7XG4gICAgICAgICAgICAgICAgVXZbcF0gPSBmb29bai1hXTtcbiAgICAgICAgICAgICAgICBwKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9vID0gTFtpXTtcbiAgICAgICAgZm9yKGo9YTtqPGk7aisrKSB7XG4gICAgICAgICAgICBpZihmb29bai1hXSkge1xuICAgICAgICAgICAgICAgIExpW3FdID0gaTtcbiAgICAgICAgICAgICAgICBMaltxXSA9IGo7XG4gICAgICAgICAgICAgICAgTHZbcV0gPSBmb29bai1hXTtcbiAgICAgICAgICAgICAgICBxKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgTGlbcV0gPSBpO1xuICAgICAgICBMaltxXSA9IGk7XG4gICAgICAgIEx2W3FdID0gMTtcbiAgICAgICAgcSsrO1xuICAgIH1cbiAgICByZXR1cm4ge1U6W1VpLFVqLFV2XSwgTDpbTGksTGosTHZdfTtcbn07XG5cbm51bWVyaWMuY0xVc29sdmUgPSBmdW5jdGlvbiBMVXNvbHZlKGx1LGIpIHtcbiAgICB2YXIgTCA9IGx1LkwsIFUgPSBsdS5VLCByZXQgPSBudW1lcmljLmNsb25lKGIpO1xuICAgIHZhciBMaSA9IExbMF0sIExqID0gTFsxXSwgTHYgPSBMWzJdO1xuICAgIHZhciBVaSA9IFVbMF0sIFVqID0gVVsxXSwgVXYgPSBVWzJdO1xuICAgIHZhciBwID0gVWkubGVuZ3RoLCBxID0gTGkubGVuZ3RoO1xuICAgIHZhciBtID0gcmV0Lmxlbmd0aCxpLGosaztcbiAgICBrID0gMDtcbiAgICBmb3IoaT0wO2k8bTtpKyspIHtcbiAgICAgICAgd2hpbGUoTGpba10gPCBpKSB7XG4gICAgICAgICAgICByZXRbaV0gLT0gTHZba10qcmV0W0xqW2tdXTtcbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgfVxuICAgICAgICBrKys7XG4gICAgfVxuICAgIGsgPSBwLTE7XG4gICAgZm9yKGk9bS0xO2k+PTA7aS0tKSB7XG4gICAgICAgIHdoaWxlKFVqW2tdID4gaSkge1xuICAgICAgICAgICAgcmV0W2ldIC09IFV2W2tdKnJldFtValtrXV07XG4gICAgICAgICAgICBrLS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0W2ldIC89IFV2W2tdO1xuICAgICAgICBrLS07XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5udW1lcmljLmNncmlkID0gZnVuY3Rpb24gZ3JpZChuLHNoYXBlKSB7XG4gICAgaWYodHlwZW9mIG4gPT09IFwibnVtYmVyXCIpIG4gPSBbbixuXTtcbiAgICB2YXIgcmV0ID0gbnVtZXJpYy5yZXAobiwtMSk7XG4gICAgdmFyIGksaixjb3VudDtcbiAgICBpZih0eXBlb2Ygc2hhcGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBzd2l0Y2goc2hhcGUpIHtcbiAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICBzaGFwZSA9IGZ1bmN0aW9uKGksaikgeyByZXR1cm4gKGk+PW5bMF0vMiB8fCBqPG5bMV0vMik7IH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc2hhcGUgPSBmdW5jdGlvbihpLGopIHsgcmV0dXJuIHRydWU7IH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb3VudD0wO1xuICAgIGZvcihpPTE7aTxuWzBdLTE7aSsrKSBmb3Ioaj0xO2o8blsxXS0xO2orKykgXG4gICAgICAgIGlmKHNoYXBlKGksaikpIHtcbiAgICAgICAgICAgIHJldFtpXVtqXSA9IGNvdW50O1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuY2RlbHNxID0gZnVuY3Rpb24gZGVsc3EoZykge1xuICAgIHZhciBkaXIgPSBbWy0xLDBdLFswLC0xXSxbMCwxXSxbMSwwXV07XG4gICAgdmFyIHMgPSBudW1lcmljLmRpbShnKSwgbSA9IHNbMF0sIG4gPSBzWzFdLCBpLGosayxwLHE7XG4gICAgdmFyIExpID0gW10sIExqID0gW10sIEx2ID0gW107XG4gICAgZm9yKGk9MTtpPG0tMTtpKyspIGZvcihqPTE7ajxuLTE7aisrKSB7XG4gICAgICAgIGlmKGdbaV1bal08MCkgY29udGludWU7XG4gICAgICAgIGZvcihrPTA7azw0O2srKykge1xuICAgICAgICAgICAgcCA9IGkrZGlyW2tdWzBdO1xuICAgICAgICAgICAgcSA9IGorZGlyW2tdWzFdO1xuICAgICAgICAgICAgaWYoZ1twXVtxXTwwKSBjb250aW51ZTtcbiAgICAgICAgICAgIExpLnB1c2goZ1tpXVtqXSk7XG4gICAgICAgICAgICBMai5wdXNoKGdbcF1bcV0pO1xuICAgICAgICAgICAgTHYucHVzaCgtMSk7XG4gICAgICAgIH1cbiAgICAgICAgTGkucHVzaChnW2ldW2pdKTtcbiAgICAgICAgTGoucHVzaChnW2ldW2pdKTtcbiAgICAgICAgTHYucHVzaCg0KTtcbiAgICB9XG4gICAgcmV0dXJuIFtMaSxMaixMdl07XG59XG5cbm51bWVyaWMuY2RvdE1WID0gZnVuY3Rpb24gZG90TVYoQSx4KSB7XG4gICAgdmFyIHJldCwgQWkgPSBBWzBdLCBBaiA9IEFbMV0sIEF2ID0gQVsyXSxrLHA9QWkubGVuZ3RoLE47XG4gICAgTj0wO1xuICAgIGZvcihrPTA7azxwO2srKykgeyBpZihBaVtrXT5OKSBOID0gQWlba107IH1cbiAgICBOKys7XG4gICAgcmV0ID0gbnVtZXJpYy5yZXAoW05dLDApO1xuICAgIGZvcihrPTA7azxwO2srKykgeyByZXRbQWlba11dKz1BdltrXSp4W0FqW2tdXTsgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbi8vIDcuIFNwbGluZXNcblxubnVtZXJpYy5TcGxpbmUgPSBmdW5jdGlvbiBTcGxpbmUoeCx5bCx5cixrbCxrcikgeyB0aGlzLnggPSB4OyB0aGlzLnlsID0geWw7IHRoaXMueXIgPSB5cjsgdGhpcy5rbCA9IGtsOyB0aGlzLmtyID0ga3I7IH1cbm51bWVyaWMuU3BsaW5lLnByb3RvdHlwZS5fYXQgPSBmdW5jdGlvbiBfYXQoeDEscCkge1xuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5bCA9IHRoaXMueWw7XG4gICAgdmFyIHlyID0gdGhpcy55cjtcbiAgICB2YXIga2wgPSB0aGlzLmtsO1xuICAgIHZhciBrciA9IHRoaXMua3I7XG4gICAgdmFyIHgxLGEsYix0O1xuICAgIHZhciBhZGQgPSBudW1lcmljLmFkZCwgc3ViID0gbnVtZXJpYy5zdWIsIG11bCA9IG51bWVyaWMubXVsO1xuICAgIGEgPSBzdWIobXVsKGtsW3BdLHhbcCsxXS14W3BdKSxzdWIoeXJbcCsxXSx5bFtwXSkpO1xuICAgIGIgPSBhZGQobXVsKGtyW3ArMV0seFtwXS14W3ArMV0pLHN1Yih5cltwKzFdLHlsW3BdKSk7XG4gICAgdCA9ICh4MS14W3BdKS8oeFtwKzFdLXhbcF0pO1xuICAgIHZhciBzID0gdCooMS10KTtcbiAgICByZXR1cm4gYWRkKGFkZChhZGQobXVsKDEtdCx5bFtwXSksbXVsKHQseXJbcCsxXSkpLG11bChhLHMqKDEtdCkpKSxtdWwoYixzKnQpKTtcbn1cbm51bWVyaWMuU3BsaW5lLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIGF0KHgwKSB7XG4gICAgaWYodHlwZW9mIHgwID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHZhciB4ID0gdGhpcy54O1xuICAgICAgICB2YXIgbiA9IHgubGVuZ3RoO1xuICAgICAgICB2YXIgcCxxLG1pZCxmbG9vciA9IE1hdGguZmxvb3IsYSxiLHQ7XG4gICAgICAgIHAgPSAwO1xuICAgICAgICBxID0gbi0xO1xuICAgICAgICB3aGlsZShxLXA+MSkge1xuICAgICAgICAgICAgbWlkID0gZmxvb3IoKHArcSkvMik7XG4gICAgICAgICAgICBpZih4W21pZF0gPD0geDApIHAgPSBtaWQ7XG4gICAgICAgICAgICBlbHNlIHEgPSBtaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2F0KHgwLHApO1xuICAgIH1cbiAgICB2YXIgbiA9IHgwLmxlbmd0aCwgaSwgcmV0ID0gQXJyYXkobik7XG4gICAgZm9yKGk9bi0xO2khPT0tMTstLWkpIHJldFtpXSA9IHRoaXMuYXQoeDBbaV0pO1xuICAgIHJldHVybiByZXQ7XG59XG5udW1lcmljLlNwbGluZS5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uIGRpZmYoKSB7XG4gICAgdmFyIHggPSB0aGlzLng7XG4gICAgdmFyIHlsID0gdGhpcy55bDtcbiAgICB2YXIgeXIgPSB0aGlzLnlyO1xuICAgIHZhciBrbCA9IHRoaXMua2w7XG4gICAgdmFyIGtyID0gdGhpcy5rcjtcbiAgICB2YXIgbiA9IHlsLmxlbmd0aDtcbiAgICB2YXIgaSxkeCxkeTtcbiAgICB2YXIgemwgPSBrbCwgenIgPSBrciwgcGwgPSBBcnJheShuKSwgcHIgPSBBcnJheShuKTtcbiAgICB2YXIgYWRkID0gbnVtZXJpYy5hZGQsIG11bCA9IG51bWVyaWMubXVsLCBkaXYgPSBudW1lcmljLmRpdiwgc3ViID0gbnVtZXJpYy5zdWI7XG4gICAgZm9yKGk9bi0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgZHggPSB4W2krMV0teFtpXTtcbiAgICAgICAgZHkgPSBzdWIoeXJbaSsxXSx5bFtpXSk7XG4gICAgICAgIHBsW2ldID0gZGl2KGFkZChtdWwoZHksIDYpLG11bChrbFtpXSwtNCpkeCksbXVsKGtyW2krMV0sLTIqZHgpKSxkeCpkeCk7XG4gICAgICAgIHByW2krMV0gPSBkaXYoYWRkKG11bChkeSwtNiksbXVsKGtsW2ldLCAyKmR4KSxtdWwoa3JbaSsxXSwgNCpkeCkpLGR4KmR4KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlNwbGluZSh4LHpsLHpyLHBsLHByKTtcbn1cbm51bWVyaWMuU3BsaW5lLnByb3RvdHlwZS5yb290cyA9IGZ1bmN0aW9uIHJvb3RzKCkge1xuICAgIGZ1bmN0aW9uIHNxcih4KSB7IHJldHVybiB4Kng7IH1cbiAgICBmdW5jdGlvbiBoZXZhbCh5MCx5MSxrMCxrMSx4KSB7XG4gICAgICAgIHZhciBBID0gazAqMi0oeTEteTApO1xuICAgICAgICB2YXIgQiA9IC1rMSoyKyh5MS15MCk7XG4gICAgICAgIHZhciB0ID0gKHgrMSkqMC41O1xuICAgICAgICB2YXIgcyA9IHQqKDEtdCk7XG4gICAgICAgIHJldHVybiAoMS10KSp5MCt0KnkxK0EqcyooMS10KStCKnMqdDtcbiAgICB9XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIHZhciB4ID0gdGhpcy54LCB5bCA9IHRoaXMueWwsIHlyID0gdGhpcy55ciwga2wgPSB0aGlzLmtsLCBrciA9IHRoaXMua3I7XG4gICAgaWYodHlwZW9mIHlsWzBdID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHlsID0gW3lsXTtcbiAgICAgICAgeXIgPSBbeXJdO1xuICAgICAgICBrbCA9IFtrbF07XG4gICAgICAgIGtyID0gW2tyXTtcbiAgICB9XG4gICAgdmFyIG0gPSB5bC5sZW5ndGgsbj14Lmxlbmd0aC0xLGksaixrLHkscyx0O1xuICAgIHZhciBhaSxiaSxjaSxkaSwgcmV0ID0gQXJyYXkobSkscmksazAsazEseTAseTEsQSxCLEQsZHgsY3gsc3RvcHMsejAsejEsem0sdDAsdDEsdG07XG4gICAgdmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG4gICAgZm9yKGk9MDtpIT09bTsrK2kpIHtcbiAgICAgICAgYWkgPSB5bFtpXTtcbiAgICAgICAgYmkgPSB5cltpXTtcbiAgICAgICAgY2kgPSBrbFtpXTtcbiAgICAgICAgZGkgPSBrcltpXTtcbiAgICAgICAgcmkgPSBbXTtcbiAgICAgICAgZm9yKGo9MDtqIT09bjtqKyspIHtcbiAgICAgICAgICAgIGlmKGo+MCAmJiBiaVtqXSphaVtqXTwwKSByaS5wdXNoKHhbal0pO1xuICAgICAgICAgICAgZHggPSAoeFtqKzFdLXhbal0pO1xuICAgICAgICAgICAgY3ggPSB4W2pdO1xuICAgICAgICAgICAgeTAgPSBhaVtqXTtcbiAgICAgICAgICAgIHkxID0gYmlbaisxXTtcbiAgICAgICAgICAgIGswID0gY2lbal0vZHg7XG4gICAgICAgICAgICBrMSA9IGRpW2orMV0vZHg7XG4gICAgICAgICAgICBEID0gc3FyKGswLWsxKzMqKHkwLXkxKSkgKyAxMiprMSp5MDtcbiAgICAgICAgICAgIEEgPSBrMSszKnkwKzIqazAtMyp5MTtcbiAgICAgICAgICAgIEIgPSAzKihrMStrMCsyKih5MC15MSkpO1xuICAgICAgICAgICAgaWYoRDw9MCkge1xuICAgICAgICAgICAgICAgIHowID0gQS9CO1xuICAgICAgICAgICAgICAgIGlmKHowPnhbal0gJiYgejA8eFtqKzFdKSBzdG9wcyA9IFt4W2pdLHowLHhbaisxXV07XG4gICAgICAgICAgICAgICAgZWxzZSBzdG9wcyA9IFt4W2pdLHhbaisxXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHowID0gKEEtc3FydChEKSkvQjtcbiAgICAgICAgICAgICAgICB6MSA9IChBK3NxcnQoRCkpL0I7XG4gICAgICAgICAgICAgICAgc3RvcHMgPSBbeFtqXV07XG4gICAgICAgICAgICAgICAgaWYoejA+eFtqXSAmJiB6MDx4W2orMV0pIHN0b3BzLnB1c2goejApO1xuICAgICAgICAgICAgICAgIGlmKHoxPnhbal0gJiYgejE8eFtqKzFdKSBzdG9wcy5wdXNoKHoxKTtcbiAgICAgICAgICAgICAgICBzdG9wcy5wdXNoKHhbaisxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0MCA9IHN0b3BzWzBdO1xuICAgICAgICAgICAgejAgPSB0aGlzLl9hdCh0MCxqKTtcbiAgICAgICAgICAgIGZvcihrPTA7azxzdG9wcy5sZW5ndGgtMTtrKyspIHtcbiAgICAgICAgICAgICAgICB0MSA9IHN0b3BzW2srMV07XG4gICAgICAgICAgICAgICAgejEgPSB0aGlzLl9hdCh0MSxqKTtcbiAgICAgICAgICAgICAgICBpZih6MCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByaS5wdXNoKHQwKTsgXG4gICAgICAgICAgICAgICAgICAgIHQwID0gdDE7XG4gICAgICAgICAgICAgICAgICAgIHowID0gejE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZih6MSA9PT0gMCB8fCB6MCp6MT4wKSB7XG4gICAgICAgICAgICAgICAgICAgIHQwID0gdDE7XG4gICAgICAgICAgICAgICAgICAgIHowID0gejE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc2lkZSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUoMSkge1xuICAgICAgICAgICAgICAgICAgICB0bSA9ICh6MCp0MS16MSp0MCkvKHowLXoxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYodG0gPD0gdDAgfHwgdG0gPj0gdDEpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgem0gPSB0aGlzLl9hdCh0bSxqKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoem0qejE+MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdDEgPSB0bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHoxID0gem07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzaWRlID09PSAtMSkgejAqPTAuNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGUgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHptKnowPjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQwID0gdG07XG4gICAgICAgICAgICAgICAgICAgICAgICB6MCA9IHptO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2lkZSA9PT0gMSkgejEqPTAuNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGUgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJpLnB1c2godG0pO1xuICAgICAgICAgICAgICAgIHQwID0gc3RvcHNbaysxXTtcbiAgICAgICAgICAgICAgICB6MCA9IHRoaXMuX2F0KHQwLCBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHoxID09PSAwKSByaS5wdXNoKHQxKTtcbiAgICAgICAgfVxuICAgICAgICByZXRbaV0gPSByaTtcbiAgICB9XG4gICAgaWYodHlwZW9mIHRoaXMueWxbMF0gPT09IFwibnVtYmVyXCIpIHJldHVybiByZXRbMF07XG4gICAgcmV0dXJuIHJldDtcbn1cbm51bWVyaWMuc3BsaW5lID0gZnVuY3Rpb24gc3BsaW5lKHgseSxrMSxrbikge1xuICAgIHZhciBuID0geC5sZW5ndGgsIGIgPSBbXSwgZHggPSBbXSwgZHkgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgc3ViID0gbnVtZXJpYy5zdWIsbXVsID0gbnVtZXJpYy5tdWwsYWRkID0gbnVtZXJpYy5hZGQ7XG4gICAgZm9yKGk9bi0yO2k+PTA7aS0tKSB7IGR4W2ldID0geFtpKzFdLXhbaV07IGR5W2ldID0gc3ViKHlbaSsxXSx5W2ldKTsgfVxuICAgIGlmKHR5cGVvZiBrMSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2Yga24gPT09IFwic3RyaW5nXCIpIHsgXG4gICAgICAgIGsxID0ga24gPSBcInBlcmlvZGljXCI7XG4gICAgfVxuICAgIC8vIEJ1aWxkIHNwYXJzZSB0cmlkaWFnb25hbCBzeXN0ZW1cbiAgICB2YXIgVCA9IFtbXSxbXSxbXV07XG4gICAgc3dpdGNoKHR5cGVvZiBrMSkge1xuICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgYlswXSA9IG11bCgzLyhkeFswXSpkeFswXSksZHlbMF0pO1xuICAgICAgICBUWzBdLnB1c2goMCwwKTtcbiAgICAgICAgVFsxXS5wdXNoKDAsMSk7XG4gICAgICAgIFRbMl0ucHVzaCgyL2R4WzBdLDEvZHhbMF0pO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIGJbMF0gPSBhZGQobXVsKDMvKGR4W24tMl0qZHhbbi0yXSksZHlbbi0yXSksbXVsKDMvKGR4WzBdKmR4WzBdKSxkeVswXSkpO1xuICAgICAgICBUWzBdLnB1c2goMCwwLDApO1xuICAgICAgICBUWzFdLnB1c2gobi0yLDAsMSk7XG4gICAgICAgIFRbMl0ucHVzaCgxL2R4W24tMl0sMi9keFtuLTJdKzIvZHhbMF0sMS9keFswXSk7XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIGJbMF0gPSBrMTtcbiAgICAgICAgVFswXS5wdXNoKDApO1xuICAgICAgICBUWzFdLnB1c2goMCk7XG4gICAgICAgIFRbMl0ucHVzaCgxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvcihpPTE7aTxuLTE7aSsrKSB7XG4gICAgICAgIGJbaV0gPSBhZGQobXVsKDMvKGR4W2ktMV0qZHhbaS0xXSksZHlbaS0xXSksbXVsKDMvKGR4W2ldKmR4W2ldKSxkeVtpXSkpO1xuICAgICAgICBUWzBdLnB1c2goaSxpLGkpO1xuICAgICAgICBUWzFdLnB1c2goaS0xLGksaSsxKTtcbiAgICAgICAgVFsyXS5wdXNoKDEvZHhbaS0xXSwyL2R4W2ktMV0rMi9keFtpXSwxL2R4W2ldKTtcbiAgICB9XG4gICAgc3dpdGNoKHR5cGVvZiBrbikge1xuICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgYltuLTFdID0gbXVsKDMvKGR4W24tMl0qZHhbbi0yXSksZHlbbi0yXSk7XG4gICAgICAgIFRbMF0ucHVzaChuLTEsbi0xKTtcbiAgICAgICAgVFsxXS5wdXNoKG4tMixuLTEpO1xuICAgICAgICBUWzJdLnB1c2goMS9keFtuLTJdLDIvZHhbbi0yXSk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgVFsxXVtUWzFdLmxlbmd0aC0xXSA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIGJbbi0xXSA9IGtuO1xuICAgICAgICBUWzBdLnB1c2gobi0xKTtcbiAgICAgICAgVFsxXS5wdXNoKG4tMSk7XG4gICAgICAgIFRbMl0ucHVzaCgxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmKHR5cGVvZiBiWzBdICE9PSBcIm51bWJlclwiKSBiID0gbnVtZXJpYy50cmFuc3Bvc2UoYik7XG4gICAgZWxzZSBiID0gW2JdO1xuICAgIHZhciBrID0gQXJyYXkoYi5sZW5ndGgpO1xuICAgIGlmKHR5cGVvZiBrMSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBmb3IoaT1rLmxlbmd0aC0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgICAgIGtbaV0gPSBudW1lcmljLmNjc0xVUFNvbHZlKG51bWVyaWMuY2NzTFVQKG51bWVyaWMuY2NzU2NhdHRlcihUKSksYltpXSk7XG4gICAgICAgICAgICBrW2ldW24tMV0gPSBrW2ldWzBdO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yKGk9ay5sZW5ndGgtMTtpIT09LTE7LS1pKSB7XG4gICAgICAgICAgICBrW2ldID0gbnVtZXJpYy5jTFVzb2x2ZShudW1lcmljLmNMVShUKSxiW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZih0eXBlb2YgeVswXSA9PT0gXCJudW1iZXJcIikgayA9IGtbMF07XG4gICAgZWxzZSBrID0gbnVtZXJpYy50cmFuc3Bvc2Uoayk7XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlNwbGluZSh4LHkseSxrLGspO1xufVxuXG4vLyA4LiBGRlRcbm51bWVyaWMuZmZ0cG93MiA9IGZ1bmN0aW9uIGZmdHBvdzIoeCx5KSB7XG4gICAgdmFyIG4gPSB4Lmxlbmd0aDtcbiAgICBpZihuID09PSAxKSByZXR1cm47XG4gICAgdmFyIGNvcyA9IE1hdGguY29zLCBzaW4gPSBNYXRoLnNpbiwgaSxqO1xuICAgIHZhciB4ZSA9IEFycmF5KG4vMiksIHllID0gQXJyYXkobi8yKSwgeG8gPSBBcnJheShuLzIpLCB5byA9IEFycmF5KG4vMik7XG4gICAgaiA9IG4vMjtcbiAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkge1xuICAgICAgICAtLWo7XG4gICAgICAgIHhvW2pdID0geFtpXTtcbiAgICAgICAgeW9bal0gPSB5W2ldO1xuICAgICAgICAtLWk7XG4gICAgICAgIHhlW2pdID0geFtpXTtcbiAgICAgICAgeWVbal0gPSB5W2ldO1xuICAgIH1cbiAgICBmZnRwb3cyKHhlLHllKTtcbiAgICBmZnRwb3cyKHhvLHlvKTtcbiAgICBqID0gbi8yO1xuICAgIHZhciB0LGsgPSAoLTYuMjgzMTg1MzA3MTc5NTg2NDc2OTI1Mjg2NzY2NTU5MDA1NzY4Mzk0MzM4Nzk4NzUwMjExNjQxOS9uKSxjaSxzaTtcbiAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkge1xuICAgICAgICAtLWo7XG4gICAgICAgIGlmKGogPT09IC0xKSBqID0gbi8yLTE7XG4gICAgICAgIHQgPSBrKmk7XG4gICAgICAgIGNpID0gY29zKHQpO1xuICAgICAgICBzaSA9IHNpbih0KTtcbiAgICAgICAgeFtpXSA9IHhlW2pdICsgY2kqeG9bal0gLSBzaSp5b1tqXTtcbiAgICAgICAgeVtpXSA9IHllW2pdICsgY2kqeW9bal0gKyBzaSp4b1tqXTtcbiAgICB9XG59XG5udW1lcmljLl9pZmZ0cG93MiA9IGZ1bmN0aW9uIF9pZmZ0cG93Mih4LHkpIHtcbiAgICB2YXIgbiA9IHgubGVuZ3RoO1xuICAgIGlmKG4gPT09IDEpIHJldHVybjtcbiAgICB2YXIgY29zID0gTWF0aC5jb3MsIHNpbiA9IE1hdGguc2luLCBpLGo7XG4gICAgdmFyIHhlID0gQXJyYXkobi8yKSwgeWUgPSBBcnJheShuLzIpLCB4byA9IEFycmF5KG4vMiksIHlvID0gQXJyYXkobi8yKTtcbiAgICBqID0gbi8yO1xuICAgIGZvcihpPW4tMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIC0tajtcbiAgICAgICAgeG9bal0gPSB4W2ldO1xuICAgICAgICB5b1tqXSA9IHlbaV07XG4gICAgICAgIC0taTtcbiAgICAgICAgeGVbal0gPSB4W2ldO1xuICAgICAgICB5ZVtqXSA9IHlbaV07XG4gICAgfVxuICAgIF9pZmZ0cG93Mih4ZSx5ZSk7XG4gICAgX2lmZnRwb3cyKHhvLHlvKTtcbiAgICBqID0gbi8yO1xuICAgIHZhciB0LGsgPSAoNi4yODMxODUzMDcxNzk1ODY0NzY5MjUyODY3NjY1NTkwMDU3NjgzOTQzMzg3OTg3NTAyMTE2NDE5L24pLGNpLHNpO1xuICAgIGZvcihpPW4tMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIC0tajtcbiAgICAgICAgaWYoaiA9PT0gLTEpIGogPSBuLzItMTtcbiAgICAgICAgdCA9IGsqaTtcbiAgICAgICAgY2kgPSBjb3ModCk7XG4gICAgICAgIHNpID0gc2luKHQpO1xuICAgICAgICB4W2ldID0geGVbal0gKyBjaSp4b1tqXSAtIHNpKnlvW2pdO1xuICAgICAgICB5W2ldID0geWVbal0gKyBjaSp5b1tqXSArIHNpKnhvW2pdO1xuICAgIH1cbn1cbm51bWVyaWMuaWZmdHBvdzIgPSBmdW5jdGlvbiBpZmZ0cG93Mih4LHkpIHtcbiAgICBudW1lcmljLl9pZmZ0cG93Mih4LHkpO1xuICAgIG51bWVyaWMuZGl2ZXEoeCx4Lmxlbmd0aCk7XG4gICAgbnVtZXJpYy5kaXZlcSh5LHkubGVuZ3RoKTtcbn1cbm51bWVyaWMuY29udnBvdzIgPSBmdW5jdGlvbiBjb252cG93MihheCxheSxieCxieSkge1xuICAgIG51bWVyaWMuZmZ0cG93MihheCxheSk7XG4gICAgbnVtZXJpYy5mZnRwb3cyKGJ4LGJ5KTtcbiAgICB2YXIgaSxuID0gYXgubGVuZ3RoLGF4aSxieGksYXlpLGJ5aTtcbiAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkge1xuICAgICAgICBheGkgPSBheFtpXTsgYXlpID0gYXlbaV07IGJ4aSA9IGJ4W2ldOyBieWkgPSBieVtpXTtcbiAgICAgICAgYXhbaV0gPSBheGkqYnhpLWF5aSpieWk7XG4gICAgICAgIGF5W2ldID0gYXhpKmJ5aStheWkqYnhpO1xuICAgIH1cbiAgICBudW1lcmljLmlmZnRwb3cyKGF4LGF5KTtcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUuZmZ0ID0gZnVuY3Rpb24gZmZ0KCkge1xuICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55O1xuICAgIHZhciBuID0geC5sZW5ndGgsIGxvZyA9IE1hdGgubG9nLCBsb2cyID0gbG9nKDIpLFxuICAgICAgICBwID0gTWF0aC5jZWlsKGxvZygyKm4tMSkvbG9nMiksIG0gPSBNYXRoLnBvdygyLHApO1xuICAgIHZhciBjeCA9IG51bWVyaWMucmVwKFttXSwwKSwgY3kgPSBudW1lcmljLnJlcChbbV0sMCksIGNvcyA9IE1hdGguY29zLCBzaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgaywgYyA9ICgtMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1MDI4ODQxOTcxNjkzOTkzNzUxMDU4MjAvbiksdDtcbiAgICB2YXIgYSA9IG51bWVyaWMucmVwKFttXSwwKSwgYiA9IG51bWVyaWMucmVwKFttXSwwKSxuaGFsZiA9IE1hdGguZmxvb3Iobi8yKTtcbiAgICBmb3Ioaz0wO2s8bjtrKyspIGFba10gPSB4W2tdO1xuICAgIGlmKHR5cGVvZiB5ICE9PSBcInVuZGVmaW5lZFwiKSBmb3Ioaz0wO2s8bjtrKyspIGJba10gPSB5W2tdO1xuICAgIGN4WzBdID0gMTtcbiAgICBmb3Ioaz0xO2s8PW0vMjtrKyspIHtcbiAgICAgICAgdCA9IGMqayprO1xuICAgICAgICBjeFtrXSA9IGNvcyh0KTtcbiAgICAgICAgY3lba10gPSBzaW4odCk7XG4gICAgICAgIGN4W20ta10gPSBjb3ModCk7XG4gICAgICAgIGN5W20ta10gPSBzaW4odClcbiAgICB9XG4gICAgdmFyIFggPSBuZXcgbnVtZXJpYy5UKGEsYiksIFkgPSBuZXcgbnVtZXJpYy5UKGN4LGN5KTtcbiAgICBYID0gWC5tdWwoWSk7XG4gICAgbnVtZXJpYy5jb252cG93MihYLngsWC55LG51bWVyaWMuY2xvbmUoWS54KSxudW1lcmljLm5lZyhZLnkpKTtcbiAgICBYID0gWC5tdWwoWSk7XG4gICAgWC54Lmxlbmd0aCA9IG47XG4gICAgWC55Lmxlbmd0aCA9IG47XG4gICAgcmV0dXJuIFg7XG59XG5udW1lcmljLlQucHJvdG90eXBlLmlmZnQgPSBmdW5jdGlvbiBpZmZ0KCkge1xuICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55O1xuICAgIHZhciBuID0geC5sZW5ndGgsIGxvZyA9IE1hdGgubG9nLCBsb2cyID0gbG9nKDIpLFxuICAgICAgICBwID0gTWF0aC5jZWlsKGxvZygyKm4tMSkvbG9nMiksIG0gPSBNYXRoLnBvdygyLHApO1xuICAgIHZhciBjeCA9IG51bWVyaWMucmVwKFttXSwwKSwgY3kgPSBudW1lcmljLnJlcChbbV0sMCksIGNvcyA9IE1hdGguY29zLCBzaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgaywgYyA9ICgzLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0MzM4MzI3OTUwMjg4NDE5NzE2OTM5OTM3NTEwNTgyMC9uKSx0O1xuICAgIHZhciBhID0gbnVtZXJpYy5yZXAoW21dLDApLCBiID0gbnVtZXJpYy5yZXAoW21dLDApLG5oYWxmID0gTWF0aC5mbG9vcihuLzIpO1xuICAgIGZvcihrPTA7azxuO2srKykgYVtrXSA9IHhba107XG4gICAgaWYodHlwZW9mIHkgIT09IFwidW5kZWZpbmVkXCIpIGZvcihrPTA7azxuO2srKykgYltrXSA9IHlba107XG4gICAgY3hbMF0gPSAxO1xuICAgIGZvcihrPTE7azw9bS8yO2srKykge1xuICAgICAgICB0ID0gYyprKms7XG4gICAgICAgIGN4W2tdID0gY29zKHQpO1xuICAgICAgICBjeVtrXSA9IHNpbih0KTtcbiAgICAgICAgY3hbbS1rXSA9IGNvcyh0KTtcbiAgICAgICAgY3lbbS1rXSA9IHNpbih0KVxuICAgIH1cbiAgICB2YXIgWCA9IG5ldyBudW1lcmljLlQoYSxiKSwgWSA9IG5ldyBudW1lcmljLlQoY3gsY3kpO1xuICAgIFggPSBYLm11bChZKTtcbiAgICBudW1lcmljLmNvbnZwb3cyKFgueCxYLnksbnVtZXJpYy5jbG9uZShZLngpLG51bWVyaWMubmVnKFkueSkpO1xuICAgIFggPSBYLm11bChZKTtcbiAgICBYLngubGVuZ3RoID0gbjtcbiAgICBYLnkubGVuZ3RoID0gbjtcbiAgICByZXR1cm4gWC5kaXYobik7XG59XG5cbi8vOS4gVW5jb25zdHJhaW5lZCBvcHRpbWl6YXRpb25cbm51bWVyaWMuZ3JhZGllbnQgPSBmdW5jdGlvbiBncmFkaWVudChmLHgpIHtcbiAgICB2YXIgbiA9IHgubGVuZ3RoO1xuICAgIHZhciBmMCA9IGYoeCk7XG4gICAgaWYoaXNOYU4oZjApKSB0aHJvdyBuZXcgRXJyb3IoJ2dyYWRpZW50OiBmKHgpIGlzIGEgTmFOIScpO1xuICAgIHZhciBtYXggPSBNYXRoLm1heDtcbiAgICB2YXIgaSx4MCA9IG51bWVyaWMuY2xvbmUoeCksZjEsZjIsIEogPSBBcnJheShuKTtcbiAgICB2YXIgZGl2ID0gbnVtZXJpYy5kaXYsIHN1YiA9IG51bWVyaWMuc3ViLGVycmVzdCxyb3VuZG9mZixtYXggPSBNYXRoLm1heCxlcHMgPSAxZS0zLGFicyA9IE1hdGguYWJzLCBtaW4gPSBNYXRoLm1pbjtcbiAgICB2YXIgdDAsdDEsdDIsaXQ9MCxkMSxkMixOO1xuICAgIGZvcihpPTA7aTxuO2krKykge1xuICAgICAgICB2YXIgaCA9IG1heCgxZS02KmYwLDFlLTgpO1xuICAgICAgICB3aGlsZSgxKSB7XG4gICAgICAgICAgICArK2l0O1xuICAgICAgICAgICAgaWYoaXQ+MjApIHsgdGhyb3cgbmV3IEVycm9yKFwiTnVtZXJpY2FsIGdyYWRpZW50IGZhaWxzXCIpOyB9XG4gICAgICAgICAgICB4MFtpXSA9IHhbaV0raDtcbiAgICAgICAgICAgIGYxID0gZih4MCk7XG4gICAgICAgICAgICB4MFtpXSA9IHhbaV0taDtcbiAgICAgICAgICAgIGYyID0gZih4MCk7XG4gICAgICAgICAgICB4MFtpXSA9IHhbaV07XG4gICAgICAgICAgICBpZihpc05hTihmMSkgfHwgaXNOYU4oZjIpKSB7IGgvPTE2OyBjb250aW51ZTsgfVxuICAgICAgICAgICAgSltpXSA9IChmMS1mMikvKDIqaCk7XG4gICAgICAgICAgICB0MCA9IHhbaV0taDtcbiAgICAgICAgICAgIHQxID0geFtpXTtcbiAgICAgICAgICAgIHQyID0geFtpXStoO1xuICAgICAgICAgICAgZDEgPSAoZjEtZjApL2g7XG4gICAgICAgICAgICBkMiA9IChmMC1mMikvaDtcbiAgICAgICAgICAgIE4gPSBtYXgoYWJzKEpbaV0pLGFicyhmMCksYWJzKGYxKSxhYnMoZjIpLGFicyh0MCksYWJzKHQxKSxhYnModDIpLDFlLTgpO1xuICAgICAgICAgICAgZXJyZXN0ID0gbWluKG1heChhYnMoZDEtSltpXSksYWJzKGQyLUpbaV0pLGFicyhkMS1kMikpL04saC9OKTtcbiAgICAgICAgICAgIGlmKGVycmVzdD5lcHMpIHsgaC89MTY7IH1cbiAgICAgICAgICAgIGVsc2UgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBKO1xufVxuXG5udW1lcmljLnVuY21pbiA9IGZ1bmN0aW9uIHVuY21pbihmLHgwLHRvbCxncmFkaWVudCxtYXhpdCxjYWxsYmFjayxvcHRpb25zKSB7XG4gICAgdmFyIGdyYWQgPSBudW1lcmljLmdyYWRpZW50O1xuICAgIGlmKHR5cGVvZiBvcHRpb25zID09PSBcInVuZGVmaW5lZFwiKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIGlmKHR5cGVvZiB0b2wgPT09IFwidW5kZWZpbmVkXCIpIHsgdG9sID0gMWUtODsgfVxuICAgIGlmKHR5cGVvZiBncmFkaWVudCA9PT0gXCJ1bmRlZmluZWRcIikgeyBncmFkaWVudCA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGdyYWQoZix4KTsgfTsgfVxuICAgIGlmKHR5cGVvZiBtYXhpdCA9PT0gXCJ1bmRlZmluZWRcIikgbWF4aXQgPSAxMDAwO1xuICAgIHgwID0gbnVtZXJpYy5jbG9uZSh4MCk7XG4gICAgdmFyIG4gPSB4MC5sZW5ndGg7XG4gICAgdmFyIGYwID0gZih4MCksZjEsZGYwO1xuICAgIGlmKGlzTmFOKGYwKSkgdGhyb3cgbmV3IEVycm9yKCd1bmNtaW46IGYoeDApIGlzIGEgTmFOIScpO1xuICAgIHZhciBtYXggPSBNYXRoLm1heCwgbm9ybTIgPSBudW1lcmljLm5vcm0yO1xuICAgIHRvbCA9IG1heCh0b2wsbnVtZXJpYy5lcHNpbG9uKTtcbiAgICB2YXIgc3RlcCxnMCxnMSxIMSA9IG9wdGlvbnMuSGludiB8fCBudW1lcmljLmlkZW50aXR5KG4pO1xuICAgIHZhciBkb3QgPSBudW1lcmljLmRvdCwgaW52ID0gbnVtZXJpYy5pbnYsIHN1YiA9IG51bWVyaWMuc3ViLCBhZGQgPSBudW1lcmljLmFkZCwgdGVuID0gbnVtZXJpYy50ZW5zb3IsIGRpdiA9IG51bWVyaWMuZGl2LCBtdWwgPSBudW1lcmljLm11bDtcbiAgICB2YXIgYWxsID0gbnVtZXJpYy5hbGwsIGlzZmluaXRlID0gbnVtZXJpYy5pc0Zpbml0ZSwgbmVnID0gbnVtZXJpYy5uZWc7XG4gICAgdmFyIGl0PTAsaSxzLHgxLHksSHksSHMseXMsaTAsdCxuc3RlcCx0MSx0MjtcbiAgICB2YXIgbXNnID0gXCJcIjtcbiAgICBnMCA9IGdyYWRpZW50KHgwKTtcbiAgICB3aGlsZShpdDxtYXhpdCkge1xuICAgICAgICBpZih0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikgeyBpZihjYWxsYmFjayhpdCx4MCxmMCxnMCxIMSkpIHsgbXNnID0gXCJDYWxsYmFjayByZXR1cm5lZCB0cnVlXCI7IGJyZWFrOyB9IH1cbiAgICAgICAgaWYoIWFsbChpc2Zpbml0ZShnMCkpKSB7IG1zZyA9IFwiR3JhZGllbnQgaGFzIEluZmluaXR5IG9yIE5hTlwiOyBicmVhazsgfVxuICAgICAgICBzdGVwID0gbmVnKGRvdChIMSxnMCkpO1xuICAgICAgICBpZighYWxsKGlzZmluaXRlKHN0ZXApKSkgeyBtc2cgPSBcIlNlYXJjaCBkaXJlY3Rpb24gaGFzIEluZmluaXR5IG9yIE5hTlwiOyBicmVhazsgfVxuICAgICAgICBuc3RlcCA9IG5vcm0yKHN0ZXApO1xuICAgICAgICBpZihuc3RlcCA8IHRvbCkgeyBtc2c9XCJOZXd0b24gc3RlcCBzbWFsbGVyIHRoYW4gdG9sXCI7IGJyZWFrOyB9XG4gICAgICAgIHQgPSAxO1xuICAgICAgICBkZjAgPSBkb3QoZzAsc3RlcCk7XG4gICAgICAgIC8vIGxpbmUgc2VhcmNoXG4gICAgICAgIHgxID0geDA7XG4gICAgICAgIHdoaWxlKGl0IDwgbWF4aXQpIHtcbiAgICAgICAgICAgIGlmKHQqbnN0ZXAgPCB0b2wpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIHMgPSBtdWwoc3RlcCx0KTtcbiAgICAgICAgICAgIHgxID0gYWRkKHgwLHMpO1xuICAgICAgICAgICAgZjEgPSBmKHgxKTtcbiAgICAgICAgICAgIGlmKGYxLWYwID49IDAuMSp0KmRmMCB8fCBpc05hTihmMSkpIHtcbiAgICAgICAgICAgICAgICB0ICo9IDAuNTtcbiAgICAgICAgICAgICAgICArK2l0O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYodCpuc3RlcCA8IHRvbCkgeyBtc2cgPSBcIkxpbmUgc2VhcmNoIHN0ZXAgc2l6ZSBzbWFsbGVyIHRoYW4gdG9sXCI7IGJyZWFrOyB9XG4gICAgICAgIGlmKGl0ID09PSBtYXhpdCkgeyBtc2cgPSBcIm1heGl0IHJlYWNoZWQgZHVyaW5nIGxpbmUgc2VhcmNoXCI7IGJyZWFrOyB9XG4gICAgICAgIGcxID0gZ3JhZGllbnQoeDEpO1xuICAgICAgICB5ID0gc3ViKGcxLGcwKTtcbiAgICAgICAgeXMgPSBkb3QoeSxzKTtcbiAgICAgICAgSHkgPSBkb3QoSDEseSk7XG4gICAgICAgIEgxID0gc3ViKGFkZChIMSxcbiAgICAgICAgICAgICAgICBtdWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAoeXMrZG90KHksSHkpKS8oeXMqeXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVuKHMscykgICAgKSksXG4gICAgICAgICAgICAgICAgZGl2KGFkZCh0ZW4oSHkscyksdGVuKHMsSHkpKSx5cykpO1xuICAgICAgICB4MCA9IHgxO1xuICAgICAgICBmMCA9IGYxO1xuICAgICAgICBnMCA9IGcxO1xuICAgICAgICArK2l0O1xuICAgIH1cbiAgICByZXR1cm4ge3NvbHV0aW9uOiB4MCwgZjogZjAsIGdyYWRpZW50OiBnMCwgaW52SGVzc2lhbjogSDEsIGl0ZXJhdGlvbnM6aXQsIG1lc3NhZ2U6IG1zZ307XG59XG5cbi8vIDEwLiBPZGUgc29sdmVyIChEb3JtYW5kLVByaW5jZSlcbm51bWVyaWMuRG9wcmkgPSBmdW5jdGlvbiBEb3ByaSh4LHksZix5bWlkLGl0ZXJhdGlvbnMsbXNnLGV2ZW50cykge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLmYgPSBmO1xuICAgIHRoaXMueW1pZCA9IHltaWQ7XG4gICAgdGhpcy5pdGVyYXRpb25zID0gaXRlcmF0aW9ucztcbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcbiAgICB0aGlzLm1lc3NhZ2UgPSBtc2c7XG59XG5udW1lcmljLkRvcHJpLnByb3RvdHlwZS5fYXQgPSBmdW5jdGlvbiBfYXQoeGksaikge1xuICAgIGZ1bmN0aW9uIHNxcih4KSB7IHJldHVybiB4Kng7IH1cbiAgICB2YXIgc29sID0gdGhpcztcbiAgICB2YXIgeHMgPSBzb2wueDtcbiAgICB2YXIgeXMgPSBzb2wueTtcbiAgICB2YXIgazEgPSBzb2wuZjtcbiAgICB2YXIgeW1pZCA9IHNvbC55bWlkO1xuICAgIHZhciBuID0geHMubGVuZ3RoO1xuICAgIHZhciB4MCx4MSx4aCx5MCx5MSx5aCx4aTtcbiAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yLGg7XG4gICAgdmFyIGMgPSAwLjU7XG4gICAgdmFyIGFkZCA9IG51bWVyaWMuYWRkLCBtdWwgPSBudW1lcmljLm11bCxzdWIgPSBudW1lcmljLnN1YiwgcCxxLHc7XG4gICAgeDAgPSB4c1tqXTtcbiAgICB4MSA9IHhzW2orMV07XG4gICAgeTAgPSB5c1tqXTtcbiAgICB5MSA9IHlzW2orMV07XG4gICAgaCAgPSB4MS14MDtcbiAgICB4aCA9IHgwK2MqaDtcbiAgICB5aCA9IHltaWRbal07XG4gICAgcCA9IHN1YihrMVtqICBdLG11bCh5MCwxLyh4MC14aCkrMi8oeDAteDEpKSk7XG4gICAgcSA9IHN1YihrMVtqKzFdLG11bCh5MSwxLyh4MS14aCkrMi8oeDEteDApKSk7XG4gICAgdyA9IFtzcXIoeGkgLSB4MSkgKiAoeGkgLSB4aCkgLyBzcXIoeDAgLSB4MSkgLyAoeDAgLSB4aCksXG4gICAgICAgICBzcXIoeGkgLSB4MCkgKiBzcXIoeGkgLSB4MSkgLyBzcXIoeDAgLSB4aCkgLyBzcXIoeDEgLSB4aCksXG4gICAgICAgICBzcXIoeGkgLSB4MCkgKiAoeGkgLSB4aCkgLyBzcXIoeDEgLSB4MCkgLyAoeDEgLSB4aCksXG4gICAgICAgICAoeGkgLSB4MCkgKiBzcXIoeGkgLSB4MSkgKiAoeGkgLSB4aCkgLyBzcXIoeDAteDEpIC8gKHgwIC0geGgpLFxuICAgICAgICAgKHhpIC0geDEpICogc3FyKHhpIC0geDApICogKHhpIC0geGgpIC8gc3FyKHgwLXgxKSAvICh4MSAtIHhoKV07XG4gICAgcmV0dXJuIGFkZChhZGQoYWRkKGFkZChtdWwoeTAsd1swXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtdWwoeWgsd1sxXSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsKHkxLHdbMl0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bCggcCx3WzNdKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtdWwoIHEsd1s0XSkpO1xufVxubnVtZXJpYy5Eb3ByaS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBhdCh4KSB7XG4gICAgdmFyIGksaixrLGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICBpZih0eXBlb2YgeCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICB2YXIgbiA9IHgubGVuZ3RoLCByZXQgPSBBcnJheShuKTtcbiAgICAgICAgZm9yKGk9bi0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgICAgIHJldFtpXSA9IHRoaXMuYXQoeFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgdmFyIHgwID0gdGhpcy54O1xuICAgIGkgPSAwOyBqID0geDAubGVuZ3RoLTE7XG4gICAgd2hpbGUoai1pPjEpIHtcbiAgICAgICAgayA9IGZsb29yKDAuNSooaStqKSk7XG4gICAgICAgIGlmKHgwW2tdIDw9IHgpIGkgPSBrO1xuICAgICAgICBlbHNlIGogPSBrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYXQoeCxpKTtcbn1cblxubnVtZXJpYy5kb3ByaSA9IGZ1bmN0aW9uIGRvcHJpKHgwLHgxLHkwLGYsdG9sLG1heGl0LGV2ZW50KSB7XG4gICAgaWYodHlwZW9mIHRvbCA9PT0gXCJ1bmRlZmluZWRcIikgeyB0b2wgPSAxZS02OyB9XG4gICAgaWYodHlwZW9mIG1heGl0ID09PSBcInVuZGVmaW5lZFwiKSB7IG1heGl0ID0gMTAwMDsgfVxuICAgIHZhciB4cyA9IFt4MF0sIHlzID0gW3kwXSwgazEgPSBbZih4MCx5MCldLCBrMixrMyxrNCxrNSxrNixrNywgeW1pZCA9IFtdO1xuICAgIHZhciBBMiA9IDEvNTtcbiAgICB2YXIgQTMgPSBbMy80MCw5LzQwXTtcbiAgICB2YXIgQTQgPSBbNDQvNDUsLTU2LzE1LDMyLzldO1xuICAgIHZhciBBNSA9IFsxOTM3Mi82NTYxLC0yNTM2MC8yMTg3LDY0NDQ4LzY1NjEsLTIxMi83MjldO1xuICAgIHZhciBBNiA9IFs5MDE3LzMxNjgsLTM1NS8zMyw0NjczMi81MjQ3LDQ5LzE3NiwtNTEwMy8xODY1Nl07XG4gICAgdmFyIGIgPSBbMzUvMzg0LDAsNTAwLzExMTMsMTI1LzE5MiwtMjE4Ny82Nzg0LDExLzg0XTtcbiAgICB2YXIgYm0gPSBbMC41KjYwMjUxOTI3NDMvMzAwODU1NTMxNTIsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDAuNSo1MTI1MjI5MjkyNS82NTQwMDgyMTU5OCxcbiAgICAgICAgICAgICAgMC41Ki0yNjkxODY4OTI1LzQ1MTI4MzI5NzI4LFxuICAgICAgICAgICAgICAwLjUqMTg3OTQwMzcyMDY3LzE1OTQ1MzQzMTcwNTYsXG4gICAgICAgICAgICAgIDAuNSotMTc3NjA5NDMzMS8xOTc0MzY0NDI1NixcbiAgICAgICAgICAgICAgMC41KjExMjM3MDk5LzIzNTA0MzM4NF07XG4gICAgdmFyIGMgPSBbMS81LDMvMTAsNC81LDgvOSwxLDFdO1xuICAgIHZhciBlID0gWy03MS81NzYwMCwwLDcxLzE2Njk1LC03MS8xOTIwLDE3MjUzLzMzOTIwMCwtMjIvNTI1LDEvNDBdO1xuICAgIHZhciBpID0gMCxlcixqO1xuICAgIHZhciBoID0gKHgxLXgwKS8xMDtcbiAgICB2YXIgaXQgPSAwO1xuICAgIHZhciBhZGQgPSBudW1lcmljLmFkZCwgbXVsID0gbnVtZXJpYy5tdWwsIHkxLGVyaW5mO1xuICAgIHZhciBtYXggPSBNYXRoLm1heCwgbWluID0gTWF0aC5taW4sIGFicyA9IE1hdGguYWJzLCBub3JtaW5mID0gbnVtZXJpYy5ub3JtaW5mLHBvdyA9IE1hdGgucG93O1xuICAgIHZhciBhbnkgPSBudW1lcmljLmFueSwgbHQgPSBudW1lcmljLmx0LCBhbmQgPSBudW1lcmljLmFuZCwgc3ViID0gbnVtZXJpYy5zdWI7XG4gICAgdmFyIGUwLCBlMSwgZXY7XG4gICAgdmFyIHJldCA9IG5ldyBudW1lcmljLkRvcHJpKHhzLHlzLGsxLHltaWQsLTEsXCJcIik7XG4gICAgaWYodHlwZW9mIGV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIGUwID0gZXZlbnQoeDAseTApO1xuICAgIHdoaWxlKHgwPHgxICYmIGl0PG1heGl0KSB7XG4gICAgICAgICsraXQ7XG4gICAgICAgIGlmKHgwK2g+eDEpIGggPSB4MS14MDtcbiAgICAgICAgazIgPSBmKHgwK2NbMF0qaCwgICAgICAgICAgICAgICAgYWRkKHkwLG11bCggICBBMipoLGsxW2ldKSkpO1xuICAgICAgICBrMyA9IGYoeDArY1sxXSpoLCAgICAgICAgICAgIGFkZChhZGQoeTAsbXVsKEEzWzBdKmgsazFbaV0pKSxtdWwoQTNbMV0qaCxrMikpKTtcbiAgICAgICAgazQgPSBmKHgwK2NbMl0qaCwgICAgICAgIGFkZChhZGQoYWRkKHkwLG11bChBNFswXSpoLGsxW2ldKSksbXVsKEE0WzFdKmgsazIpKSxtdWwoQTRbMl0qaCxrMykpKTtcbiAgICAgICAgazUgPSBmKHgwK2NbM10qaCwgICAgYWRkKGFkZChhZGQoYWRkKHkwLG11bChBNVswXSpoLGsxW2ldKSksbXVsKEE1WzFdKmgsazIpKSxtdWwoQTVbMl0qaCxrMykpLG11bChBNVszXSpoLGs0KSkpO1xuICAgICAgICBrNiA9IGYoeDArY1s0XSpoLGFkZChhZGQoYWRkKGFkZChhZGQoeTAsbXVsKEE2WzBdKmgsazFbaV0pKSxtdWwoQTZbMV0qaCxrMikpLG11bChBNlsyXSpoLGszKSksbXVsKEE2WzNdKmgsazQpKSxtdWwoQTZbNF0qaCxrNSkpKTtcbiAgICAgICAgeTEgPSBhZGQoYWRkKGFkZChhZGQoYWRkKHkwLG11bChrMVtpXSxoKmJbMF0pKSxtdWwoazMsaCpiWzJdKSksbXVsKGs0LGgqYlszXSkpLG11bChrNSxoKmJbNF0pKSxtdWwoazYsaCpiWzVdKSk7XG4gICAgICAgIGs3ID0gZih4MCtoLHkxKTtcbiAgICAgICAgZXIgPSBhZGQoYWRkKGFkZChhZGQoYWRkKG11bChrMVtpXSxoKmVbMF0pLG11bChrMyxoKmVbMl0pKSxtdWwoazQsaCplWzNdKSksbXVsKGs1LGgqZVs0XSkpLG11bChrNixoKmVbNV0pKSxtdWwoazcsaCplWzZdKSk7XG4gICAgICAgIGlmKHR5cGVvZiBlciA9PT0gXCJudW1iZXJcIikgZXJpbmYgPSBhYnMoZXIpO1xuICAgICAgICBlbHNlIGVyaW5mID0gbm9ybWluZihlcik7XG4gICAgICAgIGlmKGVyaW5mID4gdG9sKSB7IC8vIHJlamVjdFxuICAgICAgICAgICAgaCA9IDAuMipoKnBvdyh0b2wvZXJpbmYsMC4yNSk7XG4gICAgICAgICAgICBpZih4MCtoID09PSB4MCkge1xuICAgICAgICAgICAgICAgIHJldC5tc2cgPSBcIlN0ZXAgc2l6ZSBiZWNhbWUgdG9vIHNtYWxsXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB5bWlkW2ldID0gYWRkKGFkZChhZGQoYWRkKGFkZChhZGQoeTAsXG4gICAgICAgICAgICAgICAgbXVsKGsxW2ldLGgqYm1bMF0pKSxcbiAgICAgICAgICAgICAgICBtdWwoazMgICAsaCpibVsyXSkpLFxuICAgICAgICAgICAgICAgIG11bChrNCAgICxoKmJtWzNdKSksXG4gICAgICAgICAgICAgICAgbXVsKGs1ICAgLGgqYm1bNF0pKSxcbiAgICAgICAgICAgICAgICBtdWwoazYgICAsaCpibVs1XSkpLFxuICAgICAgICAgICAgICAgIG11bChrNyAgICxoKmJtWzZdKSk7XG4gICAgICAgICsraTtcbiAgICAgICAgeHNbaV0gPSB4MCtoO1xuICAgICAgICB5c1tpXSA9IHkxO1xuICAgICAgICBrMVtpXSA9IGs3O1xuICAgICAgICBpZih0eXBlb2YgZXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIHlpLHhsID0geDAseHIgPSB4MCswLjUqaCx4aTtcbiAgICAgICAgICAgIGUxID0gZXZlbnQoeHIseW1pZFtpLTFdKTtcbiAgICAgICAgICAgIGV2ID0gYW5kKGx0KGUwLDApLGx0KDAsZTEpKTtcbiAgICAgICAgICAgIGlmKCFhbnkoZXYpKSB7IHhsID0geHI7IHhyID0geDAraDsgZTAgPSBlMTsgZTEgPSBldmVudCh4cix5MSk7IGV2ID0gYW5kKGx0KGUwLDApLGx0KDAsZTEpKTsgfVxuICAgICAgICAgICAgaWYoYW55KGV2KSkge1xuICAgICAgICAgICAgICAgIHZhciB4YywgeWMsIGVuLGVpO1xuICAgICAgICAgICAgICAgIHZhciBzaWRlPTAsIHNsID0gMS4wLCBzciA9IDEuMDtcbiAgICAgICAgICAgICAgICB3aGlsZSgxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBlMCA9PT0gXCJudW1iZXJcIikgeGkgPSAoc3IqZTEqeGwtc2wqZTAqeHIpLyhzciplMS1zbCplMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSB4cjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihqPWUwLmxlbmd0aC0xO2ohPT0tMTstLWopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihlMFtqXTwwICYmIGUxW2pdPjApIHhpID0gbWluKHhpLChzciplMVtqXSp4bC1zbCplMFtqXSp4cikvKHNyKmUxW2pdLXNsKmUwW2pdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoeGkgPD0geGwgfHwgeGkgPj0geHIpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IHJldC5fYXQoeGksIGktMSk7XG4gICAgICAgICAgICAgICAgICAgIGVpID0gZXZlbnQoeGkseWkpO1xuICAgICAgICAgICAgICAgICAgICBlbiA9IGFuZChsdChlMCwwKSxsdCgwLGVpKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGFueShlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhyID0geGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlMSA9IGVpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXYgPSBlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyID0gMS4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2lkZSA9PT0gLTEpIHNsICo9IDAuNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Ugc2wgPSAxLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4bCA9IHhpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZTAgPSBlaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsID0gMS4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2lkZSA9PT0gMSkgc3IgKj0gMC41O1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBzciA9IDEuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGUgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHkxID0gcmV0Ll9hdCgwLjUqKHgwK3hpKSxpLTEpO1xuICAgICAgICAgICAgICAgIHJldC5mW2ldID0gZih4aSx5aSk7XG4gICAgICAgICAgICAgICAgcmV0LnhbaV0gPSB4aTtcbiAgICAgICAgICAgICAgICByZXQueVtpXSA9IHlpO1xuICAgICAgICAgICAgICAgIHJldC55bWlkW2ktMV0gPSB5MTtcbiAgICAgICAgICAgICAgICByZXQuZXZlbnRzID0gZXY7XG4gICAgICAgICAgICAgICAgcmV0Lml0ZXJhdGlvbnMgPSBpdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHgwICs9IGg7XG4gICAgICAgIHkwID0geTE7XG4gICAgICAgIGUwID0gZTE7XG4gICAgICAgIGggPSBtaW4oMC44KmgqcG93KHRvbC9lcmluZiwwLjI1KSw0KmgpO1xuICAgIH1cbiAgICByZXQuaXRlcmF0aW9ucyA9IGl0O1xuICAgIHJldHVybiByZXQ7XG59XG5cbi8vIDExLiBBeCA9IGJcbm51bWVyaWMuTFUgPSBmdW5jdGlvbihBLCBmYXN0KSB7XG4gIGZhc3QgPSBmYXN0IHx8IGZhbHNlO1xuXG4gIHZhciBhYnMgPSBNYXRoLmFicztcbiAgdmFyIGksIGosIGssIGFic0FqaywgQWtrLCBBaywgUGssIEFpO1xuICB2YXIgbWF4O1xuICB2YXIgbiA9IEEubGVuZ3RoLCBuMSA9IG4tMTtcbiAgdmFyIFAgPSBuZXcgQXJyYXkobik7XG4gIGlmKCFmYXN0KSBBID0gbnVtZXJpYy5jbG9uZShBKTtcblxuICBmb3IgKGsgPSAwOyBrIDwgbjsgKytrKSB7XG4gICAgUGsgPSBrO1xuICAgIEFrID0gQVtrXTtcbiAgICBtYXggPSBhYnMoQWtba10pO1xuICAgIGZvciAoaiA9IGsgKyAxOyBqIDwgbjsgKytqKSB7XG4gICAgICBhYnNBamsgPSBhYnMoQVtqXVtrXSk7XG4gICAgICBpZiAobWF4IDwgYWJzQWprKSB7XG4gICAgICAgIG1heCA9IGFic0FqaztcbiAgICAgICAgUGsgPSBqO1xuICAgICAgfVxuICAgIH1cbiAgICBQW2tdID0gUGs7XG5cbiAgICBpZiAoUGsgIT0gaykge1xuICAgICAgQVtrXSA9IEFbUGtdO1xuICAgICAgQVtQa10gPSBBaztcbiAgICAgIEFrID0gQVtrXTtcbiAgICB9XG5cbiAgICBBa2sgPSBBa1trXTtcblxuICAgIGZvciAoaSA9IGsgKyAxOyBpIDwgbjsgKytpKSB7XG4gICAgICBBW2ldW2tdIC89IEFraztcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBrICsgMTsgaSA8IG47ICsraSkge1xuICAgICAgQWkgPSBBW2ldO1xuICAgICAgZm9yIChqID0gayArIDE7IGogPCBuMTsgKytqKSB7XG4gICAgICAgIEFpW2pdIC09IEFpW2tdICogQWtbal07XG4gICAgICAgICsrajtcbiAgICAgICAgQWlbal0gLT0gQWlba10gKiBBa1tqXTtcbiAgICAgIH1cbiAgICAgIGlmKGo9PT1uMSkgQWlbal0gLT0gQWlba10gKiBBa1tqXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIExVOiBBLFxuICAgIFA6ICBQXG4gIH07XG59XG5cbm51bWVyaWMuTFVzb2x2ZSA9IGZ1bmN0aW9uIExVc29sdmUoTFVQLCBiKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgTFUgPSBMVVAuTFU7XG4gIHZhciBuICAgPSBMVS5sZW5ndGg7XG4gIHZhciB4ID0gbnVtZXJpYy5jbG9uZShiKTtcbiAgdmFyIFAgICA9IExVUC5QO1xuICB2YXIgUGksIExVaSwgTFVpaSwgdG1wO1xuXG4gIGZvciAoaT1uLTE7aSE9PS0xOy0taSkgeFtpXSA9IGJbaV07XG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBQaSA9IFBbaV07XG4gICAgaWYgKFBbaV0gIT09IGkpIHtcbiAgICAgIHRtcCA9IHhbaV07XG4gICAgICB4W2ldID0geFtQaV07XG4gICAgICB4W1BpXSA9IHRtcDtcbiAgICB9XG5cbiAgICBMVWkgPSBMVVtpXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgaTsgKytqKSB7XG4gICAgICB4W2ldIC09IHhbal0gKiBMVWlbal07XG4gICAgfVxuICB9XG5cbiAgZm9yIChpID0gbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgTFVpID0gTFVbaV07XG4gICAgZm9yIChqID0gaSArIDE7IGogPCBuOyArK2opIHtcbiAgICAgIHhbaV0gLT0geFtqXSAqIExVaVtqXTtcbiAgICB9XG5cbiAgICB4W2ldIC89IExVaVtpXTtcbiAgfVxuXG4gIHJldHVybiB4O1xufVxuXG5udW1lcmljLnNvbHZlID0gZnVuY3Rpb24gc29sdmUoQSxiLGZhc3QpIHsgcmV0dXJuIG51bWVyaWMuTFVzb2x2ZShudW1lcmljLkxVKEEsZmFzdCksIGIpOyB9XG5cbi8vIDEyLiBMaW5lYXIgcHJvZ3JhbW1pbmdcbm51bWVyaWMuZWNoZWxvbml6ZSA9IGZ1bmN0aW9uIGVjaGVsb25pemUoQSkge1xuICAgIHZhciBzID0gbnVtZXJpYy5kaW0oQSksIG0gPSBzWzBdLCBuID0gc1sxXTtcbiAgICB2YXIgSSA9IG51bWVyaWMuaWRlbnRpdHkobSk7XG4gICAgdmFyIFAgPSBBcnJheShtKTtcbiAgICB2YXIgaSxqLGssbCxBaSxJaSxaLGE7XG4gICAgdmFyIGFicyA9IE1hdGguYWJzO1xuICAgIHZhciBkaXZlcSA9IG51bWVyaWMuZGl2ZXE7XG4gICAgQSA9IG51bWVyaWMuY2xvbmUoQSk7XG4gICAgZm9yKGk9MDtpPG07KytpKSB7XG4gICAgICAgIGsgPSAwO1xuICAgICAgICBBaSA9IEFbaV07XG4gICAgICAgIElpID0gSVtpXTtcbiAgICAgICAgZm9yKGo9MTtqPG47KytqKSBpZihhYnMoQWlba10pPGFicyhBaVtqXSkpIGs9ajtcbiAgICAgICAgUFtpXSA9IGs7XG4gICAgICAgIGRpdmVxKElpLEFpW2tdKTtcbiAgICAgICAgZGl2ZXEoQWksQWlba10pO1xuICAgICAgICBmb3Ioaj0wO2o8bTsrK2opIGlmKGohPT1pKSB7XG4gICAgICAgICAgICBaID0gQVtqXTsgYSA9IFpba107XG4gICAgICAgICAgICBmb3IobD1uLTE7bCE9PS0xOy0tbCkgWltsXSAtPSBBaVtsXSphO1xuICAgICAgICAgICAgWiA9IElbal07XG4gICAgICAgICAgICBmb3IobD1tLTE7bCE9PS0xOy0tbCkgWltsXSAtPSBJaVtsXSphO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7STpJLCBBOkEsIFA6UH07XG59XG5cbm51bWVyaWMuX19zb2x2ZUxQID0gZnVuY3Rpb24gX19zb2x2ZUxQKGMsQSxiLHRvbCxtYXhpdCx4LGZsYWcpIHtcbiAgICB2YXIgc3VtID0gbnVtZXJpYy5zdW0sIGxvZyA9IG51bWVyaWMubG9nLCBtdWwgPSBudW1lcmljLm11bCwgc3ViID0gbnVtZXJpYy5zdWIsIGRvdCA9IG51bWVyaWMuZG90LCBkaXYgPSBudW1lcmljLmRpdiwgYWRkID0gbnVtZXJpYy5hZGQ7XG4gICAgdmFyIG0gPSBjLmxlbmd0aCwgbiA9IGIubGVuZ3RoLHk7XG4gICAgdmFyIHVuYm91bmRlZCA9IGZhbHNlLCBjYixpMD0wO1xuICAgIHZhciBhbHBoYSA9IDEuMDtcbiAgICB2YXIgZjAsZGYwLEFUID0gbnVtZXJpYy50cmFuc3Bvc2UoQSksIHN2ZCA9IG51bWVyaWMuc3ZkLHRyYW5zcG9zZSA9IG51bWVyaWMudHJhbnNwb3NlLGxlcSA9IG51bWVyaWMubGVxLCBzcXJ0ID0gTWF0aC5zcXJ0LCBhYnMgPSBNYXRoLmFicztcbiAgICB2YXIgbXVsZXEgPSBudW1lcmljLm11bGVxO1xuICAgIHZhciBub3JtID0gbnVtZXJpYy5ub3JtaW5mLCBhbnkgPSBudW1lcmljLmFueSxtaW4gPSBNYXRoLm1pbjtcbiAgICB2YXIgYWxsID0gbnVtZXJpYy5hbGwsIGd0ID0gbnVtZXJpYy5ndDtcbiAgICB2YXIgcCA9IEFycmF5KG0pLCBBMCA9IEFycmF5KG4pLGU9bnVtZXJpYy5yZXAoW25dLDEpLCBIO1xuICAgIHZhciBzb2x2ZSA9IG51bWVyaWMuc29sdmUsIHogPSBzdWIoYixkb3QoQSx4KSksY291bnQ7XG4gICAgdmFyIGRvdGNjID0gZG90KGMsYyk7XG4gICAgdmFyIGc7XG4gICAgZm9yKGNvdW50PWkwO2NvdW50PG1heGl0OysrY291bnQpIHtcbiAgICAgICAgdmFyIGksaixkO1xuICAgICAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkgQTBbaV0gPSBkaXYoQVtpXSx6W2ldKTtcbiAgICAgICAgdmFyIEExID0gdHJhbnNwb3NlKEEwKTtcbiAgICAgICAgZm9yKGk9bS0xO2khPT0tMTstLWkpIHBbaV0gPSAoLyp4W2ldKyovc3VtKEExW2ldKSk7XG4gICAgICAgIGFscGhhID0gMC4yNSphYnMoZG90Y2MvZG90KGMscCkpO1xuICAgICAgICB2YXIgYTEgPSAxMDAqc3FydChkb3RjYy9kb3QocCxwKSk7XG4gICAgICAgIGlmKCFpc0Zpbml0ZShhbHBoYSkgfHwgYWxwaGE+YTEpIGFscGhhID0gYTE7XG4gICAgICAgIGcgPSBhZGQoYyxtdWwoYWxwaGEscCkpO1xuICAgICAgICBIID0gZG90KEExLEEwKTtcbiAgICAgICAgZm9yKGk9bS0xO2khPT0tMTstLWkpIEhbaV1baV0gKz0gMTtcbiAgICAgICAgZCA9IHNvbHZlKEgsZGl2KGcsYWxwaGEpLHRydWUpO1xuICAgICAgICB2YXIgdDAgPSBkaXYoeixkb3QoQSxkKSk7XG4gICAgICAgIHZhciB0ID0gMS4wO1xuICAgICAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkgaWYodDBbaV08MCkgdCA9IG1pbih0LC0wLjk5OSp0MFtpXSk7XG4gICAgICAgIHkgPSBzdWIoeCxtdWwoZCx0KSk7XG4gICAgICAgIHogPSBzdWIoYixkb3QoQSx5KSk7XG4gICAgICAgIGlmKCFhbGwoZ3QoeiwwKSkpIHJldHVybiB7IHNvbHV0aW9uOiB4LCBtZXNzYWdlOiBcIlwiLCBpdGVyYXRpb25zOiBjb3VudCB9O1xuICAgICAgICB4ID0geTtcbiAgICAgICAgaWYoYWxwaGE8dG9sKSByZXR1cm4geyBzb2x1dGlvbjogeSwgbWVzc2FnZTogXCJcIiwgaXRlcmF0aW9uczogY291bnQgfTtcbiAgICAgICAgaWYoZmxhZykge1xuICAgICAgICAgICAgdmFyIHMgPSBkb3QoYyxnKSwgQWcgPSBkb3QoQSxnKTtcbiAgICAgICAgICAgIHVuYm91bmRlZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkgaWYocypBZ1tpXTwwKSB7IHVuYm91bmRlZCA9IGZhbHNlOyBicmVhazsgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoeFttLTFdPj0wKSB1bmJvdW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGVsc2UgdW5ib3VuZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZih1bmJvdW5kZWQpIHJldHVybiB7IHNvbHV0aW9uOiB5LCBtZXNzYWdlOiBcIlVuYm91bmRlZFwiLCBpdGVyYXRpb25zOiBjb3VudCB9O1xuICAgIH1cbiAgICByZXR1cm4geyBzb2x1dGlvbjogeCwgbWVzc2FnZTogXCJtYXhpbXVtIGl0ZXJhdGlvbiBjb3VudCBleGNlZWRlZFwiLCBpdGVyYXRpb25zOmNvdW50IH07XG59XG5cbm51bWVyaWMuX3NvbHZlTFAgPSBmdW5jdGlvbiBfc29sdmVMUChjLEEsYix0b2wsbWF4aXQpIHtcbiAgICB2YXIgbSA9IGMubGVuZ3RoLCBuID0gYi5sZW5ndGgseTtcbiAgICB2YXIgc3VtID0gbnVtZXJpYy5zdW0sIGxvZyA9IG51bWVyaWMubG9nLCBtdWwgPSBudW1lcmljLm11bCwgc3ViID0gbnVtZXJpYy5zdWIsIGRvdCA9IG51bWVyaWMuZG90LCBkaXYgPSBudW1lcmljLmRpdiwgYWRkID0gbnVtZXJpYy5hZGQ7XG4gICAgdmFyIGMwID0gbnVtZXJpYy5yZXAoW21dLDApLmNvbmNhdChbMV0pO1xuICAgIHZhciBKID0gbnVtZXJpYy5yZXAoW24sMV0sLTEpO1xuICAgIHZhciBBMCA9IG51bWVyaWMuYmxvY2tNYXRyaXgoW1tBICAgICAgICAgICAgICAgICAgICwgICBKICBdXSk7XG4gICAgdmFyIGIwID0gYjtcbiAgICB2YXIgeSA9IG51bWVyaWMucmVwKFttXSwwKS5jb25jYXQoTWF0aC5tYXgoMCxudW1lcmljLnN1cChudW1lcmljLm5lZyhiKSkpKzEpO1xuICAgIHZhciB4MCA9IG51bWVyaWMuX19zb2x2ZUxQKGMwLEEwLGIwLHRvbCxtYXhpdCx5LGZhbHNlKTtcbiAgICB2YXIgeCA9IG51bWVyaWMuY2xvbmUoeDAuc29sdXRpb24pO1xuICAgIHgubGVuZ3RoID0gbTtcbiAgICB2YXIgZm9vID0gbnVtZXJpYy5pbmYoc3ViKGIsZG90KEEseCkpKTtcbiAgICBpZihmb288MCkgeyByZXR1cm4geyBzb2x1dGlvbjogTmFOLCBtZXNzYWdlOiBcIkluZmVhc2libGVcIiwgaXRlcmF0aW9uczogeDAuaXRlcmF0aW9ucyB9OyB9XG4gICAgdmFyIHJldCA9IG51bWVyaWMuX19zb2x2ZUxQKGMsIEEsIGIsIHRvbCwgbWF4aXQteDAuaXRlcmF0aW9ucywgeCwgdHJ1ZSk7XG4gICAgcmV0Lml0ZXJhdGlvbnMgKz0geDAuaXRlcmF0aW9ucztcbiAgICByZXR1cm4gcmV0O1xufTtcblxubnVtZXJpYy5zb2x2ZUxQID0gZnVuY3Rpb24gc29sdmVMUChjLEEsYixBZXEsYmVxLHRvbCxtYXhpdCkge1xuICAgIGlmKHR5cGVvZiBtYXhpdCA9PT0gXCJ1bmRlZmluZWRcIikgbWF4aXQgPSAxMDAwO1xuICAgIGlmKHR5cGVvZiB0b2wgPT09IFwidW5kZWZpbmVkXCIpIHRvbCA9IG51bWVyaWMuZXBzaWxvbjtcbiAgICBpZih0eXBlb2YgQWVxID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gbnVtZXJpYy5fc29sdmVMUChjLEEsYix0b2wsbWF4aXQpO1xuICAgIHZhciBtID0gQWVxLmxlbmd0aCwgbiA9IEFlcVswXS5sZW5ndGgsIG8gPSBBLmxlbmd0aDtcbiAgICB2YXIgQiA9IG51bWVyaWMuZWNoZWxvbml6ZShBZXEpO1xuICAgIHZhciBmbGFncyA9IG51bWVyaWMucmVwKFtuXSwwKTtcbiAgICB2YXIgUCA9IEIuUDtcbiAgICB2YXIgUSA9IFtdO1xuICAgIHZhciBpO1xuICAgIGZvcihpPVAubGVuZ3RoLTE7aSE9PS0xOy0taSkgZmxhZ3NbUFtpXV0gPSAxO1xuICAgIGZvcihpPW4tMTtpIT09LTE7LS1pKSBpZihmbGFnc1tpXT09PTApIFEucHVzaChpKTtcbiAgICB2YXIgZyA9IG51bWVyaWMuZ2V0UmFuZ2U7XG4gICAgdmFyIEkgPSBudW1lcmljLmxpbnNwYWNlKDAsbS0xKSwgSiA9IG51bWVyaWMubGluc3BhY2UoMCxvLTEpO1xuICAgIHZhciBBZXEyID0gZyhBZXEsSSxRKSwgQTEgPSBnKEEsSixQKSwgQTIgPSBnKEEsSixRKSwgZG90ID0gbnVtZXJpYy5kb3QsIHN1YiA9IG51bWVyaWMuc3ViO1xuICAgIHZhciBBMyA9IGRvdChBMSxCLkkpO1xuICAgIHZhciBBNCA9IHN1YihBMixkb3QoQTMsQWVxMikpLCBiNCA9IHN1YihiLGRvdChBMyxiZXEpKTtcbiAgICB2YXIgYzEgPSBBcnJheShQLmxlbmd0aCksIGMyID0gQXJyYXkoUS5sZW5ndGgpO1xuICAgIGZvcihpPVAubGVuZ3RoLTE7aSE9PS0xOy0taSkgYzFbaV0gPSBjW1BbaV1dO1xuICAgIGZvcihpPVEubGVuZ3RoLTE7aSE9PS0xOy0taSkgYzJbaV0gPSBjW1FbaV1dO1xuICAgIHZhciBjNCA9IHN1YihjMixkb3QoYzEsZG90KEIuSSxBZXEyKSkpO1xuICAgIHZhciBTID0gbnVtZXJpYy5fc29sdmVMUChjNCxBNCxiNCx0b2wsbWF4aXQpO1xuICAgIHZhciB4MiA9IFMuc29sdXRpb247XG4gICAgaWYoeDIhPT14MikgcmV0dXJuIFM7XG4gICAgdmFyIHgxID0gZG90KEIuSSxzdWIoYmVxLGRvdChBZXEyLHgyKSkpO1xuICAgIHZhciB4ID0gQXJyYXkoYy5sZW5ndGgpO1xuICAgIGZvcihpPVAubGVuZ3RoLTE7aSE9PS0xOy0taSkgeFtQW2ldXSA9IHgxW2ldO1xuICAgIGZvcihpPVEubGVuZ3RoLTE7aSE9PS0xOy0taSkgeFtRW2ldXSA9IHgyW2ldO1xuICAgIHJldHVybiB7IHNvbHV0aW9uOiB4LCBtZXNzYWdlOlMubWVzc2FnZSwgaXRlcmF0aW9uczogUy5pdGVyYXRpb25zIH07XG59XG5cbm51bWVyaWMuTVBTdG9MUCA9IGZ1bmN0aW9uIE1QU3RvTFAoTVBTKSB7XG4gICAgaWYoTVBTIGluc3RhbmNlb2YgU3RyaW5nKSB7IE1QUy5zcGxpdCgnXFxuJyk7IH1cbiAgICB2YXIgc3RhdGUgPSAwO1xuICAgIHZhciBzdGF0ZXMgPSBbJ0luaXRpYWwgc3RhdGUnLCdOQU1FJywnUk9XUycsJ0NPTFVNTlMnLCdSSFMnLCdCT1VORFMnLCdFTkRBVEEnXTtcbiAgICB2YXIgbiA9IE1QUy5sZW5ndGg7XG4gICAgdmFyIGksaix6LE49MCxyb3dzID0ge30sIHNpZ24gPSBbXSwgcmwgPSAwLCB2YXJzID0ge30sIG52ID0gMDtcbiAgICB2YXIgbmFtZTtcbiAgICB2YXIgYyA9IFtdLCBBID0gW10sIGIgPSBbXTtcbiAgICBmdW5jdGlvbiBlcnIoZSkgeyB0aHJvdyBuZXcgRXJyb3IoJ01QU3RvTFA6ICcrZSsnXFxuTGluZSAnK2krJzogJytNUFNbaV0rJ1xcbkN1cnJlbnQgc3RhdGU6ICcrc3RhdGVzW3N0YXRlXSsnXFxuJyk7IH1cbiAgICBmb3IoaT0wO2k8bjsrK2kpIHtcbiAgICAgICAgeiA9IE1QU1tpXTtcbiAgICAgICAgdmFyIHcwID0gei5tYXRjaCgvXFxTKi9nKTtcbiAgICAgICAgdmFyIHcgPSBbXTtcbiAgICAgICAgZm9yKGo9MDtqPHcwLmxlbmd0aDsrK2opIGlmKHcwW2pdIT09XCJcIikgdy5wdXNoKHcwW2pdKTtcbiAgICAgICAgaWYody5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuICAgICAgICBmb3Ioaj0wO2o8c3RhdGVzLmxlbmd0aDsrK2opIGlmKHouc3Vic3RyKDAsc3RhdGVzW2pdLmxlbmd0aCkgPT09IHN0YXRlc1tqXSkgYnJlYWs7XG4gICAgICAgIGlmKGo8c3RhdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3RhdGUgPSBqO1xuICAgICAgICAgICAgaWYoaj09PTEpIHsgbmFtZSA9IHdbMV07IH1cbiAgICAgICAgICAgIGlmKGo9PT02KSByZXR1cm4geyBuYW1lOm5hbWUsIGM6YywgQTpudW1lcmljLnRyYW5zcG9zZShBKSwgYjpiLCByb3dzOnJvd3MsIHZhcnM6dmFycyB9O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoKHN0YXRlKSB7XG4gICAgICAgIGNhc2UgMDogY2FzZSAxOiBlcnIoJ1VuZXhwZWN0ZWQgbGluZScpO1xuICAgICAgICBjYXNlIDI6IFxuICAgICAgICAgICAgc3dpdGNoKHdbMF0pIHtcbiAgICAgICAgICAgIGNhc2UgJ04nOiBpZihOPT09MCkgTiA9IHdbMV07IGVsc2UgZXJyKCdUd28gb3IgbW9yZSBOIHJvd3MnKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdMJzogcm93c1t3WzFdXSA9IHJsOyBzaWduW3JsXSA9IDE7IGJbcmxdID0gMDsgKytybDsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdHJzogcm93c1t3WzFdXSA9IHJsOyBzaWduW3JsXSA9IC0xO2JbcmxdID0gMDsgKytybDsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdFJzogcm93c1t3WzFdXSA9IHJsOyBzaWduW3JsXSA9IDA7YltybF0gPSAwOyArK3JsOyBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IGVycignUGFyc2UgZXJyb3IgJytudW1lcmljLnByZXR0eVByaW50KHcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBpZighdmFycy5oYXNPd25Qcm9wZXJ0eSh3WzBdKSkgeyB2YXJzW3dbMF1dID0gbnY7IGNbbnZdID0gMDsgQVtudl0gPSBudW1lcmljLnJlcChbcmxdLDApOyArK252OyB9XG4gICAgICAgICAgICB2YXIgcCA9IHZhcnNbd1swXV07XG4gICAgICAgICAgICBmb3Ioaj0xO2o8dy5sZW5ndGg7ais9Mikge1xuICAgICAgICAgICAgICAgIGlmKHdbal0gPT09IE4pIHsgY1twXSA9IHBhcnNlRmxvYXQod1tqKzFdKTsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICB2YXIgcSA9IHJvd3Nbd1tqXV07XG4gICAgICAgICAgICAgICAgQVtwXVtxXSA9IChzaWduW3FdPDA/LTE6MSkqcGFyc2VGbG9hdCh3W2orMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGZvcihqPTE7ajx3Lmxlbmd0aDtqKz0yKSBiW3Jvd3Nbd1tqXV1dID0gKHNpZ25bcm93c1t3W2pdXV08MD8tMToxKSpwYXJzZUZsb2F0KHdbaisxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OiAvKkZJWE1FKi8gYnJlYWs7XG4gICAgICAgIGNhc2UgNjogZXJyKCdJbnRlcm5hbCBlcnJvcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVycignUmVhY2hlZCBlbmQgb2YgZmlsZSB3aXRob3V0IEVOREFUQScpO1xufVxuLy8gc2VlZHJhbmRvbS5qcyB2ZXJzaW9uIDIuMC5cbi8vIEF1dGhvcjogRGF2aWQgQmF1IDQvMi8yMDExXG4vL1xuLy8gRGVmaW5lcyBhIG1ldGhvZCBNYXRoLnNlZWRyYW5kb20oKSB0aGF0LCB3aGVuIGNhbGxlZCwgc3Vic3RpdHV0ZXNcbi8vIGFuIGV4cGxpY2l0bHkgc2VlZGVkIFJDNC1iYXNlZCBhbGdvcml0aG0gZm9yIE1hdGgucmFuZG9tKCkuICBBbHNvXG4vLyBzdXBwb3J0cyBhdXRvbWF0aWMgc2VlZGluZyBmcm9tIGxvY2FsIG9yIG5ldHdvcmsgc291cmNlcyBvZiBlbnRyb3B5LlxuLy9cbi8vIFVzYWdlOlxuLy9cbi8vICAgPHNjcmlwdCBzcmM9aHR0cDovL2RhdmlkYmF1LmNvbS9lbmNvZGUvc2VlZHJhbmRvbS1taW4uanM+PC9zY3JpcHQ+XG4vL1xuLy8gICBNYXRoLnNlZWRyYW5kb20oJ3lpcGVlJyk7IFNldHMgTWF0aC5yYW5kb20gdG8gYSBmdW5jdGlvbiB0aGF0IGlzXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6ZWQgdXNpbmcgdGhlIGdpdmVuIGV4cGxpY2l0IHNlZWQuXG4vL1xuLy8gICBNYXRoLnNlZWRyYW5kb20oKTsgICAgICAgIFNldHMgTWF0aC5yYW5kb20gdG8gYSBmdW5jdGlvbiB0aGF0IGlzXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlZGVkIHVzaW5nIHRoZSBjdXJyZW50IHRpbWUsIGRvbSBzdGF0ZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgb3RoZXIgYWNjdW11bGF0ZWQgbG9jYWwgZW50cm9weS5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZ2VuZXJhdGVkIHNlZWQgc3RyaW5nIGlzIHJldHVybmVkLlxuLy9cbi8vICAgTWF0aC5zZWVkcmFuZG9tKCd5b3d6YScsIHRydWUpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZWRzIHVzaW5nIHRoZSBnaXZlbiBleHBsaWNpdCBzZWVkIG1peGVkXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9nZXRoZXIgd2l0aCBhY2N1bXVsYXRlZCBlbnRyb3B5LlxuLy9cbi8vICAgPHNjcmlwdCBzcmM9XCJodHRwOi8vYml0Lmx5L3NyYW5kb20tNTEyXCI+PC9zY3JpcHQ+XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlZHMgdXNpbmcgcGh5c2ljYWwgcmFuZG9tIGJpdHMgZG93bmxvYWRlZFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gcmFuZG9tLm9yZy5cbi8vXG4vLyAgIDxzY3JpcHQgc3JjPVwiaHR0cHM6Ly9qc29ubGliLmFwcHNwb3QuY29tL3VyYW5kb20/Y2FsbGJhY2s9TWF0aC5zZWVkcmFuZG9tXCI+XG4vLyAgIDwvc2NyaXB0PiAgICAgICAgICAgICAgICAgU2VlZHMgdXNpbmcgdXJhbmRvbSBiaXRzIGZyb20gY2FsbC5qc29ubGliLmNvbSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGljaCBpcyBmYXN0ZXIgdGhhbiByYW5kb20ub3JnLlxuLy9cbi8vIEV4YW1wbGVzOlxuLy9cbi8vICAgTWF0aC5zZWVkcmFuZG9tKFwiaGVsbG9cIik7ICAgICAgICAgICAgLy8gVXNlIFwiaGVsbG9cIiBhcyB0aGUgc2VlZC5cbi8vICAgZG9jdW1lbnQud3JpdGUoTWF0aC5yYW5kb20oKSk7ICAgICAgIC8vIEFsd2F5cyAwLjU0NjM2NjM3NjgxNDA3MzRcbi8vICAgZG9jdW1lbnQud3JpdGUoTWF0aC5yYW5kb20oKSk7ICAgICAgIC8vIEFsd2F5cyAwLjQzOTczNzkzNzcwNTkyMjM0XG4vLyAgIHZhciBybmcxID0gTWF0aC5yYW5kb207ICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgY3VycmVudCBwcm5nLlxuLy9cbi8vICAgdmFyIGF1dG9zZWVkID0gTWF0aC5zZWVkcmFuZG9tKCk7ICAgIC8vIE5ldyBwcm5nIHdpdGggYW4gYXV0b21hdGljIHNlZWQuXG4vLyAgIGRvY3VtZW50LndyaXRlKE1hdGgucmFuZG9tKCkpOyAgICAgICAvLyBQcmV0dHkgbXVjaCB1bnByZWRpY3RhYmxlLlxuLy9cbi8vICAgTWF0aC5yYW5kb20gPSBybmcxOyAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIFwiaGVsbG9cIiBwcm5nIHNlcXVlbmNlLlxuLy8gICBkb2N1bWVudC53cml0ZShNYXRoLnJhbmRvbSgpKTsgICAgICAgLy8gQWx3YXlzIDAuNTU0NzY5NDMyNDczNDU1XG4vL1xuLy8gICBNYXRoLnNlZWRyYW5kb20oYXV0b3NlZWQpOyAgICAgICAgICAgLy8gUmVzdGFydCBhdCB0aGUgcHJldmlvdXMgc2VlZC5cbi8vICAgZG9jdW1lbnQud3JpdGUoTWF0aC5yYW5kb20oKSk7ICAgICAgIC8vIFJlcGVhdCB0aGUgJ3VucHJlZGljdGFibGUnIHZhbHVlLlxuLy9cbi8vIE5vdGVzOlxuLy9cbi8vIEVhY2ggdGltZSBzZWVkcmFuZG9tKCdhcmcnKSBpcyBjYWxsZWQsIGVudHJvcHkgZnJvbSB0aGUgcGFzc2VkIHNlZWRcbi8vIGlzIGFjY3VtdWxhdGVkIGluIGEgcG9vbCB0byBoZWxwIGdlbmVyYXRlIGZ1dHVyZSBzZWVkcyBmb3IgdGhlXG4vLyB6ZXJvLWFyZ3VtZW50IGZvcm0gb2YgTWF0aC5zZWVkcmFuZG9tLCBzbyBlbnRyb3B5IGNhbiBiZSBpbmplY3RlZCBvdmVyXG4vLyB0aW1lIGJ5IGNhbGxpbmcgc2VlZHJhbmRvbSB3aXRoIGV4cGxpY2l0IGRhdGEgcmVwZWF0ZWRseS5cbi8vXG4vLyBPbiBzcGVlZCAtIFRoaXMgamF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBNYXRoLnJhbmRvbSgpIGlzIGFib3V0XG4vLyAzLTEweCBzbG93ZXIgdGhhbiB0aGUgYnVpbHQtaW4gTWF0aC5yYW5kb20oKSBiZWNhdXNlIGl0IGlzIG5vdCBuYXRpdmVcbi8vIGNvZGUsIGJ1dCB0aGlzIGlzIHR5cGljYWxseSBmYXN0IGVub3VnaCBhbnl3YXkuICBTZWVkaW5nIGlzIG1vcmUgZXhwZW5zaXZlLFxuLy8gZXNwZWNpYWxseSBpZiB5b3UgdXNlIGF1dG8tc2VlZGluZy4gIFNvbWUgZGV0YWlscyAodGltaW5ncyBvbiBDaHJvbWUgNCk6XG4vL1xuLy8gT3VyIE1hdGgucmFuZG9tKCkgICAgICAgICAgICAtIGF2ZyBsZXNzIHRoYW4gMC4wMDIgbWlsbGlzZWNvbmRzIHBlciBjYWxsXG4vLyBzZWVkcmFuZG9tKCdleHBsaWNpdCcpICAgICAgIC0gYXZnIGxlc3MgdGhhbiAwLjUgbWlsbGlzZWNvbmRzIHBlciBjYWxsXG4vLyBzZWVkcmFuZG9tKCdleHBsaWNpdCcsIHRydWUpIC0gYXZnIGxlc3MgdGhhbiAyIG1pbGxpc2Vjb25kcyBwZXIgY2FsbFxuLy8gc2VlZHJhbmRvbSgpICAgICAgICAgICAgICAgICAtIGF2ZyBhYm91dCAzOCBtaWxsaXNlY29uZHMgcGVyIGNhbGxcbi8vXG4vLyBMSUNFTlNFIChCU0QpOlxuLy9cbi8vIENvcHlyaWdodCAyMDEwIERhdmlkIEJhdSwgYWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbi8vIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuLy8gXG4vLyAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbi8vXG4vLyAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbi8vICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbi8vIFxuLy8gICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoaXMgbW9kdWxlIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXlcbi8vICAgICAgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbi8vICAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4vLyBcbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbi8vXG4vKipcbiAqIEFsbCBjb2RlIGlzIGluIGFuIGFub255bW91cyBjbG9zdXJlIHRvIGtlZXAgdGhlIGdsb2JhbCBuYW1lc3BhY2UgY2xlYW4uXG4gKlxuICogQHBhcmFtIHtudW1iZXI9fSBvdmVyZmxvdyBcbiAqIEBwYXJhbSB7bnVtYmVyPX0gc3RhcnRkZW5vbVxuICovXG5cbi8vIFBhdGNoZWQgYnkgU2ViIHNvIHRoYXQgc2VlZHJhbmRvbS5qcyBkb2VzIG5vdCBwb2xsdXRlIHRoZSBNYXRoIG9iamVjdC5cbi8vIE15IHRlc3RzIHN1Z2dlc3QgdGhhdCBkb2luZyBNYXRoLnRyb3VibGUgPSAxIG1ha2VzIE1hdGggbG9va3VwcyBhYm91dCA1JVxuLy8gc2xvd2VyLlxubnVtZXJpYy5zZWVkcmFuZG9tID0geyBwb3c6TWF0aC5wb3csIHJhbmRvbTpNYXRoLnJhbmRvbSB9O1xuXG4oZnVuY3Rpb24gKHBvb2wsIG1hdGgsIHdpZHRoLCBjaHVua3MsIHNpZ25pZmljYW5jZSwgb3ZlcmZsb3csIHN0YXJ0ZGVub20pIHtcblxuXG4vL1xuLy8gc2VlZHJhbmRvbSgpXG4vLyBUaGlzIGlzIHRoZSBzZWVkcmFuZG9tIGZ1bmN0aW9uIGRlc2NyaWJlZCBhYm92ZS5cbi8vXG5tYXRoWydzZWVkcmFuZG9tJ10gPSBmdW5jdGlvbiBzZWVkcmFuZG9tKHNlZWQsIHVzZV9lbnRyb3B5KSB7XG4gIHZhciBrZXkgPSBbXTtcbiAgdmFyIGFyYzQ7XG5cbiAgLy8gRmxhdHRlbiB0aGUgc2VlZCBzdHJpbmcgb3IgYnVpbGQgb25lIGZyb20gbG9jYWwgZW50cm9weSBpZiBuZWVkZWQuXG4gIHNlZWQgPSBtaXhrZXkoZmxhdHRlbihcbiAgICB1c2VfZW50cm9weSA/IFtzZWVkLCBwb29sXSA6XG4gICAgYXJndW1lbnRzLmxlbmd0aCA/IHNlZWQgOlxuICAgIFtuZXcgRGF0ZSgpLmdldFRpbWUoKSwgcG9vbCwgd2luZG93XSwgMyksIGtleSk7XG5cbiAgLy8gVXNlIHRoZSBzZWVkIHRvIGluaXRpYWxpemUgYW4gQVJDNCBnZW5lcmF0b3IuXG4gIGFyYzQgPSBuZXcgQVJDNChrZXkpO1xuXG4gIC8vIE1peCB0aGUgcmFuZG9tbmVzcyBpbnRvIGFjY3VtdWxhdGVkIGVudHJvcHkuXG4gIG1peGtleShhcmM0LlMsIHBvb2wpO1xuXG4gIC8vIE92ZXJyaWRlIE1hdGgucmFuZG9tXG5cbiAgLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgcmFuZG9tIGRvdWJsZSBpbiBbMCwgMSkgdGhhdCBjb250YWluc1xuICAvLyByYW5kb21uZXNzIGluIGV2ZXJ5IGJpdCBvZiB0aGUgbWFudGlzc2Egb2YgdGhlIElFRUUgNzU0IHZhbHVlLlxuXG4gIG1hdGhbJ3JhbmRvbSddID0gZnVuY3Rpb24gcmFuZG9tKCkgeyAgLy8gQ2xvc3VyZSB0byByZXR1cm4gYSByYW5kb20gZG91YmxlOlxuICAgIHZhciBuID0gYXJjNC5nKGNodW5rcyk7ICAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggYSBudW1lcmF0b3IgbiA8IDIgXiA0OFxuICAgIHZhciBkID0gc3RhcnRkZW5vbTsgICAgICAgICAgICAgICAgIC8vICAgYW5kIGRlbm9taW5hdG9yIGQgPSAyIF4gNDguXG4gICAgdmFyIHggPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBhbmQgbm8gJ2V4dHJhIGxhc3QgYnl0ZScuXG4gICAgd2hpbGUgKG4gPCBzaWduaWZpY2FuY2UpIHsgICAgICAgICAgLy8gRmlsbCB1cCBhbGwgc2lnbmlmaWNhbnQgZGlnaXRzIGJ5XG4gICAgICBuID0gKG4gKyB4KSAqIHdpZHRoOyAgICAgICAgICAgICAgLy8gICBzaGlmdGluZyBudW1lcmF0b3IgYW5kXG4gICAgICBkICo9IHdpZHRoOyAgICAgICAgICAgICAgICAgICAgICAgLy8gICBkZW5vbWluYXRvciBhbmQgZ2VuZXJhdGluZyBhXG4gICAgICB4ID0gYXJjNC5nKDEpOyAgICAgICAgICAgICAgICAgICAgLy8gICBuZXcgbGVhc3Qtc2lnbmlmaWNhbnQtYnl0ZS5cbiAgICB9XG4gICAgd2hpbGUgKG4gPj0gb3ZlcmZsb3cpIHsgICAgICAgICAgICAgLy8gVG8gYXZvaWQgcm91bmRpbmcgdXAsIGJlZm9yZSBhZGRpbmdcbiAgICAgIG4gLz0gMjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGxhc3QgYnl0ZSwgc2hpZnQgZXZlcnl0aGluZ1xuICAgICAgZCAvPSAyOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgcmlnaHQgdXNpbmcgaW50ZWdlciBtYXRoIHVudGlsXG4gICAgICB4ID4+Pj0gMTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICB3ZSBoYXZlIGV4YWN0bHkgdGhlIGRlc2lyZWQgYml0cy5cbiAgICB9XG4gICAgcmV0dXJuIChuICsgeCkgLyBkOyAgICAgICAgICAgICAgICAgLy8gRm9ybSB0aGUgbnVtYmVyIHdpdGhpbiBbMCwgMSkuXG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBzZWVkIHRoYXQgd2FzIHVzZWRcbiAgcmV0dXJuIHNlZWQ7XG59O1xuXG4vL1xuLy8gQVJDNFxuLy9cbi8vIEFuIEFSQzQgaW1wbGVtZW50YXRpb24uICBUaGUgY29uc3RydWN0b3IgdGFrZXMgYSBrZXkgaW4gdGhlIGZvcm0gb2Zcbi8vIGFuIGFycmF5IG9mIGF0IG1vc3QgKHdpZHRoKSBpbnRlZ2VycyB0aGF0IHNob3VsZCBiZSAwIDw9IHggPCAod2lkdGgpLlxuLy9cbi8vIFRoZSBnKGNvdW50KSBtZXRob2QgcmV0dXJucyBhIHBzZXVkb3JhbmRvbSBpbnRlZ2VyIHRoYXQgY29uY2F0ZW5hdGVzXG4vLyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgZnJvbSBBUkM0LiAgSXRzIHJldHVybiB2YWx1ZSBpcyBhIG51bWJlciB4XG4vLyB0aGF0IGlzIGluIHRoZSByYW5nZSAwIDw9IHggPCAod2lkdGggXiBjb3VudCkuXG4vL1xuLyoqIEBjb25zdHJ1Y3RvciAqL1xuZnVuY3Rpb24gQVJDNChrZXkpIHtcbiAgdmFyIHQsIHUsIG1lID0gdGhpcywga2V5bGVuID0ga2V5Lmxlbmd0aDtcbiAgdmFyIGkgPSAwLCBqID0gbWUuaSA9IG1lLmogPSBtZS5tID0gMDtcbiAgbWUuUyA9IFtdO1xuICBtZS5jID0gW107XG5cbiAgLy8gVGhlIGVtcHR5IGtleSBbXSBpcyB0cmVhdGVkIGFzIFswXS5cbiAgaWYgKCFrZXlsZW4pIHsga2V5ID0gW2tleWxlbisrXTsgfVxuXG4gIC8vIFNldCB1cCBTIHVzaW5nIHRoZSBzdGFuZGFyZCBrZXkgc2NoZWR1bGluZyBhbGdvcml0aG0uXG4gIHdoaWxlIChpIDwgd2lkdGgpIHsgbWUuU1tpXSA9IGkrKzsgfVxuICBmb3IgKGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgIHQgPSBtZS5TW2ldO1xuICAgIGogPSBsb3diaXRzKGogKyB0ICsga2V5W2kgJSBrZXlsZW5dKTtcbiAgICB1ID0gbWUuU1tqXTtcbiAgICBtZS5TW2ldID0gdTtcbiAgICBtZS5TW2pdID0gdDtcbiAgfVxuXG4gIC8vIFRoZSBcImdcIiBtZXRob2QgcmV0dXJucyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgYXMgb25lIG51bWJlci5cbiAgbWUuZyA9IGZ1bmN0aW9uIGdldG5leHQoY291bnQpIHtcbiAgICB2YXIgcyA9IG1lLlM7XG4gICAgdmFyIGkgPSBsb3diaXRzKG1lLmkgKyAxKTsgdmFyIHQgPSBzW2ldO1xuICAgIHZhciBqID0gbG93Yml0cyhtZS5qICsgdCk7IHZhciB1ID0gc1tqXTtcbiAgICBzW2ldID0gdTtcbiAgICBzW2pdID0gdDtcbiAgICB2YXIgciA9IHNbbG93Yml0cyh0ICsgdSldO1xuICAgIHdoaWxlICgtLWNvdW50KSB7XG4gICAgICBpID0gbG93Yml0cyhpICsgMSk7IHQgPSBzW2ldO1xuICAgICAgaiA9IGxvd2JpdHMoaiArIHQpOyB1ID0gc1tqXTtcbiAgICAgIHNbaV0gPSB1O1xuICAgICAgc1tqXSA9IHQ7XG4gICAgICByID0gciAqIHdpZHRoICsgc1tsb3diaXRzKHQgKyB1KV07XG4gICAgfVxuICAgIG1lLmkgPSBpO1xuICAgIG1lLmogPSBqO1xuICAgIHJldHVybiByO1xuICB9O1xuICAvLyBGb3Igcm9idXN0IHVucHJlZGljdGFiaWxpdHkgZGlzY2FyZCBhbiBpbml0aWFsIGJhdGNoIG9mIHZhbHVlcy5cbiAgLy8gU2VlIGh0dHA6Ly93d3cucnNhLmNvbS9yc2FsYWJzL25vZGUuYXNwP2lkPTIwMDlcbiAgbWUuZyh3aWR0aCk7XG59XG5cbi8vXG4vLyBmbGF0dGVuKClcbi8vIENvbnZlcnRzIGFuIG9iamVjdCB0cmVlIHRvIG5lc3RlZCBhcnJheXMgb2Ygc3RyaW5ncy5cbi8vXG4vKiogQHBhcmFtIHtPYmplY3Q9fSByZXN1bHQgXG4gICogQHBhcmFtIHtzdHJpbmc9fSBwcm9wXG4gICogQHBhcmFtIHtzdHJpbmc9fSB0eXAgKi9cbmZ1bmN0aW9uIGZsYXR0ZW4ob2JqLCBkZXB0aCwgcmVzdWx0LCBwcm9wLCB0eXApIHtcbiAgcmVzdWx0ID0gW107XG4gIHR5cCA9IHR5cGVvZihvYmopO1xuICBpZiAoZGVwdGggJiYgdHlwID09ICdvYmplY3QnKSB7XG4gICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgaWYgKHByb3AuaW5kZXhPZignUycpIDwgNSkgeyAgICAvLyBBdm9pZCBGRjMgYnVnIChsb2NhbC9zZXNzaW9uU3RvcmFnZSlcbiAgICAgICAgdHJ5IHsgcmVzdWx0LnB1c2goZmxhdHRlbihvYmpbcHJvcF0sIGRlcHRoIC0gMSkpOyB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gKHJlc3VsdC5sZW5ndGggPyByZXN1bHQgOiBvYmogKyAodHlwICE9ICdzdHJpbmcnID8gJ1xcMCcgOiAnJykpO1xufVxuXG4vL1xuLy8gbWl4a2V5KClcbi8vIE1peGVzIGEgc3RyaW5nIHNlZWQgaW50byBhIGtleSB0aGF0IGlzIGFuIGFycmF5IG9mIGludGVnZXJzLCBhbmRcbi8vIHJldHVybnMgYSBzaG9ydGVuZWQgc3RyaW5nIHNlZWQgdGhhdCBpcyBlcXVpdmFsZW50IHRvIHRoZSByZXN1bHQga2V5LlxuLy9cbi8qKiBAcGFyYW0ge251bWJlcj19IHNtZWFyIFxuICAqIEBwYXJhbSB7bnVtYmVyPX0gaiAqL1xuZnVuY3Rpb24gbWl4a2V5KHNlZWQsIGtleSwgc21lYXIsIGopIHtcbiAgc2VlZCArPSAnJzsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBzZWVkIGlzIGEgc3RyaW5nXG4gIHNtZWFyID0gMDtcbiAgZm9yIChqID0gMDsgaiA8IHNlZWQubGVuZ3RoOyBqKyspIHtcbiAgICBrZXlbbG93Yml0cyhqKV0gPVxuICAgICAgbG93Yml0cygoc21lYXIgXj0ga2V5W2xvd2JpdHMoaildICogMTkpICsgc2VlZC5jaGFyQ29kZUF0KGopKTtcbiAgfVxuICBzZWVkID0gJyc7XG4gIGZvciAoaiBpbiBrZXkpIHsgc2VlZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleVtqXSk7IH1cbiAgcmV0dXJuIHNlZWQ7XG59XG5cbi8vXG4vLyBsb3diaXRzKClcbi8vIEEgcXVpY2sgXCJuIG1vZCB3aWR0aFwiIGZvciB3aWR0aCBhIHBvd2VyIG9mIDIuXG4vL1xuZnVuY3Rpb24gbG93Yml0cyhuKSB7IHJldHVybiBuICYgKHdpZHRoIC0gMSk7IH1cblxuLy9cbi8vIFRoZSBmb2xsb3dpbmcgY29uc3RhbnRzIGFyZSByZWxhdGVkIHRvIElFRUUgNzU0IGxpbWl0cy5cbi8vXG5zdGFydGRlbm9tID0gbWF0aC5wb3cod2lkdGgsIGNodW5rcyk7XG5zaWduaWZpY2FuY2UgPSBtYXRoLnBvdygyLCBzaWduaWZpY2FuY2UpO1xub3ZlcmZsb3cgPSBzaWduaWZpY2FuY2UgKiAyO1xuXG4vL1xuLy8gV2hlbiBzZWVkcmFuZG9tLmpzIGlzIGxvYWRlZCwgd2UgaW1tZWRpYXRlbHkgbWl4IGEgZmV3IGJpdHNcbi8vIGZyb20gdGhlIGJ1aWx0LWluIFJORyBpbnRvIHRoZSBlbnRyb3B5IHBvb2wuICBCZWNhdXNlIHdlIGRvXG4vLyBub3Qgd2FudCB0byBpbnRlZmVyZSB3aXRoIGRldGVybWluc3RpYyBQUk5HIHN0YXRlIGxhdGVyLFxuLy8gc2VlZHJhbmRvbSB3aWxsIG5vdCBjYWxsIG1hdGgucmFuZG9tIG9uIGl0cyBvd24gYWdhaW4gYWZ0ZXJcbi8vIGluaXRpYWxpemF0aW9uLlxuLy9cbm1peGtleShtYXRoLnJhbmRvbSgpLCBwb29sKTtcblxuLy8gRW5kIGFub255bW91cyBzY29wZSwgYW5kIHBhc3MgaW5pdGlhbCB2YWx1ZXMuXG59KFxuICBbXSwgICAvLyBwb29sOiBlbnRyb3B5IHBvb2wgc3RhcnRzIGVtcHR5XG4gIG51bWVyaWMuc2VlZHJhbmRvbSwgLy8gbWF0aDogcGFja2FnZSBjb250YWluaW5nIHJhbmRvbSwgcG93LCBhbmQgc2VlZHJhbmRvbVxuICAyNTYsICAvLyB3aWR0aDogZWFjaCBSQzQgb3V0cHV0IGlzIDAgPD0geCA8IDI1NlxuICA2LCAgICAvLyBjaHVua3M6IGF0IGxlYXN0IHNpeCBSQzQgb3V0cHV0cyBmb3IgZWFjaCBkb3VibGVcbiAgNTIgICAgLy8gc2lnbmlmaWNhbmNlOiB0aGVyZSBhcmUgNTIgc2lnbmlmaWNhbnQgZGlnaXRzIGluIGEgZG91YmxlXG4gICkpO1xuLyogVGhpcyBmaWxlIGlzIGEgc2xpZ2h0bHkgbW9kaWZpZWQgdmVyc2lvbiBvZiBxdWFkcHJvZy5qcyBmcm9tIEFsYmVydG8gU2FudGluaS5cbiAqIEl0IGhhcyBiZWVuIHNsaWdodGx5IG1vZGlmaWVkIGJ5IFPDqWJhc3RpZW4gTG9pc2VsIHRvIG1ha2Ugc3VyZSB0aGF0IGl0IGhhbmRsZXNcbiAqIDAtYmFzZWQgQXJyYXlzIGluc3RlYWQgb2YgMS1iYXNlZCBBcnJheXMuXG4gKiBMaWNlbnNlIGlzIGluIHJlc291cmNlcy9MSUNFTlNFLnF1YWRwcm9nICovXG4oZnVuY3Rpb24oZXhwb3J0cykge1xuXG5mdW5jdGlvbiBiYXNlMHRvMShBKSB7XG4gICAgaWYodHlwZW9mIEEgIT09IFwib2JqZWN0XCIpIHsgcmV0dXJuIEE7IH1cbiAgICB2YXIgcmV0ID0gW10sIGksbj1BLmxlbmd0aDtcbiAgICBmb3IoaT0wO2k8bjtpKyspIHJldFtpKzFdID0gYmFzZTB0bzEoQVtpXSk7XG4gICAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIGJhc2UxdG8wKEEpIHtcbiAgICBpZih0eXBlb2YgQSAhPT0gXCJvYmplY3RcIikgeyByZXR1cm4gQTsgfVxuICAgIHZhciByZXQgPSBbXSwgaSxuPUEubGVuZ3RoO1xuICAgIGZvcihpPTE7aTxuO2krKykgcmV0W2ktMV0gPSBiYXNlMXRvMChBW2ldKTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkcG9yaShhLCBsZGEsIG4pIHtcbiAgICB2YXIgaSwgaiwgaywga3AxLCB0O1xuXG4gICAgZm9yIChrID0gMTsgayA8PSBuOyBrID0gayArIDEpIHtcbiAgICAgICAgYVtrXVtrXSA9IDEgLyBhW2tdW2tdO1xuICAgICAgICB0ID0gLWFba11ba107XG4gICAgICAgIC8vfiBkc2NhbChrIC0gMSwgdCwgYVsxXVtrXSwgMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBrOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIGFbaV1ba10gPSB0ICogYVtpXVtrXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGtwMSA9IGsgKyAxO1xuICAgICAgICBpZiAobiA8IGtwMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChqID0ga3AxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICAgICAgdCA9IGFba11bal07XG4gICAgICAgICAgICBhW2tdW2pdID0gMDtcbiAgICAgICAgICAgIC8vfiBkYXhweShrLCB0LCBhWzFdW2tdLCAxLCBhWzFdW2pdLCAxKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPD0gazsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgYVtpXVtqXSA9IGFbaV1bal0gKyAodCAqIGFbaV1ba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIGRwb3NsKGEsIGxkYSwgbiwgYikge1xuICAgIHZhciBpLCBrLCBrYiwgdDtcblxuICAgIGZvciAoayA9IDE7IGsgPD0gbjsgayA9IGsgKyAxKSB7XG4gICAgICAgIC8vfiB0ID0gZGRvdChrIC0gMSwgYVsxXVtrXSwgMSwgYlsxXSwgMSk7XG4gICAgICAgIHQgPSAwO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgazsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICB0ID0gdCArIChhW2ldW2tdICogYltpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBiW2tdID0gKGJba10gLSB0KSAvIGFba11ba107XG4gICAgfVxuXG4gICAgZm9yIChrYiA9IDE7IGtiIDw9IG47IGtiID0ga2IgKyAxKSB7XG4gICAgICAgIGsgPSBuICsgMSAtIGtiO1xuICAgICAgICBiW2tdID0gYltrXSAvIGFba11ba107XG4gICAgICAgIHQgPSAtYltrXTtcbiAgICAgICAgLy9+IGRheHB5KGsgLSAxLCB0LCBhWzFdW2tdLCAxLCBiWzFdLCAxKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGs7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgYltpXSA9IGJbaV0gKyAodCAqIGFbaV1ba10pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcG9mYShhLCBsZGEsIG4sIGluZm8pIHtcbiAgICB2YXIgaSwgaiwgam0xLCBrLCB0LCBzO1xuXG4gICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgaW5mb1sxXSA9IGo7XG4gICAgICAgIHMgPSAwO1xuICAgICAgICBqbTEgPSBqIC0gMTtcbiAgICAgICAgaWYgKGptMSA8IDEpIHtcbiAgICAgICAgICAgIHMgPSBhW2pdW2pdIC0gcztcbiAgICAgICAgICAgIGlmIChzIDw9IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFbal1bal0gPSBNYXRoLnNxcnQocyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGsgPSAxOyBrIDw9IGptMTsgayA9IGsgKyAxKSB7XG4gICAgICAgICAgICAgICAgLy9+IHQgPSBhW2tdW2pdIC0gZGRvdChrIC0gMSwgYVsxXVtrXSwgMSwgYVsxXVtqXSwgMSk7XG4gICAgICAgICAgICAgICAgdCA9IGFba11bal07XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IGs7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgICAgICB0ID0gdCAtIChhW2ldW2pdICogYVtpXVtrXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQgPSB0IC8gYVtrXVtrXTtcbiAgICAgICAgICAgICAgICBhW2tdW2pdID0gdDtcbiAgICAgICAgICAgICAgICBzID0gcyArIHQgKiB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcyA9IGFbal1bal0gLSBzO1xuICAgICAgICAgICAgaWYgKHMgPD0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYVtqXVtqXSA9IE1hdGguc3FydChzKTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvWzFdID0gMDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHFwZ2VuMihkbWF0LCBkdmVjLCBmZGRtYXQsIG4sIHNvbCwgY3J2YWwsIGFtYXQsXG4gICAgYnZlYywgZmRhbWF0LCBxLCBtZXEsIGlhY3QsIG5hY3QsIGl0ZXIsIHdvcmssIGllcnIpIHtcblxuICAgIHZhciBpLCBqLCBsLCBsMSwgaW5mbywgaXQxLCBpd3p2LCBpd3J2LCBpd3JtLCBpd3N2LCBpd3V2LCBudmwsIHIsIGl3bmJ2LFxuICAgICAgICB0ZW1wLCBzdW0sIHQxLCB0dCwgZ2MsIGdzLCBudSxcbiAgICAgICAgdDFpbmYsIHQybWluLFxuICAgICAgICB2c21hbGwsIHRtcGEsIHRtcGIsXG4gICAgICAgIGdvO1xuXG4gICAgciA9IE1hdGgubWluKG4sIHEpO1xuICAgIGwgPSAyICogbiArIChyICogKHIgKyA1KSkgLyAyICsgMiAqIHEgKyAxO1xuXG4gICAgdnNtYWxsID0gMS4wZS02MDtcbiAgICBkbyB7XG4gICAgICAgIHZzbWFsbCA9IHZzbWFsbCArIHZzbWFsbDtcbiAgICAgICAgdG1wYSA9IDEgKyAwLjEgKiB2c21hbGw7XG4gICAgICAgIHRtcGIgPSAxICsgMC4yICogdnNtYWxsO1xuICAgIH0gd2hpbGUgKHRtcGEgPD0gMSB8fCB0bXBiIDw9IDEpO1xuXG4gICAgZm9yIChpID0gMTsgaSA8PSBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgd29ya1tpXSA9IGR2ZWNbaV07XG4gICAgfVxuICAgIGZvciAoaSA9IG4gKyAxOyBpIDw9IGw7IGkgPSBpICsgMSkge1xuICAgICAgICB3b3JrW2ldID0gMDtcbiAgICB9XG4gICAgZm9yIChpID0gMTsgaSA8PSBxOyBpID0gaSArIDEpIHtcbiAgICAgICAgaWFjdFtpXSA9IDA7XG4gICAgfVxuXG4gICAgaW5mbyA9IFtdO1xuXG4gICAgaWYgKGllcnJbMV0gPT09IDApIHtcbiAgICAgICAgZHBvZmEoZG1hdCwgZmRkbWF0LCBuLCBpbmZvKTtcbiAgICAgICAgaWYgKGluZm9bMV0gIT09IDApIHtcbiAgICAgICAgICAgIGllcnJbMV0gPSAyO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRwb3NsKGRtYXQsIGZkZG1hdCwgbiwgZHZlYyk7XG4gICAgICAgIGRwb3JpKGRtYXQsIGZkZG1hdCwgbik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgIHNvbFtqXSA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IGo7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIHNvbFtqXSA9IHNvbFtqXSArIGRtYXRbaV1bal0gKiBkdmVjW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICBkdmVjW2pdID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IGo7IGkgPD0gbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgZHZlY1tqXSA9IGR2ZWNbal0gKyBkbWF0W2pdW2ldICogc29sW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3J2YWxbMV0gPSAwO1xuICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgIHNvbFtqXSA9IGR2ZWNbal07XG4gICAgICAgIGNydmFsWzFdID0gY3J2YWxbMV0gKyB3b3JrW2pdICogc29sW2pdO1xuICAgICAgICB3b3JrW2pdID0gMDtcbiAgICAgICAgZm9yIChpID0gaiArIDE7IGkgPD0gbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICBkbWF0W2ldW2pdID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcnZhbFsxXSA9IC1jcnZhbFsxXSAvIDI7XG4gICAgaWVyclsxXSA9IDA7XG5cbiAgICBpd3p2ID0gbjtcbiAgICBpd3J2ID0gaXd6diArIG47XG4gICAgaXd1diA9IGl3cnYgKyByO1xuICAgIGl3cm0gPSBpd3V2ICsgciArIDE7XG4gICAgaXdzdiA9IGl3cm0gKyAociAqIChyICsgMSkpIC8gMjtcbiAgICBpd25idiA9IGl3c3YgKyBxO1xuXG4gICAgZm9yIChpID0gMTsgaSA8PSBxOyBpID0gaSArIDEpIHtcbiAgICAgICAgc3VtID0gMDtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgIHN1bSA9IHN1bSArIGFtYXRbal1baV0gKiBhbWF0W2pdW2ldO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtbaXduYnYgKyBpXSA9IE1hdGguc3FydChzdW0pO1xuICAgIH1cbiAgICBuYWN0ID0gMDtcbiAgICBpdGVyWzFdID0gMDtcbiAgICBpdGVyWzJdID0gMDtcblxuICAgIGZ1bmN0aW9uIGZuX2dvdG9fNTAoKSB7XG4gICAgICAgIGl0ZXJbMV0gPSBpdGVyWzFdICsgMTtcblxuICAgICAgICBsID0gaXdzdjtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8PSBxOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIGwgPSBsICsgMTtcbiAgICAgICAgICAgIHN1bSA9IC1idmVjW2ldO1xuICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgICAgICBzdW0gPSBzdW0gKyBhbWF0W2pdW2ldICogc29sW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHN1bSkgPCB2c21hbGwpIHtcbiAgICAgICAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPiBtZXEpIHtcbiAgICAgICAgICAgICAgICB3b3JrW2xdID0gc3VtO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3b3JrW2xdID0gLU1hdGguYWJzKHN1bSk7XG4gICAgICAgICAgICAgICAgaWYgKHN1bSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFtYXRbal1baV0gPSAtYW1hdFtqXVtpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBidmVjW2ldID0gLWJ2ZWNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuYWN0OyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIHdvcmtbaXdzdiArIGlhY3RbaV1dID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIG52bCA9IDA7XG4gICAgICAgIHRlbXAgPSAwO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IHE7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgaWYgKHdvcmtbaXdzdiArIGldIDwgdGVtcCAqIHdvcmtbaXduYnYgKyBpXSkge1xuICAgICAgICAgICAgICAgIG52bCA9IGk7XG4gICAgICAgICAgICAgICAgdGVtcCA9IHdvcmtbaXdzdiArIGldIC8gd29ya1tpd25idiArIGldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChudmwgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiA5OTk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbl9nb3RvXzU1KCkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG47IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICAgICAgc3VtID0gc3VtICsgZG1hdFtqXVtpXSAqIGFtYXRbal1bbnZsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtbaV0gPSBzdW07XG4gICAgICAgIH1cblxuICAgICAgICBsMSA9IGl3enY7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICB3b3JrW2wxICsgaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IG5hY3QgKyAxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICB3b3JrW2wxICsgaV0gPSB3b3JrW2wxICsgaV0gKyBkbWF0W2ldW2pdICogd29ya1tqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHQxaW5mID0gdHJ1ZTtcbiAgICAgICAgZm9yIChpID0gbmFjdDsgaSA+PSAxOyBpID0gaSAtIDEpIHtcbiAgICAgICAgICAgIHN1bSA9IHdvcmtbaV07XG4gICAgICAgICAgICBsID0gaXdybSArIChpICogKGkgKyAzKSkgLyAyO1xuICAgICAgICAgICAgbDEgPSBsIC0gaTtcbiAgICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDw9IG5hY3Q7IGogPSBqICsgMSkge1xuICAgICAgICAgICAgICAgIHN1bSA9IHN1bSAtIHdvcmtbbF0gKiB3b3JrW2l3cnYgKyBqXTtcbiAgICAgICAgICAgICAgICBsID0gbCArIGo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdW0gPSBzdW0gLyB3b3JrW2wxXTtcbiAgICAgICAgICAgIHdvcmtbaXdydiArIGldID0gc3VtO1xuICAgICAgICAgICAgaWYgKGlhY3RbaV0gPCBtZXEpIHtcbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdW0gPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gY29udGludWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0MWluZiA9IGZhbHNlO1xuICAgICAgICAgICAgaXQxID0gaTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdDFpbmYpIHtcbiAgICAgICAgICAgIHQxID0gd29ya1tpd3V2ICsgaXQxXSAvIHdvcmtbaXdydiArIGl0MV07XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG5hY3Q7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIGlmIChpYWN0W2ldIDwgbWVxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHdvcmtbaXdydiArIGldIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRlbXAgPSB3b3JrW2l3dXYgKyBpXSAvIHdvcmtbaXdydiArIGldO1xuICAgICAgICAgICAgICAgIGlmICh0ZW1wIDwgdDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdDEgPSB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICBpdDEgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN1bSA9IDA7XG4gICAgICAgIGZvciAoaSA9IGl3enYgKyAxOyBpIDw9IGl3enYgKyBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIHN1bSA9IHN1bSArIHdvcmtbaV0gKiB3b3JrW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChNYXRoLmFicyhzdW0pIDw9IHZzbWFsbCkge1xuICAgICAgICAgICAgaWYgKHQxaW5mKSB7XG4gICAgICAgICAgICAgICAgaWVyclsxXSA9IDE7XG4gICAgICAgICAgICAgICAgLy8gR09UTyA5OTlcbiAgICAgICAgICAgICAgICByZXR1cm4gOTk5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG5hY3Q7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrW2l3dXYgKyBpXSA9IHdvcmtbaXd1diArIGldIC0gdDEgKiB3b3JrW2l3cnYgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd29ya1tpd3V2ICsgbmFjdCArIDFdID0gd29ya1tpd3V2ICsgbmFjdCArIDFdICsgdDE7XG4gICAgICAgICAgICAgICAgLy8gR09UTyA3MDBcbiAgICAgICAgICAgICAgICByZXR1cm4gNzAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgc3VtID0gc3VtICsgd29ya1tpd3p2ICsgaV0gKiBhbWF0W2ldW252bF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0dCA9IC13b3JrW2l3c3YgKyBudmxdIC8gc3VtO1xuICAgICAgICAgICAgdDJtaW4gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCF0MWluZikge1xuICAgICAgICAgICAgICAgIGlmICh0MSA8IHR0KSB7XG4gICAgICAgICAgICAgICAgICAgIHR0ID0gdDE7XG4gICAgICAgICAgICAgICAgICAgIHQybWluID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG47IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIHNvbFtpXSA9IHNvbFtpXSArIHR0ICogd29ya1tpd3p2ICsgaV07XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNvbFtpXSkgPCB2c21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc29sW2ldID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNydmFsWzFdID0gY3J2YWxbMV0gKyB0dCAqIHN1bSAqICh0dCAvIDIgKyB3b3JrW2l3dXYgKyBuYWN0ICsgMV0pO1xuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuYWN0OyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICB3b3JrW2l3dXYgKyBpXSA9IHdvcmtbaXd1diArIGldIC0gdHQgKiB3b3JrW2l3cnYgKyBpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtbaXd1diArIG5hY3QgKyAxXSA9IHdvcmtbaXd1diArIG5hY3QgKyAxXSArIHR0O1xuXG4gICAgICAgICAgICBpZiAodDJtaW4pIHtcbiAgICAgICAgICAgICAgICBuYWN0ID0gbmFjdCArIDE7XG4gICAgICAgICAgICAgICAgaWFjdFtuYWN0XSA9IG52bDtcblxuICAgICAgICAgICAgICAgIGwgPSBpd3JtICsgKChuYWN0IC0gMSkgKiBuYWN0KSAvIDIgKyAxO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbmFjdCAtIDE7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrW2xdID0gd29ya1tpXTtcbiAgICAgICAgICAgICAgICAgICAgbCA9IGwgKyAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChuYWN0ID09PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtbbF0gPSB3b3JrW25dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IG47IGkgPj0gbmFjdCArIDE7IGkgPSBpIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtbaV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdjID0gTWF0aC5tYXgoTWF0aC5hYnMod29ya1tpIC0gMV0pLCBNYXRoLmFicyh3b3JrW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBncyA9IE1hdGgubWluKE1hdGguYWJzKHdvcmtbaSAtIDFdKSwgTWF0aC5hYnMod29ya1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtbaSAtIDFdID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gTWF0aC5hYnMoZ2MgKiBNYXRoLnNxcnQoMSArIGdzICogZ3MgLyAoZ2MgKiBnYykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IC1NYXRoLmFicyhnYyAqIE1hdGguc3FydCgxICsgZ3MgKiBncyAvIChnYyAqIGdjKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2MgPSB3b3JrW2kgLSAxXSAvIHRlbXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBncyA9IHdvcmtbaV0gLyB0ZW1wO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2MgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnYyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtbaSAtIDFdID0gZ3MgKiB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSBkbWF0W2pdW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG1hdFtqXVtpIC0gMV0gPSBkbWF0W2pdW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbWF0W2pdW2ldID0gdGVtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtbaSAtIDFdID0gdGVtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudSA9IGdzIC8gKDEgKyBnYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IGdjICogZG1hdFtqXVtpIC0gMV0gKyBncyAqIGRtYXRbal1baV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRtYXRbal1baV0gPSBudSAqIChkbWF0W2pdW2kgLSAxXSArIHRlbXApIC0gZG1hdFtqXVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG1hdFtqXVtpIC0gMV0gPSB0ZW1wO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdvcmtbbF0gPSB3b3JrW25hY3RdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3VtID0gLWJ2ZWNbbnZsXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gPSBzdW0gKyBzb2xbal0gKiBhbWF0W2pdW252bF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChudmwgPiBtZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya1tpd3N2ICsgbnZsXSA9IHN1bTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3b3JrW2l3c3YgKyBudmxdID0gLU1hdGguYWJzKHN1bSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdW0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtYXRbal1bbnZsXSA9IC1hbWF0W2pdW252bF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBidmVjW252bF0gPSAtYnZlY1tudmxdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEdPVE8gNzAwXG4gICAgICAgICAgICAgICAgcmV0dXJuIDcwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZuX2dvdG9fNzk3KCkge1xuICAgICAgICBsID0gaXdybSArIChpdDEgKiAoaXQxICsgMSkpIC8gMiArIDE7XG4gICAgICAgIGwxID0gbCArIGl0MTtcbiAgICAgICAgaWYgKHdvcmtbbDFdID09PSAwKSB7XG4gICAgICAgICAgICAvLyBHT1RPIDc5OFxuICAgICAgICAgICAgcmV0dXJuIDc5ODtcbiAgICAgICAgfVxuICAgICAgICBnYyA9IE1hdGgubWF4KE1hdGguYWJzKHdvcmtbbDEgLSAxXSksIE1hdGguYWJzKHdvcmtbbDFdKSk7XG4gICAgICAgIGdzID0gTWF0aC5taW4oTWF0aC5hYnMod29ya1tsMSAtIDFdKSwgTWF0aC5hYnMod29ya1tsMV0pKTtcbiAgICAgICAgaWYgKHdvcmtbbDEgLSAxXSA+PSAwKSB7XG4gICAgICAgICAgICB0ZW1wID0gTWF0aC5hYnMoZ2MgKiBNYXRoLnNxcnQoMSArIGdzICogZ3MgLyAoZ2MgKiBnYykpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbXAgPSAtTWF0aC5hYnMoZ2MgKiBNYXRoLnNxcnQoMSArIGdzICogZ3MgLyAoZ2MgKiBnYykpKTtcbiAgICAgICAgfVxuICAgICAgICBnYyA9IHdvcmtbbDEgLSAxXSAvIHRlbXA7XG4gICAgICAgIGdzID0gd29ya1tsMV0gLyB0ZW1wO1xuXG4gICAgICAgIGlmIChnYyA9PT0gMSkge1xuICAgICAgICAgICAgLy8gR09UTyA3OThcbiAgICAgICAgICAgIHJldHVybiA3OTg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdjID09PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSBpdDEgKyAxOyBpIDw9IG5hY3Q7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIHRlbXAgPSB3b3JrW2wxIC0gMV07XG4gICAgICAgICAgICAgICAgd29ya1tsMSAtIDFdID0gd29ya1tsMV07XG4gICAgICAgICAgICAgICAgd29ya1tsMV0gPSB0ZW1wO1xuICAgICAgICAgICAgICAgIGwxID0gbDEgKyBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICB0ZW1wID0gZG1hdFtpXVtpdDFdO1xuICAgICAgICAgICAgICAgIGRtYXRbaV1baXQxXSA9IGRtYXRbaV1baXQxICsgMV07XG4gICAgICAgICAgICAgICAgZG1hdFtpXVtpdDEgKyAxXSA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBudSA9IGdzIC8gKDEgKyBnYyk7XG4gICAgICAgICAgICBmb3IgKGkgPSBpdDEgKyAxOyBpIDw9IG5hY3Q7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIHRlbXAgPSBnYyAqIHdvcmtbbDEgLSAxXSArIGdzICogd29ya1tsMV07XG4gICAgICAgICAgICAgICAgd29ya1tsMV0gPSBudSAqICh3b3JrW2wxIC0gMV0gKyB0ZW1wKSAtIHdvcmtbbDFdO1xuICAgICAgICAgICAgICAgIHdvcmtbbDEgLSAxXSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgbDEgPSBsMSArIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG47IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIHRlbXAgPSBnYyAqIGRtYXRbaV1baXQxXSArIGdzICogZG1hdFtpXVtpdDEgKyAxXTtcbiAgICAgICAgICAgICAgICBkbWF0W2ldW2l0MSArIDFdID0gbnUgKiAoZG1hdFtpXVtpdDFdICsgdGVtcCkgLSBkbWF0W2ldW2l0MSArIDFdO1xuICAgICAgICAgICAgICAgIGRtYXRbaV1baXQxXSA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbl9nb3RvXzc5OCgpIHtcbiAgICAgICAgbDEgPSBsIC0gaXQxO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IGl0MTsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICB3b3JrW2wxXSA9IHdvcmtbbF07XG4gICAgICAgICAgICBsID0gbCArIDE7XG4gICAgICAgICAgICBsMSA9IGwxICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdvcmtbaXd1diArIGl0MV0gPSB3b3JrW2l3dXYgKyBpdDEgKyAxXTtcbiAgICAgICAgaWFjdFtpdDFdID0gaWFjdFtpdDEgKyAxXTtcbiAgICAgICAgaXQxID0gaXQxICsgMTtcbiAgICAgICAgaWYgKGl0MSA8IG5hY3QpIHtcbiAgICAgICAgICAgIC8vIEdPVE8gNzk3XG4gICAgICAgICAgICByZXR1cm4gNzk3O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm5fZ290b183OTkoKSB7XG4gICAgICAgIHdvcmtbaXd1diArIG5hY3RdID0gd29ya1tpd3V2ICsgbmFjdCArIDFdO1xuICAgICAgICB3b3JrW2l3dXYgKyBuYWN0ICsgMV0gPSAwO1xuICAgICAgICBpYWN0W25hY3RdID0gMDtcbiAgICAgICAgbmFjdCA9IG5hY3QgLSAxO1xuICAgICAgICBpdGVyWzJdID0gaXRlclsyXSArIDE7XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZ28gPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGdvID0gZm5fZ290b181MCgpO1xuICAgICAgICBpZiAoZ28gPT09IDk5OSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBnbyA9IGZuX2dvdG9fNTUoKTtcbiAgICAgICAgICAgIGlmIChnbyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdvID09PSA5OTkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ28gPT09IDcwMCkge1xuICAgICAgICAgICAgICAgIGlmIChpdDEgPT09IG5hY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZm5fZ290b183OTkoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm5fZ290b183OTcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvID0gZm5fZ290b183OTgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnbyAhPT0gNzk3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm5fZ290b183OTkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gc29sdmVRUChEbWF0LCBkdmVjLCBBbWF0LCBidmVjLCBtZXEsIGZhY3Rvcml6ZWQpIHtcbiAgICBEbWF0ID0gYmFzZTB0bzEoRG1hdCk7XG4gICAgZHZlYyA9IGJhc2UwdG8xKGR2ZWMpO1xuICAgIEFtYXQgPSBiYXNlMHRvMShBbWF0KTtcbiAgICB2YXIgaSwgbiwgcSxcbiAgICAgICAgbmFjdCwgcixcbiAgICAgICAgY3J2YWwgPSBbXSwgaWFjdCA9IFtdLCBzb2wgPSBbXSwgd29yayA9IFtdLCBpdGVyID0gW10sXG4gICAgICAgIG1lc3NhZ2U7XG5cbiAgICBtZXEgPSBtZXEgfHwgMDtcbiAgICBmYWN0b3JpemVkID0gZmFjdG9yaXplZCA/IGJhc2UwdG8xKGZhY3Rvcml6ZWQpIDogW3VuZGVmaW5lZCwgMF07XG4gICAgYnZlYyA9IGJ2ZWMgPyBiYXNlMHRvMShidmVjKSA6IFtdO1xuXG4gICAgLy8gSW4gRm9ydHJhbiB0aGUgYXJyYXkgaW5kZXggc3RhcnRzIGZyb20gMVxuICAgIG4gPSBEbWF0Lmxlbmd0aCAtIDE7XG4gICAgcSA9IEFtYXRbMV0ubGVuZ3RoIC0gMTtcblxuICAgIGlmICghYnZlYykge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IHE7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgYnZlY1tpXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gMTsgaSA8PSBxOyBpID0gaSArIDEpIHtcbiAgICAgICAgaWFjdFtpXSA9IDA7XG4gICAgfVxuICAgIG5hY3QgPSAwO1xuICAgIHIgPSBNYXRoLm1pbihuLCBxKTtcbiAgICBmb3IgKGkgPSAxOyBpIDw9IG47IGkgPSBpICsgMSkge1xuICAgICAgICBzb2xbaV0gPSAwO1xuICAgIH1cbiAgICBjcnZhbFsxXSA9IDA7XG4gICAgZm9yIChpID0gMTsgaSA8PSAoMiAqIG4gKyAociAqIChyICsgNSkpIC8gMiArIDIgKiBxICsgMSk7IGkgPSBpICsgMSkge1xuICAgICAgICB3b3JrW2ldID0gMDtcbiAgICB9XG4gICAgZm9yIChpID0gMTsgaSA8PSAyOyBpID0gaSArIDEpIHtcbiAgICAgICAgaXRlcltpXSA9IDA7XG4gICAgfVxuXG4gICAgcXBnZW4yKERtYXQsIGR2ZWMsIG4sIG4sIHNvbCwgY3J2YWwsIEFtYXQsXG4gICAgICAgIGJ2ZWMsIG4sIHEsIG1lcSwgaWFjdCwgbmFjdCwgaXRlciwgd29yaywgZmFjdG9yaXplZCk7XG5cbiAgICBtZXNzYWdlID0gXCJcIjtcbiAgICBpZiAoZmFjdG9yaXplZFsxXSA9PT0gMSkge1xuICAgICAgICBtZXNzYWdlID0gXCJjb25zdHJhaW50cyBhcmUgaW5jb25zaXN0ZW50LCBubyBzb2x1dGlvbiFcIjtcbiAgICB9XG4gICAgaWYgKGZhY3Rvcml6ZWRbMV0gPT09IDIpIHtcbiAgICAgICAgbWVzc2FnZSA9IFwibWF0cml4IEQgaW4gcXVhZHJhdGljIGZ1bmN0aW9uIGlzIG5vdCBwb3NpdGl2ZSBkZWZpbml0ZSFcIjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzb2x1dGlvbjogYmFzZTF0bzAoc29sKSxcbiAgICAgICAgdmFsdWU6IGJhc2UxdG8wKGNydmFsKSxcbiAgICAgICAgdW5jb25zdHJhaW5lZF9zb2x1dGlvbjogYmFzZTF0bzAoZHZlYyksXG4gICAgICAgIGl0ZXJhdGlvbnM6IGJhc2UxdG8wKGl0ZXIpLFxuICAgICAgICBpYWN0OiBiYXNlMXRvMChpYWN0KSxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgIH07XG59XG5leHBvcnRzLnNvbHZlUVAgPSBzb2x2ZVFQO1xufShudW1lcmljKSk7XG4vKlxyXG5TaGFudGkgUmFvIHNlbnQgbWUgdGhpcyByb3V0aW5lIGJ5IHByaXZhdGUgZW1haWwuIEkgaGFkIHRvIG1vZGlmeSBpdFxyXG5zbGlnaHRseSB0byB3b3JrIG9uIEFycmF5cyBpbnN0ZWFkIG9mIHVzaW5nIGEgTWF0cml4IG9iamVjdC5cclxuSXQgaXMgYXBwYXJlbnRseSB0cmFuc2xhdGVkIGZyb20gaHR0cDovL3N0aXRjaHBhbm9yYW1hLnNvdXJjZWZvcmdlLm5ldC9QeXRob24vc3ZkLnB5XHJcbiovXHJcblxyXG5udW1lcmljLnN2ZD0gZnVuY3Rpb24gc3ZkKEEpIHtcclxuICAgIHZhciB0ZW1wO1xyXG4vL0NvbXB1dGUgdGhlIHRoaW4gU1ZEIGZyb20gRy4gSC4gR29sdWIgYW5kIEMuIFJlaW5zY2gsIE51bWVyLiBNYXRoLiAxNCwgNDAzLTQyMCAoMTk3MClcclxuXHR2YXIgcHJlYz0gbnVtZXJpYy5lcHNpbG9uOyAvL01hdGgucG93KDIsLTUyKSAvLyBhc3N1bWVzIGRvdWJsZSBwcmVjXHJcblx0dmFyIHRvbGVyYW5jZT0gMS5lLTY0L3ByZWM7XHJcblx0dmFyIGl0bWF4PSA1MDtcclxuXHR2YXIgYz0wO1xyXG5cdHZhciBpPTA7XHJcblx0dmFyIGo9MDtcclxuXHR2YXIgaz0wO1xyXG5cdHZhciBsPTA7XHJcblx0XHJcblx0dmFyIHU9IG51bWVyaWMuY2xvbmUoQSk7XHJcblx0dmFyIG09IHUubGVuZ3RoO1xyXG5cdFxyXG5cdHZhciBuPSB1WzBdLmxlbmd0aDtcclxuXHRcclxuXHRpZiAobSA8IG4pIHRocm93IFwiTmVlZCBtb3JlIHJvd3MgdGhhbiBjb2x1bW5zXCJcclxuXHRcclxuXHR2YXIgZSA9IG5ldyBBcnJheShuKTtcclxuXHR2YXIgcSA9IG5ldyBBcnJheShuKTtcclxuXHRmb3IgKGk9MDsgaTxuOyBpKyspIGVbaV0gPSBxW2ldID0gMC4wO1xyXG5cdHZhciB2ID0gbnVtZXJpYy5yZXAoW24sbl0sMCk7XHJcbi8vXHR2Lnplcm8oKTtcclxuXHRcclxuIFx0ZnVuY3Rpb24gcHl0aGFnKGEsYilcclxuIFx0e1xyXG5cdFx0YSA9IE1hdGguYWJzKGEpXHJcblx0XHRiID0gTWF0aC5hYnMoYilcclxuXHRcdGlmIChhID4gYilcclxuXHRcdFx0cmV0dXJuIGEqTWF0aC5zcXJ0KDEuMCsoYipiL2EvYSkpXHJcblx0XHRlbHNlIGlmIChiID09IDAuMCkgXHJcblx0XHRcdHJldHVybiBhXHJcblx0XHRyZXR1cm4gYipNYXRoLnNxcnQoMS4wKyhhKmEvYi9iKSlcclxuXHR9XHJcblxyXG5cdC8vSG91c2Vob2xkZXIncyByZWR1Y3Rpb24gdG8gYmlkaWFnb25hbCBmb3JtXHJcblxyXG5cdHZhciBmPSAwLjA7XHJcblx0dmFyIGc9IDAuMDtcclxuXHR2YXIgaD0gMC4wO1xyXG5cdHZhciB4PSAwLjA7XHJcblx0dmFyIHk9IDAuMDtcclxuXHR2YXIgej0gMC4wO1xyXG5cdHZhciBzPSAwLjA7XHJcblx0XHJcblx0Zm9yIChpPTA7IGkgPCBuOyBpKyspXHJcblx0e1x0XHJcblx0XHRlW2ldPSBnO1xyXG5cdFx0cz0gMC4wO1xyXG5cdFx0bD0gaSsxO1xyXG5cdFx0Zm9yIChqPWk7IGogPCBtOyBqKyspIFxyXG5cdFx0XHRzICs9ICh1W2pdW2ldKnVbal1baV0pO1xyXG5cdFx0aWYgKHMgPD0gdG9sZXJhbmNlKVxyXG5cdFx0XHRnPSAwLjA7XHJcblx0XHRlbHNlXHJcblx0XHR7XHRcclxuXHRcdFx0Zj0gdVtpXVtpXTtcclxuXHRcdFx0Zz0gTWF0aC5zcXJ0KHMpO1xyXG5cdFx0XHRpZiAoZiA+PSAwLjApIGc9IC1nO1xyXG5cdFx0XHRoPSBmKmctc1xyXG5cdFx0XHR1W2ldW2ldPWYtZztcclxuXHRcdFx0Zm9yIChqPWw7IGogPCBuOyBqKyspXHJcblx0XHRcdHtcclxuXHRcdFx0XHRzPSAwLjBcclxuXHRcdFx0XHRmb3IgKGs9aTsgayA8IG07IGsrKykgXHJcblx0XHRcdFx0XHRzICs9IHVba11baV0qdVtrXVtqXVxyXG5cdFx0XHRcdGY9IHMvaFxyXG5cdFx0XHRcdGZvciAoaz1pOyBrIDwgbTsgaysrKSBcclxuXHRcdFx0XHRcdHVba11bal0rPWYqdVtrXVtpXVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRxW2ldPSBnXHJcblx0XHRzPSAwLjBcclxuXHRcdGZvciAoaj1sOyBqIDwgbjsgaisrKSBcclxuXHRcdFx0cz0gcyArIHVbaV1bal0qdVtpXVtqXVxyXG5cdFx0aWYgKHMgPD0gdG9sZXJhbmNlKVxyXG5cdFx0XHRnPSAwLjBcclxuXHRcdGVsc2VcclxuXHRcdHtcdFxyXG5cdFx0XHRmPSB1W2ldW2krMV1cclxuXHRcdFx0Zz0gTWF0aC5zcXJ0KHMpXHJcblx0XHRcdGlmIChmID49IDAuMCkgZz0gLWdcclxuXHRcdFx0aD0gZipnIC0gc1xyXG5cdFx0XHR1W2ldW2krMV0gPSBmLWc7XHJcblx0XHRcdGZvciAoaj1sOyBqIDwgbjsgaisrKSBlW2pdPSB1W2ldW2pdL2hcclxuXHRcdFx0Zm9yIChqPWw7IGogPCBtOyBqKyspXHJcblx0XHRcdHtcdFxyXG5cdFx0XHRcdHM9MC4wXHJcblx0XHRcdFx0Zm9yIChrPWw7IGsgPCBuOyBrKyspIFxyXG5cdFx0XHRcdFx0cyArPSAodVtqXVtrXSp1W2ldW2tdKVxyXG5cdFx0XHRcdGZvciAoaz1sOyBrIDwgbjsgaysrKSBcclxuXHRcdFx0XHRcdHVbal1ba10rPXMqZVtrXVxyXG5cdFx0XHR9XHRcclxuXHRcdH1cclxuXHRcdHk9IE1hdGguYWJzKHFbaV0pK01hdGguYWJzKGVbaV0pXHJcblx0XHRpZiAoeT54KSBcclxuXHRcdFx0eD15XHJcblx0fVxyXG5cdFxyXG5cdC8vIGFjY3VtdWxhdGlvbiBvZiByaWdodCBoYW5kIGd0cmFuc2Zvcm1hdGlvbnNcclxuXHRmb3IgKGk9bi0xOyBpICE9IC0xOyBpKz0gLTEpXHJcblx0e1x0XHJcblx0XHRpZiAoZyAhPSAwLjApXHJcblx0XHR7XHJcblx0XHQgXHRoPSBnKnVbaV1baSsxXVxyXG5cdFx0XHRmb3IgKGo9bDsgaiA8IG47IGorKykgXHJcblx0XHRcdFx0dltqXVtpXT11W2ldW2pdL2hcclxuXHRcdFx0Zm9yIChqPWw7IGogPCBuOyBqKyspXHJcblx0XHRcdHtcdFxyXG5cdFx0XHRcdHM9MC4wXHJcblx0XHRcdFx0Zm9yIChrPWw7IGsgPCBuOyBrKyspIFxyXG5cdFx0XHRcdFx0cyArPSB1W2ldW2tdKnZba11bal1cclxuXHRcdFx0XHRmb3IgKGs9bDsgayA8IG47IGsrKykgXHJcblx0XHRcdFx0XHR2W2tdW2pdKz0ocyp2W2tdW2ldKVxyXG5cdFx0XHR9XHRcclxuXHRcdH1cclxuXHRcdGZvciAoaj1sOyBqIDwgbjsgaisrKVxyXG5cdFx0e1xyXG5cdFx0XHR2W2ldW2pdID0gMDtcclxuXHRcdFx0dltqXVtpXSA9IDA7XHJcblx0XHR9XHJcblx0XHR2W2ldW2ldID0gMTtcclxuXHRcdGc9IGVbaV1cclxuXHRcdGw9IGlcclxuXHR9XHJcblx0XHJcblx0Ly8gYWNjdW11bGF0aW9uIG9mIGxlZnQgaGFuZCB0cmFuc2Zvcm1hdGlvbnNcclxuXHRmb3IgKGk9bi0xOyBpICE9IC0xOyBpKz0gLTEpXHJcblx0e1x0XHJcblx0XHRsPSBpKzFcclxuXHRcdGc9IHFbaV1cclxuXHRcdGZvciAoaj1sOyBqIDwgbjsgaisrKSBcclxuXHRcdFx0dVtpXVtqXSA9IDA7XHJcblx0XHRpZiAoZyAhPSAwLjApXHJcblx0XHR7XHJcblx0XHRcdGg9IHVbaV1baV0qZ1xyXG5cdFx0XHRmb3IgKGo9bDsgaiA8IG47IGorKylcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHM9MC4wXHJcblx0XHRcdFx0Zm9yIChrPWw7IGsgPCBtOyBrKyspIHMgKz0gdVtrXVtpXSp1W2tdW2pdO1xyXG5cdFx0XHRcdGY9IHMvaFxyXG5cdFx0XHRcdGZvciAoaz1pOyBrIDwgbTsgaysrKSB1W2tdW2pdKz1mKnVba11baV07XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yIChqPWk7IGogPCBtOyBqKyspIHVbal1baV0gPSB1W2pdW2ldL2c7XHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHRcdGZvciAoaj1pOyBqIDwgbTsgaisrKSB1W2pdW2ldID0gMDtcclxuXHRcdHVbaV1baV0gKz0gMTtcclxuXHR9XHJcblx0XHJcblx0Ly8gZGlhZ29uYWxpemF0aW9uIG9mIHRoZSBiaWRpYWdvbmFsIGZvcm1cclxuXHRwcmVjPSBwcmVjKnhcclxuXHRmb3IgKGs9bi0xOyBrICE9IC0xOyBrKz0gLTEpXHJcblx0e1xyXG5cdFx0Zm9yICh2YXIgaXRlcmF0aW9uPTA7IGl0ZXJhdGlvbiA8IGl0bWF4OyBpdGVyYXRpb24rKylcclxuXHRcdHtcdC8vIHRlc3QgZiBzcGxpdHRpbmdcclxuXHRcdFx0dmFyIHRlc3RfY29udmVyZ2VuY2UgPSBmYWxzZVxyXG5cdFx0XHRmb3IgKGw9azsgbCAhPSAtMTsgbCs9IC0xKVxyXG5cdFx0XHR7XHRcclxuXHRcdFx0XHRpZiAoTWF0aC5hYnMoZVtsXSkgPD0gcHJlYylcclxuXHRcdFx0XHR7XHR0ZXN0X2NvbnZlcmdlbmNlPSB0cnVlXHJcblx0XHRcdFx0XHRicmVhayBcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKE1hdGguYWJzKHFbbC0xXSkgPD0gcHJlYylcclxuXHRcdFx0XHRcdGJyZWFrIFxyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghdGVzdF9jb252ZXJnZW5jZSlcclxuXHRcdFx0e1x0Ly8gY2FuY2VsbGF0aW9uIG9mIGVbbF0gaWYgbD4wXHJcblx0XHRcdFx0Yz0gMC4wXHJcblx0XHRcdFx0cz0gMS4wXHJcblx0XHRcdFx0dmFyIGwxPSBsLTFcclxuXHRcdFx0XHRmb3IgKGkgPWw7IGk8aysxOyBpKyspXHJcblx0XHRcdFx0e1x0XHJcblx0XHRcdFx0XHRmPSBzKmVbaV1cclxuXHRcdFx0XHRcdGVbaV09IGMqZVtpXVxyXG5cdFx0XHRcdFx0aWYgKE1hdGguYWJzKGYpIDw9IHByZWMpXHJcblx0XHRcdFx0XHRcdGJyZWFrXHJcblx0XHRcdFx0XHRnPSBxW2ldXHJcblx0XHRcdFx0XHRoPSBweXRoYWcoZixnKVxyXG5cdFx0XHRcdFx0cVtpXT0gaFxyXG5cdFx0XHRcdFx0Yz0gZy9oXHJcblx0XHRcdFx0XHRzPSAtZi9oXHJcblx0XHRcdFx0XHRmb3IgKGo9MDsgaiA8IG07IGorKylcclxuXHRcdFx0XHRcdHtcdFxyXG5cdFx0XHRcdFx0XHR5PSB1W2pdW2wxXVxyXG5cdFx0XHRcdFx0XHR6PSB1W2pdW2ldXHJcblx0XHRcdFx0XHRcdHVbal1bbDFdID0gIHkqYysoeipzKVxyXG5cdFx0XHRcdFx0XHR1W2pdW2ldID0gLXkqcysoeipjKVxyXG5cdFx0XHRcdFx0fSBcclxuXHRcdFx0XHR9XHRcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyB0ZXN0IGYgY29udmVyZ2VuY2VcclxuXHRcdFx0ej0gcVtrXVxyXG5cdFx0XHRpZiAobD09IGspXHJcblx0XHRcdHtcdC8vY29udmVyZ2VuY2VcclxuXHRcdFx0XHRpZiAoejwwLjApXHJcblx0XHRcdFx0e1x0Ly9xW2tdIGlzIG1hZGUgbm9uLW5lZ2F0aXZlXHJcblx0XHRcdFx0XHRxW2tdPSAtelxyXG5cdFx0XHRcdFx0Zm9yIChqPTA7IGogPCBuOyBqKyspXHJcblx0XHRcdFx0XHRcdHZbal1ba10gPSAtdltqXVtrXVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRicmVhayAgLy9icmVhayBvdXQgb2YgaXRlcmF0aW9uIGxvb3AgYW5kIG1vdmUgb24gdG8gbmV4dCBrIHZhbHVlXHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGl0ZXJhdGlvbiA+PSBpdG1heC0xKVxyXG5cdFx0XHRcdHRocm93ICdFcnJvcjogbm8gY29udmVyZ2VuY2UuJ1xyXG5cdFx0XHQvLyBzaGlmdCBmcm9tIGJvdHRvbSAyeDIgbWlub3JcclxuXHRcdFx0eD0gcVtsXVxyXG5cdFx0XHR5PSBxW2stMV1cclxuXHRcdFx0Zz0gZVtrLTFdXHJcblx0XHRcdGg9IGVba11cclxuXHRcdFx0Zj0gKCh5LXopKih5K3opKyhnLWgpKihnK2gpKS8oMi4wKmgqeSlcclxuXHRcdFx0Zz0gcHl0aGFnKGYsMS4wKVxyXG5cdFx0XHRpZiAoZiA8IDAuMClcclxuXHRcdFx0XHRmPSAoKHgteikqKHgreikraCooeS8oZi1nKS1oKSkveFxyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0Zj0gKCh4LXopKih4K3opK2gqKHkvKGYrZyktaCkpL3hcclxuXHRcdFx0Ly8gbmV4dCBRUiB0cmFuc2Zvcm1hdGlvblxyXG5cdFx0XHRjPSAxLjBcclxuXHRcdFx0cz0gMS4wXHJcblx0XHRcdGZvciAoaT1sKzE7IGk8IGsrMTsgaSsrKVxyXG5cdFx0XHR7XHRcclxuXHRcdFx0XHRnPSBlW2ldXHJcblx0XHRcdFx0eT0gcVtpXVxyXG5cdFx0XHRcdGg9IHMqZ1xyXG5cdFx0XHRcdGc9IGMqZ1xyXG5cdFx0XHRcdHo9IHB5dGhhZyhmLGgpXHJcblx0XHRcdFx0ZVtpLTFdPSB6XHJcblx0XHRcdFx0Yz0gZi96XHJcblx0XHRcdFx0cz0gaC96XHJcblx0XHRcdFx0Zj0geCpjK2cqc1xyXG5cdFx0XHRcdGc9IC14KnMrZypjXHJcblx0XHRcdFx0aD0geSpzXHJcblx0XHRcdFx0eT0geSpjXHJcblx0XHRcdFx0Zm9yIChqPTA7IGogPCBuOyBqKyspXHJcblx0XHRcdFx0e1x0XHJcblx0XHRcdFx0XHR4PSB2W2pdW2ktMV1cclxuXHRcdFx0XHRcdHo9IHZbal1baV1cclxuXHRcdFx0XHRcdHZbal1baS0xXSA9IHgqYyt6KnNcclxuXHRcdFx0XHRcdHZbal1baV0gPSAteCpzK3oqY1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR6PSBweXRoYWcoZixoKVxyXG5cdFx0XHRcdHFbaS0xXT0gelxyXG5cdFx0XHRcdGM9IGYvelxyXG5cdFx0XHRcdHM9IGgvelxyXG5cdFx0XHRcdGY9IGMqZytzKnlcclxuXHRcdFx0XHR4PSAtcypnK2MqeVxyXG5cdFx0XHRcdGZvciAoaj0wOyBqIDwgbTsgaisrKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHk9IHVbal1baS0xXVxyXG5cdFx0XHRcdFx0ej0gdVtqXVtpXVxyXG5cdFx0XHRcdFx0dVtqXVtpLTFdID0geSpjK3oqc1xyXG5cdFx0XHRcdFx0dVtqXVtpXSA9IC15KnMreipjXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVbbF09IDAuMFxyXG5cdFx0XHRlW2tdPSBmXHJcblx0XHRcdHFba109IHhcclxuXHRcdH0gXHJcblx0fVxyXG5cdFx0XHJcblx0Ly92dD0gdHJhbnNwb3NlKHYpXHJcblx0Ly9yZXR1cm4gKHUscSx2dClcclxuXHRmb3IgKGk9MDtpPHEubGVuZ3RoOyBpKyspIFxyXG5cdCAgaWYgKHFbaV0gPCBwcmVjKSBxW2ldID0gMFxyXG5cdCAgXHJcblx0Ly9zb3J0IGVpZ2VudmFsdWVzXHRcclxuXHRmb3IgKGk9MDsgaTwgbjsgaSsrKVxyXG5cdHtcdCBcclxuXHQvL3dyaXRlbG4ocSlcclxuXHQgZm9yIChqPWktMTsgaiA+PSAwOyBqLS0pXHJcblx0IHtcclxuXHQgIGlmIChxW2pdIDwgcVtpXSlcclxuXHQgIHtcclxuXHQvLyAgd3JpdGVsbihpLCctJyxqKVxyXG5cdCAgIGMgPSBxW2pdXHJcblx0ICAgcVtqXSA9IHFbaV1cclxuXHQgICBxW2ldID0gY1xyXG5cdCAgIGZvcihrPTA7azx1Lmxlbmd0aDtrKyspIHsgdGVtcCA9IHVba11baV07IHVba11baV0gPSB1W2tdW2pdOyB1W2tdW2pdID0gdGVtcDsgfVxyXG5cdCAgIGZvcihrPTA7azx2Lmxlbmd0aDtrKyspIHsgdGVtcCA9IHZba11baV07IHZba11baV0gPSB2W2tdW2pdOyB2W2tdW2pdID0gdGVtcDsgfVxyXG4vL1x0ICAgdS5zd2FwQ29scyhpLGopXHJcbi8vXHQgICB2LnN3YXBDb2xzKGksailcclxuXHQgICBpID0galx0ICAgXHJcblx0ICB9XHJcblx0IH1cdFxyXG5cdH1cclxuXHRcclxuXHRyZXR1cm4ge1U6dSxTOnEsVjp2fVxyXG59O1xyXG5cclxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIvKlxuIChjKSAyMDEzLCBWbGFkaW1pciBBZ2Fmb25raW5cbiBTaW1wbGlmeS5qcywgYSBoaWdoLXBlcmZvcm1hbmNlIEpTIHBvbHlsaW5lIHNpbXBsaWZpY2F0aW9uIGxpYnJhcnlcbiBtb3VybmVyLmdpdGh1Yi5pby9zaW1wbGlmeS1qc1xuKi9cblxuKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4vLyB0byBzdWl0IHlvdXIgcG9pbnQgZm9ybWF0LCBydW4gc2VhcmNoL3JlcGxhY2UgZm9yICcueCcgYW5kICcueSc7XG4vLyBmb3IgM0QgdmVyc2lvbiwgc2VlIDNkIGJyYW5jaCAoY29uZmlndXJhYmlsaXR5IHdvdWxkIGRyYXcgc2lnbmlmaWNhbnQgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQpXG5cbi8vIHNxdWFyZSBkaXN0YW5jZSBiZXR3ZWVuIDIgcG9pbnRzXG5mdW5jdGlvbiBnZXRTcURpc3QocDEsIHAyKSB7XG5cbiAgICB2YXIgZHggPSBwMS54IC0gcDIueCxcbiAgICAgICAgZHkgPSBwMS55IC0gcDIueTtcblxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuLy8gc3F1YXJlIGRpc3RhbmNlIGZyb20gYSBwb2ludCB0byBhIHNlZ21lbnRcbmZ1bmN0aW9uIGdldFNxU2VnRGlzdChwLCBwMSwgcDIpIHtcblxuICAgIHZhciB4ID0gcDEueCxcbiAgICAgICAgeSA9IHAxLnksXG4gICAgICAgIGR4ID0gcDIueCAtIHgsXG4gICAgICAgIGR5ID0gcDIueSAtIHk7XG5cbiAgICBpZiAoZHggIT09IDAgfHwgZHkgIT09IDApIHtcblxuICAgICAgICB2YXIgdCA9ICgocC54IC0geCkgKiBkeCArIChwLnkgLSB5KSAqIGR5KSAvIChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgaWYgKHQgPiAxKSB7XG4gICAgICAgICAgICB4ID0gcDIueDtcbiAgICAgICAgICAgIHkgPSBwMi55O1xuXG4gICAgICAgIH0gZWxzZSBpZiAodCA+IDApIHtcbiAgICAgICAgICAgIHggKz0gZHggKiB0O1xuICAgICAgICAgICAgeSArPSBkeSAqIHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkeCA9IHAueCAtIHg7XG4gICAgZHkgPSBwLnkgLSB5O1xuXG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuLy8gcmVzdCBvZiB0aGUgY29kZSBkb2Vzbid0IGNhcmUgYWJvdXQgcG9pbnQgZm9ybWF0XG5cbi8vIGJhc2ljIGRpc3RhbmNlLWJhc2VkIHNpbXBsaWZpY2F0aW9uXG5mdW5jdGlvbiBzaW1wbGlmeVJhZGlhbERpc3QocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xuXG4gICAgdmFyIHByZXZQb2ludCA9IHBvaW50c1swXSxcbiAgICAgICAgbmV3UG9pbnRzID0gW3ByZXZQb2ludF0sXG4gICAgICAgIHBvaW50O1xuXG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwb2ludCA9IHBvaW50c1tpXTtcblxuICAgICAgICBpZiAoZ2V0U3FEaXN0KHBvaW50LCBwcmV2UG9pbnQpID4gc3FUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgIG5ld1BvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgIHByZXZQb2ludCA9IHBvaW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZQb2ludCAhPT0gcG9pbnQpIG5ld1BvaW50cy5wdXNoKHBvaW50KTtcblxuICAgIHJldHVybiBuZXdQb2ludHM7XG59XG5cbi8vIHNpbXBsaWZpY2F0aW9uIHVzaW5nIG9wdGltaXplZCBEb3VnbGFzLVBldWNrZXIgYWxnb3JpdGhtIHdpdGggcmVjdXJzaW9uIGVsaW1pbmF0aW9uXG5mdW5jdGlvbiBzaW1wbGlmeURvdWdsYXNQZXVja2VyKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcblxuICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBNYXJrZXJBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheSxcbiAgICAgICAgbWFya2VycyA9IG5ldyBNYXJrZXJBcnJheShsZW4pLFxuICAgICAgICBmaXJzdCA9IDAsXG4gICAgICAgIGxhc3QgPSBsZW4gLSAxLFxuICAgICAgICBzdGFjayA9IFtdLFxuICAgICAgICBuZXdQb2ludHMgPSBbXSxcbiAgICAgICAgaSwgbWF4U3FEaXN0LCBzcURpc3QsIGluZGV4O1xuXG4gICAgbWFya2Vyc1tmaXJzdF0gPSBtYXJrZXJzW2xhc3RdID0gMTtcblxuICAgIHdoaWxlIChsYXN0KSB7XG5cbiAgICAgICAgbWF4U3FEaXN0ID0gMDtcblxuICAgICAgICBmb3IgKGkgPSBmaXJzdCArIDE7IGkgPCBsYXN0OyBpKyspIHtcbiAgICAgICAgICAgIHNxRGlzdCA9IGdldFNxU2VnRGlzdChwb2ludHNbaV0sIHBvaW50c1tmaXJzdF0sIHBvaW50c1tsYXN0XSk7XG5cbiAgICAgICAgICAgIGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgbWF4U3FEaXN0ID0gc3FEaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heFNxRGlzdCA+IHNxVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICBtYXJrZXJzW2luZGV4XSA9IDE7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGZpcnN0LCBpbmRleCwgaW5kZXgsIGxhc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBmaXJzdCA9IHN0YWNrLnBvcCgpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAobWFya2Vyc1tpXSkgbmV3UG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3UG9pbnRzO1xufVxuXG4vLyBib3RoIGFsZ29yaXRobXMgY29tYmluZWQgZm9yIGF3ZXNvbWUgcGVyZm9ybWFuY2VcbmZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50cywgdG9sZXJhbmNlLCBoaWdoZXN0UXVhbGl0eSkge1xuXG4gICAgdmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICE9PSB1bmRlZmluZWQgPyB0b2xlcmFuY2UgKiB0b2xlcmFuY2UgOiAxO1xuXG4gICAgcG9pbnRzID0gaGlnaGVzdFF1YWxpdHkgPyBwb2ludHMgOiBzaW1wbGlmeVJhZGlhbERpc3QocG9pbnRzLCBzcVRvbGVyYW5jZSk7XG4gICAgcG9pbnRzID0gc2ltcGxpZnlEb3VnbGFzUGV1Y2tlcihwb2ludHMsIHNxVG9sZXJhbmNlKTtcblxuICAgIHJldHVybiBwb2ludHM7XG59XG5cbi8vIGV4cG9ydCBhcyBBTUQgbW9kdWxlIC8gTm9kZSBtb2R1bGUgLyBicm93c2VyIG9yIHdvcmtlciB2YXJpYWJsZVxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gc2ltcGxpZnk7IH0pO1xuZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIG1vZHVsZS5leHBvcnRzID0gc2ltcGxpZnk7XG5lbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHNlbGYuc2ltcGxpZnkgPSBzaW1wbGlmeTtcbmVsc2Ugd2luZG93LnNpbXBsaWZ5ID0gc2ltcGxpZnk7XG5cbn0pKCk7XG4iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUtEVHJlZVxubW9kdWxlLmV4cG9ydHMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZUtEVHJlZVxuXG52YXIgbmRhcnJheSA9IHJlcXVpcmUoXCJuZGFycmF5XCIpXG52YXIgbmRzZWxlY3QgPSByZXF1aXJlKFwibmRhcnJheS1zZWxlY3RcIilcbnZhciBwYWNrID0gcmVxdWlyZShcIm5kYXJyYXktcGFja1wiKVxudmFyIG9wcyA9IHJlcXVpcmUoXCJuZGFycmF5LW9wc1wiKVxudmFyIG5kc2NyYXRjaCA9IHJlcXVpcmUoXCJuZGFycmF5LXNjcmF0Y2hcIilcbnZhciBwb29sID0gcmVxdWlyZShcInR5cGVkYXJyYXktcG9vbFwiKVxudmFyIGlub3JkZXJUcmVlID0gcmVxdWlyZShcImlub3JkZXItdHJlZS1sYXlvdXRcIilcbnZhciBiaXRzID0gcmVxdWlyZShcImJpdC10d2lkZGxlXCIpXG52YXIgS0RUSGVhcCA9IHJlcXVpcmUoXCIuL2xpYi9oZWFwLmpzXCIpXG5cbmZ1bmN0aW9uIEtEVHJlZShwb2ludHMsIGlkcywgbiwgZCkge1xuICB0aGlzLnBvaW50cyA9IHBvaW50c1xuICB0aGlzLmlkcyA9IGlkc1xuICB0aGlzLmRpbWVuc2lvbiA9IGRcbiAgdGhpcy5sZW5ndGggPSBuXG59XG5cbnZhciBwcm90byA9IEtEVHJlZS5wcm90b3R5cGVcblxucHJvdG8uc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG4gIGlmKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBwOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLnBvaW50cy5kYXRhLCAwLCB0aGlzLmxlbmd0aCp0aGlzLmRpbWVuc2lvbiksXG4gICAgICBpOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLmlkcywgMCwgdGhpcy5sZW5ndGgpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IGQ6IHRoaXMuZGltZW5zaW9uIH1cbiAgfVxufVxuXG4vL1JhbmdlIHF1ZXJ5XG5wcm90by5yYW5nZSA9IGZ1bmN0aW9uIGtkdFJhbmdlUXVlcnkobG8sIGhpLCB2aXNpdCkge1xuICB2YXIgbiA9IHRoaXMubGVuZ3RoXG4gIGlmKG4gPCAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvL0NoZWNrIGRlZ2VuZXJhdGUgY2FzZVxuICB2YXIgZCA9IHRoaXMuZGltZW5zaW9uXG4gIGZvcih2YXIgaT0wOyBpPGQ7ICsraSkge1xuICAgIGlmKGhpW2ldIDwgbG9baV0pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuXG4gIHZhciBwb2ludHMgPSB0aGlzLnBvaW50c1xuICB2YXIgaWRzID0gdGhpcy5pZHNcblxuICAvL1dhbGsgdHJlZSBpbiBsZXZlbCBvcmRlciwgc2tpcHBpbmcgc3VidHJlZXMgd2hpY2ggZG8gbm90IGludGVyc2VjdCByYW5nZVxuICB2YXIgdmlzaXRSYW5nZSA9IG5kc2NyYXRjaC5tYWxsb2MoW24sIDIsIGRdKVxuICB2YXIgdmlzaXRJbmRleCA9IHBvb2wubWFsbG9jSW50MzIobilcbiAgdmFyIHJhbmdlRGF0YSA9IHZpc2l0UmFuZ2UuZGF0YVxuICB2YXIgcG9pbnREYXRhID0gcG9pbnRzLmRhdGFcbiAgdmFyIHZpc2l0Q291bnQgPSAxXG4gIHZhciB2aXNpdFRvcCA9IDBcbiAgdmFyIHJldHZhbFxuXG4gIHZpc2l0SW5kZXhbMF0gPSAwXG4gIHBhY2sobG8sIHZpc2l0UmFuZ2UucGljaygwLDApKVxuICBwYWNrKGhpLCB2aXNpdFJhbmdlLnBpY2soMCwxKSlcbiAgXG4gIHdoaWxlKHZpc2l0VG9wIDwgdmlzaXRDb3VudCkge1xuICAgIHZhciBpZHggPSB2aXNpdEluZGV4W3Zpc2l0VG9wXVxuICAgIHZhciBrID0gYml0cy5sb2cyKGlkeCsxKSVkXG4gICAgdmFyIGxvaWR4ID0gdmlzaXRSYW5nZS5pbmRleCh2aXNpdFRvcCwgMCwgMClcbiAgICB2YXIgaGlpZHggPSB2aXNpdFJhbmdlLmluZGV4KHZpc2l0VG9wLCAxLCAwKVxuICAgIHZhciBwaWR4ID0gcG9pbnRzLmluZGV4KGlkeCwgMClcblxuICAgIHZhciB2aXNpdFBvaW50ID0gdHJ1ZVxuICAgIGZvcih2YXIgaT0wOyBpPGQ7ICsraSkge1xuICAgICAgdmFyIHBjID0gcG9pbnREYXRhW3BpZHgraV1cbiAgICAgIGlmKChwYyA8IHJhbmdlRGF0YVtsb2lkeCArIGldKSB8fCBcbiAgICAgICAgIChyYW5nZURhdGFbaGlpZHggKyBpXSA8IHBjKSkge1xuICAgICAgICB2aXNpdFBvaW50ID0gZmFsc2VcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYodmlzaXRQb2ludCkge1xuICAgICAgcmV0dmFsID0gdmlzaXQoaWRzW2lkeF0pXG4gICAgICBpZihyZXR2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vVmlzaXQgY2hpbGRyZW5cbiAgICB2YXIgcGsgPSBwb2ludERhdGFbcGlkeCtrXVxuICAgIHZhciBoayA9IHJhbmdlRGF0YVtoaWlkeCtrXVxuICAgIHZhciBsayA9IHJhbmdlRGF0YVtsb2lkeCtrXVxuICAgIGlmKGxrIDw9IHBrKSB7XG4gICAgICB2YXIgbGVmdCA9IDIgKiBpZHggKyAxXG4gICAgICBpZihsZWZ0IDwgbikge1xuICAgICAgICB2aXNpdEluZGV4W3Zpc2l0Q291bnRdID0gbGVmdFxuICAgICAgICB2YXIgeSA9IHZpc2l0UmFuZ2UuaW5kZXgodmlzaXRDb3VudCwgMCwgMClcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8ZDsgKytpKSB7XG4gICAgICAgICAgcmFuZ2VEYXRhW3kraV0gPSByYW5nZURhdGFbbG9pZHgraV1cbiAgICAgICAgfVxuICAgICAgICB2YXIgeiA9IHZpc2l0UmFuZ2UuaW5kZXgodmlzaXRDb3VudCwgMSwgMClcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8ZDsgKytpKSB7XG4gICAgICAgICAgcmFuZ2VEYXRhW3oraV0gPSByYW5nZURhdGFbaGlpZHgraV1cbiAgICAgICAgfVxuICAgICAgICByYW5nZURhdGFbeitrXSA9IE1hdGgubWluKGhrLCBwaylcbiAgICAgICAgdmlzaXRDb3VudCArPSAxXG4gICAgICB9XG4gICAgfVxuICAgIGlmKHBrIDw9IGhrKSB7XG4gICAgICB2YXIgcmlnaHQgPSAyICogKGlkeCArIDEpXG4gICAgICBpZihyaWdodCA8IG4pIHtcbiAgICAgICAgdmlzaXRJbmRleFt2aXNpdENvdW50XSA9IHJpZ2h0XG4gICAgICAgIHZhciB5ID0gdmlzaXRSYW5nZS5pbmRleCh2aXNpdENvdW50LCAwLCAwKVxuICAgICAgICBmb3IodmFyIGk9MDsgaTxkOyArK2kpIHtcbiAgICAgICAgICByYW5nZURhdGFbeStpXSA9IHJhbmdlRGF0YVtsb2lkeCtpXVxuICAgICAgICB9XG4gICAgICAgIHZhciB6ID0gdmlzaXRSYW5nZS5pbmRleCh2aXNpdENvdW50LCAxLCAwKVxuICAgICAgICBmb3IodmFyIGk9MDsgaTxkOyArK2kpIHtcbiAgICAgICAgICByYW5nZURhdGFbeitpXSA9IHJhbmdlRGF0YVtoaWlkeCtpXVxuICAgICAgICB9XG4gICAgICAgIHJhbmdlRGF0YVt5K2tdID0gTWF0aC5tYXgobGssIHBrKVxuICAgICAgICB2aXNpdENvdW50ICs9IDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL0luY3JlbWVudCBwb2ludGVyXG4gICAgdmlzaXRUb3AgKz0gMVxuICB9XG4gIG5kc2NyYXRjaC5mcmVlKHZpc2l0UmFuZ2UpXG4gIHBvb2wuZnJlZSh2aXNpdEluZGV4KVxuICByZXR1cm4gcmV0dmFsXG59XG5cbnByb3RvLnJubiA9IGZ1bmN0aW9uKHBvaW50LCByYWRpdXMsIHZpc2l0KSB7XG4gIGlmKHJhZGl1cyA8IDApIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgbiA9IHRoaXMubGVuZ3RoXG4gIGlmKG4gPCAxKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGQgPSB0aGlzLmRpbWVuc2lvblxuICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHNcbiAgdmFyIGlkcyA9IHRoaXMuaWRzXG5cbiAgLy9XYWxrIHRyZWUgaW4gbGV2ZWwgb3JkZXIsIHNraXBwaW5nIHN1YnRyZWVzIHdoaWNoIGRvIG5vdCBpbnRlcnNlY3Qgc3BoZXJlXG4gIHZhciB2aXNpdERpc3RhbmNlID0gbmRzY3JhdGNoLm1hbGxvYyhbbiwgZF0pXG4gIHZhciB2aXNpdEluZGV4ID0gcG9vbC5tYWxsb2NJbnQzMihuKVxuICB2YXIgZGlzdGFuY2VEYXRhID0gdmlzaXREaXN0YW5jZS5kYXRhXG4gIHZhciBwb2ludERhdGEgPSBwb2ludHMuZGF0YVxuICB2YXIgdmlzaXRDb3VudCA9IDFcbiAgdmFyIHZpc2l0VG9wID0gMFxuICB2YXIgcjIgPSByYWRpdXMqcmFkaXVzXG4gIHZhciByZXR2YWxcblxuICAvL0luaXRpYWxpemUgdG9wIG9mIHF1ZXVlXG4gIHZpc2l0SW5kZXhbMF0gPSAwXG4gIGZvcih2YXIgaT0wOyBpPGQ7ICsraSkge1xuICAgIHZpc2l0RGlzdGFuY2Uuc2V0KDAsIGksIDApXG4gIH1cblxuICAvL1dhbGsgb3ZlciBxdWV1ZVxuICB3aGlsZSh2aXNpdFRvcCA8IHZpc2l0Q291bnQpIHtcbiAgICB2YXIgaWR4ID0gdmlzaXRJbmRleFt2aXNpdFRvcF1cbiAgICB2YXIgcGlkeCA9IHBvaW50cy5pbmRleChpZHgsIDApXG5cbiAgICAvL0NoZWNrIGlmIHBvaW50IGluIHNwaGVyZVxuICAgIHZhciBkMiA9IDAuMFxuICAgIGZvcih2YXIgaT0wOyBpPGQ7ICsraSkge1xuICAgICAgZDIgKz0gTWF0aC5wb3cocG9pbnRbaV0gLSBwb2ludERhdGFbcGlkeCtpXSwgMilcbiAgICB9XG4gICAgaWYoZDIgPD0gcjIpIHtcbiAgICAgIHJldHZhbCA9IHZpc2l0KGlkc1tpZHhdKVxuICAgICAgaWYocmV0dmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1Zpc2l0IGNoaWxkcmVuXG4gICAgdmFyIGsgPSBiaXRzLmxvZzIoaWR4KzEpJWRcbiAgICB2YXIgZHMgPSAwLjBcbiAgICB2YXIgZGlkeCA9IHZpc2l0RGlzdGFuY2UuaW5kZXgodmlzaXRUb3AsIDApXG4gICAgZm9yKHZhciBpPTA7IGk8ZDsgKytpKSB7XG4gICAgICBpZihpICE9PSBrKSB7XG4gICAgICAgIGRzICs9IGRpc3RhbmNlRGF0YVtkaWR4ICsgaV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL0hhbmRsZSBzcGxpdCBheGlzXG4gICAgdmFyIHFrID0gcG9pbnRba11cbiAgICB2YXIgcGsgPSBwb2ludERhdGFbcGlkeCtrXVxuICAgIHZhciBkayA9IGRpc3RhbmNlRGF0YVtkaWR4K2tdXG4gICAgdmFyIGxrID0gZGtcbiAgICB2YXIgaGsgPSBka1xuICAgIGlmKHFrIDwgcGspIHtcbiAgICAgIGhrID0gTWF0aC5tYXgoZGssIE1hdGgucG93KHBrIC0gcWssIDIpKVxuICAgIH0gZWxzZSB7XG4gICAgICBsayA9IE1hdGgubWF4KGRrLCBNYXRoLnBvdyhwayAtIHFrLCAyKSlcbiAgICB9XG5cbiAgICB2YXIgZDJsID0gbGsgKyBkc1xuICAgIHZhciBkMmggPSBoayArIGRzXG5cbiAgICBpZihkMmwgPD0gcjIpIHtcbiAgICAgIHZhciBsZWZ0ID0gMiAqIGlkeCArIDFcbiAgICAgIGlmKGxlZnQgPCBuKSB7XG4gICAgICAgIHZpc2l0SW5kZXhbdmlzaXRDb3VudF0gPSBsZWZ0XG4gICAgICAgIHZhciB5ID0gdmlzaXREaXN0YW5jZS5pbmRleCh2aXNpdENvdW50LCAwKVxuICAgICAgICBmb3IodmFyIGk9MDsgaTxkOyArK2kpIHtcbiAgICAgICAgICBkaXN0YW5jZURhdGFbeStpXSA9IGRpc3RhbmNlRGF0YVtkaWR4K2ldXG4gICAgICAgIH1cbiAgICAgICAgZGlzdGFuY2VEYXRhW3kra10gPSBsa1xuICAgICAgICB2aXNpdENvdW50ICs9IDFcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoZDJoIDw9IHIyKSB7XG4gICAgICB2YXIgcmlnaHQgPSAyICogKGlkeCArIDEpXG4gICAgICBpZihyaWdodCA8IG4pIHtcbiAgICAgICAgdmlzaXRJbmRleFt2aXNpdENvdW50XSA9IHJpZ2h0XG4gICAgICAgIHZhciB5ID0gdmlzaXREaXN0YW5jZS5pbmRleCh2aXNpdENvdW50LCAwKVxuICAgICAgICBmb3IodmFyIGk9MDsgaTxkOyArK2kpIHtcbiAgICAgICAgICBkaXN0YW5jZURhdGFbeStpXSA9IGRpc3RhbmNlRGF0YVtkaWR4K2ldXG4gICAgICAgIH1cbiAgICAgICAgZGlzdGFuY2VEYXRhW3kra10gPSBoa1xuICAgICAgICB2aXNpdENvdW50ICs9IDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL0luY3JlbWVudCBwb2ludGVyXG4gICAgdmlzaXRUb3AgKz0gMVxuICB9XG5cbiAgbmRzY3JhdGNoLmZyZWUodmlzaXREaXN0YW5jZSlcbiAgcG9vbC5mcmVlKHZpc2l0SW5kZXgpXG4gIHJldHVybiByZXR2YWxcbn1cblxucHJvdG8ubm4gPSBmdW5jdGlvbihwb2ludCwgbWF4RGlzdGFuY2UpIHtcbiAgdmFyIG4gPSB0aGlzLmxlbmd0aFxuICBpZihuIDwgMSkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmKHR5cGVvZiBtYXhEaXN0YW5jZSA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmKG1heERpc3RhbmNlIDwgMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfSBcbiAgfSBlbHNlIHtcbiAgICBtYXhEaXN0YW5jZSA9IEluZmluaXR5XG4gIH1cbiAgdmFyIGQgPSB0aGlzLmRpbWVuc2lvblxuICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHNcbiAgdmFyIHBvaW50RGF0YSA9IHBvaW50cy5kYXRhXG4gIHZhciBkYXRhVmVjdG9yID0gcG9vbC5tYWxsb2NGbG9hdDY0KGQpXG5cbiAgdmFyIHRvVmlzaXQgPSBuZXcgS0RUSGVhcChuLCBkKzEpXG4gIHZhciBpbmRleCA9IHRvVmlzaXQuaW5kZXhcbiAgdmFyIGRhdGEgPSB0b1Zpc2l0LmRhdGFcbiAgaW5kZXhbMF0gPSAwXG4gIGZvcih2YXIgaT0wOyBpPD1kOyArK2kpIHtcbiAgICBkYXRhW2ldID0gMFxuICB9XG4gIHRvVmlzaXQuY291bnQgKz0gMVxuXG4gIHZhciBuZWFyZXN0ID0gLTFcbiAgdmFyIG5lYXJlc3REID0gbWF4RGlzdGFuY2VcblxuICB3aGlsZSh0b1Zpc2l0LmNvdW50ID4gMCkge1xuICAgIGlmKGRhdGFbMF0gPj0gbmVhcmVzdEQpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgdmFyIGlkeCA9IGluZGV4WzBdXG4gICAgdmFyIHBpZHggPSBwb2ludHMuaW5kZXgoaWR4LCAwKVxuICAgIHZhciBkMiA9IDAuMFxuICAgIGZvcih2YXIgaT0wOyBpPGQ7ICsraSkge1xuICAgICAgZDIgKz0gTWF0aC5wb3cocG9pbnRbaV0tcG9pbnREYXRhW3BpZHgraV0sIDIpXG4gICAgfVxuICAgIGlmKGQyIDwgbmVhcmVzdEQpIHtcbiAgICAgIG5lYXJlc3REID0gZDJcbiAgICAgIG5lYXJlc3QgPSBpZHhcbiAgICB9XG5cbiAgICAvL0NvbXB1dGUgZGlzdGFuY2UgYm91bmRzIGZvciBjaGlsZHJlblxuICAgIHZhciBrID0gYml0cy5sb2cyKGlkeCsxKSVkXG4gICAgdmFyIGRzID0gMFxuICAgIGZvcih2YXIgaT0wOyBpPGQ7ICsraSkge1xuICAgICAgdmFyIGRkID0gZGF0YVtpKzFdXG4gICAgICBpZihpICE9PSBrKSB7XG4gICAgICAgIGRzICs9IGRkXG4gICAgICB9XG4gICAgICBkYXRhVmVjdG9yW2ldID0gZGRcbiAgICB9XG4gICAgdmFyIHFrID0gcG9pbnRba11cbiAgICB2YXIgcGsgPSBwb2ludERhdGFbcGlkeCtrXVxuICAgIHZhciBkayA9IGRhdGFWZWN0b3Jba11cbiAgICB2YXIgbGsgPSBka1xuICAgIHZhciBoayA9IGRrXG4gICAgaWYocWsgPCBwaykge1xuICAgICAgaGsgPSBNYXRoLm1heChkaywgTWF0aC5wb3cocGsgLSBxaywgMikpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxrID0gTWF0aC5tYXgoZGssIE1hdGgucG93KHBrIC0gcWssIDIpKVxuICAgIH1cbiAgICB2YXIgZDJsID0gbGsgKyBkc1xuICAgIHZhciBkMmggPSBoayArIGRzXG5cbiAgICB0b1Zpc2l0LnBvcCgpXG4gICAgXG4gICAgaWYoZDJsIDwgbmVhcmVzdEQpIHtcbiAgICAgIHZhciBsZWZ0ID0gMiAqIGlkeCArIDFcbiAgICAgIGlmKGxlZnQgPCBuKSB7XG4gICAgICAgIHZhciB2Y291bnQgPSB0b1Zpc2l0LmNvdW50XG4gICAgICAgIGluZGV4W3Zjb3VudF0gPSBsZWZ0XG4gICAgICAgIHZhciB2cHRyID0gdmNvdW50ICogKGQrMSlcbiAgICAgICAgZGF0YVt2cHRyXSA9IGQybFxuICAgICAgICBmb3IodmFyIGk9MTsgaTw9ZDsgKytpKSB7XG4gICAgICAgICAgZGF0YVt2cHRyK2ldID0gZGF0YVZlY3RvcltpLTFdXG4gICAgICAgIH1cbiAgICAgICAgZGF0YVt2cHRyK2srMV0gPSBsa1xuICAgICAgICB0b1Zpc2l0LnB1c2goKVxuICAgICAgfVxuICAgIH1cbiAgICBpZihkMmggPCBuZWFyZXN0RCkge1xuICAgICAgdmFyIHJpZ2h0ID0gMiAqIChpZHggKyAxKVxuICAgICAgaWYocmlnaHQgPCBuKSB7XG4gICAgICAgIHZhciB2Y291bnQgPSB0b1Zpc2l0LmNvdW50XG4gICAgICAgIGluZGV4W3Zjb3VudF0gPSByaWdodFxuICAgICAgICB2YXIgdnB0ciA9IHZjb3VudCAqIChkKzEpXG4gICAgICAgIGRhdGFbdnB0cl0gPSBkMmhcbiAgICAgICAgZm9yKHZhciBpPTE7IGk8PWQ7ICsraSkge1xuICAgICAgICAgIGRhdGFbdnB0citpXSA9IGRhdGFWZWN0b3JbaS0xXVxuICAgICAgICB9XG4gICAgICAgIGRhdGFbdnB0citrKzFdID0gaGtcbiAgICAgICAgdG9WaXNpdC5wdXNoKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwb29sLmZyZWVGbG9hdDY0KGRhdGFWZWN0b3IpXG4gIHRvVmlzaXQuZGlzcG9zZSgpXG4gIFxuICBpZihuZWFyZXN0IDwgMCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIHJldHVybiB0aGlzLmlkc1tuZWFyZXN0XVxufVxuXG5wcm90by5rbm4gPSBmdW5jdGlvbihwb2ludCwgbWF4UG9pbnRzLCBtYXhEaXN0YW5jZSkge1xuICAvL0NoZWNrIGRlZ2VuZXJhdGUgY2FzZXNcbiAgaWYodHlwZW9mIG1heERpc3RhbmNlID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYobWF4RGlzdGFuY2UgPCAwKSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWF4RGlzdGFuY2UgPSBJbmZpbml0eVxuICB9XG4gIHZhciBuID0gdGhpcy5sZW5ndGhcbiAgaWYobiA8IDEpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICBpZih0eXBlb2YgbWF4UG9pbnRzID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYobWF4UG9pbnRzIDw9IDApIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgICBtYXhQb2ludHMgPSBNYXRoLm1pbihtYXhQb2ludHMsIG4pfDBcbiAgfSBlbHNlIHtcbiAgICBtYXhQb2ludHMgPSBuXG4gIH1cbiAgdmFyIGlkcyA9IHRoaXMuaWRzXG5cbiAgdmFyIGQgPSB0aGlzLmRpbWVuc2lvblxuICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHNcbiAgdmFyIHBvaW50RGF0YSA9IHBvaW50cy5kYXRhXG4gIHZhciBkYXRhVmVjdG9yID0gcG9vbC5tYWxsb2NGbG9hdDY0KGQpXG4gIFxuICAvL0xpc3Qgb2YgY2xvc2VzdCBwb2ludHNcbiAgdmFyIGNsb3Nlc3RQb2ludHMgPSBuZXcgS0RUSGVhcChtYXhQb2ludHMsIDEpXG4gIHZhciBjbF9pbmRleCA9IGNsb3Nlc3RQb2ludHMuaW5kZXhcbiAgdmFyIGNsX2RhdGEgPSBjbG9zZXN0UG9pbnRzLmRhdGFcblxuICB2YXIgdG9WaXNpdCA9IG5ldyBLRFRIZWFwKG4sIGQrMSlcbiAgdmFyIGluZGV4ID0gdG9WaXNpdC5pbmRleFxuICB2YXIgZGF0YSA9IHRvVmlzaXQuZGF0YVxuICBpbmRleFswXSA9IDBcbiAgZm9yKHZhciBpPTA7IGk8PWQ7ICsraSkge1xuICAgIGRhdGFbaV0gPSAwXG4gIH1cbiAgdG9WaXNpdC5jb3VudCArPSAxXG5cbiAgdmFyIG5lYXJlc3QgPSAtMVxuICB2YXIgbmVhcmVzdEQgPSBtYXhEaXN0YW5jZVxuXG4gIHdoaWxlKHRvVmlzaXQuY291bnQgPiAwKSB7XG4gICAgaWYoZGF0YVswXSA+PSBuZWFyZXN0RCkge1xuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICB2YXIgaWR4ID0gaW5kZXhbMF1cbiAgICB2YXIgcGlkeCA9IHBvaW50cy5pbmRleChpZHgsIDApXG4gICAgdmFyIGQyID0gMC4wXG4gICAgZm9yKHZhciBpPTA7IGk8ZDsgKytpKSB7XG4gICAgICBkMiArPSBNYXRoLnBvdyhwb2ludFtpXS1wb2ludERhdGFbcGlkeCtpXSwgMilcbiAgICB9XG4gICAgaWYoZDIgPCBuZWFyZXN0RCkge1xuICAgICAgaWYoY2xvc2VzdFBvaW50cy5jb3VudCA+PSBtYXhQb2ludHMpIHtcbiAgICAgICAgY2xvc2VzdFBvaW50cy5wb3AoKVxuICAgICAgfVxuICAgICAgdmFyIHBjb3VudCA9IGNsb3Nlc3RQb2ludHMuY291bnRcbiAgICAgIGNsX2luZGV4W3Bjb3VudF0gPSBpZHhcbiAgICAgIGNsX2RhdGFbcGNvdW50XSA9IC1kMlxuICAgICAgY2xvc2VzdFBvaW50cy5wdXNoKClcbiAgICAgIGlmKGNsb3Nlc3RQb2ludHMuY291bnQgPj0gbWF4UG9pbnRzKSB7XG4gICAgICAgIG5lYXJlc3REID0gLWNsX2RhdGFbMF1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL0NvbXB1dGUgZGlzdGFuY2UgYm91bmRzIGZvciBjaGlsZHJlblxuICAgIHZhciBrID0gYml0cy5sb2cyKGlkeCsxKSVkXG4gICAgdmFyIGRzID0gMFxuICAgIGZvcih2YXIgaT0wOyBpPGQ7ICsraSkge1xuICAgICAgdmFyIGRkID0gZGF0YVtpKzFdXG4gICAgICBpZihpICE9PSBrKSB7XG4gICAgICAgIGRzICs9IGRkXG4gICAgICB9XG4gICAgICBkYXRhVmVjdG9yW2ldID0gZGRcbiAgICB9XG4gICAgdmFyIHFrID0gcG9pbnRba11cbiAgICB2YXIgcGsgPSBwb2ludERhdGFbcGlkeCtrXVxuICAgIHZhciBkayA9IGRhdGFWZWN0b3Jba11cbiAgICB2YXIgbGsgPSBka1xuICAgIHZhciBoayA9IGRrXG4gICAgaWYocWsgPCBwaykge1xuICAgICAgaGsgPSBNYXRoLm1heChkaywgTWF0aC5wb3cocGsgLSBxaywgMikpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxrID0gTWF0aC5tYXgoZGssIE1hdGgucG93KHBrIC0gcWssIDIpKVxuICAgIH1cbiAgICB2YXIgZDJsID0gbGsgKyBkc1xuICAgIHZhciBkMmggPSBoayArIGRzXG5cbiAgICB0b1Zpc2l0LnBvcCgpXG4gICAgaWYoZDJsIDwgbmVhcmVzdEQpIHtcbiAgICAgIHZhciBsZWZ0ID0gMiAqIGlkeCArIDFcbiAgICAgIGlmKGxlZnQgPCBuKSB7XG4gICAgICAgIHZhciB2Y291bnQgPSB0b1Zpc2l0LmNvdW50XG4gICAgICAgIGluZGV4W3Zjb3VudF0gPSBsZWZ0XG4gICAgICAgIHZhciB2cHRyID0gdmNvdW50ICogKGQrMSlcbiAgICAgICAgZGF0YVt2cHRyXSA9IGQybFxuICAgICAgICBmb3IodmFyIGk9MTsgaTw9ZDsgKytpKSB7XG4gICAgICAgICAgZGF0YVt2cHRyK2ldID0gZGF0YVZlY3RvcltpLTFdXG4gICAgICAgIH1cbiAgICAgICAgZGF0YVt2cHRyK2srMV0gPSBsa1xuICAgICAgICB0b1Zpc2l0LnB1c2goKVxuICAgICAgfVxuICAgIH1cbiAgICBpZihkMmggPCBuZWFyZXN0RCkge1xuICAgICAgdmFyIHJpZ2h0ID0gMiAqIChpZHggKyAxKVxuICAgICAgaWYocmlnaHQgPCBuKSB7XG4gICAgICAgIHZhciB2Y291bnQgPSB0b1Zpc2l0LmNvdW50XG4gICAgICAgIGluZGV4W3Zjb3VudF0gPSByaWdodFxuICAgICAgICB2YXIgdnB0ciA9IHZjb3VudCAqIChkKzEpXG4gICAgICAgIGRhdGFbdnB0cl0gPSBkMmhcbiAgICAgICAgZm9yKHZhciBpPTE7IGk8PWQ7ICsraSkge1xuICAgICAgICAgIGRhdGFbdnB0citpXSA9IGRhdGFWZWN0b3JbaS0xXVxuICAgICAgICB9XG4gICAgICAgIGRhdGFbdnB0citrKzFdID0gaGtcbiAgICAgICAgdG9WaXNpdC5wdXNoKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwb29sLmZyZWVGbG9hdDY0KGRhdGFWZWN0b3IpXG4gIHRvVmlzaXQuZGlzcG9zZSgpXG5cbiAgLy9Tb3J0IHJlc3VsdFxuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGNsb3Nlc3RQb2ludHMuY291bnQpXG4gIHZhciBpZHMgPSB0aGlzLmlkc1xuICBmb3IodmFyIGk9Y2xvc2VzdFBvaW50cy5jb3VudC0xOyBpPj0wOyAtLWkpIHtcbiAgICByZXN1bHRbaV0gPSBpZHNbY2xfaW5kZXhbMF1dXG4gICAgY2xvc2VzdFBvaW50cy5wb3AoKVxuICB9XG4gIGNsb3Nlc3RQb2ludHMuZGlzcG9zZSgpXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5wcm90by5kaXNwb3NlID0gZnVuY3Rpb24ga2R0RGlzcG9zZSgpIHtcbiAgcG9vbC5mcmVlKHRoaXMucG9pbnRzLmRhdGEpXG4gIHBvb2wuZnJlZUludDMyKHRoaXMuaWRzKVxuICB0aGlzLnBvaW50cyA9IG51bGxcbiAgdGhpcy5pZHMgPSBudWxsXG4gIHRoaXMubGVuZ3RoID0gMFxufVxuXG5mdW5jdGlvbiBjcmVhdGVLRFRyZWUocG9pbnRzKSB7XG4gIHZhciBuLCBkLCBpbmRleGVkXG4gIGlmKEFycmF5LmlzQXJyYXkocG9pbnRzKSkge1xuICAgIG4gPSBwb2ludHMubGVuZ3RoXG4gICAgaWYobiA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBLRFRyZWUobnVsbCwgbnVsbCwgMCwgMClcbiAgICB9XG4gICAgZCA9IHBvaW50c1swXS5sZW5ndGhcbiAgICBpbmRleGVkID0gbmRhcnJheShwb29sLm1hbGxvY0RvdWJsZShuKihkKzEpKSwgW24sIGQrMV0pXG4gICAgcGFjayhwb2ludHMsIGluZGV4ZWQuaGkobiwgZCkpXG4gIH0gZWxzZSB7XG4gICAgbiA9IHBvaW50cy5zaGFwZVswXVxuICAgIGQgPSBwb2ludHMuc2hhcGVbMV1cblxuICAgIC8vUm91bmQgdXAgZGF0YSB0eXBlIHNpemVcbiAgICB2YXIgdHlwZSA9IHBvaW50cy5kdHlwZVxuICAgIGlmKHR5cGUgPT09IFwiaW50OFwiIHx8XG4gICAgICAgdHlwZSA9PT0gXCJpbnQxNlwiIHx8XG4gICAgICAgdHlwZSA9PT0gXCJpbnQzMlwiICkge1xuICAgICAgdHlwZSA9IFwiaW50MzJcIlxuICAgIH0gZWxzZSBpZih0eXBlID09PSBcInVpbnQ4XCIgfHxcbiAgICAgIHR5cGUgPT09IFwidWludDhfY2xhbXBlZFwiIHx8XG4gICAgICB0eXBlID09PSBcImJ1ZmZlclwiIHx8XG4gICAgICB0eXBlID09PSBcInVpbnQxNlwiIHx8XG4gICAgICB0eXBlID09PSBcInVpbnQzMlwiKSB7XG4gICAgICB0eXBlID0gXCJ1aW50MzJcIlxuICAgIH0gZWxzZSBpZih0eXBlID09PSBcImZsb2F0MzJcIikge1xuICAgICAgdHlwZSA9IFwiZmxvYXQzMlwiXG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGUgPSBcImZsb2F0NjRcIlxuICAgIH1cbiAgICBpbmRleGVkID0gbmRhcnJheShwb29sLm1hbGxvYyhuKihkKzEpKSwgW24sIGQrMV0pXG4gICAgb3BzLmFzc2lnbihpbmRleGVkLmhpKG4sZCksIHBvaW50cylcbiAgfVxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICBpbmRleGVkLnNldChpLCBkLCBpKVxuICB9XG5cbiAgdmFyIHBvaW50QXJyYXkgPSBuZHNjcmF0Y2gubWFsbG9jKFtuLCBkXSwgcG9pbnRzLmR0eXBlKVxuICB2YXIgaW5kZXhBcnJheSA9IHBvb2wubWFsbG9jSW50MzIobilcbiAgdmFyIHBvaW50ZXIgPSAwXG4gIHZhciBwb2ludERhdGEgPSBwb2ludEFycmF5LmRhdGFcbiAgdmFyIGFycmF5RGF0YSA9IGluZGV4ZWQuZGF0YVxuICB2YXIgbDJfbiA9IGJpdHMubG9nMihiaXRzLm5leHRQb3cyKG4pKVxuXG4gIHZhciBzZWxfY21wID0gbmRzZWxlY3QuY29tcGlsZShpbmRleGVkLm9yZGVyLCB0cnVlLCBpbmRleGVkLmR0eXBlKVxuXG4gIC8vV2FsayB0cmVlIGluIGxldmVsIG9yZGVyXG4gIHZhciB0b1Zpc2l0ID0gW2luZGV4ZWRdXG4gIHdoaWxlKHBvaW50ZXIgPCBuKSB7XG4gICAgdmFyIGhlYWQgPSB0b1Zpc2l0LnNoaWZ0KClcbiAgICB2YXIgYXJyYXkgPSBoZWFkXG4gICAgdmFyIG5uID0gYXJyYXkuc2hhcGVbMF18MFxuICAgIFxuICAgIC8vRmluZCBtZWRpYW5cbiAgICBpZihubiA+IDEpIHtcbiAgICAgIHZhciBrID0gYml0cy5sb2cyKHBvaW50ZXIrMSklZFxuICAgICAgdmFyIG1lZGlhblxuICAgICAgdmFyIG5fMiA9IGlub3JkZXJUcmVlLnJvb3Qobm4pXG4gICAgICBtZWRpYW4gPSBzZWxfY21wKGFycmF5LCBuXzIsIGZ1bmN0aW9uKGEsYikge1xuICAgICAgICByZXR1cm4gYS5nZXQoaykgLSBiLmdldChrKVxuICAgICAgfSlcblxuICAgICAgLy9Db3B5IGludG8gbmV3IGFycmF5XG4gICAgICB2YXIgcHB0ciA9IHBvaW50QXJyYXkuaW5kZXgocG9pbnRlciwgMClcbiAgICAgIHZhciBtcHRyID0gbWVkaWFuLm9mZnNldFxuICAgICAgZm9yKHZhciBpPTA7IGk8ZDsgKytpKSB7XG4gICAgICAgIHBvaW50RGF0YVtwcHRyKytdID0gYXJyYXlEYXRhW21wdHIrK11cbiAgICAgIH1cbiAgICAgIGluZGV4QXJyYXlbcG9pbnRlcl0gPSBhcnJheURhdGFbbXB0cl1cbiAgICAgIHBvaW50ZXIgKz0gMVxuXG4gICAgICAvL1F1ZXVlIG5ldyBpdGVtc1xuICAgICAgdG9WaXNpdC5wdXNoKGFycmF5LmhpKG5fMikpXG4gICAgICBpZihubiA+IDIpIHtcbiAgICAgICAgdG9WaXNpdC5wdXNoKGFycmF5LmxvKG5fMisxKSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9Db3B5IGludG8gbmV3IGFycmF5XG4gICAgICB2YXIgbXB0ciA9IGFycmF5Lm9mZnNldFxuICAgICAgdmFyIHBwdHIgPSBwb2ludEFycmF5LmluZGV4KHBvaW50ZXIsIDApXG4gICAgICBmb3IodmFyIGk9MDsgaTxkOyArK2kpIHtcbiAgICAgICAgcG9pbnREYXRhW3BwdHIraV0gPSBhcnJheURhdGFbbXB0cisrXVxuICAgICAgfVxuICAgICAgaW5kZXhBcnJheVtwb2ludGVyXSA9IGFycmF5RGF0YVttcHRyXVxuICAgICAgcG9pbnRlciArPSAxXG4gICAgfVxuICB9XG5cbiAgLy9SZWxlYXNlIGluZGV4ZWRcbiAgcG9vbC5mcmVlKGluZGV4ZWQuZGF0YSlcblxuICByZXR1cm4gbmV3IEtEVHJlZShwb2ludEFycmF5LCBpbmRleEFycmF5LCBuLCBkKVxufVxuXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUtEVHJlZShkYXRhKSB7XG4gIHZhciBwb2ludHMgPSBkYXRhLnBcbiAgdmFyIGlkcyA9IGRhdGEuaVxuICBpZihwb2ludHMpIHtcbiAgICB2YXIgbmQgPSBwb2ludHMubGVuZ3RoXG4gICAgdmFyIHBvaW50QXJyYXkgPSBwb29sLm1hbGxvY0Zsb2F0NjQobmQpXG4gICAgZm9yKHZhciBpPTA7IGk8bmQ7ICsraSkge1xuICAgICAgcG9pbnRBcnJheVtpXSA9IHBvaW50c1tpXVxuICAgIH1cbiAgICB2YXIgbiA9IGlkcy5sZW5ndGhcbiAgICB2YXIgaWRBcnJheSA9IHBvb2wubWFsbG9jSW50MzIobilcbiAgICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICAgIGlkQXJyYXlbaV0gPSBpZHNbaV1cbiAgICB9XG4gICAgdmFyIGQgPSAobmQvbil8MFxuICAgIHJldHVybiBuZXcgS0RUcmVlKFxuICAgICAgbmRhcnJheShwb2ludEFycmF5LCBbbixkXSksXG4gICAgICBpZEFycmF5LFxuICAgICAgbixcbiAgICAgIGQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLRFRyZWUobnVsbCwgbnVsbCwgMCwgZGF0YS5kKVxuICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBLRFRIZWFwXG5cbnZhciBwb29sID0gcmVxdWlyZShcInR5cGVkYXJyYXktcG9vbFwiKVxuXG5mdW5jdGlvbiBoZWFwUGFyZW50KGkpIHtcbiAgaWYoaSAmIDEpIHtcbiAgICByZXR1cm4gKGkgLSAxKSA+PiAxXG4gIH1cbiAgcmV0dXJuIChpID4+IDEpIC0gMVxufVxuXG5mdW5jdGlvbiBLRFRIZWFwKG4sIGQpIHtcbiAgdGhpcy5jb3VudCA9IDBcbiAgdGhpcy5kYXRhU2l6ZSA9IGRcbiAgdGhpcy5pbmRleCA9IHBvb2wubWFsbG9jSW50MzIobilcbiAgdGhpcy5kYXRhID0gcG9vbC5tYWxsb2NGbG9hdDY0KG4qZClcbn1cblxudmFyIHByb3RvID0gS0RUSGVhcC5wcm90b3R5cGVcblxucHJvdG8uaGVhcFN3YXAgPSBmdW5jdGlvbihfaSxfaikge1xuICB2YXIgZGF0YSA9IHRoaXMuZGF0YVxuICB2YXIgaW5kZXggPSB0aGlzLmluZGV4XG4gIHZhciBkID0gdGhpcy5kYXRhU2l6ZVxuICB2YXIgdG1wID0gaW5kZXhbX2ldXG4gIGluZGV4W19pXSA9IGluZGV4W19qXVxuICBpbmRleFtfal0gPSB0bXBcbiAgdmFyIGFwdHIgPSBkKl9pXG4gIHZhciBicHRyID0gZCpfalxuICBmb3IodmFyIF9rPTA7IF9rPGQ7ICsrX2spIHtcbiAgICB2YXIgdDIgPSBkYXRhW2FwdHJdXG4gICAgZGF0YVthcHRyXSA9IGRhdGFbYnB0cl1cbiAgICBkYXRhW2JwdHJdID0gdDJcbiAgICBhcHRyICs9IDFcbiAgICBicHRyICs9IDFcbiAgfVxufVxuXG5wcm90by5oZWFwVXAgPSBmdW5jdGlvbihpKSB7XG4gIHZhciBkID0gdGhpcy5kYXRhU2l6ZVxuICB2YXIgaW5kZXggPSB0aGlzLmluZGV4XG4gIHZhciBkYXRhID0gdGhpcy5kYXRhXG4gIHZhciB3ID0gZGF0YVtkKmldXG4gIHdoaWxlKGk+MCkge1xuICAgIHZhciBwYXJlbnQgPSBoZWFwUGFyZW50KGkpXG4gICAgaWYocGFyZW50ID49IDApIHtcbiAgICAgIHZhciBwdyA9IGRhdGFbZCpwYXJlbnRdXG4gICAgICBpZih3IDwgcHcpIHtcbiAgICAgICAgdGhpcy5oZWFwU3dhcChpLCBwYXJlbnQpXG4gICAgICAgIGkgPSBwYXJlbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWtcbiAgfVxufVxuXG5wcm90by5oZWFwRG93biA9IGZ1bmN0aW9uKGkpIHtcbiAgdmFyIGQgPSB0aGlzLmRhdGFTaXplXG4gIHZhciBpbmRleCA9IHRoaXMuaW5kZXhcbiAgdmFyIGRhdGEgPSB0aGlzLmRhdGFcbiAgdmFyIGNvdW50ID0gdGhpcy5jb3VudFxuICB2YXIgdyA9IGRhdGFbZCppXVxuICB3aGlsZSh0cnVlKSB7XG4gICAgdmFyIHR3ID0gd1xuICAgIHZhciBsZWZ0ICA9IDIqaSArIDFcbiAgICB2YXIgcmlnaHQgPSAyKihpICsgMSlcbiAgICB2YXIgbmV4dCA9IGlcbiAgICBpZihsZWZ0IDwgY291bnQpIHtcbiAgICAgIHZhciBsdyA9IGRhdGFbZCpsZWZ0XVxuICAgICAgaWYobHcgPCB0dykge1xuICAgICAgICBuZXh0ID0gbGVmdFxuICAgICAgICB0dyA9IGx3XG4gICAgICB9XG4gICAgfVxuICAgIGlmKHJpZ2h0IDwgY291bnQpIHtcbiAgICAgIHZhciBydyA9IGRhdGFbZCpyaWdodF1cbiAgICAgIGlmKHJ3IDwgdHcpIHtcbiAgICAgICAgbmV4dCA9IHJpZ2h0XG4gICAgICB9XG4gICAgfVxuICAgIGlmKG5leHQgPT09IGkpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIHRoaXMuaGVhcFN3YXAoaSwgbmV4dClcbiAgICBpID0gbmV4dCAgICAgIFxuICB9XG59XG5cbi8vQ2xlYXIgaXRlbSBmcm9tIHRvcCBvZiBoZWFwXG5wcm90by5wb3AgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jb3VudCAtPSAxXG4gIHRoaXMuaGVhcFN3YXAoMCwgdGhpcy5jb3VudClcbiAgdGhpcy5oZWFwRG93bigwKVxufVxuXG4vL0Fzc3VtZSBvYmplY3QgYWxyZWFkeSB3cml0dGVuIHRvIGRhdGFcbnByb3RvLnB1c2ggPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5oZWFwVXAodGhpcy5jb3VudClcbiAgdGhpcy5jb3VudCArPSAxXG59XG5cbnByb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcbiAgcG9vbC5mcmVlSW50MzIodGhpcy5pbmRleClcbiAgcG9vbC5mcmVlRmxvYXQ2NCh0aGlzLmRhdGEpXG59IiwiLyoqXG4gKiBCaXQgdHdpZGRsaW5nIGhhY2tzIGZvciBKYXZhU2NyaXB0LlxuICpcbiAqIEF1dGhvcjogTWlrb2xhIEx5c2Vua29cbiAqXG4gKiBQb3J0ZWQgZnJvbSBTdGFuZm9yZCBiaXQgdHdpZGRsaW5nIGhhY2sgbGlicmFyeTpcbiAqICAgIGh0dHA6Ly9ncmFwaGljcy5zdGFuZm9yZC5lZHUvfnNlYW5kZXIvYml0aGFja3MuaHRtbFxuICovXG5cblwidXNlIHN0cmljdFwiOyBcInVzZSByZXN0cmljdFwiO1xuXG4vL051bWJlciBvZiBiaXRzIGluIGFuIGludGVnZXJcbnZhciBJTlRfQklUUyA9IDMyO1xuXG4vL0NvbnN0YW50c1xuZXhwb3J0cy5JTlRfQklUUyAgPSBJTlRfQklUUztcbmV4cG9ydHMuSU5UX01BWCAgID0gIDB4N2ZmZmZmZmY7XG5leHBvcnRzLklOVF9NSU4gICA9IC0xPDwoSU5UX0JJVFMtMSk7XG5cbi8vUmV0dXJucyAtMSwgMCwgKzEgZGVwZW5kaW5nIG9uIHNpZ24gb2YgeFxuZXhwb3J0cy5zaWduID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gKHYgPiAwKSAtICh2IDwgMCk7XG59XG5cbi8vQ29tcHV0ZXMgYWJzb2x1dGUgdmFsdWUgb2YgaW50ZWdlclxuZXhwb3J0cy5hYnMgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBtYXNrID0gdiA+PiAoSU5UX0JJVFMtMSk7XG4gIHJldHVybiAodiBeIG1hc2spIC0gbWFzaztcbn1cblxuLy9Db21wdXRlcyBtaW5pbXVtIG9mIGludGVnZXJzIHggYW5kIHlcbmV4cG9ydHMubWluID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4geSBeICgoeCBeIHkpICYgLSh4IDwgeSkpO1xufVxuXG4vL0NvbXB1dGVzIG1heGltdW0gb2YgaW50ZWdlcnMgeCBhbmQgeVxuZXhwb3J0cy5tYXggPSBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiB4IF4gKCh4IF4geSkgJiAtKHggPCB5KSk7XG59XG5cbi8vQ2hlY2tzIGlmIGEgbnVtYmVyIGlzIGEgcG93ZXIgb2YgdHdvXG5leHBvcnRzLmlzUG93MiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICEodiAmICh2LTEpKSAmJiAoISF2KTtcbn1cblxuLy9Db21wdXRlcyBsb2cgYmFzZSAyIG9mIHZcbmV4cG9ydHMubG9nMiA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHIsIHNoaWZ0O1xuICByID0gICAgICh2ID4gMHhGRkZGKSA8PCA0OyB2ID4+Pj0gcjtcbiAgc2hpZnQgPSAodiA+IDB4RkYgICkgPDwgMzsgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xuICBzaGlmdCA9ICh2ID4gMHhGICAgKSA8PCAyOyB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnQ7XG4gIHNoaWZ0ID0gKHYgPiAweDMgICApIDw8IDE7IHYgPj4+PSBzaGlmdDsgciB8PSBzaGlmdDtcbiAgcmV0dXJuIHIgfCAodiA+PiAxKTtcbn1cblxuLy9Db21wdXRlcyBsb2cgYmFzZSAxMCBvZiB2XG5leHBvcnRzLmxvZzEwID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gICh2ID49IDEwMDAwMDAwMDApID8gOSA6ICh2ID49IDEwMDAwMDAwMCkgPyA4IDogKHYgPj0gMTAwMDAwMDApID8gNyA6XG4gICAgICAgICAgKHYgPj0gMTAwMDAwMCkgPyA2IDogKHYgPj0gMTAwMDAwKSA/IDUgOiAodiA+PSAxMDAwMCkgPyA0IDpcbiAgICAgICAgICAodiA+PSAxMDAwKSA/IDMgOiAodiA+PSAxMDApID8gMiA6ICh2ID49IDEwKSA/IDEgOiAwO1xufVxuXG4vL0NvdW50cyBudW1iZXIgb2YgYml0c1xuZXhwb3J0cy5wb3BDb3VudCA9IGZ1bmN0aW9uKHYpIHtcbiAgdiA9IHYgLSAoKHYgPj4+IDEpICYgMHg1NTU1NTU1NSk7XG4gIHYgPSAodiAmIDB4MzMzMzMzMzMpICsgKCh2ID4+PiAyKSAmIDB4MzMzMzMzMzMpO1xuICByZXR1cm4gKCh2ICsgKHYgPj4+IDQpICYgMHhGMEYwRjBGKSAqIDB4MTAxMDEwMSkgPj4+IDI0O1xufVxuXG4vL0NvdW50cyBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3NcbmZ1bmN0aW9uIGNvdW50VHJhaWxpbmdaZXJvcyh2KSB7XG4gIHZhciBjID0gMzI7XG4gIHYgJj0gLXY7XG4gIGlmICh2KSBjLS07XG4gIGlmICh2ICYgMHgwMDAwRkZGRikgYyAtPSAxNjtcbiAgaWYgKHYgJiAweDAwRkYwMEZGKSBjIC09IDg7XG4gIGlmICh2ICYgMHgwRjBGMEYwRikgYyAtPSA0O1xuICBpZiAodiAmIDB4MzMzMzMzMzMpIGMgLT0gMjtcbiAgaWYgKHYgJiAweDU1NTU1NTU1KSBjIC09IDE7XG4gIHJldHVybiBjO1xufVxuZXhwb3J0cy5jb3VudFRyYWlsaW5nWmVyb3MgPSBjb3VudFRyYWlsaW5nWmVyb3M7XG5cbi8vUm91bmRzIHRvIG5leHQgcG93ZXIgb2YgMlxuZXhwb3J0cy5uZXh0UG93MiA9IGZ1bmN0aW9uKHYpIHtcbiAgdiArPSB2ID09PSAwO1xuICAtLXY7XG4gIHYgfD0gdiA+Pj4gMTtcbiAgdiB8PSB2ID4+PiAyO1xuICB2IHw9IHYgPj4+IDQ7XG4gIHYgfD0gdiA+Pj4gODtcbiAgdiB8PSB2ID4+PiAxNjtcbiAgcmV0dXJuIHYgKyAxO1xufVxuXG4vL1JvdW5kcyBkb3duIHRvIHByZXZpb3VzIHBvd2VyIG9mIDJcbmV4cG9ydHMucHJldlBvdzIgPSBmdW5jdGlvbih2KSB7XG4gIHYgfD0gdiA+Pj4gMTtcbiAgdiB8PSB2ID4+PiAyO1xuICB2IHw9IHYgPj4+IDQ7XG4gIHYgfD0gdiA+Pj4gODtcbiAgdiB8PSB2ID4+PiAxNjtcbiAgcmV0dXJuIHYgLSAodj4+PjEpO1xufVxuXG4vL0NvbXB1dGVzIHBhcml0eSBvZiB3b3JkXG5leHBvcnRzLnBhcml0eSA9IGZ1bmN0aW9uKHYpIHtcbiAgdiBePSB2ID4+PiAxNjtcbiAgdiBePSB2ID4+PiA4O1xuICB2IF49IHYgPj4+IDQ7XG4gIHYgJj0gMHhmO1xuICByZXR1cm4gKDB4Njk5NiA+Pj4gdikgJiAxO1xufVxuXG52YXIgUkVWRVJTRV9UQUJMRSA9IG5ldyBBcnJheSgyNTYpO1xuXG4oZnVuY3Rpb24odGFiKSB7XG4gIGZvcih2YXIgaT0wOyBpPDI1NjsgKytpKSB7XG4gICAgdmFyIHYgPSBpLCByID0gaSwgcyA9IDc7XG4gICAgZm9yICh2ID4+Pj0gMTsgdjsgdiA+Pj49IDEpIHtcbiAgICAgIHIgPDw9IDE7XG4gICAgICByIHw9IHYgJiAxO1xuICAgICAgLS1zO1xuICAgIH1cbiAgICB0YWJbaV0gPSAociA8PCBzKSAmIDB4ZmY7XG4gIH1cbn0pKFJFVkVSU0VfVEFCTEUpO1xuXG4vL1JldmVyc2UgYml0cyBpbiBhIDMyIGJpdCB3b3JkXG5leHBvcnRzLnJldmVyc2UgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAgKFJFVkVSU0VfVEFCTEVbIHYgICAgICAgICAmIDB4ZmZdIDw8IDI0KSB8XG4gICAgICAgICAgKFJFVkVSU0VfVEFCTEVbKHYgPj4+IDgpICAmIDB4ZmZdIDw8IDE2KSB8XG4gICAgICAgICAgKFJFVkVSU0VfVEFCTEVbKHYgPj4+IDE2KSAmIDB4ZmZdIDw8IDgpICB8XG4gICAgICAgICAgIFJFVkVSU0VfVEFCTEVbKHYgPj4+IDI0KSAmIDB4ZmZdO1xufVxuXG4vL0ludGVybGVhdmUgYml0cyBvZiAyIGNvb3JkaW5hdGVzIHdpdGggMTYgYml0cy4gIFVzZWZ1bCBmb3IgZmFzdCBxdWFkdHJlZSBjb2Rlc1xuZXhwb3J0cy5pbnRlcmxlYXZlMiA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgeCAmPSAweEZGRkY7XG4gIHggPSAoeCB8ICh4IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gIHggPSAoeCB8ICh4IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gIHggPSAoeCB8ICh4IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gIHggPSAoeCB8ICh4IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgeSAmPSAweEZGRkY7XG4gIHkgPSAoeSB8ICh5IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gIHkgPSAoeSB8ICh5IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gIHkgPSAoeSB8ICh5IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gIHkgPSAoeSB8ICh5IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgcmV0dXJuIHggfCAoeSA8PCAxKTtcbn1cblxuLy9FeHRyYWN0cyB0aGUgbnRoIGludGVybGVhdmVkIGNvbXBvbmVudFxuZXhwb3J0cy5kZWludGVybGVhdmUyID0gZnVuY3Rpb24odiwgbikge1xuICB2ID0gKHYgPj4+IG4pICYgMHg1NTU1NTU1NTtcbiAgdiA9ICh2IHwgKHYgPj4+IDEpKSAgJiAweDMzMzMzMzMzO1xuICB2ID0gKHYgfCAodiA+Pj4gMikpICAmIDB4MEYwRjBGMEY7XG4gIHYgPSAodiB8ICh2ID4+PiA0KSkgICYgMHgwMEZGMDBGRjtcbiAgdiA9ICh2IHwgKHYgPj4+IDE2KSkgJiAweDAwMEZGRkY7XG4gIHJldHVybiAodiA8PCAxNikgPj4gMTY7XG59XG5cblxuLy9JbnRlcmxlYXZlIGJpdHMgb2YgMyBjb29yZGluYXRlcywgZWFjaCB3aXRoIDEwIGJpdHMuICBVc2VmdWwgZm9yIGZhc3Qgb2N0cmVlIGNvZGVzXG5leHBvcnRzLmludGVybGVhdmUzID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICB4ICY9IDB4M0ZGO1xuICB4ICA9ICh4IHwgKHg8PDE2KSkgJiA0Mjc4MTkwMzM1O1xuICB4ICA9ICh4IHwgKHg8PDgpKSAgJiAyNTE3MTk2OTU7XG4gIHggID0gKHggfCAoeDw8NCkpICAmIDMyNzIzNTYwMzU7XG4gIHggID0gKHggfCAoeDw8MikpICAmIDEyMjcxMzM1MTM7XG5cbiAgeSAmPSAweDNGRjtcbiAgeSAgPSAoeSB8ICh5PDwxNikpICYgNDI3ODE5MDMzNTtcbiAgeSAgPSAoeSB8ICh5PDw4KSkgICYgMjUxNzE5Njk1O1xuICB5ICA9ICh5IHwgKHk8PDQpKSAgJiAzMjcyMzU2MDM1O1xuICB5ICA9ICh5IHwgKHk8PDIpKSAgJiAxMjI3MTMzNTEzO1xuICB4IHw9ICh5IDw8IDEpO1xuICBcbiAgeiAmPSAweDNGRjtcbiAgeiAgPSAoeiB8ICh6PDwxNikpICYgNDI3ODE5MDMzNTtcbiAgeiAgPSAoeiB8ICh6PDw4KSkgICYgMjUxNzE5Njk1O1xuICB6ICA9ICh6IHwgKHo8PDQpKSAgJiAzMjcyMzU2MDM1O1xuICB6ICA9ICh6IHwgKHo8PDIpKSAgJiAxMjI3MTMzNTEzO1xuICBcbiAgcmV0dXJuIHggfCAoeiA8PCAyKTtcbn1cblxuLy9FeHRyYWN0cyBudGggaW50ZXJsZWF2ZWQgY29tcG9uZW50IG9mIGEgMy10dXBsZVxuZXhwb3J0cy5kZWludGVybGVhdmUzID0gZnVuY3Rpb24odiwgbikge1xuICB2ID0gKHYgPj4+IG4pICAgICAgICYgMTIyNzEzMzUxMztcbiAgdiA9ICh2IHwgKHY+Pj4yKSkgICAmIDMyNzIzNTYwMzU7XG4gIHYgPSAodiB8ICh2Pj4+NCkpICAgJiAyNTE3MTk2OTU7XG4gIHYgPSAodiB8ICh2Pj4+OCkpICAgJiA0Mjc4MTkwMzM1O1xuICB2ID0gKHYgfCAodj4+PjE2KSkgICYgMHgzRkY7XG4gIHJldHVybiAodjw8MjIpPj4yMjtcbn1cblxuLy9Db21wdXRlcyBuZXh0IGNvbWJpbmF0aW9uIGluIGNvbGV4aWNvZ3JhcGhpYyBvcmRlciAodGhpcyBpcyBtaXN0YWtlbmx5IGNhbGxlZCBuZXh0UGVybXV0YXRpb24gb24gdGhlIGJpdCB0d2lkZGxpbmcgaGFja3MgcGFnZSlcbmV4cG9ydHMubmV4dENvbWJpbmF0aW9uID0gZnVuY3Rpb24odikge1xuICB2YXIgdCA9IHYgfCAodiAtIDEpO1xuICByZXR1cm4gKHQgKyAxKSB8ICgoKH50ICYgLX50KSAtIDEpID4+PiAoY291bnRUcmFpbGluZ1plcm9zKHYpICsgMSkpO1xufVxuXG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgYml0cyA9IHJlcXVpcmUoXCJiaXQtdHdpZGRsZVwiKVxuXG5mdW5jdGlvbiByb290SW5vcmRlcihuKSB7XG4gIHZhciBwdHJlZSA9IChiaXRzLm5leHRQb3cyKG4rMSk+Pj4xKSAtIDFcbiAgdmFyIGYgICAgID0gbiAtIHB0cmVlXG4gIGlmKGJpdHMubmV4dFBvdzIoZiktMSA+PSBwdHJlZSkge1xuICAgIHJldHVybiBwdHJlZVxuICB9XG4gIHJldHVybiAocHRyZWU+Pj4xKStmXG59XG5leHBvcnRzLnJvb3QgPSByb290SW5vcmRlclxuXG5mdW5jdGlvbiBiZWdpbklub3JkZXIobikge1xuICByZXR1cm4gMFxufVxuZXhwb3J0cy5iZWdpbiA9IGJlZ2luSW5vcmRlclxuXG5mdW5jdGlvbiBlbmRJbm9yZGVyKG4pIHtcbiAgcmV0dXJuIG4tMVxufVxuZXhwb3J0cy5lbmQgPSBlbmRJbm9yZGVyXG5cblxuLy9UaGlzIGlzIHJlYWxseSBob3JyaWJsZSBiZWNhdXNlIG4gaXMgbm90IG5lY2Vzc2FyaWx5IGEgcG93ZXIgb2YgMlxuLy8gSWYgaXQgd2FzLCB3ZSBjb3VsZCBqdXN0IGRvOlxuLy9cbi8vICAgIGhlaWdodCA9IGJpdHMuY291bnRUcmFpbGluZ1plcm9zKH54KVxuLy9cbi8vIEluc3RlYWQsIHdlIGp1c3QgYmluYXJ5IHNlYXJjaCBiZWNhdXNlIGRvaW5nIHRoZSByaWdodCB0aGluZyBoZXJlIGlzIHdheSB0b28gY29tcGxpY2F0ZWQuXG5mdW5jdGlvbiBoZWlnaHRJbm9yZGVyKG4sIHgpIHtcbiAgaWYobiA8PSAwKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICB2YXIgciA9IHJvb3RJbm9yZGVyKG4pXG4gIGlmKHggPiByKSB7XG4gICAgcmV0dXJuIGhlaWdodElub3JkZXIobi1yLTEsIHgtci0xKVxuICB9IGVsc2UgaWYoeCA9PT0gcikge1xuICAgIHJldHVybiBiaXRzLmxvZzIobilcbiAgfVxuICByZXR1cm4gaGVpZ2h0SW5vcmRlcihyLCB4KVxufVxuZXhwb3J0cy5oZWlnaHQgPSBoZWlnaHRJbm9yZGVyXG5cbmZ1bmN0aW9uIHByZXZJbm9yZGVyKG4sIHgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KHgtMSwwKVxufVxuZXhwb3J0cy5wcmV2ID0gcHJldklub3JkZXJcblxuZnVuY3Rpb24gbmV4dElub3JkZXIobiwgeCkge1xuICByZXR1cm4gTWF0aC5taW4oeCsxLG4tMSlcbn1cbmV4cG9ydHMubmV4dCA9IG5leHRJbm9yZGVyXG5cblxuLy9UaGUgdmVyc2lvbiBmb3IgbiA9ICgxPDxrKS0xOlxuLy9cbi8vICBwYXJlbnQgPSAoeCAmIH4oMTw8KGgrMSkpKSArICgxPDxoKVxuLy9cbmZ1bmN0aW9uIHBhcmVudElub3JkZXIobiwgeCkge1xuICBpZihuIDw9IDApIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICB2YXIgciA9IHJvb3RJbm9yZGVyKG4pXG4gIGlmKHggPiByKSB7XG4gICAgdmFyIHEgPSBwYXJlbnRJbm9yZGVyKG4tci0xLCB4LXItMSlcbiAgICBpZihxIDwgMCkge1xuICAgICAgcmV0dXJuIHJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHEgKyByICsgMVxuICAgIH1cbiAgfSBlbHNlIGlmKHggPT09IHIpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICB2YXIgcSA9ICBwYXJlbnRJbm9yZGVyKHIsIHgpXG4gIGlmKHEgPCAwKSB7XG4gICAgcmV0dXJuIHJcbiAgfVxuICByZXR1cm4gcVxufVxuZXhwb3J0cy5wYXJlbnQgPSBwYXJlbnRJbm9yZGVyXG5cblxuLy9BZ2Fpbiwgd2UgZ2V0IHNjcmV3ZWQgYmVjYXVzZSBuIGlzIG5vdCBhIHBvd2VyIG9mIHR3byAtMS4gIElmIGl0IHdhcywgd2UgY291bGQgZG86XG4vL1xuLy8gICAgbGVmdCA9IHggLSAoMSA8PCAoaC0xKSApXG4vL1xuLy8gV2hlcmUgaCBpcyB0aGUgaGVpZ2h0IG9mIHRoZSBub2RlXG4vL1xuZnVuY3Rpb24gbGVmdElub3JkZXIobiwgeCkge1xuICBpZihuIDw9IDApIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIHZhciByID0gcm9vdElub3JkZXIobilcbiAgaWYoeCA+IHIpIHtcbiAgICByZXR1cm4gbGVmdElub3JkZXIobi1yLTEsIHgtci0xKSArIHIgKyAxXG4gIH0gZWxzZSBpZih4ID09PSByKSB7XG4gICAgcmV0dXJuIHJvb3RJbm9yZGVyKHgpXG4gIH1cbiAgcmV0dXJuIGxlZnRJbm9yZGVyKHIsIHgpXG5cbn1cbmV4cG9ydHMubGVmdCA9IGxlZnRJbm9yZGVyXG5cbi8vZm9yIHBvd2VyIG9mIHR3byBtaW51cyBvbmU6XG4vL1xuLy8gICAgcmlnaHQgPSB4ICsgKDE8PChoLTEpKVxuLy9cbmZ1bmN0aW9uIHJpZ2h0SW5vcmRlcihuLCB4KSB7XG4gIGlmKG4gPD0gMCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgdmFyIHIgPSByb290SW5vcmRlcihuKVxuICBpZih4ID4gcikge1xuICAgIHJldHVybiByaWdodElub3JkZXIobi1yLTEsIHgtci0xKSArIHIgKyAxXG4gIH0gZWxzZSBpZih4ID09PSByKSB7XG4gICAgcmV0dXJuIHJvb3RJbm9yZGVyKG4tci0xKSArIHIgKyAxXG4gIH1cbiAgcmV0dXJuIHJpZ2h0SW5vcmRlcihyLCB4KVxufVxuZXhwb3J0cy5yaWdodCA9IHJpZ2h0SW5vcmRlclxuXG5cbmZ1bmN0aW9uIGxlYWZJbm9yZGVyKG4sIHgpIHtcbiAgcmV0dXJuIGhlaWdodElub3JkZXIobiwgeCkgPT09IDBcbn1cbmV4cG9ydHMubGVhZiA9IGxlYWZJbm9yZGVyXG5cblxuZnVuY3Rpb24gbG9Jbm9yZGVyKG4sIHgpIHtcbiAgbiB8PSAwXG4gIHggfD0gMFxuICB2YXIgbCA9IDBcbiAgd2hpbGUobiA+IDEpIHtcbiAgICB2YXIgciA9IHJvb3RJbm9yZGVyKG4pXG4gICAgaWYoeCA+IHIpIHtcbiAgICAgIGwgKz0gciArIDFcbiAgICAgIG4gLT0gciArIDFcbiAgICAgIHggLT0gciArIDFcbiAgICB9IGVsc2UgaWYoeCA9PT0gcikge1xuICAgICAgYnJlYWtcbiAgICB9IGVsc2Uge1xuICAgICAgbiA9IHJcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxcbn1cbmV4cG9ydHMubG8gPSBsb0lub3JkZXJcblxuZnVuY3Rpb24gaGlJbm9yZGVyKG4sIHgpIHtcbiAgbiB8PSAwXG4gIHggfD0gMFxuICB2YXIgbCA9IDBcbiAgd2hpbGUobiA+IDEpIHtcbiAgICB2YXIgciA9IHJvb3RJbm9yZGVyKG4pXG4gICAgaWYoeCA+IHIpIHtcbiAgICAgIGwgKz0gciArIDFcbiAgICAgIG4gLT0gciArIDFcbiAgICAgIHggLT0gciArIDFcbiAgICB9IGVsc2UgaWYoeCA9PT0gcikge1xuICAgICAgbCArPSBuLTFcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSByXG4gICAgfVxuICB9XG4gIHJldHVybiBsXG59XG5leHBvcnRzLmhpID0gaGlJbm9yZGVyXG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgY29tcGlsZSA9IHJlcXVpcmUoXCJjd2lzZS1jb21waWxlclwiKVxuXG52YXIgRW1wdHlQcm9jID0ge1xuICBib2R5OiBcIlwiLFxuICBhcmdzOiBbXSxcbiAgdGhpc1ZhcnM6IFtdLFxuICBsb2NhbFZhcnM6IFtdXG59XG5cbmZ1bmN0aW9uIGZpeHVwKHgpIHtcbiAgaWYoIXgpIHtcbiAgICByZXR1cm4gRW1wdHlQcm9jXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8eC5hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGEgPSB4LmFyZ3NbaV1cbiAgICBpZihpID09PSAwKSB7XG4gICAgICB4LmFyZ3NbaV0gPSB7bmFtZTogYSwgbHZhbHVlOnRydWUsIHJ2YWx1ZTogISF4LnJ2YWx1ZSwgY291bnQ6eC5jb3VudHx8MSB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHguYXJnc1tpXSA9IHtuYW1lOiBhLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDogMX1cbiAgICB9XG4gIH1cbiAgaWYoIXgudGhpc1ZhcnMpIHtcbiAgICB4LnRoaXNWYXJzID0gW11cbiAgfVxuICBpZigheC5sb2NhbFZhcnMpIHtcbiAgICB4LmxvY2FsVmFycyA9IFtdXG4gIH1cbiAgcmV0dXJuIHhcbn1cblxuZnVuY3Rpb24gcGNvbXBpbGUodXNlcl9hcmdzKSB7XG4gIHJldHVybiBjb21waWxlKHtcbiAgICBhcmdzOiAgICAgdXNlcl9hcmdzLmFyZ3MsXG4gICAgcHJlOiAgICAgIGZpeHVwKHVzZXJfYXJncy5wcmUpLFxuICAgIGJvZHk6ICAgICBmaXh1cCh1c2VyX2FyZ3MuYm9keSksXG4gICAgcG9zdDogICAgIGZpeHVwKHVzZXJfYXJncy5wcm9jKSxcbiAgICBmdW5jTmFtZTogdXNlcl9hcmdzLmZ1bmNOYW1lXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG1ha2VPcCh1c2VyX2FyZ3MpIHtcbiAgdmFyIGFyZ3MgPSBbXVxuICBmb3IodmFyIGk9MDsgaTx1c2VyX2FyZ3MuYXJncy5sZW5ndGg7ICsraSkge1xuICAgIGFyZ3MucHVzaChcImFcIitpKVxuICB9XG4gIHZhciB3cmFwcGVyID0gbmV3IEZ1bmN0aW9uKFwiUFwiLCBbXG4gICAgXCJyZXR1cm4gZnVuY3Rpb24gXCIsIHVzZXJfYXJncy5mdW5jTmFtZSwgXCJfbmRhcnJheW9wcyhcIiwgYXJncy5qb2luKFwiLFwiKSwgXCIpIHtQKFwiLCBhcmdzLmpvaW4oXCIsXCIpLCBcIik7cmV0dXJuIGEwfVwiXG4gIF0uam9pbihcIlwiKSlcbiAgcmV0dXJuIHdyYXBwZXIocGNvbXBpbGUodXNlcl9hcmdzKSlcbn1cblxudmFyIGFzc2lnbl9vcHMgPSB7XG4gIGFkZDogIFwiK1wiLFxuICBzdWI6ICBcIi1cIixcbiAgbXVsOiAgXCIqXCIsXG4gIGRpdjogIFwiL1wiLFxuICBtb2Q6ICBcIiVcIixcbiAgYmFuZDogXCImXCIsXG4gIGJvcjogIFwifFwiLFxuICBieG9yOiBcIl5cIixcbiAgbHNoaWZ0OiBcIjw8XCIsXG4gIHJzaGlmdDogXCI+PlwiLFxuICBycnNoaWZ0OiBcIj4+PlwiXG59XG47KGZ1bmN0aW9uKCl7XG4gIGZvcih2YXIgaWQgaW4gYXNzaWduX29wcykge1xuICAgIHZhciBvcCA9IGFzc2lnbl9vcHNbaWRdXG4gICAgZXhwb3J0c1tpZF0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIixcImFycmF5XCIsXCJhcnJheVwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIixcImNcIl0sXG4gICAgICAgICAgICAgYm9keTogXCJhPWJcIitvcCtcImNcIn0sXG4gICAgICBmdW5jTmFtZTogaWRcbiAgICB9KVxuICAgIGV4cG9ydHNbaWQrXCJlcVwiXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLFwiYXJyYXlcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCJdLFxuICAgICAgICAgICAgIGJvZHk6XCJhXCIrb3ArXCI9YlwifSxcbiAgICAgIHJ2YWx1ZTogdHJ1ZSxcbiAgICAgIGZ1bmNOYW1lOiBpZCtcImVxXCJcbiAgICB9KVxuICAgIGV4cG9ydHNbaWQrXCJzXCJdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsIFwiYXJyYXlcIiwgXCJzY2FsYXJcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCIsXCJzXCJdLFxuICAgICAgICAgICAgIGJvZHk6XCJhPWJcIitvcCtcInNcIn0sXG4gICAgICBmdW5jTmFtZTogaWQrXCJzXCJcbiAgICB9KVxuICAgIGV4cG9ydHNbaWQrXCJzZXFcIl0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIixcInNjYWxhclwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIixcInNcIl0sXG4gICAgICAgICAgICAgYm9keTpcImFcIitvcCtcIj1zXCJ9LFxuICAgICAgcnZhbHVlOiB0cnVlLFxuICAgICAgZnVuY05hbWU6IGlkK1wic2VxXCJcbiAgICB9KVxuICB9XG59KSgpO1xuXG52YXIgdW5hcnlfb3BzID0ge1xuICBub3Q6IFwiIVwiLFxuICBibm90OiBcIn5cIixcbiAgbmVnOiBcIi1cIixcbiAgcmVjaXA6IFwiMS4wL1wiXG59XG47KGZ1bmN0aW9uKCl7XG4gIGZvcih2YXIgaWQgaW4gdW5hcnlfb3BzKSB7XG4gICAgdmFyIG9wID0gdW5hcnlfb3BzW2lkXVxuICAgIGV4cG9ydHNbaWRdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCJdLFxuICAgICAgICAgICAgIGJvZHk6XCJhPVwiK29wK1wiYlwifSxcbiAgICAgIGZ1bmNOYW1lOiBpZFxuICAgIH0pXG4gICAgZXhwb3J0c1tpZCtcImVxXCJdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiXSxcbiAgICAgICAgICAgICBib2R5OlwiYT1cIitvcCtcImFcIn0sXG4gICAgICBydmFsdWU6IHRydWUsXG4gICAgICBjb3VudDogMixcbiAgICAgIGZ1bmNOYW1lOiBpZCtcImVxXCJcbiAgICB9KVxuICB9XG59KSgpO1xuXG52YXIgYmluYXJ5X29wcyA9IHtcbiAgYW5kOiBcIiYmXCIsXG4gIG9yOiBcInx8XCIsXG4gIGVxOiBcIj09PVwiLFxuICBuZXE6IFwiIT09XCIsXG4gIGx0OiBcIjxcIixcbiAgZ3Q6IFwiPlwiLFxuICBsZXE6IFwiPD1cIixcbiAgZ2VxOiBcIj49XCJcbn1cbjsoZnVuY3Rpb24oKSB7XG4gIGZvcih2YXIgaWQgaW4gYmluYXJ5X29wcykge1xuICAgIHZhciBvcCA9IGJpbmFyeV9vcHNbaWRdXG4gICAgZXhwb3J0c1tpZF0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIixcImFycmF5XCIsXCJhcnJheVwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIiwgXCJiXCIsIFwiY1wiXSxcbiAgICAgICAgICAgICBib2R5OlwiYT1iXCIrb3ArXCJjXCJ9LFxuICAgICAgZnVuY05hbWU6IGlkXG4gICAgfSlcbiAgICBleHBvcnRzW2lkK1wic1wiXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLFwiYXJyYXlcIixcInNjYWxhclwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIiwgXCJiXCIsIFwic1wiXSxcbiAgICAgICAgICAgICBib2R5OlwiYT1iXCIrb3ArXCJzXCJ9LFxuICAgICAgZnVuY05hbWU6IGlkK1wic1wiXG4gICAgfSlcbiAgICBleHBvcnRzW2lkK1wiZXFcIl0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIiwgXCJiXCJdLFxuICAgICAgICAgICAgIGJvZHk6XCJhPWFcIitvcCtcImJcIn0sXG4gICAgICBydmFsdWU6dHJ1ZSxcbiAgICAgIGNvdW50OjIsXG4gICAgICBmdW5jTmFtZTogaWQrXCJlcVwiXG4gICAgfSlcbiAgICBleHBvcnRzW2lkK1wic2VxXCJdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsIFwic2NhbGFyXCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwic1wiXSxcbiAgICAgICAgICAgICBib2R5OlwiYT1hXCIrb3ArXCJzXCJ9LFxuICAgICAgcnZhbHVlOnRydWUsXG4gICAgICBjb3VudDoyLFxuICAgICAgZnVuY05hbWU6IGlkK1wic2VxXCJcbiAgICB9KVxuICB9XG59KSgpO1xuXG52YXIgbWF0aF91bmFyeSA9IFtcbiAgXCJhYnNcIixcbiAgXCJhY29zXCIsXG4gIFwiYXNpblwiLFxuICBcImF0YW5cIixcbiAgXCJjZWlsXCIsXG4gIFwiY29zXCIsXG4gIFwiZXhwXCIsXG4gIFwiZmxvb3JcIixcbiAgXCJsb2dcIixcbiAgXCJyb3VuZFwiLFxuICBcInNpblwiLFxuICBcInNxcnRcIixcbiAgXCJ0YW5cIlxuXVxuOyhmdW5jdGlvbigpIHtcbiAgZm9yKHZhciBpPTA7IGk8bWF0aF91bmFyeS5sZW5ndGg7ICsraSkge1xuICAgIHZhciBmID0gbWF0aF91bmFyeVtpXVxuICAgIGV4cG9ydHNbZl0gPSBtYWtlT3Aoe1xuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICAgICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiXSwgYm9keTpcImE9dGhpc19mKGIpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmXG4gICAgICAgICAgICAgICAgICB9KVxuICAgIGV4cG9ydHNbZitcImVxXCJdID0gbWFrZU9wKHtcbiAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXCJhcnJheVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczogW1wiYVwiXSwgYm9keTpcImE9dGhpc19mKGEpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICAgICAgcnZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiAyLFxuICAgICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wiZXFcIlxuICAgICAgICAgICAgICAgICAgICB9KVxuICB9XG59KSgpO1xuXG52YXIgbWF0aF9jb21tID0gW1xuICBcIm1heFwiLFxuICBcIm1pblwiLFxuICBcImF0YW4yXCIsXG4gIFwicG93XCJcbl1cbjsoZnVuY3Rpb24oKXtcbiAgZm9yKHZhciBpPTA7IGk8bWF0aF9jb21tLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGY9IG1hdGhfY29tbVtpXVxuICAgIGV4cG9ydHNbZl0gPSBtYWtlT3Aoe1xuICAgICAgICAgICAgICAgICAgYXJnczpbXCJhcnJheVwiLCBcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIixcImNcIl0sIGJvZHk6XCJhPXRoaXNfZihiLGMpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZlxuICAgICAgICAgICAgICAgIH0pXG4gICAgZXhwb3J0c1tmK1wic1wiXSA9IG1ha2VPcCh7XG4gICAgICAgICAgICAgICAgICBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIiwgXCJzY2FsYXJcIl0sXG4gICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIixcImNcIl0sIGJvZHk6XCJhPXRoaXNfZihiLGMpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZitcInNcIlxuICAgICAgICAgICAgICAgICAgfSlcbiAgICBleHBvcnRzW2YrXCJlcVwiXSA9IG1ha2VPcCh7IGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiXSwgYm9keTpcImE9dGhpc19mKGEsYilcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIHJ2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvdW50OiAyLFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJlcVwiXG4gICAgICAgICAgICAgICAgICB9KVxuICAgIGV4cG9ydHNbZitcInNlcVwiXSA9IG1ha2VPcCh7IGFyZ3M6W1wiYXJyYXlcIiwgXCJzY2FsYXJcIl0sXG4gICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIl0sIGJvZHk6XCJhPXRoaXNfZihhLGIpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBydmFsdWU6dHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvdW50OjIsXG4gICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZitcInNlcVwiXG4gICAgICAgICAgICAgICAgICB9KVxuICB9XG59KSgpO1xuXG52YXIgbWF0aF9ub25jb21tID0gW1xuICBcImF0YW4yXCIsXG4gIFwicG93XCJcbl1cbjsoZnVuY3Rpb24oKXtcbiAgZm9yKHZhciBpPTA7IGk8bWF0aF9ub25jb21tLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGY9IG1hdGhfbm9uY29tbVtpXVxuICAgIGV4cG9ydHNbZitcIm9wXCJdID0gbWFrZU9wKHtcbiAgICAgICAgICAgICAgICAgIGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCIsXCJjXCJdLCBib2R5OlwiYT10aGlzX2YoYyxiKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJvcFwiXG4gICAgICAgICAgICAgICAgfSlcbiAgICBleHBvcnRzW2YrXCJvcHNcIl0gPSBtYWtlT3Aoe1xuICAgICAgICAgICAgICAgICAgYXJnczpbXCJhcnJheVwiLCBcImFycmF5XCIsIFwic2NhbGFyXCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCIsXCJjXCJdLCBib2R5OlwiYT10aGlzX2YoYyxiKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJvcHNcIlxuICAgICAgICAgICAgICAgICAgfSlcbiAgICBleHBvcnRzW2YrXCJvcGVxXCJdID0gbWFrZU9wKHsgYXJnczpbXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCJdLCBib2R5OlwiYT10aGlzX2YoYixhKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgcnZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgY291bnQ6IDIsXG4gICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZitcIm9wZXFcIlxuICAgICAgICAgICAgICAgICAgfSlcbiAgICBleHBvcnRzW2YrXCJvcHNlcVwiXSA9IG1ha2VPcCh7IGFyZ3M6W1wiYXJyYXlcIiwgXCJzY2FsYXJcIl0sXG4gICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIl0sIGJvZHk6XCJhPXRoaXNfZihiLGEpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBydmFsdWU6dHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvdW50OjIsXG4gICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZitcIm9wc2VxXCJcbiAgICAgICAgICAgICAgICAgIH0pXG4gIH1cbn0pKCk7XG5cbmV4cG9ydHMuYW55ID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIl0sXG4gIHByZTogRW1wdHlQcm9jLFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJhXCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjF9XSwgYm9keTogXCJpZihhKXtyZXR1cm4gdHJ1ZX1cIiwgbG9jYWxWYXJzOiBbXSwgdGhpc1ZhcnM6IFtdfSxcbiAgcG9zdDoge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W10sIGJvZHk6XCJyZXR1cm4gZmFsc2VcIn0sXG4gIGZ1bmNOYW1lOiBcImFueVwiXG59KVxuXG5leHBvcnRzLmFsbCA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCJdLFxuICBwcmU6IEVtcHR5UHJvYyxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwieFwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDoxfV0sIGJvZHk6IFwiaWYoIXgpe3JldHVybiBmYWxzZX1cIiwgbG9jYWxWYXJzOiBbXSwgdGhpc1ZhcnM6IFtdfSxcbiAgcG9zdDoge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W10sIGJvZHk6XCJyZXR1cm4gdHJ1ZVwifSxcbiAgZnVuY05hbWU6IFwiYWxsXCJcbn0pXG5cbmV4cG9ydHMuc3VtID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIl0sXG4gIHByZToge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwidGhpc19zPTBcIn0sXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcImFcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6MX1dLCBib2R5OiBcInRoaXNfcys9YVwiLCBsb2NhbFZhcnM6IFtdLCB0aGlzVmFyczogW1widGhpc19zXCJdfSxcbiAgcG9zdDoge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwicmV0dXJuIHRoaXNfc1wifSxcbiAgZnVuY05hbWU6IFwic3VtXCJcbn0pXG5cbmV4cG9ydHMucHJvZCA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCJdLFxuICBwcmU6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInRoaXNfcz0xXCJ9LFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJhXCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjF9XSwgYm9keTogXCJ0aGlzX3MqPWFcIiwgbG9jYWxWYXJzOiBbXSwgdGhpc1ZhcnM6IFtcInRoaXNfc1wiXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInJldHVybiB0aGlzX3NcIn0sXG4gIGZ1bmNOYW1lOiBcInByb2RcIlxufSlcblxuZXhwb3J0cy5ub3JtMnNxdWFyZWQgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJ0aGlzX3M9MFwifSxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwiYVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDoyfV0sIGJvZHk6IFwidGhpc19zKz1hKmFcIiwgbG9jYWxWYXJzOiBbXSwgdGhpc1ZhcnM6IFtcInRoaXNfc1wiXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInJldHVybiB0aGlzX3NcIn0sXG4gIGZ1bmNOYW1lOiBcIm5vcm0yc3F1YXJlZFwiXG59KVxuICBcbmV4cG9ydHMubm9ybTIgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJ0aGlzX3M9MFwifSxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwiYVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDoyfV0sIGJvZHk6IFwidGhpc19zKz1hKmFcIiwgbG9jYWxWYXJzOiBbXSwgdGhpc1ZhcnM6IFtcInRoaXNfc1wiXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInJldHVybiBNYXRoLnNxcnQodGhpc19zKVwifSxcbiAgZnVuY05hbWU6IFwibm9ybTJcIlxufSlcbiAgXG5cbmV4cG9ydHMubm9ybWluZiA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCJdLFxuICBwcmU6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInRoaXNfcz0wXCJ9LFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJhXCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjR9XSwgYm9keTpcImlmKC1hPnRoaXNfcyl7dGhpc19zPS1hfWVsc2UgaWYoYT50aGlzX3Mpe3RoaXNfcz1hfVwiLCBsb2NhbFZhcnM6IFtdLCB0aGlzVmFyczogW1widGhpc19zXCJdfSxcbiAgcG9zdDoge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwicmV0dXJuIHRoaXNfc1wifSxcbiAgZnVuY05hbWU6IFwibm9ybWluZlwiXG59KVxuXG5leHBvcnRzLm5vcm0xID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIl0sXG4gIHByZToge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwidGhpc19zPTBcIn0sXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcImFcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6M31dLCBib2R5OiBcInRoaXNfcys9YTwwPy1hOmFcIiwgbG9jYWxWYXJzOiBbXSwgdGhpc1ZhcnM6IFtcInRoaXNfc1wiXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInJldHVybiB0aGlzX3NcIn0sXG4gIGZ1bmNOYW1lOiBcIm5vcm0xXCJcbn0pXG5cbmV4cG9ydHMuc3VwID0gY29tcGlsZSh7XG4gIGFyZ3M6IFsgXCJhcnJheVwiIF0sXG4gIHByZTpcbiAgIHsgYm9keTogXCJ0aGlzX2g9LUluZmluaXR5XCIsXG4gICAgIGFyZ3M6IFtdLFxuICAgICB0aGlzVmFyczogWyBcInRoaXNfaFwiIF0sXG4gICAgIGxvY2FsVmFyczogW10gfSxcbiAgYm9keTpcbiAgIHsgYm9keTogXCJpZihfaW5saW5lXzFfYXJnMF8+dGhpc19oKXRoaXNfaD1faW5saW5lXzFfYXJnMF9cIixcbiAgICAgYXJnczogW3tcIm5hbWVcIjpcIl9pbmxpbmVfMV9hcmcwX1wiLFwibHZhbHVlXCI6ZmFsc2UsXCJydmFsdWVcIjp0cnVlLFwiY291bnRcIjoyfSBdLFxuICAgICB0aGlzVmFyczogWyBcInRoaXNfaFwiIF0sXG4gICAgIGxvY2FsVmFyczogW10gfSxcbiAgcG9zdDpcbiAgIHsgYm9keTogXCJyZXR1cm4gdGhpc19oXCIsXG4gICAgIGFyZ3M6IFtdLFxuICAgICB0aGlzVmFyczogWyBcInRoaXNfaFwiIF0sXG4gICAgIGxvY2FsVmFyczogW10gfVxuIH0pXG5cbmV4cG9ydHMuaW5mID0gY29tcGlsZSh7XG4gIGFyZ3M6IFsgXCJhcnJheVwiIF0sXG4gIHByZTpcbiAgIHsgYm9keTogXCJ0aGlzX2g9SW5maW5pdHlcIixcbiAgICAgYXJnczogW10sXG4gICAgIHRoaXNWYXJzOiBbIFwidGhpc19oXCIgXSxcbiAgICAgbG9jYWxWYXJzOiBbXSB9LFxuICBib2R5OlxuICAgeyBib2R5OiBcImlmKF9pbmxpbmVfMV9hcmcwXzx0aGlzX2gpdGhpc19oPV9pbmxpbmVfMV9hcmcwX1wiLFxuICAgICBhcmdzOiBbe1wibmFtZVwiOlwiX2lubGluZV8xX2FyZzBfXCIsXCJsdmFsdWVcIjpmYWxzZSxcInJ2YWx1ZVwiOnRydWUsXCJjb3VudFwiOjJ9IF0sXG4gICAgIHRoaXNWYXJzOiBbIFwidGhpc19oXCIgXSxcbiAgICAgbG9jYWxWYXJzOiBbXSB9LFxuICBwb3N0OlxuICAgeyBib2R5OiBcInJldHVybiB0aGlzX2hcIixcbiAgICAgYXJnczogW10sXG4gICAgIHRoaXNWYXJzOiBbIFwidGhpc19oXCIgXSxcbiAgICAgbG9jYWxWYXJzOiBbXSB9XG4gfSlcblxuZXhwb3J0cy5hcmdtaW4gPSBjb21waWxlKHtcbiAgYXJnczpbXCJpbmRleFwiLFwiYXJyYXlcIixcInNoYXBlXCJdLFxuICBwcmU6e1xuICAgIGJvZHk6XCJ7dGhpc192PUluZmluaXR5O3RoaXNfaT1faW5saW5lXzBfYXJnMl8uc2xpY2UoMCl9XCIsXG4gICAgYXJnczpbXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMF9hcmcwX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6ZmFsc2UsY291bnQ6MH0sXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMF9hcmcxX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6ZmFsc2UsY291bnQ6MH0sXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMF9hcmcyX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6dHJ1ZSxjb3VudDoxfVxuICAgICAgXSxcbiAgICB0aGlzVmFyczpbXCJ0aGlzX2lcIixcInRoaXNfdlwiXSxcbiAgICBsb2NhbFZhcnM6W119LFxuICBib2R5OntcbiAgICBib2R5Olwie2lmKF9pbmxpbmVfMV9hcmcxXzx0aGlzX3Ype3RoaXNfdj1faW5saW5lXzFfYXJnMV87Zm9yKHZhciBfaW5saW5lXzFfaz0wO19pbmxpbmVfMV9rPF9pbmxpbmVfMV9hcmcwXy5sZW5ndGg7KytfaW5saW5lXzFfayl7dGhpc19pW19pbmxpbmVfMV9rXT1faW5saW5lXzFfYXJnMF9bX2lubGluZV8xX2tdfX19XCIsXG4gICAgYXJnczpbXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMV9hcmcwX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6dHJ1ZSxjb3VudDoyfSxcbiAgICAgIHtuYW1lOlwiX2lubGluZV8xX2FyZzFfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTp0cnVlLGNvdW50OjJ9XSxcbiAgICB0aGlzVmFyczpbXCJ0aGlzX2lcIixcInRoaXNfdlwiXSxcbiAgICBsb2NhbFZhcnM6W1wiX2lubGluZV8xX2tcIl19LFxuICBwb3N0OntcbiAgICBib2R5Olwie3JldHVybiB0aGlzX2l9XCIsXG4gICAgYXJnczpbXSxcbiAgICB0aGlzVmFyczpbXCJ0aGlzX2lcIl0sXG4gICAgbG9jYWxWYXJzOltdfVxufSlcblxuZXhwb3J0cy5hcmdtYXggPSBjb21waWxlKHtcbiAgYXJnczpbXCJpbmRleFwiLFwiYXJyYXlcIixcInNoYXBlXCJdLFxuICBwcmU6e1xuICAgIGJvZHk6XCJ7dGhpc192PS1JbmZpbml0eTt0aGlzX2k9X2lubGluZV8wX2FyZzJfLnNsaWNlKDApfVwiLFxuICAgIGFyZ3M6W1xuICAgICAge25hbWU6XCJfaW5saW5lXzBfYXJnMF9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOmZhbHNlLGNvdW50OjB9LFxuICAgICAge25hbWU6XCJfaW5saW5lXzBfYXJnMV9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOmZhbHNlLGNvdW50OjB9LFxuICAgICAge25hbWU6XCJfaW5saW5lXzBfYXJnMl9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOnRydWUsY291bnQ6MX1cbiAgICAgIF0sXG4gICAgdGhpc1ZhcnM6W1widGhpc19pXCIsXCJ0aGlzX3ZcIl0sXG4gICAgbG9jYWxWYXJzOltdfSxcbiAgYm9keTp7XG4gICAgYm9keTpcIntpZihfaW5saW5lXzFfYXJnMV8+dGhpc192KXt0aGlzX3Y9X2lubGluZV8xX2FyZzFfO2Zvcih2YXIgX2lubGluZV8xX2s9MDtfaW5saW5lXzFfazxfaW5saW5lXzFfYXJnMF8ubGVuZ3RoOysrX2lubGluZV8xX2spe3RoaXNfaVtfaW5saW5lXzFfa109X2lubGluZV8xX2FyZzBfW19pbmxpbmVfMV9rXX19fVwiLFxuICAgIGFyZ3M6W1xuICAgICAge25hbWU6XCJfaW5saW5lXzFfYXJnMF9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOnRydWUsY291bnQ6Mn0sXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMV9hcmcxX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6dHJ1ZSxjb3VudDoyfV0sXG4gICAgdGhpc1ZhcnM6W1widGhpc19pXCIsXCJ0aGlzX3ZcIl0sXG4gICAgbG9jYWxWYXJzOltcIl9pbmxpbmVfMV9rXCJdfSxcbiAgcG9zdDp7XG4gICAgYm9keTpcIntyZXR1cm4gdGhpc19pfVwiLFxuICAgIGFyZ3M6W10sXG4gICAgdGhpc1ZhcnM6W1widGhpc19pXCJdLFxuICAgIGxvY2FsVmFyczpbXX1cbn0pICBcblxuZXhwb3J0cy5yYW5kb20gPSBtYWtlT3Aoe1xuICBhcmdzOiBbXCJhcnJheVwiXSxcbiAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLnJhbmRvbVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICBib2R5OiB7YXJnczogW1wiYVwiXSwgYm9keTpcImE9dGhpc19mKClcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgZnVuY05hbWU6IFwicmFuZG9tXCJcbn0pXG5cbmV4cG9ydHMuYXNzaWduID0gbWFrZU9wKHtcbiAgYXJnczpbXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICBib2R5OiB7YXJnczpbXCJhXCIsIFwiYlwiXSwgYm9keTpcImE9YlwifSxcbiAgZnVuY05hbWU6IFwiYXNzaWduXCIgfSlcblxuZXhwb3J0cy5hc3NpZ25zID0gbWFrZU9wKHtcbiAgYXJnczpbXCJhcnJheVwiLCBcInNjYWxhclwiXSxcbiAgYm9keToge2FyZ3M6W1wiYVwiLCBcImJcIl0sIGJvZHk6XCJhPWJcIn0sXG4gIGZ1bmNOYW1lOiBcImFzc2lnbnNcIiB9KVxuXG5cbmV4cG9ydHMuZXF1YWxzID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgcHJlOiBFbXB0eVByb2MsXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcInhcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6MX0sXG4gICAgICAgICAgICAgICB7bmFtZTpcInlcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6MX1dLCBcbiAgICAgICAgYm9keTogXCJpZih4IT09eSl7cmV0dXJuIGZhbHNlfVwiLCBcbiAgICAgICAgbG9jYWxWYXJzOiBbXSwgXG4gICAgICAgIHRoaXNWYXJzOiBbXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltdLCBib2R5OlwicmV0dXJuIHRydWVcIn0sXG4gIGZ1bmNOYW1lOiBcImVxdWFsc1wiXG59KVxuXG5cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBjcmVhdGVUaHVuayA9IHJlcXVpcmUoXCIuL2xpYi90aHVuay5qc1wiKVxuXG5mdW5jdGlvbiBQcm9jZWR1cmUoKSB7XG4gIHRoaXMuYXJnVHlwZXMgPSBbXVxuICB0aGlzLnNoaW1BcmdzID0gW11cbiAgdGhpcy5hcnJheUFyZ3MgPSBbXVxuICB0aGlzLnNjYWxhckFyZ3MgPSBbXVxuICB0aGlzLm9mZnNldEFyZ3MgPSBbXVxuICB0aGlzLm9mZnNldEFyZ0luZGV4ID0gW11cbiAgdGhpcy5pbmRleEFyZ3MgPSBbXVxuICB0aGlzLnNoYXBlQXJncyA9IFtdXG4gIHRoaXMuZnVuY05hbWUgPSBcIlwiXG4gIHRoaXMucHJlID0gbnVsbFxuICB0aGlzLmJvZHkgPSBudWxsXG4gIHRoaXMucG9zdCA9IG51bGxcbiAgdGhpcy5kZWJ1ZyA9IGZhbHNlXG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVDd2lzZSh1c2VyX2FyZ3MpIHtcbiAgLy9DcmVhdGUgcHJvY2VkdXJlXG4gIHZhciBwcm9jID0gbmV3IFByb2NlZHVyZSgpXG4gIFxuICAvL1BhcnNlIGJsb2Nrc1xuICBwcm9jLnByZSAgICA9IHVzZXJfYXJncy5wcmVcbiAgcHJvYy5ib2R5ICAgPSB1c2VyX2FyZ3MuYm9keVxuICBwcm9jLnBvc3QgICA9IHVzZXJfYXJncy5wb3N0XG5cbiAgLy9QYXJzZSBhcmd1bWVudHNcbiAgdmFyIHByb2NfYXJncyA9IHVzZXJfYXJncy5hcmdzLnNsaWNlKDApXG4gIHByb2MuYXJnVHlwZXMgPSBwcm9jX2FyZ3NcbiAgZm9yKHZhciBpPTA7IGk8cHJvY19hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGFyZ190eXBlID0gcHJvY19hcmdzW2ldXG4gICAgaWYoYXJnX3R5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgcHJvYy5hcnJheUFyZ3MucHVzaChpKVxuICAgICAgcHJvYy5zaGltQXJncy5wdXNoKFwiYXJyYXlcIiArIGkpXG4gICAgICBpZihpIDwgcHJvYy5wcmUuYXJncy5sZW5ndGggJiYgcHJvYy5wcmUuYXJnc1tpXS5jb3VudD4wKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwcmUoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBhcmdzXCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5wb3N0LmFyZ3MubGVuZ3RoICYmIHByb2MucG9zdC5hcmdzW2ldLmNvdW50PjApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBhcmdzXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGFyZ190eXBlID09PSBcInNjYWxhclwiKSB7XG4gICAgICBwcm9jLnNjYWxhckFyZ3MucHVzaChpKVxuICAgICAgcHJvYy5zaGltQXJncy5wdXNoKFwic2NhbGFyXCIgKyBpKVxuICAgIH0gZWxzZSBpZihhcmdfdHlwZSA9PT0gXCJpbmRleFwiKSB7XG4gICAgICBwcm9jLmluZGV4QXJncy5wdXNoKGkpXG4gICAgICBpZihpIDwgcHJvYy5wcmUuYXJncy5sZW5ndGggJiYgcHJvYy5wcmUuYXJnc1tpXS5jb3VudCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGluZGV4XCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5ib2R5LmFyZ3MubGVuZ3RoICYmIHByb2MuYm9keS5hcmdzW2ldLmx2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogYm9keSgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgaW5kZXhcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0uY291bnQgPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwb3N0KCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgaW5kZXhcIilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoYXJnX3R5cGUgPT09IFwic2hhcGVcIikge1xuICAgICAgcHJvYy5zaGFwZUFyZ3MucHVzaChpKVxuICAgICAgaWYoaSA8IHByb2MucHJlLmFyZ3MubGVuZ3RoICYmIHByb2MucHJlLmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwcmUoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IHNoYXBlXCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5ib2R5LmFyZ3MubGVuZ3RoICYmIHByb2MuYm9keS5hcmdzW2ldLmx2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogYm9keSgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgc2hhcGVcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwb3N0KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBzaGFwZVwiKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZih0eXBlb2YgYXJnX3R5cGUgPT09IFwib2JqZWN0XCIgJiYgYXJnX3R5cGUub2Zmc2V0KSB7XG4gICAgICBwcm9jLmFyZ1R5cGVzW2ldID0gXCJvZmZzZXRcIlxuICAgICAgcHJvYy5vZmZzZXRBcmdzLnB1c2goeyBhcnJheTogYXJnX3R5cGUuYXJyYXksIG9mZnNldDphcmdfdHlwZS5vZmZzZXQgfSlcbiAgICAgIHByb2Mub2Zmc2V0QXJnSW5kZXgucHVzaChpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVW5rbm93biBhcmd1bWVudCB0eXBlIFwiICsgcHJvY19hcmdzW2ldKVxuICAgIH1cbiAgfVxuICBcbiAgLy9NYWtlIHN1cmUgYXQgbGVhc3Qgb25lIGFycmF5IGFyZ3VtZW50IHdhcyBzcGVjaWZpZWRcbiAgaWYocHJvYy5hcnJheUFyZ3MubGVuZ3RoIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogTm8gYXJyYXkgYXJndW1lbnRzIHNwZWNpZmllZFwiKVxuICB9XG4gIFxuICAvL01ha2Ugc3VyZSBhcmd1bWVudHMgYXJlIGNvcnJlY3RcbiAgaWYocHJvYy5wcmUuYXJncy5sZW5ndGggPiBwcm9jX2FyZ3MubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IFRvbyBtYW55IGFyZ3VtZW50cyBpbiBwcmUoKSBibG9ja1wiKVxuICB9XG4gIGlmKHByb2MuYm9keS5hcmdzLmxlbmd0aCA+IHByb2NfYXJncy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIGJvZHkoKSBibG9ja1wiKVxuICB9XG4gIGlmKHByb2MucG9zdC5hcmdzLmxlbmd0aCA+IHByb2NfYXJncy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIHBvc3QoKSBibG9ja1wiKVxuICB9XG5cbiAgLy9DaGVjayBkZWJ1ZyBmbGFnXG4gIHByb2MuZGVidWcgPSAhIXVzZXJfYXJncy5wcmludENvZGUgfHwgISF1c2VyX2FyZ3MuZGVidWdcbiAgXG4gIC8vUmV0cmlldmUgbmFtZVxuICBwcm9jLmZ1bmNOYW1lID0gdXNlcl9hcmdzLmZ1bmNOYW1lIHx8IFwiY3dpc2VcIlxuICBcbiAgLy9SZWFkIGluIGJsb2NrIHNpemVcbiAgcHJvYy5ibG9ja1NpemUgPSB1c2VyX2FyZ3MuYmxvY2tTaXplIHx8IDY0XG5cbiAgcmV0dXJuIGNyZWF0ZVRodW5rKHByb2MpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGlsZUN3aXNlXG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgdW5pcSA9IHJlcXVpcmUoXCJ1bmlxXCIpXG5cbmZ1bmN0aW9uIGlubmVyRmlsbChvcmRlciwgcHJvYywgYm9keSkge1xuICB2YXIgZGltZW5zaW9uID0gb3JkZXIubGVuZ3RoXG4gICAgLCBuYXJncyA9IHByb2MuYXJyYXlBcmdzLmxlbmd0aFxuICAgICwgaGFzX2luZGV4ID0gcHJvYy5pbmRleEFyZ3MubGVuZ3RoPjBcbiAgICAsIGNvZGUgPSBbXVxuICAgICwgdmFycyA9IFtdXG4gICAgLCBpZHg9MCwgcGlkeD0wLCBpLCBqXG4gIGZvcihpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICB2YXJzLnB1c2goW1wiaVwiLGksXCI9MFwiXS5qb2luKFwiXCIpKVxuICB9XG4gIC8vQ29tcHV0ZSBzY2FuIGRlbHRhc1xuICBmb3Ioaj0wOyBqPG5hcmdzOyArK2opIHtcbiAgICBmb3IoaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICBwaWR4ID0gaWR4XG4gICAgICBpZHggPSBvcmRlcltpXVxuICAgICAgaWYoaSA9PT0gMCkge1xuICAgICAgICB2YXJzLnB1c2goW1wiZFwiLGosXCJzXCIsaSxcIj10XCIsaixcInBcIixpZHhdLmpvaW4oXCJcIikpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXJzLnB1c2goW1wiZFwiLGosXCJzXCIsaSxcIj0odFwiLGosXCJwXCIsaWR4LFwiLXNcIixwaWR4LFwiKnRcIixqLFwicFwiLHBpZHgsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvZGUucHVzaChcInZhciBcIiArIHZhcnMuam9pbihcIixcIikpXG4gIC8vU2NhbiBsb29wXG4gIGZvcihpPWRpbWVuc2lvbi0xOyBpPj0wOyAtLWkpIHtcbiAgICBpZHggPSBvcmRlcltpXVxuICAgIGNvZGUucHVzaChbXCJmb3IoaVwiLGksXCI9MDtpXCIsaSxcIjxzXCIsaWR4LFwiOysraVwiLGksXCIpe1wiXS5qb2luKFwiXCIpKVxuICB9XG4gIC8vUHVzaCBib2R5IG9mIGlubmVyIGxvb3BcbiAgY29kZS5wdXNoKGJvZHkpXG4gIC8vQWR2YW5jZSBzY2FuIHBvaW50ZXJzXG4gIGZvcihpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBwaWR4ID0gaWR4XG4gICAgaWR4ID0gb3JkZXJbaV1cbiAgICBmb3Ioaj0wOyBqPG5hcmdzOyArK2opIHtcbiAgICAgIGNvZGUucHVzaChbXCJwXCIsaixcIis9ZFwiLGosXCJzXCIsaV0uam9pbihcIlwiKSlcbiAgICB9XG4gICAgaWYoaGFzX2luZGV4KSB7XG4gICAgICBpZihpID4gMCkge1xuICAgICAgICBjb2RlLnB1c2goW1wiaW5kZXhbXCIscGlkeCxcIl0tPXNcIixwaWR4XS5qb2luKFwiXCIpKVxuICAgICAgfVxuICAgICAgY29kZS5wdXNoKFtcIisraW5kZXhbXCIsaWR4LFwiXVwiXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgICBjb2RlLnB1c2goXCJ9XCIpXG4gIH1cbiAgcmV0dXJuIGNvZGUuam9pbihcIlxcblwiKVxufVxuXG5mdW5jdGlvbiBvdXRlckZpbGwobWF0Y2hlZCwgb3JkZXIsIHByb2MsIGJvZHkpIHtcbiAgdmFyIGRpbWVuc2lvbiA9IG9yZGVyLmxlbmd0aFxuICAgICwgbmFyZ3MgPSBwcm9jLmFycmF5QXJncy5sZW5ndGhcbiAgICAsIGJsb2NrU2l6ZSA9IHByb2MuYmxvY2tTaXplXG4gICAgLCBoYXNfaW5kZXggPSBwcm9jLmluZGV4QXJncy5sZW5ndGggPiAwXG4gICAgLCBjb2RlID0gW11cbiAgZm9yKHZhciBpPTA7IGk8bmFyZ3M7ICsraSkge1xuICAgIGNvZGUucHVzaChbXCJ2YXIgb2Zmc2V0XCIsaSxcIj1wXCIsaV0uam9pbihcIlwiKSlcbiAgfVxuICAvL0dlbmVyYXRlIG1hdGNoZWQgbG9vcHNcbiAgZm9yKHZhciBpPW1hdGNoZWQ7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goW1wiZm9yKHZhciBqXCIraStcIj1TU1tcIiwgb3JkZXJbaV0sIFwiXXwwO2pcIiwgaSwgXCI+MDspe1wiXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJpZihqXCIsaSxcIjxcIixibG9ja1NpemUsXCIpe1wiXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJzXCIsb3JkZXJbaV0sXCI9alwiLGldLmpvaW4oXCJcIikpXG4gICAgY29kZS5wdXNoKFtcImpcIixpLFwiPTBcIl0uam9pbihcIlwiKSlcbiAgICBjb2RlLnB1c2goW1wifWVsc2V7c1wiLG9yZGVyW2ldLFwiPVwiLGJsb2NrU2l6ZV0uam9pbihcIlwiKSlcbiAgICBjb2RlLnB1c2goW1wialwiLGksXCItPVwiLGJsb2NrU2l6ZSxcIn1cIl0uam9pbihcIlwiKSlcbiAgICBpZihoYXNfaW5kZXgpIHtcbiAgICAgIGNvZGUucHVzaChbXCJpbmRleFtcIixvcmRlcltpXSxcIl09alwiLGldLmpvaW4oXCJcIikpXG4gICAgfVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPG5hcmdzOyArK2kpIHtcbiAgICB2YXIgaW5kZXhTdHIgPSBbXCJvZmZzZXRcIitpXVxuICAgIGZvcih2YXIgaj1tYXRjaGVkOyBqPGRpbWVuc2lvbjsgKytqKSB7XG4gICAgICBpbmRleFN0ci5wdXNoKFtcImpcIixqLFwiKnRcIixpLFwicFwiLG9yZGVyW2pdXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgICBjb2RlLnB1c2goW1wicFwiLGksXCI9KFwiLGluZGV4U3RyLmpvaW4oXCIrXCIpLFwiKVwiXS5qb2luKFwiXCIpKVxuICB9XG4gIGNvZGUucHVzaChpbm5lckZpbGwob3JkZXIsIHByb2MsIGJvZHkpKVxuICBmb3IodmFyIGk9bWF0Y2hlZDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcIn1cIilcbiAgfVxuICByZXR1cm4gY29kZS5qb2luKFwiXFxuXCIpXG59XG5cbi8vQ291bnQgdGhlIG51bWJlciBvZiBjb21wYXRpYmxlIGlubmVyIG9yZGVyc1xuZnVuY3Rpb24gY291bnRNYXRjaGVzKG9yZGVycykge1xuICB2YXIgbWF0Y2hlZCA9IDAsIGRpbWVuc2lvbiA9IG9yZGVyc1swXS5sZW5ndGhcbiAgd2hpbGUobWF0Y2hlZCA8IGRpbWVuc2lvbikge1xuICAgIGZvcih2YXIgaj0xOyBqPG9yZGVycy5sZW5ndGg7ICsraikge1xuICAgICAgaWYob3JkZXJzW2pdW21hdGNoZWRdICE9PSBvcmRlcnNbMF1bbWF0Y2hlZF0pIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZWRcbiAgICAgIH1cbiAgICB9XG4gICAgKyttYXRjaGVkXG4gIH1cbiAgcmV0dXJuIG1hdGNoZWRcbn1cblxuLy9Qcm9jZXNzZXMgYSBibG9jayBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGRhdGEgdHlwZXNcbmZ1bmN0aW9uIHByb2Nlc3NCbG9jayhibG9jaywgcHJvYywgZHR5cGVzKSB7XG4gIHZhciBjb2RlID0gYmxvY2suYm9keVxuICB2YXIgcHJlID0gW11cbiAgdmFyIHBvc3QgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxibG9jay5hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNhcmcgPSBibG9jay5hcmdzW2ldXG4gICAgaWYoY2FyZy5jb3VudCA8PSAwKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKGNhcmcubmFtZSwgXCJnXCIpXG4gICAgdmFyIHB0clN0ciA9IFwiXCJcbiAgICB2YXIgYXJyTnVtID0gcHJvYy5hcnJheUFyZ3MuaW5kZXhPZihpKVxuICAgIHN3aXRjaChwcm9jLmFyZ1R5cGVzW2ldKSB7XG4gICAgICBjYXNlIFwib2Zmc2V0XCI6XG4gICAgICAgIHZhciBvZmZBcmdJbmRleCA9IHByb2Mub2Zmc2V0QXJnSW5kZXguaW5kZXhPZihpKVxuICAgICAgICB2YXIgb2ZmQXJnID0gcHJvYy5vZmZzZXRBcmdzW29mZkFyZ0luZGV4XVxuICAgICAgICBhcnJOdW0gPSBvZmZBcmcuYXJyYXlcbiAgICAgICAgcHRyU3RyID0gXCIrcVwiICsgb2ZmQXJnSW5kZXhcbiAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICBwdHJTdHIgPSBcInBcIiArIGFyck51bSArIHB0clN0clxuICAgICAgICB2YXIgbG9jYWxTdHIgPSBcImxcIiArIGlcbiAgICAgICAgdmFyIGFyclN0ciA9IFwiYVwiICsgYXJyTnVtXG4gICAgICAgIGlmKGNhcmcuY291bnQgPT09IDEpIHtcbiAgICAgICAgICBpZihkdHlwZXNbYXJyTnVtXSA9PT0gXCJnZW5lcmljXCIpIHtcbiAgICAgICAgICAgIGlmKGNhcmcubHZhbHVlKSB7XG4gICAgICAgICAgICAgIHByZS5wdXNoKFtcInZhciBcIiwgbG9jYWxTdHIsIFwiPVwiLCBhcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgbG9jYWxTdHIpXG4gICAgICAgICAgICAgIHBvc3QucHVzaChbYXJyU3RyLCBcIi5zZXQoXCIsIHB0clN0ciwgXCIsXCIsIGxvY2FsU3RyLFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgW2FyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBbYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl1cIl0uam9pbihcIlwiKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihkdHlwZXNbYXJyTnVtXSA9PT0gXCJnZW5lcmljXCIpIHtcbiAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgbG9jYWxTdHIpXG4gICAgICAgICAgaWYoY2FyZy5sdmFsdWUpIHtcbiAgICAgICAgICAgIHBvc3QucHVzaChbYXJyU3RyLCBcIi5zZXQoXCIsIHB0clN0ciwgXCIsXCIsIGxvY2FsU3RyLFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl1cIl0uam9pbihcIlwiKSlcbiAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICBpZihjYXJnLmx2YWx1ZSkge1xuICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXT1cIiwgbG9jYWxTdHJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBicmVha1xuICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBcIllcIiArIHByb2Muc2NhbGFyQXJncy5pbmRleE9mKGkpKVxuICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJpbmRleFwiOlxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBcImluZGV4XCIpXG4gICAgICBicmVha1xuICAgICAgY2FzZSBcInNoYXBlXCI6XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFwic2hhcGVcIilcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiBbcHJlLmpvaW4oXCJcXG5cIiksIGNvZGUsIHBvc3Quam9pbihcIlxcblwiKV0uam9pbihcIlxcblwiKS50cmltKClcbn1cblxuZnVuY3Rpb24gdHlwZVN1bW1hcnkoZHR5cGVzKSB7XG4gIHZhciBzdW1tYXJ5ID0gbmV3IEFycmF5KGR0eXBlcy5sZW5ndGgpXG4gIHZhciBhbGxFcXVhbCA9IHRydWVcbiAgZm9yKHZhciBpPTA7IGk8ZHR5cGVzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHQgPSBkdHlwZXNbaV1cbiAgICB2YXIgZGlnaXRzID0gdC5tYXRjaCgvXFxkKy8pXG4gICAgaWYoIWRpZ2l0cykge1xuICAgICAgZGlnaXRzID0gXCJcIlxuICAgIH0gZWxzZSB7XG4gICAgICBkaWdpdHMgPSBkaWdpdHNbMF1cbiAgICB9XG4gICAgaWYodC5jaGFyQXQoMCkgPT09IDApIHtcbiAgICAgIHN1bW1hcnlbaV0gPSBcInVcIiArIHQuY2hhckF0KDEpICsgZGlnaXRzXG4gICAgfSBlbHNlIHtcbiAgICAgIHN1bW1hcnlbaV0gPSB0LmNoYXJBdCgwKSArIGRpZ2l0c1xuICAgIH1cbiAgICBpZihpID4gMCkge1xuICAgICAgYWxsRXF1YWwgPSBhbGxFcXVhbCAmJiBzdW1tYXJ5W2ldID09PSBzdW1tYXJ5W2ktMV1cbiAgICB9XG4gIH1cbiAgaWYoYWxsRXF1YWwpIHtcbiAgICByZXR1cm4gc3VtbWFyeVswXVxuICB9XG4gIHJldHVybiBzdW1tYXJ5LmpvaW4oXCJcIilcbn1cblxuLy9HZW5lcmF0ZXMgYSBjd2lzZSBvcGVyYXRvclxuZnVuY3Rpb24gZ2VuZXJhdGVDV2lzZU9wKHByb2MsIHR5cGVzaWcpIHtcblxuICAvL0NvbXB1dGUgZGltZW5zaW9uXG4gIHZhciBkaW1lbnNpb24gPSB0eXBlc2lnWzFdLmxlbmd0aHwwXG4gIHZhciBvcmRlcnMgPSBuZXcgQXJyYXkocHJvYy5hcnJheUFyZ3MubGVuZ3RoKVxuICB2YXIgZHR5cGVzID0gbmV3IEFycmF5KHByb2MuYXJyYXlBcmdzLmxlbmd0aClcblxuICAvL0ZpcnN0IGNyZWF0ZSBhcmd1bWVudHMgZm9yIHByb2NlZHVyZVxuICB2YXIgYXJnbGlzdCA9IFtcIlNTXCJdXG4gIHZhciBjb2RlID0gW1wiJ3VzZSBzdHJpY3QnXCJdXG4gIHZhciB2YXJzID0gW11cbiAgXG4gIGZvcih2YXIgaj0wOyBqPGRpbWVuc2lvbjsgKytqKSB7XG4gICAgdmFycy5wdXNoKFtcInNcIiwgaiwgXCI9U1NbXCIsIGosIFwiXVwiXS5qb2luKFwiXCIpKVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgYXJnbGlzdC5wdXNoKFwiYVwiK2kpXG4gICAgYXJnbGlzdC5wdXNoKFwidFwiK2kpXG4gICAgYXJnbGlzdC5wdXNoKFwicFwiK2kpXG4gICAgZHR5cGVzW2ldID0gdHlwZXNpZ1syKmldXG4gICAgb3JkZXJzW2ldID0gdHlwZXNpZ1syKmkrMV1cbiAgICBcbiAgICBmb3IodmFyIGo9MDsgajxkaW1lbnNpb247ICsraikge1xuICAgICAgdmFycy5wdXNoKFtcInRcIixpLFwicFwiLGosXCI9dFwiLGksXCJbXCIsaixcIl1cIl0uam9pbihcIlwiKSlcbiAgICB9XG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5zY2FsYXJBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgYXJnbGlzdC5wdXNoKFwiWVwiICsgaSlcbiAgfVxuICBpZihwcm9jLnNoYXBlQXJncy5sZW5ndGggPiAwKSB7XG4gICAgdmFycy5wdXNoKFwic2hhcGU9U1Muc2xpY2UoMClcIilcbiAgfVxuICBpZihwcm9jLmluZGV4QXJncy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHplcm9zID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgICAgemVyb3NbaV0gPSBcIjBcIlxuICAgIH1cbiAgICB2YXJzLnB1c2goW1wiaW5kZXg9W1wiLCB6ZXJvcy5qb2luKFwiLFwiKSwgXCJdXCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5vZmZzZXRBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIG9mZl9hcmcgPSBwcm9jLm9mZnNldEFyZ3NbaV1cbiAgICB2YXIgaW5pdF9zdHJpbmcgPSBbXVxuICAgIGZvcih2YXIgaj0wOyBqPG9mZl9hcmcub2Zmc2V0Lmxlbmd0aDsgKytqKSB7XG4gICAgICBpZihvZmZfYXJnLm9mZnNldFtqXSA9PT0gMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmKG9mZl9hcmcub2Zmc2V0W2pdID09PSAxKSB7XG4gICAgICAgIGluaXRfc3RyaW5nLnB1c2goW1widFwiLCBvZmZfYXJnLmFycmF5LCBcInBcIiwgal0uam9pbihcIlwiKSkgICAgICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRfc3RyaW5nLnB1c2goW29mZl9hcmcub2Zmc2V0W2pdLCBcIip0XCIsIG9mZl9hcmcuYXJyYXksIFwicFwiLCBqXS5qb2luKFwiXCIpKVxuICAgICAgfVxuICAgIH1cbiAgICBpZihpbml0X3N0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhcnMucHVzaChcInFcIiArIGkgKyBcIj0wXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhcnMucHVzaChbXCJxXCIsIGksIFwiPVwiLCBpbml0X3N0cmluZy5qb2luKFwiK1wiKV0uam9pbihcIlwiKSlcbiAgICB9XG4gIH1cblxuICAvL1ByZXBhcmUgdGhpcyB2YXJpYWJsZXNcbiAgdmFyIHRoaXNWYXJzID0gdW5pcShbXS5jb25jYXQocHJvYy5wcmUudGhpc1ZhcnMpXG4gICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChwcm9jLmJvZHkudGhpc1ZhcnMpXG4gICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChwcm9jLnBvc3QudGhpc1ZhcnMpKVxuICB2YXJzID0gdmFycy5jb25jYXQodGhpc1ZhcnMpXG4gIGNvZGUucHVzaChcInZhciBcIiArIHZhcnMuam9pbihcIixcIikpXG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwicFwiK2krXCJ8PTBcIilcbiAgfVxuICBcbiAgLy9JbmxpbmUgcHJlbHVkZVxuICBpZihwcm9jLnByZS5ib2R5Lmxlbmd0aCA+IDMpIHtcbiAgICBjb2RlLnB1c2gocHJvY2Vzc0Jsb2NrKHByb2MucHJlLCBwcm9jLCBkdHlwZXMpKVxuICB9XG5cbiAgLy9Qcm9jZXNzIGJvZHlcbiAgdmFyIGJvZHkgPSBwcm9jZXNzQmxvY2socHJvYy5ib2R5LCBwcm9jLCBkdHlwZXMpXG4gIHZhciBtYXRjaGVkID0gY291bnRNYXRjaGVzKG9yZGVycylcbiAgaWYobWF0Y2hlZCA8IGRpbWVuc2lvbikge1xuICAgIGNvZGUucHVzaChvdXRlckZpbGwobWF0Y2hlZCwgb3JkZXJzWzBdLCBwcm9jLCBib2R5KSlcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goaW5uZXJGaWxsKG9yZGVyc1swXSwgcHJvYywgYm9keSkpXG4gIH1cblxuICAvL0lubGluZSBlcGlsb2dcbiAgaWYocHJvYy5wb3N0LmJvZHkubGVuZ3RoID4gMykge1xuICAgIGNvZGUucHVzaChwcm9jZXNzQmxvY2socHJvYy5wb3N0LCBwcm9jLCBkdHlwZXMpKVxuICB9XG4gIFxuICBpZihwcm9jLmRlYnVnKSB7XG4gICAgY29uc29sZS5sb2coXCJHZW5lcmF0ZWQgY3dpc2Ugcm91dGluZSBmb3IgXCIsIHR5cGVzaWcsIFwiOlxcblxcblwiLCBjb2RlLmpvaW4oXCJcXG5cIikpXG4gIH1cbiAgXG4gIHZhciBsb29wTmFtZSA9IFsocHJvYy5mdW5jTmFtZXx8XCJ1bm5hbWVkXCIpLCBcIl9jd2lzZV9sb29wX1wiLCBvcmRlcnNbMF0uam9pbihcInNcIiksXCJtXCIsbWF0Y2hlZCx0eXBlU3VtbWFyeShkdHlwZXMpXS5qb2luKFwiXCIpXG4gIHZhciBmID0gbmV3IEZ1bmN0aW9uKFtcImZ1bmN0aW9uIFwiLGxvb3BOYW1lLFwiKFwiLCBhcmdsaXN0LmpvaW4oXCIsXCIpLFwiKXtcIiwgY29kZS5qb2luKFwiXFxuXCIpLFwifSByZXR1cm4gXCIsIGxvb3BOYW1lXS5qb2luKFwiXCIpKVxuICByZXR1cm4gZigpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGdlbmVyYXRlQ1dpc2VPcCIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBjb21waWxlID0gcmVxdWlyZShcIi4vY29tcGlsZS5qc1wiKVxuXG5mdW5jdGlvbiBjcmVhdGVUaHVuayhwcm9jKSB7XG4gIHZhciBjb2RlID0gW1wiJ3VzZSBzdHJpY3QnXCIsIFwidmFyIENBQ0hFRD17fVwiXVxuICB2YXIgdmFycyA9IFtdXG4gIHZhciB0aHVua05hbWUgPSBwcm9jLmZ1bmNOYW1lICsgXCJfY3dpc2VfdGh1bmtcIlxuICBcbiAgLy9CdWlsZCB0aHVua1xuICBjb2RlLnB1c2goW1wicmV0dXJuIGZ1bmN0aW9uIFwiLCB0aHVua05hbWUsIFwiKFwiLCBwcm9jLnNoaW1BcmdzLmpvaW4oXCIsXCIpLCBcIil7XCJdLmpvaW4oXCJcIikpXG4gIHZhciB0eXBlc2lnID0gW11cbiAgdmFyIHN0cmluZ190eXBlc2lnID0gW11cbiAgdmFyIHByb2NfYXJncyA9IFtbXCJhcnJheVwiLHByb2MuYXJyYXlBcmdzWzBdLFwiLnNoYXBlXCJdLmpvaW4oXCJcIildXG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGogPSBwcm9jLmFycmF5QXJnc1tpXVxuICAgIHZhcnMucHVzaChbXCJ0XCIsIGosIFwiPWFycmF5XCIsIGosIFwiLmR0eXBlLFwiLFxuICAgICAgICAgICAgICAgXCJyXCIsIGosIFwiPWFycmF5XCIsIGosIFwiLm9yZGVyXCJdLmpvaW4oXCJcIikpXG4gICAgdHlwZXNpZy5wdXNoKFwidFwiICsgailcbiAgICB0eXBlc2lnLnB1c2goXCJyXCIgKyBqKVxuICAgIHN0cmluZ190eXBlc2lnLnB1c2goXCJ0XCIrailcbiAgICBzdHJpbmdfdHlwZXNpZy5wdXNoKFwiclwiK2orXCIuam9pbigpXCIpXG4gICAgcHJvY19hcmdzLnB1c2goXCJhcnJheVwiICsgaiArIFwiLmRhdGFcIilcbiAgICBwcm9jX2FyZ3MucHVzaChcImFycmF5XCIgKyBqICsgXCIuc3RyaWRlXCIpXG4gICAgcHJvY19hcmdzLnB1c2goXCJhcnJheVwiICsgaiArIFwiLm9mZnNldHwwXCIpXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5zY2FsYXJBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgcHJvY19hcmdzLnB1c2goXCJzY2FsYXJcIiArIHByb2Muc2NhbGFyQXJnc1tpXSlcbiAgfVxuICB2YXJzLnB1c2goW1widHlwZT1bXCIsIHN0cmluZ190eXBlc2lnLmpvaW4oXCIsXCIpLCBcIl0uam9pbigpXCJdLmpvaW4oXCJcIikpXG4gIHZhcnMucHVzaChcInByb2M9Q0FDSEVEW3R5cGVdXCIpXG4gIGNvZGUucHVzaChcInZhciBcIiArIHZhcnMuam9pbihcIixcIikpXG4gIFxuICBjb2RlLnB1c2goW1wiaWYoIXByb2Mpe1wiLFxuICAgICAgICAgICAgIFwiQ0FDSEVEW3R5cGVdPXByb2M9Y29tcGlsZShbXCIsIHR5cGVzaWcuam9pbihcIixcIiksIFwiXSl9XCIsXG4gICAgICAgICAgICAgXCJyZXR1cm4gcHJvYyhcIiwgcHJvY19hcmdzLmpvaW4oXCIsXCIpLCBcIil9XCJdLmpvaW4oXCJcIikpXG5cbiAgaWYocHJvYy5kZWJ1Zykge1xuICAgIGNvbnNvbGUubG9nKFwiR2VuZXJhdGVkIHRodW5rOlwiLCBjb2RlLmpvaW4oXCJcXG5cIikpXG4gIH1cbiAgXG4gIC8vQ29tcGlsZSB0aHVua1xuICB2YXIgdGh1bmsgPSBuZXcgRnVuY3Rpb24oXCJjb21waWxlXCIsIGNvZGUuam9pbihcIlxcblwiKSlcbiAgcmV0dXJuIHRodW5rKGNvbXBpbGUuYmluZCh1bmRlZmluZWQsIHByb2MpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVRodW5rXG4iLCJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiB1bmlxdWVfcHJlZChsaXN0LCBjb21wYXJlKSB7XG4gIHZhciBwdHIgPSAxXG4gICAgLCBsZW4gPSBsaXN0Lmxlbmd0aFxuICAgICwgYT1saXN0WzBdLCBiPWxpc3RbMF1cbiAgZm9yKHZhciBpPTE7IGk8bGVuOyArK2kpIHtcbiAgICBiID0gYVxuICAgIGEgPSBsaXN0W2ldXG4gICAgaWYoY29tcGFyZShhLCBiKSkge1xuICAgICAgaWYoaSA9PT0gcHRyKSB7XG4gICAgICAgIHB0cisrXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBsaXN0W3B0cisrXSA9IGFcbiAgICB9XG4gIH1cbiAgbGlzdC5sZW5ndGggPSBwdHJcbiAgcmV0dXJuIGxpc3Rcbn1cblxuZnVuY3Rpb24gdW5pcXVlX2VxKGxpc3QpIHtcbiAgdmFyIHB0ciA9IDFcbiAgICAsIGxlbiA9IGxpc3QubGVuZ3RoXG4gICAgLCBhPWxpc3RbMF0sIGIgPSBsaXN0WzBdXG4gIGZvcih2YXIgaT0xOyBpPGxlbjsgKytpLCBiPWEpIHtcbiAgICBiID0gYVxuICAgIGEgPSBsaXN0W2ldXG4gICAgaWYoYSAhPT0gYikge1xuICAgICAgaWYoaSA9PT0gcHRyKSB7XG4gICAgICAgIHB0cisrXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBsaXN0W3B0cisrXSA9IGFcbiAgICB9XG4gIH1cbiAgbGlzdC5sZW5ndGggPSBwdHJcbiAgcmV0dXJuIGxpc3Rcbn1cblxuZnVuY3Rpb24gdW5pcXVlKGxpc3QsIGNvbXBhcmUsIHNvcnRlZCkge1xuICBpZihsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBsaXN0XG4gIH1cbiAgaWYoY29tcGFyZSkge1xuICAgIGlmKCFzb3J0ZWQpIHtcbiAgICAgIGxpc3Quc29ydChjb21wYXJlKVxuICAgIH1cbiAgICByZXR1cm4gdW5pcXVlX3ByZWQobGlzdCwgY29tcGFyZSlcbiAgfVxuICBpZighc29ydGVkKSB7XG4gICAgbGlzdC5zb3J0KClcbiAgfVxuICByZXR1cm4gdW5pcXVlX2VxKGxpc3QpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pcXVlXG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgbmRhcnJheSA9IHJlcXVpcmUoXCJuZGFycmF5XCIpXG52YXIgZG9fY29udmVydCA9IHJlcXVpcmUoXCIuL2RvQ29udmVydC5qc1wiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbnZlcnQoYXJyLCByZXN1bHQpIHtcbiAgdmFyIHNoYXBlID0gW10sIGMgPSBhcnIsIHN6ID0gMVxuICB3aGlsZShjIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBzaGFwZS5wdXNoKGMubGVuZ3RoKVxuICAgIHN6ICo9IGMubGVuZ3RoXG4gICAgYyA9IGNbMF1cbiAgfVxuICBpZihzaGFwZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmRhcnJheSgpXG4gIH1cbiAgaWYoIXJlc3VsdCkge1xuICAgIHJlc3VsdCA9IG5kYXJyYXkobmV3IEZsb2F0NjRBcnJheShzeiksIHNoYXBlKVxuICB9XG4gIGRvX2NvbnZlcnQocmVzdWx0LCBhcnIpXG4gIHJldHVybiByZXN1bHRcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXJlcXVpcmUoJ2N3aXNlLWNvbXBpbGVyJykoe1wiYXJnc1wiOltcImFycmF5XCIsXCJzY2FsYXJcIixcImluZGV4XCJdLFwicHJlXCI6e1wiYm9keVwiOlwie31cIixcImFyZ3NcIjpbXSxcInRoaXNWYXJzXCI6W10sXCJsb2NhbFZhcnNcIjpbXX0sXCJib2R5XCI6e1wiYm9keVwiOlwie1xcbnZhciBfaW5saW5lXzFfdj1faW5saW5lXzFfYXJnMV8sX2lubGluZV8xX2lcXG5mb3IoX2lubGluZV8xX2k9MDtfaW5saW5lXzFfaTxfaW5saW5lXzFfYXJnMl8ubGVuZ3RoLTE7KytfaW5saW5lXzFfaSkge1xcbl9pbmxpbmVfMV92PV9pbmxpbmVfMV92W19pbmxpbmVfMV9hcmcyX1tfaW5saW5lXzFfaV1dXFxufVxcbl9pbmxpbmVfMV9hcmcwXz1faW5saW5lXzFfdltfaW5saW5lXzFfYXJnMl9bX2lubGluZV8xX2FyZzJfLmxlbmd0aC0xXV1cXG59XCIsXCJhcmdzXCI6W3tcIm5hbWVcIjpcIl9pbmxpbmVfMV9hcmcwX1wiLFwibHZhbHVlXCI6dHJ1ZSxcInJ2YWx1ZVwiOmZhbHNlLFwiY291bnRcIjoxfSx7XCJuYW1lXCI6XCJfaW5saW5lXzFfYXJnMV9cIixcImx2YWx1ZVwiOmZhbHNlLFwicnZhbHVlXCI6dHJ1ZSxcImNvdW50XCI6MX0se1wibmFtZVwiOlwiX2lubGluZV8xX2FyZzJfXCIsXCJsdmFsdWVcIjpmYWxzZSxcInJ2YWx1ZVwiOnRydWUsXCJjb3VudFwiOjR9XSxcInRoaXNWYXJzXCI6W10sXCJsb2NhbFZhcnNcIjpbXCJfaW5saW5lXzFfaVwiLFwiX2lubGluZV8xX3ZcIl19LFwicG9zdFwiOntcImJvZHlcIjpcInt9XCIsXCJhcmdzXCI6W10sXCJ0aGlzVmFyc1wiOltdLFwibG9jYWxWYXJzXCI6W119LFwiZnVuY05hbWVcIjpcImNvbnZlcnRcIixcImJsb2NrU2l6ZVwiOjY0fSlcbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBjcmVhdGVUaHVuayA9IHJlcXVpcmUoXCIuL2xpYi90aHVuay5qc1wiKVxuXG5mdW5jdGlvbiBQcm9jZWR1cmUoKSB7XG4gIHRoaXMuYXJnVHlwZXMgPSBbXVxuICB0aGlzLnNoaW1BcmdzID0gW11cbiAgdGhpcy5hcnJheUFyZ3MgPSBbXVxuICB0aGlzLnNjYWxhckFyZ3MgPSBbXVxuICB0aGlzLm9mZnNldEFyZ3MgPSBbXVxuICB0aGlzLm9mZnNldEFyZ0luZGV4ID0gW11cbiAgdGhpcy5pbmRleEFyZ3MgPSBbXVxuICB0aGlzLnNoYXBlQXJncyA9IFtdXG4gIHRoaXMuZnVuY05hbWUgPSBcIlwiXG4gIHRoaXMucHJlID0gbnVsbFxuICB0aGlzLmJvZHkgPSBudWxsXG4gIHRoaXMucG9zdCA9IG51bGxcbiAgdGhpcy5kZWJ1ZyA9IGZhbHNlXG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVDd2lzZSh1c2VyX2FyZ3MpIHtcbiAgLy9DcmVhdGUgcHJvY2VkdXJlXG4gIHZhciBwcm9jID0gbmV3IFByb2NlZHVyZSgpXG4gIFxuICAvL1BhcnNlIGJsb2Nrc1xuICBwcm9jLnByZSAgICA9IHVzZXJfYXJncy5wcmVcbiAgcHJvYy5ib2R5ICAgPSB1c2VyX2FyZ3MuYm9keVxuICBwcm9jLnBvc3QgICA9IHVzZXJfYXJncy5wb3N0XG5cbiAgLy9QYXJzZSBhcmd1bWVudHNcbiAgdmFyIHByb2NfYXJncyA9IHVzZXJfYXJncy5hcmdzLnNsaWNlKDApXG4gIHByb2MuYXJnVHlwZXMgPSBwcm9jX2FyZ3Muc2xpY2UoMClcbiAgZm9yKHZhciBpPTA7IGk8cHJvY19hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGFyZ190eXBlID0gcHJvY19hcmdzW2ldXG4gICAgaWYoYXJnX3R5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgcHJvYy5hcnJheUFyZ3MucHVzaChpKVxuICAgICAgcHJvYy5zaGltQXJncy5wdXNoKFwiYXJyYXlcIiArIGkpXG4gICAgICBpZihpIDwgcHJvYy5wcmUuYXJncy5sZW5ndGggJiYgcHJvYy5wcmUuYXJnc1tpXS5jb3VudD4wKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwcmUoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBhcmdzXCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5wb3N0LmFyZ3MubGVuZ3RoICYmIHByb2MucG9zdC5hcmdzW2ldLmNvdW50PjApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBhcmdzXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGFyZ190eXBlID09PSBcInNjYWxhclwiKSB7XG4gICAgICBwcm9jLnNjYWxhckFyZ3MucHVzaChpKVxuICAgICAgcHJvYy5zaGltQXJncy5wdXNoKFwic2NhbGFyXCIgKyBpKVxuICAgIH0gZWxzZSBpZihhcmdfdHlwZSA9PT0gXCJpbmRleFwiKSB7XG4gICAgICBwcm9jLmluZGV4QXJncy5wdXNoKGkpXG4gICAgICBpZihpIDwgcHJvYy5wcmUuYXJncy5sZW5ndGggJiYgcHJvYy5wcmUuYXJnc1tpXS5jb3VudCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGluZGV4XCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5ib2R5LmFyZ3MubGVuZ3RoICYmIHByb2MuYm9keS5hcmdzW2ldLmx2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogYm9keSgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgaW5kZXhcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0uY291bnQgPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwb3N0KCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgaW5kZXhcIilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoYXJnX3R5cGUgPT09IFwic2hhcGVcIikge1xuICAgICAgcHJvYy5zaGFwZUFyZ3MucHVzaChpKVxuICAgICAgaWYoaSA8IHByb2MucHJlLmFyZ3MubGVuZ3RoICYmIHByb2MucHJlLmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwcmUoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IHNoYXBlXCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5ib2R5LmFyZ3MubGVuZ3RoICYmIHByb2MuYm9keS5hcmdzW2ldLmx2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogYm9keSgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgc2hhcGVcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwb3N0KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBzaGFwZVwiKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZih0eXBlb2YgYXJnX3R5cGUgPT09IFwib2JqZWN0XCIgJiYgYXJnX3R5cGUub2Zmc2V0KSB7XG4gICAgICBwcm9jLmFyZ1R5cGVzW2ldID0gXCJvZmZzZXRcIlxuICAgICAgcHJvYy5vZmZzZXRBcmdzLnB1c2goeyBhcnJheTogYXJnX3R5cGUuYXJyYXksIG9mZnNldDphcmdfdHlwZS5vZmZzZXQgfSlcbiAgICAgIHByb2Mub2Zmc2V0QXJnSW5kZXgucHVzaChpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVW5rbm93biBhcmd1bWVudCB0eXBlIFwiICsgcHJvY19hcmdzW2ldKVxuICAgIH1cbiAgfVxuICBcbiAgLy9NYWtlIHN1cmUgYXQgbGVhc3Qgb25lIGFycmF5IGFyZ3VtZW50IHdhcyBzcGVjaWZpZWRcbiAgaWYocHJvYy5hcnJheUFyZ3MubGVuZ3RoIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogTm8gYXJyYXkgYXJndW1lbnRzIHNwZWNpZmllZFwiKVxuICB9XG4gIFxuICAvL01ha2Ugc3VyZSBhcmd1bWVudHMgYXJlIGNvcnJlY3RcbiAgaWYocHJvYy5wcmUuYXJncy5sZW5ndGggPiBwcm9jX2FyZ3MubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IFRvbyBtYW55IGFyZ3VtZW50cyBpbiBwcmUoKSBibG9ja1wiKVxuICB9XG4gIGlmKHByb2MuYm9keS5hcmdzLmxlbmd0aCA+IHByb2NfYXJncy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIGJvZHkoKSBibG9ja1wiKVxuICB9XG4gIGlmKHByb2MucG9zdC5hcmdzLmxlbmd0aCA+IHByb2NfYXJncy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIHBvc3QoKSBibG9ja1wiKVxuICB9XG5cbiAgLy9DaGVjayBkZWJ1ZyBmbGFnXG4gIHByb2MuZGVidWcgPSAhIXVzZXJfYXJncy5wcmludENvZGUgfHwgISF1c2VyX2FyZ3MuZGVidWdcbiAgXG4gIC8vUmV0cmlldmUgbmFtZVxuICBwcm9jLmZ1bmNOYW1lID0gdXNlcl9hcmdzLmZ1bmNOYW1lIHx8IFwiY3dpc2VcIlxuICBcbiAgLy9SZWFkIGluIGJsb2NrIHNpemVcbiAgcHJvYy5ibG9ja1NpemUgPSB1c2VyX2FyZ3MuYmxvY2tTaXplIHx8IDY0XG5cbiAgcmV0dXJuIGNyZWF0ZVRodW5rKHByb2MpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGlsZUN3aXNlXG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgdW5pcSA9IHJlcXVpcmUoXCJ1bmlxXCIpXG5cbmZ1bmN0aW9uIGlubmVyRmlsbChvcmRlciwgcHJvYywgYm9keSkge1xuICB2YXIgZGltZW5zaW9uID0gb3JkZXIubGVuZ3RoXG4gICAgLCBuYXJncyA9IHByb2MuYXJyYXlBcmdzLmxlbmd0aFxuICAgICwgaGFzX2luZGV4ID0gcHJvYy5pbmRleEFyZ3MubGVuZ3RoPjBcbiAgICAsIGNvZGUgPSBbXVxuICAgICwgdmFycyA9IFtdXG4gICAgLCBpZHg9MCwgcGlkeD0wLCBpLCBqXG4gIGZvcihpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICB2YXJzLnB1c2goW1wiaVwiLGksXCI9MFwiXS5qb2luKFwiXCIpKVxuICB9XG4gIC8vQ29tcHV0ZSBzY2FuIGRlbHRhc1xuICBmb3Ioaj0wOyBqPG5hcmdzOyArK2opIHtcbiAgICBmb3IoaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICBwaWR4ID0gaWR4XG4gICAgICBpZHggPSBvcmRlcltpXVxuICAgICAgaWYoaSA9PT0gMCkge1xuICAgICAgICB2YXJzLnB1c2goW1wiZFwiLGosXCJzXCIsaSxcIj10XCIsaixcIltcIixpZHgsXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXJzLnB1c2goW1wiZFwiLGosXCJzXCIsaSxcIj0odFwiLGosXCJbXCIsaWR4LFwiXS1zXCIscGlkeCxcIip0XCIsaixcIltcIixwaWR4LFwiXSlcIl0uam9pbihcIlwiKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29kZS5wdXNoKFwidmFyIFwiICsgdmFycy5qb2luKFwiLFwiKSlcbiAgLy9TY2FuIGxvb3BcbiAgZm9yKGk9ZGltZW5zaW9uLTE7IGk+PTA7IC0taSkge1xuICAgIGlkeCA9IG9yZGVyW2ldXG4gICAgY29kZS5wdXNoKFtcImZvcihpXCIsaSxcIj0wO2lcIixpLFwiPHNcIixpZHgsXCI7KytpXCIsaSxcIil7XCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgLy9QdXNoIGJvZHkgb2YgaW5uZXIgbG9vcFxuICBjb2RlLnB1c2goYm9keSlcbiAgLy9BZHZhbmNlIHNjYW4gcG9pbnRlcnNcbiAgZm9yKGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIHBpZHggPSBpZHhcbiAgICBpZHggPSBvcmRlcltpXVxuICAgIGZvcihqPTA7IGo8bmFyZ3M7ICsraikge1xuICAgICAgY29kZS5wdXNoKFtcInBcIixqLFwiKz1kXCIsaixcInNcIixpXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgICBpZihoYXNfaW5kZXgpIHtcbiAgICAgIGlmKGkgPiAwKSB7XG4gICAgICAgIGNvZGUucHVzaChbXCJpbmRleFtcIixwaWR4LFwiXS09c1wiLHBpZHhdLmpvaW4oXCJcIikpXG4gICAgICB9XG4gICAgICBjb2RlLnB1c2goW1wiKytpbmRleFtcIixpZHgsXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIGNvZGUucHVzaChcIn1cIilcbiAgfVxuICByZXR1cm4gY29kZS5qb2luKFwiXFxuXCIpXG59XG5cbmZ1bmN0aW9uIG91dGVyRmlsbChtYXRjaGVkLCBvcmRlciwgcHJvYywgYm9keSkge1xuICB2YXIgZGltZW5zaW9uID0gb3JkZXIubGVuZ3RoXG4gICAgLCBuYXJncyA9IHByb2MuYXJyYXlBcmdzLmxlbmd0aFxuICAgICwgYmxvY2tTaXplID0gcHJvYy5ibG9ja1NpemVcbiAgICAsIGhhc19pbmRleCA9IHByb2MuaW5kZXhBcmdzLmxlbmd0aCA+IDBcbiAgICAsIGNvZGUgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxuYXJnczsgKytpKSB7XG4gICAgY29kZS5wdXNoKFtcInZhciBvZmZzZXRcIixpLFwiPXBcIixpXS5qb2luKFwiXCIpKVxuICB9XG4gIC8vR2VuZXJhdGUgbWF0Y2hlZCBsb29wc1xuICBmb3IodmFyIGk9bWF0Y2hlZDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChbXCJmb3IodmFyIGpcIitpK1wiPVNTW1wiLCBvcmRlcltpXSwgXCJdfDA7alwiLCBpLCBcIj4wOyl7XCJdLmpvaW4oXCJcIikpXG4gICAgY29kZS5wdXNoKFtcImlmKGpcIixpLFwiPFwiLGJsb2NrU2l6ZSxcIil7XCJdLmpvaW4oXCJcIikpXG4gICAgY29kZS5wdXNoKFtcInNcIixvcmRlcltpXSxcIj1qXCIsaV0uam9pbihcIlwiKSlcbiAgICBjb2RlLnB1c2goW1wialwiLGksXCI9MFwiXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJ9ZWxzZXtzXCIsb3JkZXJbaV0sXCI9XCIsYmxvY2tTaXplXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJqXCIsaSxcIi09XCIsYmxvY2tTaXplLFwifVwiXS5qb2luKFwiXCIpKVxuICAgIGlmKGhhc19pbmRleCkge1xuICAgICAgY29kZS5wdXNoKFtcImluZGV4W1wiLG9yZGVyW2ldLFwiXT1qXCIsaV0uam9pbihcIlwiKSlcbiAgICB9XG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8bmFyZ3M7ICsraSkge1xuICAgIHZhciBpbmRleFN0ciA9IFtcIm9mZnNldFwiK2ldXG4gICAgZm9yKHZhciBqPW1hdGNoZWQ7IGo8ZGltZW5zaW9uOyArK2opIHtcbiAgICAgIGluZGV4U3RyLnB1c2goW1wialwiLGosXCIqdFwiLGksXCJbXCIsb3JkZXJbal0sXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIGNvZGUucHVzaChbXCJwXCIsaSxcIj0oXCIsaW5kZXhTdHIuam9pbihcIitcIiksXCIpXCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgY29kZS5wdXNoKGlubmVyRmlsbChvcmRlciwgcHJvYywgYm9keSkpXG4gIGZvcih2YXIgaT1tYXRjaGVkOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwifVwiKVxuICB9XG4gIHJldHVybiBjb2RlLmpvaW4oXCJcXG5cIilcbn1cblxuLy9Db3VudCB0aGUgbnVtYmVyIG9mIGNvbXBhdGlibGUgaW5uZXIgb3JkZXJzXG5mdW5jdGlvbiBjb3VudE1hdGNoZXMob3JkZXJzKSB7XG4gIHZhciBtYXRjaGVkID0gMCwgZGltZW5zaW9uID0gb3JkZXJzWzBdLmxlbmd0aFxuICB3aGlsZShtYXRjaGVkIDwgZGltZW5zaW9uKSB7XG4gICAgZm9yKHZhciBqPTE7IGo8b3JkZXJzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZihvcmRlcnNbal1bbWF0Y2hlZF0gIT09IG9yZGVyc1swXVttYXRjaGVkXSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlZFxuICAgICAgfVxuICAgIH1cbiAgICArK21hdGNoZWRcbiAgfVxuICByZXR1cm4gbWF0Y2hlZFxufVxuXG4vL1Byb2Nlc3NlcyBhIGJsb2NrIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gZGF0YSB0eXBlc1xuZnVuY3Rpb24gcHJvY2Vzc0Jsb2NrKGJsb2NrLCBwcm9jLCBkdHlwZXMpIHtcbiAgdmFyIGNvZGUgPSBibG9jay5ib2R5XG4gIHZhciBwcmUgPSBbXVxuICB2YXIgcG9zdCA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPGJsb2NrLmFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgY2FyZyA9IGJsb2NrLmFyZ3NbaV1cbiAgICBpZihjYXJnLmNvdW50IDw9IDApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoY2FyZy5uYW1lLCBcImdcIilcbiAgICB2YXIgcHRyU3RyID0gXCJcIlxuICAgIHZhciBhcnJOdW0gPSBwcm9jLmFycmF5QXJncy5pbmRleE9mKGkpXG4gICAgc3dpdGNoKHByb2MuYXJnVHlwZXNbaV0pIHtcbiAgICAgIGNhc2UgXCJvZmZzZXRcIjpcbiAgICAgICAgdmFyIG9mZkFyZ0luZGV4ID0gcHJvYy5vZmZzZXRBcmdJbmRleC5pbmRleE9mKGkpXG4gICAgICAgIHZhciBvZmZBcmcgPSBwcm9jLm9mZnNldEFyZ3Nbb2ZmQXJnSW5kZXhdXG4gICAgICAgIGFyck51bSA9IG9mZkFyZy5hcnJheVxuICAgICAgICBwdHJTdHIgPSBcIitxXCIgKyBvZmZBcmdJbmRleFxuICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgIHB0clN0ciA9IFwicFwiICsgYXJyTnVtICsgcHRyU3RyXG4gICAgICAgIHZhciBsb2NhbFN0ciA9IFwibFwiICsgaVxuICAgICAgICB2YXIgYXJyU3RyID0gXCJhXCIgKyBhcnJOdW1cbiAgICAgICAgaWYoY2FyZy5jb3VudCA9PT0gMSkge1xuICAgICAgICAgIGlmKGR0eXBlc1thcnJOdW1dID09PSBcImdlbmVyaWNcIikge1xuICAgICAgICAgICAgaWYoY2FyZy5sdmFsdWUpIHtcbiAgICAgICAgICAgICAgcHJlLnB1c2goW1widmFyIFwiLCBsb2NhbFN0ciwgXCI9XCIsIGFyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiLnNldChcIiwgcHRyU3RyLCBcIixcIiwgbG9jYWxTdHIsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBbYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFthcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKGR0eXBlc1thcnJOdW1dID09PSBcImdlbmVyaWNcIikge1xuICAgICAgICAgIHByZS5wdXNoKFtcInZhciBcIiwgbG9jYWxTdHIsIFwiPVwiLCBhcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICBpZihjYXJnLmx2YWx1ZSkge1xuICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiLnNldChcIiwgcHRyU3RyLCBcIixcIiwgbG9jYWxTdHIsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZS5wdXNoKFtcInZhciBcIiwgbG9jYWxTdHIsIFwiPVwiLCBhcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIGxvY2FsU3RyKVxuICAgICAgICAgIGlmKGNhcmcubHZhbHVlKSB7XG4gICAgICAgICAgICBwb3N0LnB1c2goW2FyclN0ciwgXCJbXCIsIHB0clN0ciwgXCJdPVwiLCBsb2NhbFN0cl0uam9pbihcIlwiKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFwiWVwiICsgcHJvYy5zY2FsYXJBcmdzLmluZGV4T2YoaSkpXG4gICAgICBicmVha1xuICAgICAgY2FzZSBcImluZGV4XCI6XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFwiaW5kZXhcIilcbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic2hhcGVcIjpcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgXCJzaGFwZVwiKVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtwcmUuam9pbihcIlxcblwiKSwgY29kZSwgcG9zdC5qb2luKFwiXFxuXCIpXS5qb2luKFwiXFxuXCIpLnRyaW0oKVxufVxuXG5mdW5jdGlvbiB0eXBlU3VtbWFyeShkdHlwZXMpIHtcbiAgdmFyIHN1bW1hcnkgPSBuZXcgQXJyYXkoZHR5cGVzLmxlbmd0aClcbiAgdmFyIGFsbEVxdWFsID0gdHJ1ZVxuICBmb3IodmFyIGk9MDsgaTxkdHlwZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgdCA9IGR0eXBlc1tpXVxuICAgIHZhciBkaWdpdHMgPSB0Lm1hdGNoKC9cXGQrLylcbiAgICBpZighZGlnaXRzKSB7XG4gICAgICBkaWdpdHMgPSBcIlwiXG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZ2l0cyA9IGRpZ2l0c1swXVxuICAgIH1cbiAgICBpZih0LmNoYXJBdCgwKSA9PT0gMCkge1xuICAgICAgc3VtbWFyeVtpXSA9IFwidVwiICsgdC5jaGFyQXQoMSkgKyBkaWdpdHNcbiAgICB9IGVsc2Uge1xuICAgICAgc3VtbWFyeVtpXSA9IHQuY2hhckF0KDApICsgZGlnaXRzXG4gICAgfVxuICAgIGlmKGkgPiAwKSB7XG4gICAgICBhbGxFcXVhbCA9IGFsbEVxdWFsICYmIHN1bW1hcnlbaV0gPT09IHN1bW1hcnlbaS0xXVxuICAgIH1cbiAgfVxuICBpZihhbGxFcXVhbCkge1xuICAgIHJldHVybiBzdW1tYXJ5WzBdXG4gIH1cbiAgcmV0dXJuIHN1bW1hcnkuam9pbihcIlwiKVxufVxuXG4vL0dlbmVyYXRlcyBhIGN3aXNlIG9wZXJhdG9yXG5mdW5jdGlvbiBnZW5lcmF0ZUNXaXNlT3AocHJvYywgdHlwZXNpZykge1xuXG4gIC8vQ29tcHV0ZSBkaW1lbnNpb25cbiAgdmFyIGRpbWVuc2lvbiA9IHR5cGVzaWdbMV0ubGVuZ3RofDBcbiAgdmFyIG9yZGVycyA9IG5ldyBBcnJheShwcm9jLmFycmF5QXJncy5sZW5ndGgpXG4gIHZhciBkdHlwZXMgPSBuZXcgQXJyYXkocHJvYy5hcnJheUFyZ3MubGVuZ3RoKVxuXG4gIC8vRmlyc3QgY3JlYXRlIGFyZ3VtZW50cyBmb3IgcHJvY2VkdXJlXG4gIHZhciBhcmdsaXN0ID0gW1wiU1NcIl1cbiAgdmFyIGNvZGUgPSBbXCIndXNlIHN0cmljdCdcIl1cbiAgdmFyIHZhcnMgPSBbXVxuICBcbiAgZm9yKHZhciBqPTA7IGo8ZGltZW5zaW9uOyArK2opIHtcbiAgICB2YXJzLnB1c2goW1wic1wiLCBqLCBcIj1TU1tcIiwgaiwgXCJdXCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBhcmdsaXN0LnB1c2goXCJhXCIraSlcbiAgICBhcmdsaXN0LnB1c2goXCJ0XCIraSlcbiAgICBhcmdsaXN0LnB1c2goXCJwXCIraSlcbiAgICBkdHlwZXNbaV0gPSB0eXBlc2lnWzIqaV1cbiAgICBvcmRlcnNbaV0gPSB0eXBlc2lnWzIqaSsxXVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPHByb2Muc2NhbGFyQXJncy5sZW5ndGg7ICsraSkge1xuICAgIGFyZ2xpc3QucHVzaChcIllcIiArIGkpXG4gIH1cbiAgaWYocHJvYy5zaGFwZUFyZ3MubGVuZ3RoID4gMCkge1xuICAgIHZhcnMucHVzaChcInNoYXBlPVNTLnNsaWNlKDApXCIpXG4gIH1cbiAgaWYocHJvYy5pbmRleEFyZ3MubGVuZ3RoID4gMCkge1xuICAgIHZhciB6ZXJvcyA9IG5ldyBBcnJheShkaW1lbnNpb24pXG4gICAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICAgIHplcm9zW2ldID0gXCIwXCJcbiAgICB9XG4gICAgdmFycy5wdXNoKFtcImluZGV4PVtcIiwgemVyb3Muam9pbihcIixcIiksIFwiXVwiXS5qb2luKFwiXCIpKVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPHByb2Mub2Zmc2V0QXJncy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBvZmZfYXJnID0gcHJvYy5vZmZzZXRBcmdzW2ldXG4gICAgdmFyIGluaXRfc3RyaW5nID0gW11cbiAgICBmb3IodmFyIGo9MDsgajxvZmZfYXJnLm9mZnNldC5sZW5ndGg7ICsraikge1xuICAgICAgaWYob2ZmX2FyZy5vZmZzZXRbal0gPT09IDApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSBpZihvZmZfYXJnLm9mZnNldFtqXSA9PT0gMSkge1xuICAgICAgICBpbml0X3N0cmluZy5wdXNoKFtcInRcIiwgb2ZmX2FyZy5hcnJheSwgXCJbXCIsIGosIFwiXVwiXS5qb2luKFwiXCIpKSAgICAgIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdF9zdHJpbmcucHVzaChbb2ZmX2FyZy5vZmZzZXRbal0sIFwiKnRcIiwgb2ZmX2FyZy5hcnJheSwgXCJbXCIsIGosIFwiXVwiXS5qb2luKFwiXCIpKVxuICAgICAgfVxuICAgIH1cbiAgICBpZihpbml0X3N0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhcnMucHVzaChcInFcIiArIGkgKyBcIj0wXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhcnMucHVzaChbXCJxXCIsIGksIFwiPShcIiwgaW5pdF9zdHJpbmcuam9pbihcIitcIiksXCIpfDBcIl0uam9pbihcIlwiKSlcbiAgICB9XG4gIH1cblxuICAvL1ByZXBhcmUgdGhpcyB2YXJpYWJsZXNcbiAgdmFyIHRoaXNWYXJzID0gdW5pcShbXS5jb25jYXQocHJvYy5wcmUudGhpc1ZhcnMpXG4gICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChwcm9jLmJvZHkudGhpc1ZhcnMpXG4gICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChwcm9jLnBvc3QudGhpc1ZhcnMpKVxuICB2YXJzID0gdmFycy5jb25jYXQodGhpc1ZhcnMpXG4gIGNvZGUucHVzaChcInZhciBcIiArIHZhcnMuam9pbihcIixcIikpXG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwicFwiK2krXCJ8PTBcIilcbiAgfVxuICBcbiAgLy9JbmxpbmUgcHJlbHVkZVxuICBpZihwcm9jLnByZS5ib2R5Lmxlbmd0aCA+IDMpIHtcbiAgICBjb2RlLnB1c2gocHJvY2Vzc0Jsb2NrKHByb2MucHJlLCBwcm9jLCBkdHlwZXMpKVxuICB9XG5cbiAgLy9Qcm9jZXNzIGJvZHlcbiAgdmFyIGJvZHkgPSBwcm9jZXNzQmxvY2socHJvYy5ib2R5LCBwcm9jLCBkdHlwZXMpXG4gIHZhciBtYXRjaGVkID0gY291bnRNYXRjaGVzKG9yZGVycylcbiAgaWYobWF0Y2hlZCA8IGRpbWVuc2lvbikge1xuICAgIGNvZGUucHVzaChvdXRlckZpbGwobWF0Y2hlZCwgb3JkZXJzWzBdLCBwcm9jLCBib2R5KSlcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goaW5uZXJGaWxsKG9yZGVyc1swXSwgcHJvYywgYm9keSkpXG4gIH1cblxuICAvL0lubGluZSBlcGlsb2dcbiAgaWYocHJvYy5wb3N0LmJvZHkubGVuZ3RoID4gMykge1xuICAgIGNvZGUucHVzaChwcm9jZXNzQmxvY2socHJvYy5wb3N0LCBwcm9jLCBkdHlwZXMpKVxuICB9XG4gIFxuICBpZihwcm9jLmRlYnVnKSB7XG4gICAgY29uc29sZS5sb2coXCJHZW5lcmF0ZWQgY3dpc2Ugcm91dGluZSBmb3IgXCIsIHR5cGVzaWcsIFwiOlxcblxcblwiLCBjb2RlLmpvaW4oXCJcXG5cIikpXG4gIH1cbiAgXG4gIHZhciBsb29wTmFtZSA9IFsocHJvYy5mdW5jTmFtZXx8XCJ1bm5hbWVkXCIpLCBcIl9jd2lzZV9sb29wX1wiLCBvcmRlcnNbMF0uam9pbihcInNcIiksXCJtXCIsbWF0Y2hlZCx0eXBlU3VtbWFyeShkdHlwZXMpXS5qb2luKFwiXCIpXG4gIHZhciBmID0gbmV3IEZ1bmN0aW9uKFtcImZ1bmN0aW9uIFwiLGxvb3BOYW1lLFwiKFwiLCBhcmdsaXN0LmpvaW4oXCIsXCIpLFwiKXtcIiwgY29kZS5qb2luKFwiXFxuXCIpLFwifSByZXR1cm4gXCIsIGxvb3BOYW1lXS5qb2luKFwiXCIpKVxuICByZXR1cm4gZigpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGdlbmVyYXRlQ1dpc2VPcCIsIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIHVuaXF1ZV9wcmVkKGxpc3QsIGNvbXBhcmUpIHtcbiAgdmFyIHB0ciA9IDFcbiAgICAsIGxlbiA9IGxpc3QubGVuZ3RoXG4gICAgLCBhPWxpc3RbMF0sIGI9bGlzdFswXVxuICBmb3IodmFyIGk9MTsgaTxsZW47ICsraSkge1xuICAgIGIgPSBhXG4gICAgYSA9IGxpc3RbaV1cbiAgICBpZihjb21wYXJlKGEsIGIpKSB7XG4gICAgICBpZihpID09PSBwdHIpIHtcbiAgICAgICAgcHRyKytcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGxpc3RbcHRyKytdID0gYVxuICAgIH1cbiAgfVxuICBsaXN0Lmxlbmd0aCA9IHB0clxuICByZXR1cm4gbGlzdFxufVxuXG5mdW5jdGlvbiB1bmlxdWVfZXEobGlzdCkge1xuICB2YXIgcHRyID0gMVxuICAgICwgbGVuID0gbGlzdC5sZW5ndGhcbiAgICAsIGE9bGlzdFswXSwgYiA9IGxpc3RbMF1cbiAgZm9yKHZhciBpPTE7IGk8bGVuOyArK2ksIGI9YSkge1xuICAgIGIgPSBhXG4gICAgYSA9IGxpc3RbaV1cbiAgICBpZihhICE9PSBiKSB7XG4gICAgICBpZihpID09PSBwdHIpIHtcbiAgICAgICAgcHRyKytcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGxpc3RbcHRyKytdID0gYVxuICAgIH1cbiAgfVxuICBsaXN0Lmxlbmd0aCA9IHB0clxuICByZXR1cm4gbGlzdFxufVxuXG5mdW5jdGlvbiB1bmlxdWUobGlzdCwgY29tcGFyZSwgc29ydGVkKSB7XG4gIGlmKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgaWYoY29tcGFyZSkge1xuICAgIGlmKCFzb3J0ZWQpIHtcbiAgICAgIGxpc3Quc29ydChjb21wYXJlKVxuICAgIH1cbiAgICByZXR1cm4gdW5pcXVlX3ByZWQobGlzdCwgY29tcGFyZSlcbiAgfVxuICBpZighc29ydGVkKSB7XG4gICAgbGlzdC5zb3J0KClcbiAgfVxuICByZXR1cm4gdW5pcXVlX2VxKGxpc3QpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pcXVlIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIG5kYXJyYXkgPSByZXF1aXJlKFwibmRhcnJheVwiKVxudmFyIG9wcyA9IHJlcXVpcmUoXCJuZGFycmF5LW9wc1wiKVxudmFyIHBvb2wgPSByZXF1aXJlKFwidHlwZWRhcnJheS1wb29sXCIpXG5cbmZ1bmN0aW9uIGNsb25lKGFycmF5KSB7XG4gIHZhciBkdHlwZSA9IGFycmF5LmR0eXBlXG4gIGlmKGR0eXBlID09PSBcImdlbmVyaWNcIiB8fCBkdHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgZHR5cGUgPSBcImRvdWJsZVwiXG4gIH1cbiAgdmFyIGRhdGEgPSBwb29sLm1hbGxvYyhhcnJheS5zaXplLCBkdHlwZSlcbiAgdmFyIHJlc3VsdCA9IG5kYXJyYXkoZGF0YSwgYXJyYXkuc2hhcGUpXG4gIG9wcy5hc3NpZ24ocmVzdWx0LCBhcnJheSlcbiAgcmV0dXJuIHJlc3VsdFxufVxuZXhwb3J0cy5jbG9uZSA9IGNsb25lXG5cbmZ1bmN0aW9uIG1hbGxvYyhzaGFwZSwgZHR5cGUpIHtcbiAgaWYoIWR0eXBlKSB7XG4gICAgZHR5cGUgPSBcImRvdWJsZVwiXG4gIH1cbiAgdmFyIHN6ID0gMVxuICB2YXIgc3RyaWRlID0gbmV3IEFycmF5KHNoYXBlLmxlbmd0aClcbiAgZm9yKHZhciBpPXNoYXBlLmxlbmd0aC0xOyBpPj0wOyAtLWkpIHtcbiAgICBzdHJpZGVbaV0gPSBzelxuICAgIHN6ICo9IHNoYXBlW2ldXG4gIH1cbiAgcmV0dXJuIG5kYXJyYXkocG9vbC5tYWxsb2Moc3osIGR0eXBlKSwgc2hhcGUsIHN0cmlkZSwgMClcbn1cbmV4cG9ydHMubWFsbG9jID0gbWFsbG9jXG5cbmZ1bmN0aW9uIGZyZWUoYXJyYXkpIHtcbiAgaWYoYXJyYXkuZHR5cGUgPT09IFwiZ2VuZXJpY1wiIHx8IGFycmF5LmR0eXBlID09PSBcImFycmF5XCIpIHtcbiAgICByZXR1cm5cbiAgfVxuICBwb29sLmZyZWUoYXJyYXkuZGF0YSlcbn1cbmV4cG9ydHMuZnJlZSA9IGZyZWVcblxuZnVuY3Rpb24gemVyb3Moc2hhcGUsIGR0eXBlKSB7XG4gIGlmKCFkdHlwZSkge1xuICAgIGR0eXBlID0gXCJkb3VibGVcIlxuICB9XG5cbiAgdmFyIHN6ID0gMVxuICB2YXIgc3RyaWRlID0gbmV3IEFycmF5KHNoYXBlLmxlbmd0aClcbiAgZm9yKHZhciBpPXNoYXBlLmxlbmd0aC0xOyBpPj0wOyAtLWkpIHtcbiAgICBzdHJpZGVbaV0gPSBzelxuICAgIHN6ICo9IHNoYXBlW2ldXG4gIH1cbiAgdmFyIGJ1ZiA9IHBvb2wubWFsbG9jKHN6LCBkdHlwZSlcbiAgZm9yKHZhciBpPTA7IGk8c3o7ICsraSkge1xuICAgIGJ1ZltpXSA9IDBcbiAgfVxuICByZXR1cm4gbmRhcnJheShidWYsIHNoYXBlLCBzdHJpZGUsIDApXG59XG5leHBvcnRzLnplcm9zID0gemVyb3MiLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IG5kU2VsZWN0XG5tb2R1bGUuZXhwb3J0cy5jb21waWxlID0gbG9va3VwQ2FjaGVcblxuLy9NYWNyb3NcbnZhciBBUlJBWSA9IFwiYVwiXG52YXIgUkFOSyA9IFwiS1wiXG52YXIgQ01QID0gXCJDXCJcbnZhciBEQVRBID0gXCJkXCJcbnZhciBPRkZTRVQgPSBcIm9cIlxudmFyIFJORCA9IFwiUlwiXG52YXIgVE1QID0gXCJUXCJcbnZhciBMTyA9IFwiTFwiXG52YXIgSEkgPSBcIkhcIlxudmFyIFBJVk9UID0gXCJYXCJcbmZ1bmN0aW9uIFNIQVBFKGkpIHtcbiAgcmV0dXJuIFwic1wiICsgaVxufVxuZnVuY3Rpb24gU1RSSURFKGkpIHtcbiAgcmV0dXJuIFwidFwiICsgaVxufVxuZnVuY3Rpb24gU1RFUChpKSB7XG4gIHJldHVybiBcInVcIiArIGlcbn1cbmZ1bmN0aW9uIFNURVBfQ01QKGkpIHtcbiAgcmV0dXJuIFwidlwiICsgaVxufVxuZnVuY3Rpb24gSU5ERVgoaSkge1xuICByZXR1cm4gXCJpXCIgKyBpXG59XG5mdW5jdGlvbiBQSUNLKGkpIHtcbiAgcmV0dXJuIFwicFwiICsgaVxufVxuZnVuY3Rpb24gUFRSKGkpIHtcbiAgcmV0dXJuIFwieFwiICsgaVxufVxuXG4vL0NyZWF0ZSBuZXcgb3JkZXIgd2hlcmUgaW5kZXggMCBpcyBzbG93ZXN0IGluZGV4XG5mdW5jdGlvbiBwZXJtdXRlT3JkZXIob3JkZXIpIHtcbiAgdmFyIG5vcmRlciA9IG9yZGVyLnNsaWNlKClcbiAgbm9yZGVyLnNwbGljZShvcmRlci5pbmRleE9mKDApLCAxKVxuICBub3JkZXIudW5zaGlmdCgwKVxuICByZXR1cm4gbm9yZGVyXG59XG5cbi8vR2VuZXJhdGUgcXVpY2sgc2VsZWN0IHByb2NlZHVyZVxuZnVuY3Rpb24gY29tcGlsZVF1aWNrU2VsZWN0KG9yZGVyLCB1c2VDb21wYXJlLCBkdHlwZSkge1xuICBvcmRlciA9IHBlcm11dGVPcmRlcihvcmRlcilcblxuICB2YXIgZGltZW5zaW9uID0gb3JkZXIubGVuZ3RoXG4gIHZhciB1c2VHZXR0ZXIgPSAoZHR5cGUgPT09IFwiZ2VuZXJpY1wiKVxuICB2YXIgZnVuY05hbWUgPSBcIm5kU2VsZWN0XCIgKyBkdHlwZSArIG9yZGVyLmpvaW4oXCJfXCIpICsgXCJfXCIgKyAodXNlQ29tcGFyZSA/IFwiY21wXCIgOiBcImxleFwiKVxuXG4gIHZhciBjb2RlID0gW11cblxuICAvL0dldCBhcmd1bWVudHMgZm9yIGNvZGVcbiAgdmFyIGFyZ3MgPSBbQVJSQVksIFJBTktdXG4gIGlmKHVzZUNvbXBhcmUpIHtcbiAgICBhcmdzLnB1c2goQ01QKVxuICB9XG5cbiAgLy9VbnBhY2sgbmRhcnJheSB2YXJpYWJsZXNcbiAgdmFyIHZhcnMgPSBbXG4gICAgREFUQSArIFwiPVwiICsgQVJSQVkgKyBcIi5kYXRhXCIsXG4gICAgT0ZGU0VUICsgXCI9XCIgKyBBUlJBWSArIFwiLm9mZnNldHwwXCIsXG4gICAgUk5EICsgXCI9TWF0aC5yYW5kb21cIixcbiAgICBUTVBdXG4gIGZvcih2YXIgaT0wOyBpPDI7ICsraSkge1xuICAgIHZhcnMucHVzaChQVFIoaSkgKyBcIj0wXCIpXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICB2YXJzLnB1c2goXG4gICAgICBTSEFQRShpKSArIFwiPVwiICsgQVJSQVkgKyBcIi5zaGFwZVtcIiArIGkgKyBcIl18MFwiLFxuICAgICAgU1RSSURFKGkpICsgXCI9XCIgKyBBUlJBWSArIFwiLnN0cmlkZVtcIiArIGkgKyBcIl18MFwiLFxuICAgICAgSU5ERVgoaSkgKyBcIj0wXCIpXG4gIH1cbiAgZm9yKHZhciBpPTE7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBpZihpIDwgZGltZW5zaW9uLTEpIHtcbiAgICAgIHZhcnMucHVzaChTVEVQX0NNUChpKSArIFwiPShcIiArIFNUUklERShpKSArIFwiLVwiICsgU0hBUEUoaSsxKSArIFwiKlwiICsgU1RSSURFKGkrMSkgKyBcIil8MFwiLFxuICAgICAgICAgICAgICAgIFNURVAob3JkZXJbaV0pICsgXCI9KFwiICsgU1RSSURFKG9yZGVyW2ldKSArIFwiLVwiICsgU0hBUEUob3JkZXJbaSsxXSkgKyBcIipcIiArIFNUUklERShvcmRlcltpKzFdKSArIFwiKXwwXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhcnMucHVzaChTVEVQX0NNUChpKSArIFwiPVwiICsgU1RSSURFKGkpLFxuICAgICAgICAgICAgICAgIFNURVAob3JkZXJbaV0pICsgXCI9XCIgKyBTVFJJREUob3JkZXJbaV0pKVxuICAgIH1cbiAgfVxuICBpZih1c2VDb21wYXJlKSB7XG4gICAgZm9yKHZhciBpPTA7IGk8MjsgKytpKSB7XG4gICAgICB2YXJzLnB1c2goUElDSyhpKSArIFwiPVwiICsgQVJSQVkgKyBcIi5waWNrKDApXCIpXG4gICAgfVxuICB9XG4gIHZhcnMucHVzaChcbiAgICBQSVZPVCArIFwiPTBcIixcbiAgICBMTyArIFwiPTBcIixcbiAgICBISSArIFwiPVwiICsgU0hBUEUob3JkZXJbMF0pICsgXCItMVwiKVxuXG4gIGZ1bmN0aW9uIGNvbXBhcmUob3V0LCBpMCwgaTEpIHtcbiAgICBpZih1c2VDb21wYXJlKSB7XG4gICAgICBjb2RlLnB1c2goXG4gICAgICAgIFBJQ0soMCksIFwiLm9mZnNldD1cIiwgT0ZGU0VULCBcIitcIiwgU1RSSURFKG9yZGVyWzBdKSwgXCIqKFwiLCBpMCwgXCIpO1wiLFxuICAgICAgICBQSUNLKDEpLCBcIi5vZmZzZXQ9XCIsIE9GRlNFVCwgXCIrXCIsIFNUUklERShvcmRlclswXSksIFwiKihcIiwgaTEsIFwiKTtcIixcbiAgICAgICAgb3V0LCBcIj1cIiwgQ01QLCBcIihcIiwgUElDSygwKSwgXCIsXCIsIFBJQ0soMSksIFwiKTtcIilcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZS5wdXNoKFxuICAgICAgICBQVFIoMCksIFwiPVwiLCBPRkZTRVQsIFwiK1wiLCBTVFJJREUoMCksIFwiKihcIiwgaTAsIFwiKTtcIixcbiAgICAgICAgUFRSKDEpLCBcIj1cIiwgT0ZGU0VULCBcIitcIiwgU1RSSURFKDApLCBcIiooXCIsIGkxLCBcIik7XCIpXG4gICAgICBpZihkaW1lbnNpb24gPiAxKSB7XG4gICAgICAgIGNvZGUucHVzaChcIl9jbXA6XCIpXG4gICAgICB9XG4gICAgICBmb3IodmFyIGk9ZGltZW5zaW9uLTE7IGk+MDsgLS1pKSB7XG4gICAgICAgIGNvZGUucHVzaChcImZvcihcIiwgSU5ERVgoaSksIFwiPTA7XCIsIFxuICAgICAgICAgIElOREVYKGkpLCBcIjxcIiwgU0hBUEUoaSksIFwiO1wiLFxuICAgICAgICAgIElOREVYKGkpLCBcIisrKXtcIilcbiAgICAgIH1cbiAgICAgIGlmKHVzZUdldHRlcikge1xuICAgICAgICBjb2RlLnB1c2gob3V0LCBcIj1cIiwgREFUQSwgXCIuZ2V0KFwiLCBQVFIoMCksIFwiKS1cIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgREFUQSwgXCIuZ2V0KFwiLCBQVFIoMSksIFwiKTtcIilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvZGUucHVzaChvdXQsIFwiPVwiLCBEQVRBLCBcIltcIiwgUFRSKDApLCBcIl0tXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIERBVEEsIFwiW1wiLCBQVFIoMSksIFwiXTtcIilcbiAgICAgIH1cbiAgICAgIGlmKGRpbWVuc2lvbiA+IDEpIHtcbiAgICAgICAgY29kZS5wdXNoKFwiaWYoXCIsIG91dCwgXCIpYnJlYWsgX2NtcDtcIilcbiAgICAgIH1cbiAgICAgIGZvcih2YXIgaT0xOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICAgIGNvZGUucHVzaChcbiAgICAgICAgICBQVFIoMCksIFwiKz1cIiwgU1RFUF9DTVAoaSksIFwiO1wiLFxuICAgICAgICAgIFBUUigxKSwgXCIrPVwiLCBTVEVQX0NNUChpKSxcbiAgICAgICAgICBcIn1cIilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzd2FwKGkwLCBpMSkge1xuICAgIGNvZGUucHVzaChcbiAgICAgIFBUUigwKSwgXCI9XCIsIE9GRlNFVCwgXCIrXCIsIFNUUklERShvcmRlclswXSksIFwiKihcIiwgaTAsIFwiKTtcIixcbiAgICAgIFBUUigxKSwgXCI9XCIsIE9GRlNFVCwgXCIrXCIsIFNUUklERShvcmRlclswXSksIFwiKihcIiwgaTEsIFwiKTtcIilcbiAgICBmb3IodmFyIGk9ZGltZW5zaW9uLTE7IGk+MDsgLS1pKSB7XG4gICAgICBjb2RlLnB1c2goXCJmb3IoXCIsIElOREVYKG9yZGVyW2ldKSwgXCI9MDtcIiwgXG4gICAgICAgIElOREVYKG9yZGVyW2ldKSwgXCI8XCIsIFNIQVBFKG9yZGVyW2ldKSwgXCI7XCIsXG4gICAgICAgIElOREVYKG9yZGVyW2ldKSwgXCIrKyl7XCIpXG4gICAgfVxuICAgIGlmKHVzZUdldHRlcikge1xuICAgICAgY29kZS5wdXNoKFRNUCwgXCI9XCIsIERBVEEsIFwiLmdldChcIiwgUFRSKDApLCBcIik7XCIsIFxuICAgICAgICAgICAgICAgIERBVEEsIFwiLnNldChcIiwgUFRSKDApLCBcIixcIiwgREFUQSwgXCIuZ2V0KFwiLCBQVFIoMSksIFwiKSk7XCIsXG4gICAgICAgICAgICAgICAgREFUQSwgXCIuc2V0KFwiLCBQVFIoMSksIFwiLFwiLCBUTVAsIFwiKTtcIilcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZS5wdXNoKFRNUCwgXCI9XCIsIERBVEEsIFwiW1wiLCBQVFIoMCksIFwiXTtcIiwgXG4gICAgICAgICAgICAgICAgREFUQSwgXCJbXCIsIFBUUigwKSwgXCJdPVwiLCBEQVRBLCBcIltcIiwgUFRSKDEpLCBcIl07XCIsXG4gICAgICAgICAgICAgICAgREFUQSwgXCJbXCIsIFBUUigxKSwgXCJdPVwiLCBUTVAsIFwiO1wiKVxuICAgIH1cbiAgICBmb3IodmFyIGk9MTsgaTxkaW1lbnNpb247ICsraSkge1xuICAgICAgY29kZS5wdXNoKFxuICAgICAgICBQVFIoMCksIFwiKz1cIiwgU1RFUChvcmRlcltpXSksIFwiO1wiLFxuICAgICAgICBQVFIoMSksIFwiKz1cIiwgU1RFUChvcmRlcltpXSksXG4gICAgICAgIFwifVwiKVxuICAgIH1cbiAgfVxuXG4gIGNvZGUucHVzaChcbiAgICBcIndoaWxlKFwiLCBMTywgXCI8XCIsIEhJLCBcIil7XCIsXG4gICAgICBQSVZPVCwgXCI9KFwiLCBSTkQsIFwiKCkqKFwiLCBISSwgXCItXCIsIExPLCBcIisxKStcIiwgTE8sIFwiKXwwO1wiKVxuXG4gIC8vUGFydGl0aW9uIGFycmF5IGJ5IHBpdm90XG4gIHN3YXAoUElWT1QsIEhJKVxuXG4gIGNvZGUucHVzaChcbiAgICBQSVZPVCwgXCI9XCIsIExPLCBcIjtcIixcbiAgICBcImZvcihcIiwgSU5ERVgoMCksIFwiPVwiLCBMTywgXCI7XCIsXG4gICAgICBJTkRFWCgwKSwgXCI8XCIsIEhJLCBcIjtcIixcbiAgICAgIElOREVYKDApLCBcIisrKXtcIilcbiAgY29tcGFyZShUTVAsIElOREVYKDApLCBISSlcbiAgY29kZS5wdXNoKFwiaWYoXCIsIFRNUCwgXCI8MCl7XCIpXG4gICAgc3dhcChQSVZPVCwgSU5ERVgoMCkpXG4gICAgY29kZS5wdXNoKFBJVk9ULCBcIisrO1wiKVxuICBjb2RlLnB1c2goXCJ9fVwiKVxuICBzd2FwKFBJVk9ULCBISSlcblxuICAvL0NoZWNrIHBpdm90IGJvdW5kc1xuICBjb2RlLnB1c2goXG4gICAgXCJpZihcIiwgUElWT1QsIFwiPT09XCIsIFJBTkssIFwiKXtcIixcbiAgICAgIExPLCBcIj1cIiwgUElWT1QsIFwiO1wiLFxuICAgICAgXCJicmVhaztcIixcbiAgICBcIn1lbHNlIGlmKFwiLCBSQU5LLCBcIjxcIiwgUElWT1QsIFwiKXtcIixcbiAgICAgIEhJLCBcIj1cIiwgUElWT1QsIFwiLTE7XCIsXG4gICAgXCJ9ZWxzZXtcIixcbiAgICAgIExPLCBcIj1cIiwgUElWT1QsIFwiKzE7XCIsXG4gICAgXCJ9XCIsXG4gIFwifVwiKVxuXG4gIGlmKHVzZUNvbXBhcmUpIHtcbiAgICBjb2RlLnB1c2goUElDSygwKSwgXCIub2Zmc2V0PVwiLCBPRkZTRVQsIFwiK1wiLCBMTywgXCIqXCIsIFNUUklERSgwKSwgXCI7XCIsXG4gICAgICBcInJldHVybiBcIiwgUElDSygwKSwgXCI7XCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIFwiLCBBUlJBWSwgXCIucGljayhcIiwgTE8sIFwiKTtcIilcbiAgfVxuXG4gIC8vQ29tcGlsZSBhbmQgbGluayBqcyB0b2dldGhlclxuICB2YXIgcHJvY0NvZGUgPSBbXG4gICAgXCIndXNlIHN0cmljdCc7ZnVuY3Rpb24gXCIsIGZ1bmNOYW1lLCBcIihcIiwgYXJncywgXCIpe1wiLFxuICAgICAgXCJ2YXIgXCIsIHZhcnMuam9pbigpLCBcIjtcIixcbiAgICAgIGNvZGUuam9pbihcIlwiKSxcbiAgICBcIn07cmV0dXJuIFwiLCBmdW5jTmFtZVxuICBdLmpvaW4oXCJcIilcblxuICB2YXIgcHJvYyA9IG5ldyBGdW5jdGlvbihwcm9jQ29kZSlcbiAgcmV0dXJuIHByb2MoKVxufVxuXG52YXIgQ0FDSEUgPSB7fVxuXG5mdW5jdGlvbiBsb29rdXBDYWNoZShvcmRlciwgdXNlQ29tcGFyZSwgZHR5cGUpIHtcbiAgdmFyIHR5cGVzaWcgPSBvcmRlci5qb2luKCkgKyB1c2VDb21wYXJlICsgZHR5cGVcbiAgdmFyIHByb2MgPSBDQUNIRVt0eXBlc2lnXVxuICBpZihwcm9jKSB7XG4gICAgcmV0dXJuIHByb2NcbiAgfVxuICByZXR1cm4gQ0FDSEVbdHlwZXNpZ10gPSBjb21waWxlUXVpY2tTZWxlY3Qob3JkZXIsIHVzZUNvbXBhcmUsIGR0eXBlKVxufVxuXG5mdW5jdGlvbiBuZFNlbGVjdChhcnJheSwgaywgY29tcGFyZSkge1xuICBrIHw9IDBcbiAgaWYoKGFycmF5LmRpbWVuc2lvbiA9PT0gMCkgfHwgXG4gICAgKGFycmF5LnNoYXBlWzBdIDw9IGspIHx8XG4gICAgKGsgPCAwKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmFyIHVzZUNvbXBhcmUgPSAhIWNvbXBhcmVcbiAgdmFyIHByb2MgPSBsb29rdXBDYWNoZShhcnJheS5vcmRlciwgdXNlQ29tcGFyZSwgYXJyYXkuZHR5cGUpXG4gIGlmKHVzZUNvbXBhcmUpIHtcbiAgICByZXR1cm4gcHJvYyhhcnJheSwgaywgY29tcGFyZSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJvYyhhcnJheSwgaylcbiAgfVxufSIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbnZhciBpb3RhID0gcmVxdWlyZShcImlvdGEtYXJyYXlcIilcblxudmFyIGFycmF5TWV0aG9kcyA9IFtcbiAgXCJjb25jYXRcIixcbiAgXCJqb2luXCIsXG4gIFwic2xpY2VcIixcbiAgXCJ0b1N0cmluZ1wiLFxuICBcImluZGV4T2ZcIixcbiAgXCJsYXN0SW5kZXhPZlwiLFxuICBcImZvckVhY2hcIixcbiAgXCJldmVyeVwiLFxuICBcInNvbWVcIixcbiAgXCJmaWx0ZXJcIixcbiAgXCJtYXBcIixcbiAgXCJyZWR1Y2VcIixcbiAgXCJyZWR1Y2VSaWdodFwiXG5dXG5cbnZhciBoYXNUeXBlZEFycmF5cyAgPSAoKHR5cGVvZiBGbG9hdDY0QXJyYXkpICE9PSBcInVuZGVmaW5lZFwiKVxudmFyIGhhc0J1ZmZlciAgICAgICA9ICgodHlwZW9mIEJ1ZmZlcikgIT09IFwidW5kZWZpbmVkXCIpXG5cbmZ1bmN0aW9uIGNvbXBhcmUxc3QoYSwgYikge1xuICByZXR1cm4gYVswXSAtIGJbMF1cbn1cblxuZnVuY3Rpb24gb3JkZXIoKSB7XG4gIHZhciBzdHJpZGUgPSB0aGlzLnN0cmlkZVxuICB2YXIgdGVybXMgPSBuZXcgQXJyYXkoc3RyaWRlLmxlbmd0aClcbiAgdmFyIGlcbiAgZm9yKGk9MDsgaTx0ZXJtcy5sZW5ndGg7ICsraSkge1xuICAgIHRlcm1zW2ldID0gW01hdGguYWJzKHN0cmlkZVtpXSksIGldXG4gIH1cbiAgdGVybXMuc29ydChjb21wYXJlMXN0KVxuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KHRlcm1zLmxlbmd0aClcbiAgZm9yKGk9MDsgaTxyZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSB0ZXJtc1tpXVsxXVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gY29tcGlsZUNvbnN0cnVjdG9yKGR0eXBlLCBkaW1lbnNpb24pIHtcbiAgdmFyIGNsYXNzTmFtZSA9IFtcIlZpZXdcIiwgZGltZW5zaW9uLCBcImRcIiwgZHR5cGVdLmpvaW4oXCJcIilcbiAgaWYoZGltZW5zaW9uIDwgMCkge1xuICAgIGNsYXNzTmFtZSA9IFwiVmlld19OaWxcIiArIGR0eXBlXG4gIH1cbiAgdmFyIHVzZUdldHRlcnMgPSAoZHR5cGUgPT09IFwiZ2VuZXJpY1wiKVxuICBcbiAgaWYoZGltZW5zaW9uID09PSAtMSkge1xuICAgIC8vU3BlY2lhbCBjYXNlIGZvciB0cml2aWFsIGFycmF5c1xuICAgIHZhciBjb2RlID0gXG4gICAgICBcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIihhKXt0aGlzLmRhdGE9YTt9O1xcXG52YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZTtcXFxucHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJztcXFxucHJvdG8uaW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gLTF9O1xcXG5wcm90by5zaXplPTA7XFxcbnByb3RvLmRpbWVuc2lvbj0tMTtcXFxucHJvdG8uc2hhcGU9cHJvdG8uc3RyaWRlPXByb3RvLm9yZGVyPVtdO1xcXG5wcm90by5sbz1wcm90by5oaT1wcm90by50cmFuc3Bvc2U9cHJvdG8uc3RlcD1cXFxuZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEpO307XFxcbnByb3RvLmdldD1wcm90by5zZXQ9ZnVuY3Rpb24oKXt9O1xcXG5wcm90by5waWNrPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O1xcXG5yZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihhKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihhKTt9XCJcbiAgICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gICAgcmV0dXJuIHByb2NlZHVyZSgpXG4gIH0gZWxzZSBpZihkaW1lbnNpb24gPT09IDApIHtcbiAgICAvL1NwZWNpYWwgY2FzZSBmb3IgMGQgYXJyYXlzXG4gICAgdmFyIGNvZGUgPVxuICAgICAgXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSxkKSB7XFxcbnRoaXMuZGF0YSA9IGE7XFxcbnRoaXMub2Zmc2V0ID0gZFxcXG59O1xcXG52YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZTtcXFxucHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJztcXFxucHJvdG8uaW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vZmZzZXR9O1xcXG5wcm90by5kaW1lbnNpb249MDtcXFxucHJvdG8uc2l6ZT0xO1xcXG5wcm90by5zaGFwZT1cXFxucHJvdG8uc3RyaWRlPVxcXG5wcm90by5vcmRlcj1bXTtcXFxucHJvdG8ubG89XFxcbnByb3RvLmhpPVxcXG5wcm90by50cmFuc3Bvc2U9XFxcbnByb3RvLnN0ZXA9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2NvcHkoKSB7XFxcbnJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSx0aGlzLm9mZnNldClcXFxufTtcXFxucHJvdG8ucGljaz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfcGljaygpe1xcXG5yZXR1cm4gVHJpdmlhbEFycmF5KHRoaXMuZGF0YSk7XFxcbn07XFxcbnByb3RvLnZhbHVlT2Y9cHJvdG8uZ2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9nZXQoKXtcXFxucmV0dXJuIFwiKyh1c2VHZXR0ZXJzID8gXCJ0aGlzLmRhdGEuZ2V0KHRoaXMub2Zmc2V0KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdXCIpK1xuXCJ9O1xcXG5wcm90by5zZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3NldCh2KXtcXFxucmV0dXJuIFwiKyh1c2VHZXR0ZXJzID8gXCJ0aGlzLmRhdGEuc2V0KHRoaXMub2Zmc2V0LHYpXCIgOiBcInRoaXMuZGF0YVt0aGlzLm9mZnNldF09dlwiKStcIlxcXG59O1xcXG5yZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihhLGIsYyxkKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihhLGQpfVwiXG4gICAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihcIlRyaXZpYWxBcnJheVwiLCBjb2RlKVxuICAgIHJldHVybiBwcm9jZWR1cmUoQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV1bMF0pXG4gIH1cblxuICB2YXIgY29kZSA9IFtcIid1c2Ugc3RyaWN0J1wiXVxuICAgIFxuICAvL0NyZWF0ZSBjb25zdHJ1Y3RvciBmb3Igdmlld1xuICB2YXIgaW5kaWNlcyA9IGlvdGEoZGltZW5zaW9uKVxuICB2YXIgYXJncyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiaVwiK2kgfSlcbiAgdmFyIGluZGV4X3N0ciA9IFwidGhpcy5vZmZzZXQrXCIgKyBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICAgIHJldHVybiBcInRoaXMuX3N0cmlkZVwiICsgaSArIFwiKmlcIiArIGlcbiAgICAgIH0pLmpvaW4oXCIrXCIpXG4gIGNvZGUucHVzaChcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIihhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIitpXG4gICAgfSkuam9pbihcIixcIikgKyBcIixcIiArXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiY1wiK2lcbiAgICB9KS5qb2luKFwiLFwiKSArIFwiLGQpe3RoaXMuZGF0YT1hXCIpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwidGhpcy5fc2hhcGVcIitpK1wiPWJcIitpK1wifDBcIilcbiAgfVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcInRoaXMuX3N0cmlkZVwiK2krXCI9Y1wiK2krXCJ8MFwiKVxuICB9XG4gIGNvZGUucHVzaChcInRoaXMub2Zmc2V0PWR8MH1cIixcbiAgICBcInZhciBwcm90bz1cIitjbGFzc05hbWUrXCIucHJvdG90eXBlXCIsXG4gICAgXCJwcm90by5kdHlwZT0nXCIrZHR5cGUrXCInXCIsXG4gICAgXCJwcm90by5kaW1lbnNpb249XCIrZGltZW5zaW9uKVxuICBcbiAgLy92aWV3LnN0cmlkZSBhbmQgdmlldy5zaGFwZVxuICB2YXIgc3RyaWRlQ2xhc3NOYW1lID0gXCJWU3RyaWRlXCIgKyBkaW1lbnNpb24gKyBcImRcIiArIGR0eXBlXG4gIHZhciBzaGFwZUNsYXNzTmFtZSA9IFwiVlNoYXBlXCIgKyBkaW1lbnNpb24gKyBcImRcIiArIGR0eXBlXG4gIHZhciBwcm9wcyA9IHtcInN0cmlkZVwiOnN0cmlkZUNsYXNzTmFtZSwgXCJzaGFwZVwiOnNoYXBlQ2xhc3NOYW1lfVxuICBmb3IodmFyIHByb3AgaW4gcHJvcHMpIHtcbiAgICB2YXIgYXJyYXlOYW1lID0gcHJvcHNbcHJvcF1cbiAgICBjb2RlLnB1c2goXG4gICAgICBcImZ1bmN0aW9uIFwiICsgYXJyYXlOYW1lICsgXCIodikge3RoaXMuX3Y9dn0gdmFyIGFwcm90bz1cIiArIGFycmF5TmFtZSArIFwiLnByb3RvdHlwZVwiLFxuICAgICAgXCJhcHJvdG8ubGVuZ3RoPVwiK2RpbWVuc2lvbilcbiAgICBcbiAgICB2YXIgYXJyYXlfZWxlbWVudHMgPSBbXVxuICAgIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICBhcnJheV9lbGVtZW50cy5wdXNoKFtcInRoaXMuX3YuX1wiLCBwcm9wLCBpXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgICBjb2RlLnB1c2goXG4gICAgICBcImFwcm90by50b0pTT049ZnVuY3Rpb24gXCIgKyBhcnJheU5hbWUgKyBcIl90b0pTT04oKXtyZXR1cm4gW1wiICsgYXJyYXlfZWxlbWVudHMuam9pbihcIixcIikgKyBcIl19XCIsXG4gICAgICBcImFwcm90by52YWx1ZU9mPWFwcm90by50b1N0cmluZz1mdW5jdGlvbiBcIiArIGFycmF5TmFtZSArIFwiX3RvU3RyaW5nKCl7cmV0dXJuIFtcIiArIGFycmF5X2VsZW1lbnRzLmpvaW4oXCIsXCIpICsgXCJdLmpvaW4oKX1cIilcbiAgICBcbiAgICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgICAgY29kZS5wdXNoKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcm90byxcIitpK1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdi5fXCIrcHJvcCtpK1wifSxzZXQ6ZnVuY3Rpb24odil7cmV0dXJuIHRoaXMuX3YuX1wiK3Byb3AraStcIj12fDB9LGVudW1lcmFibGU6dHJ1ZX0pXCIpXG4gICAgfVxuICAgIGZvcih2YXIgaT0wOyBpPGFycmF5TWV0aG9kcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYoYXJyYXlNZXRob2RzW2ldIGluIEFycmF5LnByb3RvdHlwZSkge1xuICAgICAgICBjb2RlLnB1c2goXCJhcHJvdG8uXCIrYXJyYXlNZXRob2RzW2ldK1wiPUFycmF5LnByb3RvdHlwZS5cIithcnJheU1ldGhvZHNbaV0pXG4gICAgICB9XG4gICAgfVxuICAgIGNvZGUucHVzaChbXCJPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sJ1wiLHByb3AsXCInLHtnZXQ6ZnVuY3Rpb24gXCIsIGFycmF5TmFtZSwgXCJfZ2V0KCl7cmV0dXJuIG5ldyBcIiwgYXJyYXlOYW1lLCBcIih0aGlzKX0sc2V0OiBmdW5jdGlvbiBcIiwgYXJyYXlOYW1lLCBcIl9zZXQodil7XCJdLmpvaW4oXCJcIikpXG4gICAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICAgIGNvZGUucHVzaChcInRoaXMuX1wiK3Byb3AraStcIj12W1wiK2krXCJdfDBcIilcbiAgICB9XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHZ9fSlcIilcbiAgfVxuICBcbiAgLy92aWV3LnNpemU6XG4gIGNvZGUucHVzaChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywnc2l6ZScse2dldDpmdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc2l6ZSgpe1xcXG5yZXR1cm4gXCIraW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJ0aGlzLl9zaGFwZVwiK2kgfSkuam9pbihcIipcIiksXG5cIn19KVwiKVxuXG4gIC8vdmlldy5vcmRlcjpcbiAgaWYoZGltZW5zaW9uID09PSAxKSB7XG4gICAgY29kZS5wdXNoKFwicHJvdG8ub3JkZXI9WzBdXCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCdvcmRlcicse2dldDpcIilcbiAgICBpZihkaW1lbnNpb24gPCA0KSB7XG4gICAgICBjb2RlLnB1c2goXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfb3JkZXIoKXtcIilcbiAgICAgIGlmKGRpbWVuc2lvbiA9PT0gMikge1xuICAgICAgICBjb2RlLnB1c2goXCJyZXR1cm4gKE1hdGguYWJzKHRoaXMuX3N0cmlkZTApPk1hdGguYWJzKHRoaXMuX3N0cmlkZTEpKT9bMSwwXTpbMCwxXX19KVwiKVxuICAgICAgfSBlbHNlIGlmKGRpbWVuc2lvbiA9PT0gMykge1xuICAgICAgICBjb2RlLnB1c2goXG5cInZhciBzMD1NYXRoLmFicyh0aGlzLl9zdHJpZGUwKSxzMT1NYXRoLmFicyh0aGlzLl9zdHJpZGUxKSxzMj1NYXRoLmFicyh0aGlzLl9zdHJpZGUyKTtcXFxuaWYoczA+czEpe1xcXG5pZihzMT5zMil7XFxcbnJldHVybiBbMiwxLDBdO1xcXG59ZWxzZSBpZihzMD5zMil7XFxcbnJldHVybiBbMSwyLDBdO1xcXG59ZWxzZXtcXFxucmV0dXJuIFsxLDAsMl07XFxcbn1cXFxufWVsc2UgaWYoczA+czIpe1xcXG5yZXR1cm4gWzIsMCwxXTtcXFxufWVsc2UgaWYoczI+czEpe1xcXG5yZXR1cm4gWzAsMSwyXTtcXFxufWVsc2V7XFxcbnJldHVybiBbMCwyLDFdO1xcXG59fX0pXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUucHVzaChcIk9SREVSfSlcIilcbiAgICB9XG4gIH1cbiAgXG4gIC8vdmlldy5zZXQoaTAsIC4uLiwgdik6XG4gIGNvZGUucHVzaChcblwicHJvdG8uc2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zZXQoXCIrYXJncy5qb2luKFwiLFwiKStcIix2KXtcIilcbiAgaWYodXNlR2V0dGVycykge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGEuc2V0KFwiK2luZGV4X3N0citcIix2KX1cIilcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhW1wiK2luZGV4X3N0citcIl09dn1cIilcbiAgfVxuICBcbiAgLy92aWV3LmdldChpMCwgLi4uKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uZ2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9nZXQoXCIrYXJncy5qb2luKFwiLFwiKStcIil7XCIpXG4gIGlmKHVzZUdldHRlcnMpIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhLmdldChcIitpbmRleF9zdHIrXCIpfVwiKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGFbXCIraW5kZXhfc3RyK1wiXX1cIilcbiAgfVxuICBcbiAgLy92aWV3LmluZGV4OlxuICBjb2RlLnB1c2goXG4gICAgXCJwcm90by5pbmRleD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfaW5kZXgoXCIsIGFyZ3Muam9pbigpLCBcIil7cmV0dXJuIFwiK2luZGV4X3N0citcIn1cIilcblxuICAvL3ZpZXcuaGkoKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uaGk9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2hpKFwiK2FyZ3Muam9pbihcIixcIikrXCIpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gW1wiKHR5cGVvZiBpXCIsaSxcIiE9PSdudW1iZXInfHxpXCIsaSxcIjwwKT90aGlzLl9zaGFwZVwiLCBpLCBcIjppXCIsIGksXCJ8MFwiXS5qb2luKFwiXCIpXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwidGhpcy5fc3RyaWRlXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLHRoaXMub2Zmc2V0KX1cIilcbiAgXG4gIC8vdmlldy5sbygpOlxuICB2YXIgYV92YXJzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJhXCIraStcIj10aGlzLl9zaGFwZVwiK2kgfSlcbiAgdmFyIGNfdmFycyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiY1wiK2krXCI9dGhpcy5fc3RyaWRlXCIraSB9KVxuICBjb2RlLnB1c2goXCJwcm90by5sbz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfbG8oXCIrYXJncy5qb2luKFwiLFwiKStcIil7dmFyIGI9dGhpcy5vZmZzZXQsZD0wLFwiK2FfdmFycy5qb2luKFwiLFwiKStcIixcIitjX3ZhcnMuam9pbihcIixcIikpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFxuXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyYmaVwiK2krXCI+PTApe1xcXG5kPWlcIitpK1wifDA7XFxcbmIrPWNcIitpK1wiKmQ7XFxcbmFcIitpK1wiLT1kfVwiKVxuICB9XG4gIGNvZGUucHVzaChcInJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJhXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImNcIitpXG4gICAgfSkuam9pbihcIixcIikrXCIsYil9XCIpXG4gIFxuICAvL3ZpZXcuc3RlcCgpOlxuICBjb2RlLnB1c2goXCJwcm90by5zdGVwPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zdGVwKFwiK2FyZ3Muam9pbihcIixcIikrXCIpe3ZhciBcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJhXCIraStcIj10aGlzLl9zaGFwZVwiK2lcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJiXCIraStcIj10aGlzLl9zdHJpZGVcIitpXG4gICAgfSkuam9pbihcIixcIikrXCIsYz10aGlzLm9mZnNldCxkPTAsY2VpbD1NYXRoLmNlaWxcIilcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXG5cImlmKHR5cGVvZiBpXCIraStcIj09PSdudW1iZXInKXtcXFxuZD1pXCIraStcInwwO1xcXG5pZihkPDApe1xcXG5jKz1iXCIraStcIiooYVwiK2krXCItMSk7XFxcbmFcIitpK1wiPWNlaWwoLWFcIitpK1wiL2QpXFxcbn1lbHNle1xcXG5hXCIraStcIj1jZWlsKGFcIitpK1wiL2QpXFxcbn1cXFxuYlwiK2krXCIqPWRcXFxufVwiKVxuICB9XG4gIGNvZGUucHVzaChcInJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJhXCIgKyBpXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYlwiICsgaVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGMpfVwiKVxuICBcbiAgLy92aWV3LnRyYW5zcG9zZSgpOlxuICB2YXIgdFNoYXBlID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgdmFyIHRTdHJpZGUgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIHRTaGFwZVtpXSA9IFwiYVtpXCIraStcIl1cIlxuICAgIHRTdHJpZGVbaV0gPSBcImJbaVwiK2krXCJdXCJcbiAgfVxuICBjb2RlLnB1c2goXCJwcm90by50cmFuc3Bvc2U9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3RyYW5zcG9zZShcIithcmdzK1wiKXtcIitcbiAgICBhcmdzLm1hcChmdW5jdGlvbihuLGlkeCkgeyByZXR1cm4gbiArIFwiPShcIiArIG4gKyBcIj09PXVuZGVmaW5lZD9cIiArIGlkeCArIFwiOlwiICsgbiArIFwifDApXCJ9KS5qb2luKFwiO1wiKSxcbiAgICBcInZhciBhPXRoaXMuc2hhcGUsYj10aGlzLnN0cmlkZTtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrdFNoYXBlLmpvaW4oXCIsXCIpK1wiLFwiK3RTdHJpZGUuam9pbihcIixcIikrXCIsdGhpcy5vZmZzZXQpfVwiKVxuICBcbiAgLy92aWV3LnBpY2soKTpcbiAgY29kZS5wdXNoKFwicHJvdG8ucGljaz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfcGljayhcIithcmdzK1wiKXt2YXIgYT1bXSxiPVtdLGM9dGhpcy5vZmZzZXRcIilcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyYmaVwiK2krXCI+PTApe2M9KGMrdGhpcy5fc3RyaWRlXCIraStcIippXCIraStcIil8MH1lbHNle2EucHVzaCh0aGlzLl9zaGFwZVwiK2krXCIpO2IucHVzaCh0aGlzLl9zdHJpZGVcIitpK1wiKX1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJ2YXIgY3Rvcj1DVE9SX0xJU1RbYS5sZW5ndGgrMV07cmV0dXJuIGN0b3IodGhpcy5kYXRhLGEsYixjKX1cIilcbiAgICBcbiAgLy9BZGQgcmV0dXJuIHN0YXRlbWVudFxuICBjb2RlLnB1c2goXCJyZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihkYXRhLHNoYXBlLHN0cmlkZSxvZmZzZXQpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKGRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwic2hhcGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcInN0cmlkZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsb2Zmc2V0KX1cIilcblxuICAvL0NvbXBpbGUgcHJvY2VkdXJlXG4gIHZhciBwcm9jZWR1cmUgPSBuZXcgRnVuY3Rpb24oXCJDVE9SX0xJU1RcIiwgXCJPUkRFUlwiLCBjb2RlLmpvaW4oXCJcXG5cIikpXG4gIHJldHVybiBwcm9jZWR1cmUoQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV0sIG9yZGVyKVxufVxuXG5mdW5jdGlvbiBhcnJheURUeXBlKGRhdGEpIHtcbiAgaWYoaGFzQnVmZmVyKSB7XG4gICAgaWYoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICByZXR1cm4gXCJidWZmZXJcIlxuICAgIH1cbiAgfVxuICBpZihoYXNUeXBlZEFycmF5cykge1xuICAgIHN3aXRjaChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkpIHtcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEZsb2F0NjRBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiZmxvYXQ2NFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBGbG9hdDMyQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImZsb2F0MzJcIlxuICAgICAgY2FzZSBcIltvYmplY3QgSW50OEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQ4XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEludDE2QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImludDE2XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEludDMyQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImludDMyXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQ4XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQxNkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50MTZcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDMyQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQzMlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50OENsYW1wZWRBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDhfY2xhbXBlZFwiXG4gICAgfVxuICB9XG4gIGlmKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICByZXR1cm4gXCJhcnJheVwiXG4gIH1cbiAgcmV0dXJuIFwiZ2VuZXJpY1wiXG59XG5cbnZhciBDQUNIRURfQ09OU1RSVUNUT1JTID0ge1xuICBcImZsb2F0MzJcIjpbXSxcbiAgXCJmbG9hdDY0XCI6W10sXG4gIFwiaW50OFwiOltdLFxuICBcImludDE2XCI6W10sXG4gIFwiaW50MzJcIjpbXSxcbiAgXCJ1aW50OFwiOltdLFxuICBcInVpbnQxNlwiOltdLFxuICBcInVpbnQzMlwiOltdLFxuICBcImFycmF5XCI6W10sXG4gIFwidWludDhfY2xhbXBlZFwiOltdLFxuICBcImJ1ZmZlclwiOltdLFxuICBcImdlbmVyaWNcIjpbXVxufVxuXG47KGZ1bmN0aW9uKCkge1xuICBmb3IodmFyIGlkIGluIENBQ0hFRF9DT05TVFJVQ1RPUlMpIHtcbiAgICBDQUNIRURfQ09OU1RSVUNUT1JTW2lkXS5wdXNoKGNvbXBpbGVDb25zdHJ1Y3RvcihpZCwgLTEpKVxuICB9XG59KTtcblxuZnVuY3Rpb24gd3JhcHBlZE5EQXJyYXlDdG9yKGRhdGEsIHNoYXBlLCBzdHJpZGUsIG9mZnNldCkge1xuICBpZihkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgY3RvciA9IENBQ0hFRF9DT05TVFJVQ1RPUlMuYXJyYXlbMF1cbiAgICByZXR1cm4gY3RvcihbXSlcbiAgfSBlbHNlIGlmKHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiKSB7XG4gICAgZGF0YSA9IFtkYXRhXVxuICB9XG4gIGlmKHNoYXBlID09PSB1bmRlZmluZWQpIHtcbiAgICBzaGFwZSA9IFsgZGF0YS5sZW5ndGggXVxuICB9XG4gIHZhciBkID0gc2hhcGUubGVuZ3RoXG4gIGlmKHN0cmlkZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RyaWRlID0gbmV3IEFycmF5KGQpXG4gICAgZm9yKHZhciBpPWQtMSwgc3o9MTsgaT49MDsgLS1pKSB7XG4gICAgICBzdHJpZGVbaV0gPSBzelxuICAgICAgc3ogKj0gc2hhcGVbaV1cbiAgICB9XG4gIH1cbiAgaWYob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBvZmZzZXQgPSAwXG4gICAgZm9yKHZhciBpPTA7IGk8ZDsgKytpKSB7XG4gICAgICBpZihzdHJpZGVbaV0gPCAwKSB7XG4gICAgICAgIG9mZnNldCAtPSAoc2hhcGVbaV0tMSkqc3RyaWRlW2ldXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBkdHlwZSA9IGFycmF5RFR5cGUoZGF0YSlcbiAgdmFyIGN0b3JfbGlzdCA9IENBQ0hFRF9DT05TVFJVQ1RPUlNbZHR5cGVdXG4gIHdoaWxlKGN0b3JfbGlzdC5sZW5ndGggPD0gZCsxKSB7XG4gICAgY3Rvcl9saXN0LnB1c2goY29tcGlsZUNvbnN0cnVjdG9yKGR0eXBlLCBjdG9yX2xpc3QubGVuZ3RoLTEpKVxuICB9XG4gIHZhciBjdG9yID0gY3Rvcl9saXN0W2QrMV1cbiAgcmV0dXJuIGN0b3IoZGF0YSwgc2hhcGUsIHN0cmlkZSwgb2Zmc2V0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBwZWROREFycmF5Q3RvclxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKSIsIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIGlvdGEobikge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KG4pXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IGlcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW90YSIsIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIGR1cGVfYXJyYXkoY291bnQsIHZhbHVlLCBpKSB7XG4gIHZhciBjID0gY291bnRbaV18MFxuICBpZihjIDw9IDApIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGMpLCBqXG4gIGlmKGkgPT09IGNvdW50Lmxlbmd0aC0xKSB7XG4gICAgZm9yKGo9MDsgajxjOyArK2opIHtcbiAgICAgIHJlc3VsdFtqXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvcihqPTA7IGo8YzsgKytqKSB7XG4gICAgICByZXN1bHRbal0gPSBkdXBlX2FycmF5KGNvdW50LCB2YWx1ZSwgaSsxKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGR1cGVfbnVtYmVyKGNvdW50LCB2YWx1ZSkge1xuICB2YXIgcmVzdWx0LCBpXG4gIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudClcbiAgZm9yKGk9MDsgaTxjb3VudDsgKytpKSB7XG4gICAgcmVzdWx0W2ldID0gdmFsdWVcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGR1cGUoY291bnQsIHZhbHVlKSB7XG4gIGlmKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhbHVlID0gMFxuICB9XG4gIHN3aXRjaCh0eXBlb2YgY291bnQpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBpZihjb3VudCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGR1cGVfbnVtYmVyKGNvdW50fDAsIHZhbHVlKVxuICAgICAgfVxuICAgIGJyZWFrXG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgaWYodHlwZW9mIChjb3VudC5sZW5ndGgpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBkdXBlX2FycmF5KGNvdW50LCB2YWx1ZSwgMClcbiAgICAgIH1cbiAgICBicmVha1xuICB9XG4gIHJldHVybiBbXVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGR1cGUiLCIoZnVuY3Rpb24gKGdsb2JhbCxCdWZmZXIpe1xudmFyIGJpdHMgPSByZXF1aXJlKFwiYml0LXR3aWRkbGVcIilcbnZhciBkdXAgPSByZXF1aXJlKFwiZHVwXCIpXG5pZighZ2xvYmFsLl9fVFlQRURBUlJBWV9QT09MKSB7XG4gIGdsb2JhbC5fX1RZUEVEQVJSQVlfUE9PTCA9IHtcbiAgICAgIFVJTlQ4ICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIFVJTlQxNiAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIFVJTlQzMiAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIElOVDggICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIElOVDE2ICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIElOVDMyICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIEZMT0FUICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIERPVUJMRSAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIERBVEEgICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIFVJTlQ4QyAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIEJVRkZFUiAgOiBkdXAoWzMyLCAwXSlcbiAgfVxufVxudmFyIGhhc1VpbnQ4QyA9ICh0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkpICE9PSBcInVuZGVmaW5lZFwiXG52YXIgUE9PTCA9IGdsb2JhbC5fX1RZUEVEQVJSQVlfUE9PTFxuaWYoIVBPT0wuVUlOVDhDKSB7XG4gIFBPT0wuVUlOVDhDID0gZHVwKFszMiwgMF0pXG59XG5pZighUE9PTC5CVUZGRVIpIHtcbiAgUE9PTC5CVUZGRVIgPSBkdXAoWzMyLCAwXSlcbn1cbnZhciBVSU5UOCAgID0gUE9PTC5VSU5UOFxuICAsIFVJTlQxNiAgPSBQT09MLlVJTlQxNlxuICAsIFVJTlQzMiAgPSBQT09MLlVJTlQzMlxuICAsIElOVDggICAgPSBQT09MLklOVDhcbiAgLCBJTlQxNiAgID0gUE9PTC5JTlQxNlxuICAsIElOVDMyICAgPSBQT09MLklOVDMyXG4gICwgRkxPQVQgICA9IFBPT0wuRkxPQVRcbiAgLCBET1VCTEUgID0gUE9PTC5ET1VCTEVcbiAgLCBEQVRBICAgID0gUE9PTC5EQVRBXG4gICwgVUlOVDhDICA9IFBPT0wuVUlOVDhDXG4gICwgQlVGRkVSICA9IFBPT0wuQlVGRkVSXG5cbmV4cG9ydHMuZnJlZSA9IGZ1bmN0aW9uIGZyZWUoYXJyYXkpIHtcbiAgdmFyIG4gPSBhcnJheS5sZW5ndGh8MFxuICAgICwgbG9nX24gPSBiaXRzLmxvZzIobilcbiAgaWYoQnVmZmVyLmlzQnVmZmVyKGFycmF5KSkge1xuICAgIEJVRkZFUltsb2dfbl0ucHVzaChhcnJheSlcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2goT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycmF5KSkge1xuICAgICAgY2FzZSBcIltvYmplY3QgVWludDhBcnJheV1cIjpcbiAgICAgICAgVUlOVDhbbG9nX25dLnB1c2goYXJyYXkpXG4gICAgICBicmVha1xuICAgICAgY2FzZSBcIltvYmplY3QgVWludDE2QXJyYXldXCI6XG4gICAgICAgIFVJTlQxNltsb2dfbl0ucHVzaChhcnJheSlcbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50MzJBcnJheV1cIjpcbiAgICAgICAgVUlOVDMyW2xvZ19uXS5wdXNoKGFycmF5KVxuICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEludDhBcnJheV1cIjpcbiAgICAgICAgSU5UOFtsb2dfbl0ucHVzaChhcnJheSlcbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQxNkFycmF5XVwiOlxuICAgICAgICBJTlQxNltsb2dfbl0ucHVzaChhcnJheSlcbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQzMkFycmF5XVwiOlxuICAgICAgICBJTlQzMltsb2dfbl0ucHVzaChhcnJheSlcbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50OENsYW1wZWRBcnJheV1cIjpcbiAgICAgICAgVUlOVDhDW2xvZ19uXS5wdXNoKGFycmF5KVxuICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIjpcbiAgICAgICAgRkxPQVRbbG9nX25dLnB1c2goYXJyYXkpXG4gICAgICBicmVha1xuICAgICAgY2FzZSBcIltvYmplY3QgRmxvYXQ2NEFycmF5XVwiOlxuICAgICAgICBET1VCTEVbbG9nX25dLnB1c2goYXJyYXkpXG4gICAgICBicmVha1xuICAgICAgY2FzZSBcIltvYmplY3QgQXJyYXlCdWZmZXJdXCI6XG4gICAgICAgIERBVEFbbG9nX25dLnB1c2goYXJyYXkpXG4gICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZWRhcnJheS1wb29sOiBVbnNwZWNpZmllZCBhcnJheSB0eXBlXCIpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuZnJlZVVpbnQ4ID0gZnVuY3Rpb24gZnJlZVVpbnQ4KGFycmF5KSB7XG4gIFVJTlQ4W2JpdHMubG9nMihhcnJheS5sZW5ndGgpXS5wdXNoKGFycmF5KVxufVxuXG5leHBvcnRzLmZyZWVVaW50MTYgPSBmdW5jdGlvbiBmcmVlVWludDE2KGFycmF5KSB7XG4gIFVJTlQxNltiaXRzLmxvZzIoYXJyYXkubGVuZ3RoKV0ucHVzaChhcnJheSlcbn1cblxuZXhwb3J0cy5mcmVlVWludDMyID0gZnVuY3Rpb24gZnJlZVVpbnQzMihhcnJheSkge1xuICBVSU5UMzJbYml0cy5sb2cyKGFycmF5Lmxlbmd0aCldLnB1c2goYXJyYXkpXG59XG5cbmV4cG9ydHMuZnJlZUludDggPSBmdW5jdGlvbiBmcmVlSW50OChhcnJheSkge1xuICBJTlQ4W2JpdHMubG9nMihhcnJheS5sZW5ndGgpXS5wdXNoKGFycmF5KVxufVxuXG5leHBvcnRzLmZyZWVJbnQxNiA9IGZ1bmN0aW9uIGZyZWVJbnQxNihhcnJheSkge1xuICBJTlQxNltiaXRzLmxvZzIoYXJyYXkubGVuZ3RoKV0ucHVzaChhcnJheSlcbn1cblxuZXhwb3J0cy5mcmVlSW50MzIgPSBmdW5jdGlvbiBmcmVlSW50MzIoYXJyYXkpIHtcbiAgSU5UMzJbYml0cy5sb2cyKGFycmF5Lmxlbmd0aCldLnB1c2goYXJyYXkpXG59XG5cbmV4cG9ydHMuZnJlZUZsb2F0MzIgPSBleHBvcnRzLmZyZWVGbG9hdCA9IGZ1bmN0aW9uIGZyZWVGbG9hdChhcnJheSkge1xuICBGTE9BVFtiaXRzLmxvZzIoYXJyYXkubGVuZ3RoKV0ucHVzaChhcnJheSlcbn1cblxuZXhwb3J0cy5mcmVlRmxvYXQ2NCA9IGV4cG9ydHMuZnJlZURvdWJsZSA9IGZ1bmN0aW9uIGZyZWVEb3VibGUoYXJyYXkpIHtcbiAgRE9VQkxFW2JpdHMubG9nMihhcnJheS5sZW5ndGgpXS5wdXNoKGFycmF5KVxufVxuXG5leHBvcnRzLmZyZWVBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIGZyZWVBcnJheUJ1ZmZlcihhcnJheSkge1xuICBEQVRBW2JpdHMubG9nMihhcnJheS5sZW5ndGgpXS5wdXNoKGFycmF5KVxufVxuXG5pZihoYXNVaW50OEMpIHtcbiAgZXhwb3J0cy5mcmVlVWludDhDbGFtcGVkID0gZnVuY3Rpb24gZnJlZVVpbnQ4Q2xhbXBlZChhcnJheSkge1xuICAgIFVJTlQ4Q1tiaXRzLmxvZzIoYXJyYXkubGVuZ3RoKV0ucHVzaChhcnJheSlcbiAgfVxufSBlbHNlIHtcbiAgZXhwb3J0cy5mcmVlVWludDhDbGFtcGVkID0gZXhwb3J0cy5mcmVlVWludDhcbn1cblxuZXhwb3J0cy5mcmVlQnVmZmVyID0gZnVuY3Rpb24gZnJlZUJ1ZmZlcihhcnJheSkge1xuICBCVUZGRVJbYml0cy5sb2cyKGFycmF5Lmxlbmd0aCldLnB1c2goYXJyYXkpXG59XG5cbmV4cG9ydHMubWFsbG9jID0gZnVuY3Rpb24gbWFsbG9jKG4sIGR0eXBlKSB7XG4gIG4gPSBiaXRzLm5leHRQb3cyKG4pXG4gIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKVxuICBpZihkdHlwZSA9PT0gdW5kZWZpbmVkIHx8IGR0eXBlID09PSBcImFycmF5YnVmZmVyXCIpIHtcbiAgICB2YXIgZCA9IERBVEFbbG9nX25dXG4gICAgaWYoZC5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgciA9IGRbZC5sZW5ndGgtMV1cbiAgICAgIGQucG9wKClcbiAgICAgIHJldHVybiByXG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIobilcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2goZHR5cGUpIHtcbiAgICAgIGNhc2UgXCJ1aW50OFwiOlxuICAgICAgICB2YXIgdTggPSBVSU5UOFtsb2dfbl1cbiAgICAgICAgaWYodTgubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiB1OC5wb3AoKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShuKVxuICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcInVpbnQxNlwiOlxuICAgICAgICB2YXIgdTE2ID0gVUlOVDE2W2xvZ19uXVxuICAgICAgICBpZih1MTYubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiB1MTYucG9wKClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KG4pXG4gICAgICBicmVha1xuXG4gICAgICBjYXNlIFwidWludDMyXCI6XG4gICAgICAgIHZhciB1MzIgPSBVSU5UMzJbbG9nX25dXG4gICAgICAgIGlmKHUzMi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHUzMi5wb3AoKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkobilcbiAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJpbnQ4XCI6XG4gICAgICAgIHZhciBpOCA9IElOVDhbbG9nX25dXG4gICAgICAgIGlmKGk4Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gaTgucG9wKClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEludDhBcnJheShuKVxuICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcImludDE2XCI6XG4gICAgICAgIHZhciBpMTYgPSBJTlQxNltsb2dfbl1cbiAgICAgICAgaWYoaTE2Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gaTE2LnBvcCgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KG4pXG4gICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgICAgdmFyIGkzMiA9IElOVDMyW2xvZ19uXVxuICAgICAgICBpZihpMzIubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiBpMzIucG9wKClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkobilcbiAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJmbG9hdFwiOlxuICAgICAgY2FzZSBcImZsb2F0MzJcIjpcbiAgICAgICAgdmFyIGYgPSBGTE9BVFtsb2dfbl1cbiAgICAgICAgaWYoZi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGYucG9wKClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShuKVxuICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcImRvdWJsZVwiOlxuICAgICAgY2FzZSBcImZsb2F0NjRcIjpcbiAgICAgICAgdmFyIGRkID0gRE9VQkxFW2xvZ19uXVxuICAgICAgICBpZihkZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGRkLnBvcCgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkobilcbiAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJ1aW50OF9jbGFtcGVkXCI6XG4gICAgICAgIGlmKGhhc1VpbnQ4Qykge1xuICAgICAgICAgIHZhciB1OGMgPSBVSU5UOENbbG9nX25dXG4gICAgICAgICAgaWYodThjLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1OGMucG9wKClcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OENsYW1wZWRBcnJheShuKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB1OCA9IFVJTlQ4W2xvZ19uXVxuICAgICAgICAgIGlmKHU4Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1OC5wb3AoKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobilcbiAgICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcImJ1ZmZlclwiOlxuICAgICAgICB2YXIgYnVmID0gQlVGRkVSW2xvZ19uXVxuICAgICAgICBpZihidWYubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiBidWYucG9wKClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihuKVxuICAgICAgYnJlYWtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0cy5tYWxsb2NVaW50OCA9IGZ1bmN0aW9uIG1hbGxvY1VpbnQ4KG4pIHtcbiAgbiA9IGJpdHMubmV4dFBvdzIobilcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIHZhciBjYWNoZSA9IFVJTlQ4W2xvZ19uXVxuICBpZihjYWNoZS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGNhY2hlLnBvcCgpXG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG4pXG59XG5cbmV4cG9ydHMubWFsbG9jVWludDE2ID0gZnVuY3Rpb24gbWFsbG9jVWludDE2KG4pIHtcbiAgbiA9IGJpdHMubmV4dFBvdzIobilcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIHZhciBjYWNoZSA9IFVJTlQxNltsb2dfbl1cbiAgaWYoY2FjaGUubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBjYWNoZS5wb3AoKVxuICB9XG4gIHJldHVybiBuZXcgVWludDE2QXJyYXkobilcbn1cblxuZXhwb3J0cy5tYWxsb2NVaW50MzIgPSBmdW5jdGlvbiBtYWxsb2NVaW50MzIobikge1xuICBuID0gYml0cy5uZXh0UG93MihuKVxuICB2YXIgbG9nX24gPSBiaXRzLmxvZzIobilcbiAgdmFyIGNhY2hlID0gVUlOVDMyW2xvZ19uXVxuICBpZihjYWNoZS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGNhY2hlLnBvcCgpXG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShuKVxufVxuXG5leHBvcnRzLm1hbGxvY0ludDggPSBmdW5jdGlvbiBtYWxsb2NJbnQ4KG4pIHtcbiAgbiA9IGJpdHMubmV4dFBvdzIobilcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIHZhciBjYWNoZSA9IElOVDhbbG9nX25dXG4gIGlmKGNhY2hlLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gY2FjaGUucG9wKClcbiAgfVxuICByZXR1cm4gbmV3IEludDhBcnJheShuKVxufVxuXG5leHBvcnRzLm1hbGxvY0ludDE2ID0gZnVuY3Rpb24gbWFsbG9jSW50MTYobikge1xuICBuID0gYml0cy5uZXh0UG93MihuKVxuICB2YXIgbG9nX24gPSBiaXRzLmxvZzIobilcbiAgdmFyIGNhY2hlID0gSU5UMTZbbG9nX25dXG4gIGlmKGNhY2hlLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gY2FjaGUucG9wKClcbiAgfVxuICByZXR1cm4gbmV3IEludDE2QXJyYXkobilcbn1cblxuZXhwb3J0cy5tYWxsb2NJbnQzMiA9IGZ1bmN0aW9uIG1hbGxvY0ludDMyKG4pIHtcbiAgbiA9IGJpdHMubmV4dFBvdzIobilcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIHZhciBjYWNoZSA9IElOVDMyW2xvZ19uXVxuICBpZihjYWNoZS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGNhY2hlLnBvcCgpXG4gIH1cbiAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KG4pXG59XG5cbmV4cG9ydHMubWFsbG9jRmxvYXQzMiA9IGV4cG9ydHMubWFsbG9jRmxvYXQgPSBmdW5jdGlvbiBtYWxsb2NGbG9hdChuKSB7XG4gIG4gPSBiaXRzLm5leHRQb3cyKG4pXG4gIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKVxuICB2YXIgY2FjaGUgPSBGTE9BVFtsb2dfbl1cbiAgaWYoY2FjaGUubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBjYWNoZS5wb3AoKVxuICB9XG4gIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KG4pXG59XG5cbmV4cG9ydHMubWFsbG9jRmxvYXQ2NCA9IGV4cG9ydHMubWFsbG9jRG91YmxlID0gZnVuY3Rpb24gbWFsbG9jRG91YmxlKG4pIHtcbiAgbiA9IGJpdHMubmV4dFBvdzIobilcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIHZhciBjYWNoZSA9IERPVUJMRVtsb2dfbl1cbiAgaWYoY2FjaGUubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBjYWNoZS5wb3AoKVxuICB9XG4gIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KG4pXG59XG5cbmV4cG9ydHMubWFsbG9jQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBtYWxsb2NBcnJheUJ1ZmZlcihuKSB7XG4gIG4gPSBiaXRzLm5leHRQb3cyKG4pXG4gIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKVxuICB2YXIgY2FjaGUgPSBEQVRBW2xvZ19uXVxuICBpZihjYWNoZS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGNhY2hlLnBvcCgpXG4gIH1cbiAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcihuKVxufVxuXG5pZihoYXNVaW50OEMpIHtcbiAgZXhwb3J0cy5tYWxsb2NVaW50OENsYW1wZWQgPSBmdW5jdGlvbiBtYWxsb2NVaW50OENsYW1wZWQobikge1xuICAgIG4gPSBiaXRzLm5leHRQb3cyKG4pXG4gICAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gICAgdmFyIGNhY2hlID0gVUlOVDhDW2xvZ19uXVxuICAgIGlmKGNhY2hlLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBjYWNoZS5wb3AoKVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KG4pXG4gIH1cbn0gZWxzZSB7XG4gIGV4cG9ydHMubWFsbG9jVWludDhDbGFtcGVkID0gZXhwb3J0cy5tYWxsb2NVaW50OFxufVxuXG5leHBvcnRzLm1hbGxvY0J1ZmZlciA9IGZ1bmN0aW9uIG1hbGxvY0J1ZmZlcihuKSB7XG4gIG4gPSBiaXRzLm5leHRQb3cyKG4pXG4gIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKVxuICB2YXIgY2FjaGUgPSBCVUZGRVJbbG9nX25dXG4gIGlmKGNhY2hlLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gY2FjaGUucG9wKClcbiAgfVxuICByZXR1cm4gbmV3IEJ1ZmZlcihuKVxufVxuXG5leHBvcnRzLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xuICBmb3IodmFyIGk9MDsgaTwzMjsgKytpKSB7XG4gICAgVUlOVDhbaV0ubGVuZ3RoID0gMFxuICAgIFVJTlQxNltpXS5sZW5ndGggPSAwXG4gICAgVUlOVDMyW2ldLmxlbmd0aCA9IDBcbiAgICBJTlQ4W2ldLmxlbmd0aCA9IDBcbiAgICBJTlQxNltpXS5sZW5ndGggPSAwXG4gICAgSU5UMzJbaV0ubGVuZ3RoID0gMFxuICAgIEZMT0FUW2ldLmxlbmd0aCA9IDBcbiAgICBET1VCTEVbaV0ubGVuZ3RoID0gMFxuICAgIERBVEFbaV0ubGVuZ3RoID0gMFxuICAgIFVJTlQ4Q1tpXS5sZW5ndGggPSAwXG4gICAgQlVGRkVSW2ldLmxlbmd0aCA9IDBcbiAgfVxufVxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpIl19
